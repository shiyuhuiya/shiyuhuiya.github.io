<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>数据结构与算法 | 三叶的博客</title><meta name="author" content="三叶sanye"><meta name="copyright" content="三叶sanye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="时间复杂度，空间复杂度非线性结构二叉树二叉树的性质 深度为k的二叉树最多结点数目：深度为k即有k层，第k层的最大结点数等于2^(k-1)，经过等比数列求和后可得到深度为k的二叉树最多有(2^k)-1个结点，这就好比k位二进制能标识的最大的数为(2^k)-1，8位二进制数能表示的最大的数是2^8-1&#x3D;127。 一条边出现表示一个新的结点（除了根节点）：结点数目&#x3D;边数+1 边数 &#x3D;"><meta property="og:type" content="article"><meta property="og:title" content="数据结构与算法"><meta property="og:url" content="https://www.sanye.blog/posts/4b0178e0.html"><meta property="og:site_name" content="三叶的博客"><meta property="og:description" content="时间复杂度，空间复杂度非线性结构二叉树二叉树的性质 深度为k的二叉树最多结点数目：深度为k即有k层，第k层的最大结点数等于2^(k-1)，经过等比数列求和后可得到深度为k的二叉树最多有(2^k)-1个结点，这就好比k位二进制能标识的最大的数为(2^k)-1，8位二进制数能表示的最大的数是2^8-1&#x3D;127。 一条边出现表示一个新的结点（除了根节点）：结点数目&#x3D;边数+1 边数 &#x3D;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.sanye.blog/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg"><meta property="article:published_time" content="2025-02-07T14:48:29.000Z"><meta property="article:modified_time" content="2025-02-14T06:16:31.975Z"><meta property="article:author" content="三叶sanye"><meta property="article:tag" content="数据结构与算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.sanye.blog/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.sanye.blog/posts/4b0178e0.html"><link rel="preconnect" href="//unpkg.com"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>(()=>{const t={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:t,getScript:(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach((([e,t])=>n.setAttribute(e,t))),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),getCSS:(e,t)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const o=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=o,btf.activateLightMode=a;const n=t.get("theme"),r=window.matchMedia("(prefers-color-scheme: dark)"),c=window.matchMedia("(prefers-color-scheme: light)");if(void 0===n){if(c.matches)a();else if(r.matches)o();else{const e=(new Date).getHours();e<=6||e>=18?o():a()}r.addEventListener("change",(()=>{void 0===t.get("theme")&&(e.matches?o():a())}))}else"light"===n?a():o();const d=t.get("aside-status");void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:{chs_to_cht:"已切换为繁体中文",cht_to_chs:"已切换为简体中文",day_to_night:"已切换为深色模式",night_to_day:"已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-center"},infinitegrid:{js:"https://unpkg.com/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"数据结构与算法",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,isShuoshuo:!1}</script><link rel="stylesheet" href="/css/bilibiliBanner.css" media="defer" onload='this.media="screen"'><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/time.css"><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="iron-container iron-circle"><div class="iron-box1 iron-circle iron-center"></div><div class="iron-box2 iron-circle iron-center"></div><div class="iron-box3 iron-circle iron-center"></div><div class="iron-box4 iron-circle iron-center"></div><div class="iron-box5 iron-circle iron-center"></div><div class="iron-box6 iron-circle"><div class="iron-coil" style="--i:0"></div><div class="iron-coil" style="--i:1"></div><div class="iron-coil" style="--i:2"></div><div class="iron-coil" style="--i:3"></div><div class="iron-coil" style="--i:4"></div><div class="iron-coil" style="--i:5"></div><div class="iron-coil" style="--i:6"></div><div class="iron-coil" style="--i:7"></div></div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o=()=>{e.style.overflow="",d.classList.add("loaded")},l=()=>{e.style.overflow="hidden",d.classList.remove("loaded")};l(),window.addEventListener("load",o)})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/%E4%B8%89%E5%8F%B6.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/images/cover/秘密风景.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name iconfont icon-sanyecao">三叶的博客</span></a><a class="nav-page-title" href="/"><span class="site-name iconfont icon-sanyecao">数据结构与算法</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法<a class="post-edit-link" href="https://github.com/shiyuhuiya/shiyuhuiya.github.io/issues_posts/数据结构与算法.md" rel="external nofollow noreferrer" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-07T14:48:29.000Z" title="发表于 2025-02-07 22:48:29">2025-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-14T06:16:31.975Z" title="更新于 2025-02-14 14:16:31">2025-02-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%A7%91%E4%B8%93%E4%B8%9A%E6%A0%B8%E5%BF%83/">计科专业核心</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-02-14 14:16:31&quot;}" hidden></div><h1 id="时间复杂度，空间复杂度"><a href="#时间复杂度，空间复杂度" class="headerlink" title="时间复杂度，空间复杂度"></a>时间复杂度，空间复杂度</h1><h1 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul><li>深度为k的二叉树最多结点数目：深度为k即有k层，第k层的最大结点数等于<code>2^(k-1)</code>，经过等比数列求和后可得到深度为k的二叉树最多有<code>(2^k)-1</code>个结点，这就好比k位二进制能标识的最大的数为<code>(2^k)-1</code>，8位二进制数能表示的最大的数是2^8-1&#x3D;127。</li><li>一条边出现表示一个新的结点（除了根节点）：<code>结点数目=边数+1</code></li><li>边数 &#x3D; 出度为1的结点数目+<code>2*出度为2的结点数目</code>*</li><li>结点总数&#x3D;出度为1的结点数目+出度为2的结点数目+叶子结点数</li><li>结点数目&#x3D;边数+1&#x3D;（出度为1的结点数目+<code>2*出度为2的结点数目</code>）+1，<strong>即不需要确定叶子结点的数目，也可以得出结点总数</strong></li><li>出度为2的结点数 + 1 &#x3D; 叶子结点数</li></ul><p>思路：</p><ul><li><p>思考<code>边数</code>和<code>结点数</code>的关系</p></li><li><p>思考<code>边数</code>和<code>结点出度</code>之间的关系</p></li></ul><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="先序遍历-Preorder"><a href="#先序遍历-Preorder" class="headerlink" title="先序遍历(Preorder)"></a>先序遍历(Preorder)</h4><p>访问顺序：根节点 -&gt; 左子树 -&gt; 右子树</p><ul><li>访问根节点。</li><li>递归地对左子树进行先序遍历。</li><li>递归地对右子树进行先序遍历。</li></ul><p>假设有一棵二叉树如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \</span><br><span class="line">D   E</span><br></pre></td></tr></table></figure><p>先序遍历的结果为：<code>A, B, D, E, C</code></p><h4 id="中序遍历-Inorder"><a href="#中序遍历-Inorder" class="headerlink" title="中序遍历(Inorder)"></a>中序遍历(Inorder)</h4><p><strong>访问顺序</strong>：左子树 -&gt; 根节点 -&gt; 右子树</p><ul><li>递归地对左子树进行中序遍历。</li><li>访问根节点。</li><li>递归地对右子树进行中序遍历。</li></ul><p>假设有一棵二叉树如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \</span><br><span class="line">D   E</span><br></pre></td></tr></table></figure><p>中序遍历的结果为：<code>D,B,E,A,C</code></p><h4 id="后序遍历（Postorder）"><a href="#后序遍历（Postorder）" class="headerlink" title="后序遍历（Postorder）"></a>后序遍历（Postorder）</h4><p><strong>访问顺序</strong>：左子树 -&gt; 右子树 -&gt; 根节点</p><ul><li>递归地对左子树进行后序遍历。</li><li>递归地对右子树进行后序遍历。</li><li>访问根节点。</li></ul><p>假设有一棵二叉树如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \</span><br><span class="line">D   E</span><br></pre></td></tr></table></figure><p>后序遍历的结果为：<code>D,E,B,C,A</code></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><ul><li><p>无右孩子的二叉树，先序序列和后序序列正好相反</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   /</span><br><span class="line">  B</span><br><span class="line"> /</span><br><span class="line">D</span><br></pre></td></tr></table></figure></li><li><p>只有根结点的二叉树或非叶子结点只有右子树的二叉树</p></li></ul><h3 id="常见名词解释"><a href="#常见名词解释" class="headerlink" title="常见名词解释"></a>常见名词解释</h3><p>完全二叉树：即除了最后一层之外，每一层都被完全填满，并且最后一层尽可能靠左填充。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \  /</span><br><span class="line">D   E F  </span><br></pre></td></tr></table></figure><p>满二叉树：每层结点都是满的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \  /\</span><br><span class="line">D   E F G</span><br></pre></td></tr></table></figure><h3 id="二叉排序树-搜索树-查找树"><a href="#二叉排序树-搜索树-查找树" class="headerlink" title="二叉排序树 搜索树 查找树"></a>二叉排序树 搜索树 查找树</h3><p>要求<code>左子树的所有结点的值&lt;根结点的值&lt;右子树所有结点的值</code></p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>二分查找一般要求线性存储，插入删除元素的时间复杂度为<code>O(n)</code>；而使用<code>二叉查找树</code>就能实现插入和删除的时间复杂度为<code>O(logn)</code></p><h4 id="构建二叉搜索树"><a href="#构建二叉搜索树" class="headerlink" title="构建二叉搜索树"></a>构建二叉搜索树</h4><ul><li>同一批数字，按不同的方式排列，构建出来的二叉树可能是<code>不同</code>的，但是都必须满足规则，且<code>中序遍历</code>的序列都是有序的</li><li>如果这批数字本身就是有序的，那么构建出的二叉树就是<code>链表</code>，查找的时间复杂度变为<code>O(n)</code></li></ul><h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><ul><li>如果删除的是叶子结点直接删除</li><li>否则从这个结点的<code>左子树中找出最大</code>的或者<code>右子树最小</code>的作为新的根。</li></ul><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>构建<code>二叉搜索树</code>有时候会出现<code>链表</code>，使得查找的时间复杂度变高；需要寻找一种方法解决这个问题</p><p>平衡二叉树，<code>所有结点</code>的<code>(左子树高度-右子树高度)的绝对值&lt;=1</code>（平衡因子&#x3D;|左子树高度-右子树高度|）</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>能实现在<code>不出现歧义</code>的情况下实现<code>最短编码</code></p><p>哈夫曼编码和二叉树有啥关系？利用二叉树实现哈夫曼编码，这棵树叫做<code>哈夫曼树</code></p><h4 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h4><ul><li>确定结点的值：把每个元素归为一个节点，结点的值是元素的<code>个数</code></li><li>合并结点：找出值最小的两个节点，合并为一个新的父节点，这个父节点的值是两个节点值的和</li><li>合并产生的节点继续参与拼接，<code>重排队列</code>，依此类推，<strong>从下往上</strong>构建一株哈夫曼树</li><li>给路径编号，得到该结点的编号；左边路径编号为0，右边路径编号为1（其实是任意的），<strong>某个节点的编号等于根节点到该节点路径编号的拼接</strong></li></ul><h4 id="哈夫曼树的特点"><a href="#哈夫曼树的特点" class="headerlink" title="哈夫曼树的特点"></a>哈夫曼树的特点</h4><ul><li>结点的度只能是0，2；因为二叉树是<code>叶子结点</code>或者<code>非叶子结点</code>两两合并形成的，度为2的结点都是合并形成的，叶子结点是原来就有的（编码序列）；由这个特点很容易得到<code>叶子结点</code>和<code>非叶子结点</code>的关系</li><li><code>叶子节点数-1=非叶子结点数</code>；边数+1 &#x3D; 结点数 &#x3D; <code>度为2的非叶子结点</code>+叶子结点 &#x3D; <code>(2*度为2的非叶子结点数)</code>+1，<strong>推导出叶子结点数等于非叶子结点数+1</strong></li><li>也就是说如果需要给n个不同的元素编码，也就是有n个叶子结点，最终构建的哈夫曼树会有<code>2*n-1</code>个结点</li></ul><h4 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h4><p><code>所有叶子节点的路径长度*节点的值 的和</code>，其实就是<strong>最终编码长度</strong></p><h4 id="如何实现最短？"><a href="#如何实现最短？" class="headerlink" title="如何实现最短？"></a>如何实现最短？</h4><p>个数越多的元素越晚被合并，到根节点的路径越短，编号越短；正因个数越多的编码越短，就能实现总编码序列最短。</p><h4 id="如何实现无起歧义？"><a href="#如何实现无起歧义？" class="headerlink" title="如何实现无起歧义？"></a>如何实现无起歧义？</h4><p>没有前缀就没有歧义（某个元素的编码不是任何一个元素编码的前缀部分），因为从根结点到任意叶子节点所经过的路径，不会是根结点到其他叶子节点所经过的路径的<strong>前缀</strong>，<strong>因为叶子结点之后不会再有结点</strong>。</p><h2 id="散列表（哈希表）"><a href="#散列表（哈希表）" class="headerlink" title="散列表（哈希表）"></a>散列表（哈希表）</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>取余法</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul><li>线性探测法：发生冲突时，顺着冲突地址的<code>下一单元</code>查找空位，如果表尾也没有空位，则从<code>表头</code>开始重新查找</li><li>二次探测法：<code>d=1,-1,2^2,-2^2,3^3,-3^3</code>,…….依此类推，往两边查找，所谓二次探测其实是指的是两个方向</li><li>伪随机数列：d&#x3D;伪随机数</li><li>链地址法：每个地址上独有一个链表，发生冲突把后添加的元素挂载<code>链表</code>后面。</li></ul><h3 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h3><p><code>装填因子 = 装填元素个数 / 散列表长度</code></p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>多对多的一种数据结构</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li><p>邻接：描述两个结点之间的关系，他们之间有<code>边</code>或者<code>弧</code>相连</p></li><li><p>网：有权图</p></li><li><p>连通图：没有孤立的结点，也许存在环</p></li><li><p>强连通图：每个结点都能到达其他结点；有n个顶点的强连通图最多有<code>n(n-1)</code>条边，也就是每两个结点都有一条边；最少有n条边，就是一个环。</p></li></ul><h3 id="存储方法"><a href="#存储方法" class="headerlink" title="存储方法"></a>存储方法</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><ul><li>用一个<code>一维数组</code>存储结点，记录<code>下标</code>和<code>结点</code>的对应关系</li><li>用一个<code>二维数组</code>表示两结点之间的邻接关系，比如<code>arr[i][j]=1</code>表示有条边从<code>i结点</code>指向<code>j结点</code>，如果等于0就表示没有</li></ul><p>结论：</p><ul><li>无向图的邻接矩阵是<code>对称</code>的</li><li>无向图<code>结点i</code>的度等于arr[i]数组的和</li><li>有向图<code>结点i</code>的出度，等于arr[i]的和，入度等于对应列<code>arr[x][i]</code>的和</li><li><code>arr[i][j]=x</code>表示有条边从<code>i结点</code>指向<code>j结点</code>，如果等于无穷大就表示没有，<code>x</code>表示该边的<code>权值</code></li></ul><p><strong>优缺点</strong></p><p>增删结点麻烦；空间复杂度和边数无关，只和结点数有关，可能浪费空间</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><img src="..\images\数据结构与算法\邻接表.png" style="zoom:67%"><ul><li><p>用一个一维数组记录下标与结点的关系；按编号顺序将顶点数据存储在一维数组中;</p></li><li><p>存储空间大小和结点数，边数都有关；</p></li><li><p>方便计算出度；节约稀疏图的空间</p></li><li><p><strong>邻接表不唯一</strong>，每个链表后续结点的顺序都是可变的</p></li></ul><h4 id="逆邻接表"><a href="#逆邻接表" class="headerlink" title="逆邻接表"></a>逆邻接表</h4><p>方便计算入度；节约稀疏图的空间</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>对于任意无向图有向图，邻接矩阵是唯一的，但是邻接表不是唯一的。</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算。</p><p>存在结点重复访问的问题，因为图中出现环是很正常的，解决方法是使用<strong>辅助数组</strong>，记录每个结点的状态</p><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>先序遍历；访问的顺序不是固定的，是随机的</p><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>从图的某一结点出发，首先依次访问该结点的所有邻接点<code>Vi, Vi2....Vi</code>，再按这些顶点被访问的先后次序，依次访问与它们相邻接的所有<code>未被访问</code>的顶点；重复此过程，直至所有顶点均被访问为止，一般通过队列实现。</p><h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><h4 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h4><p>图中所有<code>点</code>均由<code>边</code>连接在—起，但<code>不存在回路的图</code>；一个图可以有<code>多个生成树</code>；生成树是图的<strong>最小连通子图</strong>（树是图的特例，不存在孤立的结点，不存在环；有n个结点，n-1条边）；可以通过<code>深度/广度优先遍历</code>来构造。</p><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>前提是图的各边有权值，<code>最小</code>指的是路径上各边权值和最小；最小生成树不一定唯一（ok，生成树和最小生成树都不是唯一的）</p><p>如何构造（本质都是用了贪心算法）：</p><ul><li>普利姆算法：<ul><li>选择点；起初选择权值最小的那条边对应的2个结点，再查找这两个节点中的那条和其他结点权值最小的边，纳入这个边另一侧的结点，依此类推。</li><li>时间复杂度O(N*2)；n为结点数，因为所有已包含的结点都要查看是否与所有未包含的结点之间存在权值最小的边;适合稠密图</li></ul></li><li>克鲁斯卡尔算法：<ul><li>选择边；每次选择一条权值最小的边，但是如果选择了不满足连通图，则选择次小的边，依此类推</li><li>时间复杂度O(eloge)e为边数；只需要对所有的边进行排序，排序的时间复杂度为eloge；适合稀疏图</li></ul></li></ul><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><p>区别于最小生成树，不需要包含全部结点。</p><p><strong>如何寻找：</strong></p><ul><li>迪杰斯特拉算法：求单个结点到<em>所有其他结点</em>的最短路径，实话只了解思想不懂得原理和算法实现很容易忘</li><li>弗洛伊德算法：求全部结点到其他结点的最短路径</li></ul><p><strong>区别与联系</strong></p><ul><li>第一步都是记录结点与其他结点的<code>直接距离</code>，对于不可达的结点距离设为无穷远</li><li>迪杰斯特拉算法算法后续选择<code>距离最近的结点纳入</code>；已确定最小距离的结点，然后重新计算这个结点加入后，源结点到其他结点的最小距离，然后再纳入距离最近的结点，依此类推，时间复杂度为O(N^2)</li><li>弗洛伊德算法纳入结点的顺序是随意的，一般按照编号纳入，每纳入一个结点就重新计算每个源节点与其他结点的最小距离。</li></ul><h4 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h4><ul><li><p>aov网：拓扑序列</p><ul><li><p>结点表示活动，边表示制约关系，不能存在回路</p></li><li><p><strong>拓扑排序</strong>：把一个aov图输出为一个线性序列（拓扑序列）每个结点的先后顺序不变；可以通过广度优先遍历（队列）实现，必须从没有入度的结点开始，用来检测aov图中是否存在回路。</p></li></ul></li><li><p>aoe网：关键路径</p><ul><li>边表示活动；边的权值表示活动持续的时间，结点表示事件（既可以表示前一个事件的结束，又可以表示下一个事件的开始）</li><li>入度为0的结点也叫源点，出度为0的结点也叫汇点</li><li>关键路径——源点到汇点<code>路径长度最长</code>的路径。路径长度——路径上各活动持续时间之和。</li></ul></li></ul><h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>定义：数组是一种固定大小的线性结构，它将元素存储在一个连续的内存位置中；</p><p>优点：数组可以通过索引直接访问其元素，因此访问速度快</p><p>缺点：插入和删除操作通常需要移动大量元素。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表中元素的存储是不连续的，每个结点包含数据和对下一个结点的引用</p><p>增删元素快，查询元素慢</p><p><strong>单循环链表</strong></p><img src="..\images\数据结构与算法\单循环链表.png" style="zoom:67%"><p>单循环链表，即单个方向循环的链表</p><p>由图可知，单循环链表删除首结点的操作是:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const first = Q-&gt;rear-&gt;next</span><br><span class="line">Q-&gt;rear-&gt;next = first.next</span><br><span class="line">first.next = null</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出的线性结构</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出的线性结构</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul><li>顺序存储（数组）</li><li>链式存储（链表）</li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><img src="..\images\数据结构与算法\队列.png" style="zoom:50%"><p><code>front</code>指向队头的元素，<code>rear</code>指向下一个空地址，起初这两个指针的指向是相同的。</p><p>入队一个元素，<code>rear++</code>；出队一个元素<code>front--</code>，可以看出front始终指向队列中最先入队的元素。</p><h3 id="循环队列（顺序存储）"><a href="#循环队列（顺序存储）" class="headerlink" title="循环队列（顺序存储）"></a>循环队列（顺序存储）</h3><p>循环队列用来解决队列假满的问题，就是<code>rear=maxsize</code>，但是<code>font!=0</code>，此时虽然队列中还有空间，但是无法放入元素。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>在逻辑上实现循环，实际上存储结构还是数组</li><li>出队一个元素，头指针的指向改变：<code>front=(front+1)%maxsize</code></li><li>入队一个元素，尾指针的变化：<code>rear=(rear+1)%maxsize</code></li><li>这样好像是进出队列就没限制了，但是其实只要保证出队列的时候，是弹出front指针指向的元素就行。</li></ul><h4 id="判断非空"><a href="#判断非空" class="headerlink" title="判断非空"></a>判断非空</h4><p>循环队列虽然能解决假满的问题，又引出一个<strong>新的问题</strong>，当<code>front==rear</code>时存在两种情况，队满和队空，无法判断具体是情况。</p><p><img src="..\images\数据结构与算法\队列假满.png" style="zoom:50%"><img src="..\images\数据结构与算法\队列假满2.png" style="zoom:50%"></p><p>解决办法：</p><ul><li>设置一个标志位，记录元素个数</li><li><strong>少用一个元素空间</strong>：<ul><li>队空：<code>front==rear</code></li><li>队满：<code>(rear+1)%maxsize == front</code> ，即尾指针的下一个位置就是头指针的位置，这个时候就记作队满</li><li>初始状态：<code>front=rear=0</code></li><li>判断元素个数：<code>(rear+maxsize-front)%maxsize</code>，如果rear本来就比front大，那么<code>rear-front&gt;0</code>，加上maxsize求余的结果也不变，反之如果出现rear&lt;front这种<code>异常情况</code>，给rear加上maxsize才能转化出rear原本的下标。</li></ul></li></ul><p><strong>以后如果不是特别说明都认为循环队列少用一个元素空间</strong></p><p>总的来说，我们通过<code>循环队列</code>和<code>少用一个元素空间</code>的方法，完美的解决了<code>队列假满</code>和front&#x3D;&#x3D;rear时状态二义的问题。</p><h3 id="链队（带头结点）"><a href="#链队（带头结点）" class="headerlink" title="链队（带头结点）"></a>链队（带头结点）</h3><p>也是带有头尾两个指针，带有头结点，头节点不存储实际的数据</p><p>起初，两个指针<code>都指向头节点</code>即<code>front=rear=new Node()</code>，后续元素入队则<code>rear.next = new Node()</code>，<code>rear = rear.next</code>，front始终指向头节点。</p><p>我们也注意到，在用链表表示的队列中，尾指针rear指向的竟然是最后一个结点，而在用数组表示的 队列中，rear指向的是下一个元素填入的位置，而不是最后一个元素…..</p><img src="..\images\数据结构与算法\链式队列.png" style="zoom:33%"><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><ul><li><code>const first = front.next</code>(存储队首元素地址)</li><li><code>front.next = first.next</code>(修改头节点的下一个结点)</li><li><code>first.next = null</code>(断开队首元素与队列的连接)</li><li>一般情况下，元素出队<strong>只需要修改头结点</strong>，但如果链队只有一个结点，那么出队不仅要修改头指针，还要修改尾指针，让尾指针指向头节点。</li></ul><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><ul><li><code>const last = rear</code></li><li><code>rear = new Node()</code></li><li><code>last.next = rear</code></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>可以观察到，对于带头结点的队列，无论插入元素还是弹出元素，头指针(front)始终指向<code>头节点</code>。</p><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>零个或多个字符组成的有限序列，存储的是字符</p><h3 id="名词解释-1"><a href="#名词解释-1" class="headerlink" title="名词解释"></a>名词解释</h3><p>空串：长度为0的串</p><p>空白串：由空白字符组成的串，长度不为0</p><p>子序列：是主串中的字符集合，这些字符的相对顺序与在主串中相同，可以不连续。</p><p>子串：主串中任意个连续字符组成的子序列</p><p>子串位置：子串第一个字符在主串中的位置序号</p><p>真字串：不包含本身的子串</p><p>主串：包含子串的串</p><h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><ul><li><p>BF算法：暴力算法&#x2F;简单匹配法</p></li><li><p>KMP算法</p></li></ul><h3 id="存储模式"><a href="#存储模式" class="headerlink" title="存储模式"></a>存储模式</h3><ul><li>顺序存储：结构存储密度高</li><li>链式存储结构：存储密度低，因为还要存储下一个节点的地址；操作方便</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆在逻辑上是一种特殊的<code>完全二叉树</code>，分为<code>大根堆</code>和<code>小根堆</code>；大根堆指的是根节点比左右子节点的值大，小根堆反之，至于左右子节点的大小没有限制。</p><img src="..\images\数据结构与算法\大根堆.png" style="zoom:67%"><h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><img src="..\images\数据结构与算法\堆的存储.png" style="zoom:50%"><p>堆通常使用数组来实现，这样可以方便地进行索引操作。</p><p>在数组表示的堆中，对于任意节点 i（索引从 0 开始）：</p><ul><li>根节点索引为i</li><li>左子节点的索引为 <code>2i + 1</code>。</li><li>右子节点的索引为 <code>2i + 2</code>。</li><li>父节点的索引为 <code>(j - 1) / 2</code>（向下取整）。j指的是左右子节点索引</li></ul><h3 id="调整堆"><a href="#调整堆" class="headerlink" title="调整堆"></a>调整堆</h3><h4 id="下滤"><a href="#下滤" class="headerlink" title="下滤"></a>下滤</h4><ul><li>适用于根节点不符合堆序的情况</li><li>弹出堆顶元素，并用末尾元素替代堆顶元素时，适合使用这种方式调整堆。</li></ul><h4 id="上滤"><a href="#上滤" class="headerlink" title="上滤"></a>上滤</h4><ul><li>适合子节点不符合堆序的情况</li><li>新插入的元素使用这种方式调整堆</li></ul><h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><h4 id="自顶向下构建"><a href="#自顶向下构建" class="headerlink" title="自顶向下构建"></a>自顶向下构建</h4><ul><li>已知一串序列，从上到下，从左到右构建二叉树，边构建过程中边调整，也就是上滤</li><li>假设结点数为N，则层数大概为log2(N)；构建堆需要添加N个结点，每个结点最多移动log2(N)次，所以时间复杂度可以助记为Nlog2(N)</li></ul><h4 id="自底向上构建（也叫筛选法）"><a href="#自底向上构建（也叫筛选法）" class="headerlink" title="自底向上构建（也叫筛选法）"></a>自底向上构建（也叫筛选法）</h4><p>已知一串序列，从下到上，从左到右构建二叉树；构建好了再从底部<strong>最后一个非叶子结点</strong>开始调整堆（下滤，意思就是每个非叶子结点都有可能被交换到下一层）；</p><p><strong>时间复杂度为O（N）</strong>，如果是完全二叉树，非叶子结点大概有 结点数目的一半（n&#x2F;2），然后每次<code>heapify</code>最多进行2次比较和2次交换，时间复杂度就是<code>4*(n/2)</code>，无论如何时间复杂度都是<code>O(n)</code></p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a><strong>拓展</strong></h3><ul><li>一棵二叉树，第1层最多有<code>2^0</code>个结点，第2层最多有<code>2^1</code>，第三层最多有<code>2^2</code>…..;每层最多有<code>2^(n-1)</code>个结点（n代表第几层）; 规律和<strong>2进制</strong>一样。</li><li>假设二叉树有n层（n位），结点数目最多为<code>2^n-1</code>，比如8位二进制能表示的最大数就是<code>2^8-1=255</code></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>优先队列</p><ul><li><p>队首元素永远是最大&#x2F;最小的，每次弹出或者加入元素都会重新调整队列</p></li><li><p>弹出（下滤）和插入结点（上滤）维护的时间复杂度都为log2(N)</p></li></ul></li><li><p>堆排序：不断弹出堆顶元素并重新调整堆；n个元素，需要建堆n次（第一次初始建堆，后续只需维护），每次 建好后再取走。</p></li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>建堆：一般指的是初次构建，从底往上构建堆的时间复杂度，为O（n）</li><li>调整堆、插入、删除（维护堆）：O(log2（n）) 因为n个结点的堆最多有log2（n）层，调整的时候最多移动有log2（n）-1次</li><li>堆排序：建堆时间复杂度<code>+</code>n次调整时间复杂度，<code>O（n）+O（nlogn）约等于O（nlogn)</code></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在计算机科学中，“堆”也指代一种<code>内存区域</code>，用于<code>动态分配</code>内存，但这与作为数据结构的堆有所不同。</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>逐步排序数组：有n个元素，遍历n-1遍，每次遍历都可能把当前遍历元素插入到已遍历的位置，确保到当前位置位置的元素是有序的，直至遍历到最后一个元素，确保全部元素有序。</p><p>时间复杂度</p><ul><li>遍历n-1遍，每次遍历都可能需要插入，最坏（逆序）时间复杂度为O（n^2);也可能都不需要插入，本来就有序，每次只需要比较一次，时间复杂度为O（n）；平均情况时间复杂度：O(n^2)，和选择排序，冒泡排序坐一桌</li><li>无论是否有序，都要遍历n-1次</li></ul><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>插入排序的一个更高效的改进版本</p><p>步骤：</p><ul><li>根据步长分为多个子表，步长为n就有n组子表</li><li>对每组子表进行直接插入排序</li><li>更改步长为n&#x2F;2，即原来的一半，再对每组子表进行直接插入排序</li><li>依此类推，直至步长缩短为1，进行最后一次插入排序</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span><span class="comment">//初始化为true，即便已经有序也要走一遍检查一下</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span> &amp;&amp; flag; i++) &#123;<span class="comment">//因为可能不需要排序n-1次，对循环退出再加个条件</span></span><br><span class="line">    flag = <span class="literal">false</span><span class="comment">//先假设序列是有序的，不需要再走一遍</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; arr.<span class="property">length</span> - i; j++) &#123;</span><br></pre></td></tr></table></figure><ul><li>从右往左维护，遍历n-1遍</li><li>从第二个元素开始遍历，判断该元素是否小于前一个元素，如果是则交换</li><li>以此类推确保当前遍历位置的元素是遍历到的所有元素中最大的；下次遍历维护好的元素不参与比较</li><li>冒泡冒泡就是让最大的冒泡到最后面，重点在找最大的元素</li></ul><p>时间复杂度：如果序列本身有序，则只走一趟，比较n-1次，不交换元素，时间复杂度为O(n)</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr3.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr3.<span class="property">length</span>; j++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>从左往右维护，遍历n-1遍；找出最小的元素，和第i个元素交换，第i个元素就是要维护的元素</li><li>比较次数与初始序列无关，时间复杂度和初始序列无关；</li><li>无论初始序列如何，每次遍历都要比较n-1，n-2, n-3,….,1次，总的比较次数为n(n-1)&#x2F;2，时间复杂度为O(n^2)</li><li>算法的排序趟数与初始序列无关,就是要遍历n-1遍</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>用到了递归的思想，用到了轴的思想，每次只确定一个元素的位置</p><p>每次都以第一个元素为轴，遍历所有其他元素，让所有比第一个元素小的元素在轴的左边，比第一个元素是大的元素在轴的右边，遍历完所有元素就能确定第一个元素该在哪个位置，每次遍历只能确定一个元素的位置，所以还需要递归轴左边的和轴右边的部分，确定所有元素的位置</p><p>时间复杂度：平均情况为nlogn，最坏情况n^2,最坏情况是数组本身就有序，每次快排都要比较n-1,n-2,….,1次，所以时间复杂度为n^2</p><p>空间复杂度：O(1)原地排序</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>用到了二叉树的逻辑结构，对数组中的数据进行层次遍历</p><p>也是每次建堆都能等到最大的&#x2F;最小的元素，就和选择排序每次能得到最小（最大）的元素一样，堆排序其实就是选择排序的优化</p><p>如果是升序排列则是构建大根堆，反之小根堆</p><p>时间复杂度：O(nlogn)，最好最坏情况都是，而且不占用额外空间，缺点是不稳定</p><p>空间复杂度：O(1)原地排序</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>两有序并为1有序，利用了一个元素必然就是有序的这一特点作为递归出口<br>合并有序数组的算法实现也是一个重点，用到了分治的思想，分而治之，对一个数组排序的工作可以划分为多左半部分排序再对右半部分排序，再合并，当一部分划分到只有一个元素时候，这部分自然就是有序的了直接返回即可</p><p>时间复杂度：O(nlogn)，没有最坏情况，而且稳定没缺点就是需要额外空间（递归栈来维护）<br>空间复杂度：需要额外的空间，非O（1）</p><h2 id="如何判断排序方法是否稳定"><a href="#如何判断排序方法是否稳定" class="headerlink" title="如何判断排序方法是否稳定"></a>如何判断排序方法是否稳定</h2><p>大小相同的元素排序后，前后顺序保持不变的就是稳定的</p><p>不稳定的排序算法</p><ul><li>选择排序：比如：[4, 4, 2, 1]-&gt;[1,4,2,4]-&gt;[1,2,4,4]</li><li>希尔排序比如：[2, 2, 1, 3]-&gt;[2,1],[2,3]-&gt;[1,2],[2,3]-&gt;[1,2,2,3]</li><li>快速排序：可能不稳定</li><li>堆排序：可能不稳定</li></ul><p>其他排序算法都是稳定的，口诀：一堆希尔快选</p><h2 id="排序方法的选择"><a href="#排序方法的选择" class="headerlink" title="排序方法的选择"></a>排序方法的选择</h2><p>算法的时间复杂度与初始序列无关的是：选择排序、堆排序、归并排序</p><h2 id="插入-删除的时间复杂度"><a href="#插入-删除的时间复杂度" class="headerlink" title="插入&#x2F;删除的时间复杂度"></a>插入&#x2F;删除的时间复杂度</h2><p>假设有n个元素，则有n+1中插入方式，位置从左到右边分别移动n，n-1，….,0个元素，总共移动（1+n）*n&#x2F;2次，平均每次插入移动n&#x2F;2次，所以插入的时间复杂度是O(n)。删除同理。</p><h2 id="二分查找次数"><a href="#二分查找次数" class="headerlink" title="二分查找次数"></a>二分查找次数</h2><h3 id="快速判断"><a href="#快速判断" class="headerlink" title="快速判断"></a>快速判断</h3><p>假设有100个元素，最大查找次数为n，则有2^n&gt;&#x3D;100，n&#x3D;6为64&lt;100,n&#x3D;7为128&gt;100满足题意</p><h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><p>每查找一次都将区间减半，直到区间长度为1（对于每次查找的中间元素，我们都把它纳入下次查找区间，方便理解，虽然它不可能是要查找的元素，理应不存在这个区间）</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>2^x(x为查找次数)，n为元素个数，x&#x3D;log2(n),这个值就是时间复杂度。</p><h1 id="js中的数据结构"><a href="#js中的数据结构" class="headerlink" title="js中的数据结构"></a>js中的数据结构</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>js中的数据结构都是用类和对象来实现的，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val, next = <span class="literal">null</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val; <span class="comment">// 节点的值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = next; <span class="comment">// 指向下一个节点的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>str.toLowerCase()</strong></p><p>将字符串中的所有<code>大写字母</code>转换为小写，返回一个<code>新的字符串</code>，不会修改原来的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lowerStr = str.<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lowerStr); <span class="comment">// 输出: &quot;hello world!&quot;</span></span><br></pre></td></tr></table></figure><p><strong>str.codePointAt</strong>()</p><p>返回字符串指定位置字符的asc编码,如果只是想要知道某个字符的asc编码，让这个字符串只包含一个字母即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> charA = <span class="string">&quot;A&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> codeA = charA.<span class="title function_">codePointAt</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(codeA); <span class="comment">// 输出: 65 (大写字母 &#x27;A&#x27; 的 Unicode 编码)</span></span><br></pre></td></tr></table></figure><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><ul><li>Math.round()：四舍五入</li><li>Math.ceil()：向上取整</li><li>Math.floor()：向下取整</li><li>Math.max()：求最大值</li><li>Math.min()：求最小值</li></ul><p><strong>注意：没有提供Math.sum方法</strong></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://www.sanye.blog">三叶sanye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://www.sanye.blog/posts/4b0178e0.html">https://www.sanye.blog/posts/4b0178e0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.sanye.blog" target="_blank">三叶的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="post-share"><div class="social-share" data-image="/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/e255a10a.html" title="计算机网络"><img class="cover" src="/images/cover/maomao.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">计算机网络</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/posts/d04bd5bc.html" title="操作系统"><img class="cover" src="/images/cover/%E6%98%9F%E7%A9%BA.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">操作系统</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/%E4%B8%89%E5%8F%B6.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">三叶sanye</div><div class="author-info-description">记录学习，分享知识</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://space.bilibili.com/660655866?spm_id_from=333.1007.0.0" rel="external nofollow noreferrer" target="_blank" title="Bilibli"><i class="fa-brands fa-bilibili" style="color:#74c0fc"></i></a><a class="social-icon" href="https://github.com/syhy" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:3519450570@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">笔记主要自用，希望也能帮到你😀</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">时间复杂度，空间复杂度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">非线性结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.1.2.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-Preorder"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">先序遍历(Preorder)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-Inorder"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">中序遍历(Inorder)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88Postorder%EF%BC%89"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">后序遍历（Postorder）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">2.1.3.</span> <span class="toc-text">常见名词解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-%E6%90%9C%E7%B4%A2%E6%A0%91-%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">2.1.4.</span> <span class="toc-text">二叉排序树 搜索树 查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">构建二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">删除结点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.1.5.</span> <span class="toc-text">平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF-1"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">背景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">2.1.6.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">哈夫曼编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">构建哈夫曼树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.6.3.</span> <span class="toc-text">哈夫曼树的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-number">2.1.6.4.</span> <span class="toc-text">带权路径长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%9F%AD%EF%BC%9F"><span class="toc-number">2.1.6.5.</span> <span class="toc-text">如何实现最短？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%A0%E8%B5%B7%E6%AD%A7%E4%B9%89%EF%BC%9F"><span class="toc-number">2.1.6.6.</span> <span class="toc-text">如何实现无起歧义？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">散列表（哈希表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">2.2.1.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">解决冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E5%A1%AB%E5%9B%A0%E5%AD%90"><span class="toc-number">2.2.3.</span> <span class="toc-text">装填因子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">2.3.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">2.3.1.</span> <span class="toc-text">名词解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">存储方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">逆邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.3.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">深度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">广度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.3.4.</span> <span class="toc-text">图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">最短路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE"><span class="toc-number">2.3.4.4.</span> <span class="toc-text">有向无环图</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">线性结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.3.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">3.4.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">3.4.2.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%88%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">3.4.3.</span> <span class="toc-text">循环队列（顺序存储）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%9D%9E%E7%A9%BA"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">判断非空</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%EF%BC%88%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%EF%BC%89"><span class="toc-number">3.4.4.</span> <span class="toc-text">链队（带头结点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E9%98%9F"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">出队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E9%98%9F"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">3.5.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A-1"><span class="toc-number">3.5.1.</span> <span class="toc-text">名词解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.2.</span> <span class="toc-text">串的模式匹配算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.3.</span> <span class="toc-text">存储模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">3.6.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.6.1.</span> <span class="toc-text">堆的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E5%A0%86"><span class="toc-number">3.6.2.</span> <span class="toc-text">调整堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%BB%A4"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">下滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E6%BB%A4"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">上滤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E5%A0%86"><span class="toc-number">3.6.3.</span> <span class="toc-text">建堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%9E%84%E5%BB%BA"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">自顶向下构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E6%9E%84%E5%BB%BA%EF%BC%88%E4%B9%9F%E5%8F%AB%E7%AD%9B%E9%80%89%E6%B3%95%EF%BC%89"><span class="toc-number">3.6.3.2.</span> <span class="toc-text">自底向上构建（也叫筛选法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">3.6.4.</span> <span class="toc-text">拓展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">3.6.5.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.6.6.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">3.6.7.</span> <span class="toc-text">补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.</span> <span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.</span> <span class="toc-text">简单选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.5.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">4.6.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">4.7.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E7%A8%B3%E5%AE%9A"><span class="toc-number">4.8.</span> <span class="toc-text">如何判断排序方法是否稳定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">4.9.</span> <span class="toc-text">排序方法的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">4.10.</span> <span class="toc-text">插入&#x2F;删除的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%AC%A1%E6%95%B0"><span class="toc-number">4.11.</span> <span class="toc-text">二分查找次数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%88%A4%E6%96%AD"><span class="toc-number">4.11.1.</span> <span class="toc-text">快速判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B"><span class="toc-number">4.11.2.</span> <span class="toc-text">详细过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">4.11.3.</span> <span class="toc-text">时间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">js中的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8api"><span class="toc-number">5.2.</span> <span class="toc-text">常用api</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.2.1.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-number">5.2.2.</span> <span class="toc-text">Math</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/19656fd5.html" title="react">react</a><time datetime="2025-02-20T13:33:23.000Z" title="发表于 2025-02-20 21:33:23">2025-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/518e617c.html" title="git"><img src="/images/cover/dog.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="git"></a><div class="content"><a class="title" href="/posts/518e617c.html" title="git">git</a><time datetime="2025-02-09T08:07:36.000Z" title="发表于 2025-02-09 16:07:36">2025-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e255a10a.html" title="计算机网络"><img src="/images/cover/maomao.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="计算机网络"></a><div class="content"><a class="title" href="/posts/e255a10a.html" title="计算机网络">计算机网络</a><time datetime="2025-02-07T15:08:21.000Z" title="发表于 2025-02-07 23:08:21">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4b0178e0.html" title="数据结构与算法"><img src="/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="数据结构与算法"></a><div class="content"><a class="title" href="/posts/4b0178e0.html" title="数据结构与算法">数据结构与算法</a><time datetime="2025-02-07T14:48:29.000Z" title="发表于 2025-02-07 22:48:29">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d04bd5bc.html" title="操作系统"><img src="/images/cover/%E6%98%9F%E7%A9%BA.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="操作系统"></a><div class="content"><a class="title" href="/posts/d04bd5bc.html" title="操作系统">操作系统</a><time datetime="2025-02-06T15:49:56.000Z" title="发表于 2025-02-06 23:49:56">2025-02-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/images/cover/1.png)"><div id="footer-wrap"><div class="footer_custom_text"><div id="sanye"><svg class="icon" aria-hidden="true"><use href="#icon-banquan"></use></svg><span>2024 - 2025 By 三叶sanye</span><svg class="icon" aria-hidden="true"><use href="#icon-sanyecao"></use></svg></div><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://unpkg.com/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/time.js"></script><script src="/js/iconfont.js"></script><script defer id="ribbon" src="https://unpkg.com/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script src="https://unpkg.com/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://unpkg.com/butterfly-extsrc/dist/click-heart.min.js" async mobile="false"></script><script async data-pjax src="/js/busuanzi.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,display:{position:"left",width:120,height:240},mobile:{show:!0},react:{opacity:.7}})</script></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端面试---vue部分 | 三叶的博客</title><meta name="author" content="三叶sanye"><meta name="copyright" content="三叶sanye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Vue2推荐一个学习vue的网站：Vue3 说说你对vue的理解前端发展背景最早的网页是没有数据库的，可以理解成就是一张可以在网络上浏览的报纸，就是纯静态页面 直到CGI技术的出现通过 CGI Perl 运行一小段代码与数据库或文件系统进行交互(前后端交互) 后来JSP(Java Server Pages)技术取代了CGI技术，其实就是Java + HTML 1234567891011&lt;%@">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试---vue部分">
<meta property="og:url" content="https://www.sanye.blog/posts/f33bd2b9.html">
<meta property="og:site_name" content="三叶的博客">
<meta property="og:description" content="Vue2推荐一个学习vue的网站：Vue3 说说你对vue的理解前端发展背景最早的网页是没有数据库的，可以理解成就是一张可以在网络上浏览的报纸，就是纯静态页面 直到CGI技术的出现通过 CGI Perl 运行一小段代码与数据库或文件系统进行交互(前后端交互) 后来JSP(Java Server Pages)技术取代了CGI技术，其实就是Java + HTML 1234567891011&lt;%@">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.sanye.blog/images/cover/%E5%B0%8F%E9%95%87.jpg">
<meta property="article:published_time" content="2024-12-13T10:56:10.000Z">
<meta property="article:modified_time" content="2025-02-20T06:02:00.169Z">
<meta property="article:author" content="三叶sanye">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.sanye.blog/images/cover/%E5%B0%8F%E9%95%87.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.sanye.blog/posts/f33bd2b9.html"><link rel="preconnect" href="//unpkg.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-center"},
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试---vue部分',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/bilibiliBanner.css"  media="defer" onload="this.media='screen'"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/time.css"><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="iron-container iron-circle"><div class="iron-box1 iron-circle iron-center"></div><div class="iron-box2 iron-circle iron-center"></div><div class="iron-box3 iron-circle iron-center"></div><div class="iron-box4 iron-circle iron-center"></div><div class="iron-box5 iron-circle iron-center"></div><div class="iron-box6 iron-circle"><div class="iron-coil" style="--i: 0"></div><div class="iron-coil" style="--i: 1"></div><div class="iron-coil" style="--i: 2"></div><div class="iron-coil" style="--i: 3"></div><div class="iron-coil" style="--i: 4"></div><div class="iron-coil" style="--i: 5"></div><div class="iron-coil" style="--i: 6"></div><div class="iron-coil" style="--i: 7"></div></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/%E4%B8%89%E5%8F%B6.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/cover/小镇.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name iconfont icon-sanyecao">三叶的博客</span></a><a class="nav-page-title" href="/"><span class="site-name iconfont icon-sanyecao">前端面试---vue部分</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">前端面试---vue部分<a class="post-edit-link" href="https://github.com/shiyuhuiya/shiyuhuiya.github.io/issues_posts/前端面试-vue.md" rel="external nofollow noreferrer" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-13T10:56:10.000Z" title="发表于 2024-12-13 18:56:10">2024-12-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-20T06:02:00.169Z" title="更新于 2025-02-20 14:02:00">2025-02-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">前端面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">25.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>94分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-02-20 14:02:00&quot;}" hidden></div><h1 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h1><p>推荐一个学习vue的网站：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.vue3js.cn/">Vue3</a></p>
<h2 id="说说你对vue的理解"><a href="#说说你对vue的理解" class="headerlink" title="说说你对vue的理解"></a>说说你对vue的理解</h2><h3 id="前端发展背景"><a href="#前端发展背景" class="headerlink" title="前端发展背景"></a>前端发展背景</h3><p>最早的网页是没有数据库的，可以理解成就是一张可以在网络上浏览的报纸，就是<code>纯静态页面</code></p>
<p>直到<code>CGI</code>技术的出现通过 CGI Perl 运行一小段代码与数据库或文件系统进行<code>交互</code>(前后端交互)</p>
<p>后来JSP(Java Server Pages)技术取代了CGI技术，其实就是Java + HTML</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=utf-8&quot;</span> pageEncoding=<span class="string">&quot;utf-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;JSP demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=<span class="string">&quot;http://localhost:8080/web05_session/1.jpg&quot;</span> width=<span class="string">&quot;200&quot;</span> height=<span class="string">&quot;100&quot;</span> alt=<span class="string">&quot;示例图片&quot;</span> /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>JSP有一个很大的<code>缺点</code>，就是不太灵活。JSP使用<code> Java</code> 而不是<code> JavaScript</code>，并且 Java 代码只能在服务器端运行。我们每次的请求：获取的数据、内容的加载，服务器都会做对应的处理，并渲染dom然后返回渲染好的dom，简单的来说，JSP把页面的渲染工作完全交给后端服务器。</p>
<p>后来<code>ajax</code>火了，它允许用户在不刷新整个页面的前提下，和后端服务器交换数据，并由浏览器执行js代码，更新部分页面。</p>
<p>随后移动设备的普及，Jquery的出现，以及SPA（Single Page Application 单页面应用）的雏形，Backbone EmberJS AngularJS 这样一批前端框架随之出现，但当时SPA的路不好走，例如SEO问题，SPA 过多的页面、复杂场景下 View 的绑定等，都没有很好的处理经过这几年的飞速发展，节约了开发人员大量的精力、降低了开发者和开发过程的门槛，极大提升了开发效率和迭代速度。我们可以看到Web技术的变化之大与快，每一种新的技术出现都是一些特定场景的解决方案，那我们今天的主角Vue又是为了解决什么呢？</p>
<h3 id="Vue是什么"><a href="#Vue是什么" class="headerlink" title="Vue是什么"></a>Vue是什么</h3><p>是一个用于创建<code>用户界面</code>的开源<code>JavaScript框架</code>，也是一个创建<code>单页应用（SPA）</code>的前端框架。</p>
<h3 id="Vue核心特性"><a href="#Vue核心特性" class="headerlink" title="Vue核心特性"></a><strong>Vue核心特性</strong></h3><ul>
<li><p><strong>数据驱动视图更新</strong></p>
<p>数据驱动(MVVM)</p>
<p>MVVM表示的是 Model-View-ViewModel</p>
<ul>
<li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li>
<li>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</li>
<li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁，在vue中这个桥梁是vue实例</li>
</ul>
</li>
<li><p><strong>组件化</strong></p>
<p>降低了代码的耦合度，可维护性，可扩展性高，便于调试</p>
</li>
<li><p><strong>指令系统</strong></p>
<p>指令 (Directives) 是带有<code> v- 前缀</code>的<code>特殊属性</code>，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p>
<p>常用的指令</p>
<ul>
<li>条件渲染指令 <code>v-if</code></li>
<li>列表渲染指令<code>v-for</code></li>
<li>属性绑定指令<code>v-bind</code></li>
<li>事件绑定指令<code>v-on</code></li>
<li>双向数据绑定指令<code>v-model</code></li>
</ul>
</li>
</ul>
<h2 id="说说你对vue双向绑定的理解"><a href="#说说你对vue双向绑定的理解" class="headerlink" title="说说你对vue双向绑定的理解"></a>说说你对vue双向绑定的理解</h2><p><code>双向绑定</code>不等同于<code>响应式</code>了，这两个东西是有区别的。</p>
<p><code>响应性</code>是一种可以使我们声明式地处理变化的编程范式。简单来讲就是当更改<code>响应式数据</code>时，视图会随即<code>自动更新</code>。而实现这个功能的原理就是劫持数据，收集依赖，当数据发生变化时，执行相应的依赖（副作用&#x2F;更新视图）。响应式的具体实现原理可以参考后面的文章《说说Vue实例挂载过程中发生了什么》，《手写一个简单的vue》，《说说你对Vue.observable的理解》。</p>
<p><code>双向绑定</code>是数据变化驱动视图更新，视图更新触发数据变化。其实就是<code>v-model</code>的功能，而我们知道<code>v-model</code>只是一个语法糖。因此如果要问双向绑定的原理，思路应该是<strong>如何实现这个语法糖</strong>。其原理是把<code>input</code>的value绑定data的一个值，当原生input的事件触发时，用事件的值来更新data的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用 v-model --&gt;</span><br><span class="line">&lt;input v-model=&quot;message&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 编译后的等效代码 --&gt;</span><br><span class="line">&lt;input :value=&quot;message&quot; @input=&quot;e =&gt; &#123;message = e.target.value&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>



<h2 id="Vue的学习路线"><a href="#Vue的学习路线" class="headerlink" title="Vue的学习路线"></a><strong>Vue的学习路线</strong></h2><h3 id="原生开发"><a href="#原生开发" class="headerlink" title="原生开发"></a><strong>原生开发</strong></h3><p>通过script标签引入vue.js,src属性通常是http链接，或者下载到本地的vue.js文件的路径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果是http链接，当浏览器加载这个脚本会发送一个get请求获取并执行vue的js代码，类似jsonp请求。</p>
<p>引入vue.js后，<strong>Vue</strong>这个构造函数成为<strong>全局变量</strong>，挂载到<strong>window</strong>对象上</p>
<p>然后我们在页面的<strong>script</strong>标签中写些代码，创建一个vue实例，传入一个配置对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此时我们还未引入<strong>组件</strong>的概念，但是我们已经能够学习vue的大部分知识点了。包括模板语法，数据绑定，数据代理如何实现，vue的常用指令，计算属性，数据监听，vue的生命周期等等。</p>
<h3 id="原生开发之组件化开发"><a href="#原生开发之组件化开发" class="headerlink" title="原生开发之组件化开发"></a><strong>原生开发之组件化开发</strong></h3><p>什么组件？组件化开发有什么好处？</p>
<p>在vue中，组件就是能实现<code>局部功能</code>的<code>html，css，js</code>代码的集合，组件化开发有利于<strong>代码复用</strong>，提高开发效率，同时把功能上密切相关的html，css，js代码放到一起，<strong>依赖关系明确</strong>，易于维护。</p>
<p>vue的组件可分为<strong>单文件组件</strong>和<strong>非单文件组件</strong>，非单文件组件就是通过<strong>Vue.extend({})<strong>，返回一个</strong>VueComponent</strong>构造函数，这个</p>
<p>构造函数被用来创建<strong>组件实例</strong>，依赖的<strong>配置对象</strong>就是<code>Vue.extend(&#123;&#125;)</code>传入的对象，这个配置对象的结构和<code>new Vue()</code>传入的配置对象的结构几乎一致。存在如下关系，即<code>Vuecomponent</code>是Vue的<code>子类</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">组件实例.<span class="property">_proto_</span> = <span class="title class_">VueComponent</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">VueComponent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_proto_</span> = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure>

<img src="..\images\前端面试-vue\vue.png" style="zoom:80%;" />

<h3 id="非单文件组件使用"><a href="#非单文件组件使用" class="headerlink" title="非单文件组件使用"></a><strong>非单文件组件使用</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">:name</span>=<span class="string">&quot;str&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;str&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">School</span>&gt;</span><span class="tag">&lt;/<span class="name">School</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个school组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">School</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">str</span>: <span class="string">&quot;haha&quot;</span>,</span><br><span class="line">      <span class="attr">keyword</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//组件注册</span></span><br><span class="line">    <span class="attr">components</span>:&#123;<span class="title class_">School</span>&#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>



<h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a><strong>单文件组件</strong></h3><p>单文件组件就是我们熟知的<code>.vue</code>文件, 单文件组件解决了非单文件组件无法把<strong>css代码</strong>与html，js代码放到一起的问题。</p>
<p>显然，<code>.vue</code>文件是vue团队开发的文件，无法在浏览器上运行，所以我们需要借助打包工具webpack来处理这个文件，webpack又是基于nodejs的，nodejs是使用模块化开发的。这样vue的开发就过渡到了基于nodejs+webpack的<strong>模块化</strong>开发，为了简化模块化开发过程中webpack的配置，vue团队就开发了<code>vue-cli</code>，即vue的脚手架</p>
<p>单文件组件的大致结构如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中<code>export default &#123;&#125;</code>由<code>export default Vue.extend(&#123;&#125;)</code>简化而来的，组件注册的时候会自动处理。</p>
<p>组件之间通过嵌套确定层级关系，所有其他组件都在根组件App.vue内，根组件直接嵌入index.html文件；组件化开发后不需要直接在html页面中写结构，内容被分解为一个一个vue组件。</p>
<h2 id="谈谈对el和template属性的理解"><a href="#谈谈对el和template属性的理解" class="headerlink" title="谈谈对el和template属性的理解"></a>谈谈对el和template属性的理解</h2><p>当我们在学习Vue的基础语法，vue的组件的适合一定涉及到了这两个容易混淆的属性。</p>
<ul>
<li><p><strong>创建Vue根实例必须要给出el属性</strong>，指明要为哪个容器服务，这个容器会成为<strong>模板</strong>；创建<code>组件实例</code><strong>不能</strong>传入el属性。</p>
</li>
<li><p>如果创建<strong>vue根实例</strong>同时配置了el和template属性，则template将<strong>替换el</strong>指定的容器成为模板(可以参考<code>vm.$mount</code>源码，template属性优先级更高)，不过要注意的是nodejs开发环境中，通过<code>import</code>导入的<code>vue</code>是精简版的，<strong>没有模板解析器的</strong>, 模板解析器被单独提取出来作为一个开发环境的包(生产环境打包就不会将模板解析器包含进去，从而减小最终文件的体积)，用来处理<code>.vue</code>文件中的<code>template</code>，所以在创建vue根实例的时候不能使用<code>template</code>，所以无法借助它实现在页面中自动插入Vue.app的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&#x27;&lt;App&gt;&lt;/App&gt;&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>:&#123;<span class="title class_">App</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码会报错，不能配置<code>template</code></p>
<p>应当修改为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">render</span>:<span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)<span class="comment">//传入的h是createElement函数，用来创建VNode</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>或者引入完整版的vue.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue/dist/vue.js&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建组件必须指定组件的结构，即template，组件的模板，不必指定组件为哪个容器服务（不要el）</p>
</li>
<li><p>el指定的容器中的<code>结构</code>可以被抽离为一个一个单独的模板<code>template</code>，一个个单独的组件，也就是说模板中可以不写实际结构，只写组件标签，这些组件标签会在模板解析的时候被解析。</p>
</li>
<li><p>其实组件中的<code>template</code>也能被拆分，从而形成一个一个组件，这就是组件的嵌套。</p>
</li>
</ul>
<h2 id="说说Vue实例挂载过程中发生了什么"><a href="#说说Vue实例挂载过程中发生了什么" class="headerlink" title="说说Vue实例挂载过程中发生了什么"></a>说说Vue实例挂载过程中发生了什么</h2><p>我们都听过知其然知其所以然这句话</p>
<p>那么不知道大家是否思考过<code>new Vue()</code>这个过程中究竟做了些什么？</p>
<p>过程中是如何完成<code>数据的绑定</code>，又是如何将<code>数据渲染到视图</code>的等等。</p>
<h3 id="流程图一览"><a href="#流程图一览" class="headerlink" title="流程图一览"></a>流程图一览</h3><img src="..\images\前端面试-vue\vue挂载3.png" style="zoom: 67%;" />

<h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>首先找到<code>vue</code>的构造函数</p>
<p><strong>vue构造函数源码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：src\core\instance\index.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">//如果不是Vue实例调用这个构造函数就报错</span></span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//this指向创建的Vue实例</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>options</code>是用户传递入的配置对象，包含<code>data、methods</code>等常用属性。</p>
<p><code>vue</code>构建函数调用了<code>_init</code>方法，并传入了<code>options</code>，所以我们关注的核心就是<code>_init</code>方法：</p>
<p><strong>_init方法源码</strong></p>
<img src="..\images\前端面试-vue\vue挂载.png" style="zoom: 80%;" />

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：src\core\instance\init.js</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="comment">//vm = this = vue实例</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    ....</span><br><span class="line">	<span class="comment">// 初始化组件生命周期标志位</span></span><br><span class="line">	<span class="title function_">initLifecycle</span>(vm)</span><br><span class="line">	<span class="comment">// 初始化组件事件侦听</span></span><br><span class="line">	<span class="title function_">initEvents</span>(vm)</span><br><span class="line">	<span class="comment">// 初始化渲染方法</span></span><br><span class="line">	<span class="title function_">initRender</span>(vm)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 调用生命周期钩子&#x27;beforeCreate&#x27;</span></span><br><span class="line">	<span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 初始化注入内容，在初始化data、props之前。</span></span><br><span class="line">	<span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">	<span class="comment">// 初始化 props/data/method/watch/methods/computed</span></span><br><span class="line">	<span class="title function_">initState</span>(vm)</span><br><span class="line">	<span class="comment">//之所以最后初始化Provide，因为Provide引用的数据就是data或者computed等属性中的。</span></span><br><span class="line">	<span class="title function_">initProvide</span>(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 调用生命周期钩子&#x27;created&#x27;</span></span><br><span class="line">	<span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">	....</span><br><span class="line">	<span class="comment">// 挂载元素</span></span><br><span class="line">	<span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">	   vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析后得出如下结论：</p>
<ul>
<li>在调用<code>beforeCreate</code>之前，主要做一些数据初始化的工作，<code>数据初始化</code>并未完成，像<code>data</code>、<code>props</code>这些对象内部属性无法通过<code>this</code>访问到。所以说<code>beforeCreate</code>的执行时机<code>先于data()函数调用</code></li>
<li>执行<code>created</code>的时候，数据已经初始化完成，能够通过<code>this</code>访问<code>data</code>、<code>props</code>这些对象的属性，但这时候并未完成<code>dom</code>的挂载，因此无法访问到<code>dom</code>元素</li>
<li>通过调用<code>vm.$mount</code>方法实现了dom挂载</li>
</ul>
<p>我们主要进一步分析<code>initState</code>方法</p>
<p><strong>initState方法源码</strong></p>
<img src="..\images\前端面试-vue\vue挂载2.png" style="zoom: 67%;" />

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：src\core\instance\state.js</span></span><br><span class="line"><span class="comment">//vm是vue实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span> (<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化组件的watcher列表</span></span><br><span class="line">  vm.<span class="property">_watchers</span> = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span></span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>)</span><br><span class="line">  <span class="comment">// 初始化methods，要做的其实很简单，单纯把methods中的全部方法挂载到this上就行</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化data  </span></span><br><span class="line">    <span class="title function_">initData</span>(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">observe</span>(vm.<span class="property">_data</span> = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化computed</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line">  <span class="comment">// 初始化watch</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) &#123;</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析后发现，<code>initState</code>方法<strong>依次，统一</strong>初始化了<code>props/methods/data/computed/watch</code>，说明在<code>created</code>的时候，这些东西都准备好了</p>
<p>我们继续分析<code>initState</code>中的<code>initData</code>方法</p>
<p><strong>initData方法源码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span> (<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  <span class="comment">// 判断data的类型是不是函数，如果是则调用函数，并把返回值赋予局部变量data，同时赋值给vm._data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? <span class="title function_">getData</span>(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  .....</span><br><span class="line">  <span class="comment">//获取data中所有可枚举属性</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 属性名不能与methods中的属性名重复</span></span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 属性名不能与props名称重复</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) &#123; <span class="comment">// 验证key值的合法性</span></span><br><span class="line">      <span class="comment">// 将vm._data中的key属性，代理到vm上,这样就可以通过this.key访问到vm._data.key的值（this=vm）</span></span><br><span class="line">      <span class="comment">// 所以说vm._data指向的对象是代理源对象</span></span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 监听data中数据的变化，data中的数据改变会触发视图更新</span></span><br><span class="line">  <span class="comment">// 由第一行代码可知data指的是一个局部变量，它和vm._data指向同一个数据对象，由于添加了数据代理</span></span><br><span class="line">  <span class="comment">// 修改this.key的值也会触发视图更新</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读源码后发现：</p>
<ul>
<li><code>props</code>和<code>method</code>在<code>data</code>之前就被初始化了，所以<code>data</code>中的属性值不能与<code>props</code>和<code>methods</code>中的属性值<code>重复</code>；之所以要防止重复，因为它们都会被代理到<code>this(vm)</code>上（是的，包括props中的数据），都是直接通过<code>this</code>来访问，重复了就会产生冲突。同时我们也可以发现，<code>props</code>中的数据的优先级是高于<code>data</code>中的数据的，<strong>因为初始化的时机更早</strong>。</li>
<li><code>data</code>定义的时候可选择<code>函数形式</code>或者<code>对象形式</code>（组件只能为函数形式），<code>data()</code>函数调用是为了产出数据，挂载到<code>vm._data</code>上，然后再给数据<code>添加代理</code>，<code>添加响应式</code>，所以<code>data</code>函数被调用的时候，内部是无法通过<code>this</code>来访问其他数据的。</li>
<li><code>initData</code>方法把<code>vm._data</code>中的属性代理到<code>vm</code>上并给<code>vm._data</code>上的数据添加了<code>响应式</code>（实现了数据的代理，给数据添了响应式）。</li>
</ul>
<p>vue的<strong>数据代理</strong>核心在于<code>proxy</code>方法，我们来看看它做了什么</p>
<p><strong>proxy方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">target, sourceKey, key</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[sourceKey][key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      target[sourceKey][key] = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span> <span class="comment">// 允许后续删除或重新定义该属性</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br></pre></td></tr></table></figure>

<p>再次之后，访问<code>target.key</code>返回的就是<code>target.sourceKey.key</code>，说到底还是从target上面取数据，只不过简化了访问的路径。</p>
<p>vue<strong>数据监听的核心</strong>在于<code>observe</code>方法，我们来分析一下这个方法</p>
<p><strong>observe方法源码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || obj == <span class="literal">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Observer</span>(obj);  <span class="comment">//observe方法的核心在于调用Observer类</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>Observer类的源码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">walk</span>(value);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="title function_">walk</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;  </span><br><span class="line">      <span class="title function_">defineReactive</span>(obj, key, obj[key]);  </span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>我们很容易发现这个类的核心是<code>defineReactive</code>方法，那么这个方法内部到底做了些什么呢？</p>
<p>这里我自己实现了一个<code>简易版</code>的<code>defineReactive</code>方法来帮助理解它的原理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, value</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取数据&#x27;</span>)</span><br><span class="line">      <span class="comment">//这里不能写成obj[key]，否则会陷入无限递归，即在get中触发了get</span></span><br><span class="line">      <span class="comment">//返回的是闭包中的value值，也就是说再添加get之前，先把数据取出来</span></span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="comment">// 修改的是闭包中的value值，并没有直接修改obj中的数据。</span></span><br><span class="line">      <span class="comment">// 修改obj[key]也会陷入无限递归，因为再set中触发了set</span></span><br><span class="line">      value = val</span><br><span class="line">      <span class="comment">// 触发视图更新</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;修改数据&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>defineReactive</code>方法的核心在于使用<code>Object.defineProperty</code>给对象属性<code>添加监听</code>，<strong>且没有借助其他源对象</strong>。而是闭包中的数据。真正的<code>defineReactive</code>方法要做的比上述代码多的多，比如，如果<code>val</code>的值是对象，则递归添加响应式，还有触发get要收集依赖，数据改变要触发视图更新等。</p>
<p>修改后的Obj对象结构如图，可以看到原来的属性被<code>覆盖</code>了，变得不可枚举。</p>
<img src="..\images\前端面试-vue\defineReactive.png" style="zoom:90%;" />



<p>分析之后我们发现，vue2中的<code>数据代理</code>和<code>数据监听</code>都是通过<code>Object.defineProperty</code>实现的。</p>
<p>由下面代码可知</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">walk</span>(value);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> new Observer(obj)返回的对象应该只有一个value属性，而整个value属性的值就是一个响应式对象。</p>
<p>vue的构造函数中使用的挂载方法是<code>vm.$mount</code>，我们尝试分析它的源码：</p>
<p><strong>vm.$mount方法源码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 获取或查询元素，传入的是vm.$options.el</span></span><br><span class="line">  el = el &amp;&amp; <span class="title function_">query</span>(el)</span><br><span class="line">  <span class="comment">// vue 不允许直接挂载到body或页面文档上</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">    <span class="comment">//抛出异常</span></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//提取出options，后续使用不需要通过this</span></span><br><span class="line">  <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span></span><br><span class="line">  <span class="comment">//如果没有render属性,也就是说没有render函数,解析 template/el 并转换为 render 函数</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">    <span class="comment">//提取出template，后续使用不需要通过this</span></span><br><span class="line">    <span class="keyword">let</span> template = options.<span class="property">template</span></span><br><span class="line">    <span class="comment">// 存在template模板，解析vue模板文件</span></span><br><span class="line">    <span class="comment">// 第一个if主要是为了处理template属性的另类值，比如id选择器，dom对象，最终都是为了转换成模板字符串</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">          template = <span class="title function_">idToTemplate</span>(template)</span><br><span class="line">          .....</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;<span class="comment">//这个条件语句用于检查 template 是否是一个 DOM 节点对象</span></span><br><span class="line">        <span class="comment">//返回的是一个字符串，代表了 template 元素内部的 HTML 内容</span></span><br><span class="line">        template = template.<span class="property">innerHTML</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//抛出异常</span></span><br><span class="line">        .....</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      <span class="comment">// 如果没有template属性，通过选择器获取元素内容（即获取tempalte）</span></span><br><span class="line">      template = <span class="title function_">getOuterHTML</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时template的值如果存在，一定是HTML字符串的形式，比如&#x27;&lt;p&gt;123&lt;/p&gt;&#x27;</span></span><br><span class="line">    <span class="comment">//然后再解析这个字符串</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(template, &#123;</span><br><span class="line">        <span class="comment">//省略.....</span></span><br><span class="line">      &#125;, <span class="variable language_">this</span>)</span><br><span class="line">      options.<span class="property">render</span> = render</span><br><span class="line">      options.<span class="property">staticRenderFns</span> = staticRenderFns</span><br><span class="line">      .......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阅读上面代码，我们能得到以下结论：</p>
<ul>
<li>根元素不能是<code>body</code>或者<code>html</code>，也就是说<code>el</code>的指向不能是这两个元素。</li>
<li><code>$mount</code>方法的工作流程就是，如果没有<code>render</code>函数，则<strong>解析template（模板）</strong>，如果没有template(模板)，只有<code>el</code>（选择器），则通过选择器获取<code>template</code>，然后解析<code>template</code>模板，即HTML 字符串，得到<code>render</code>方法。</li>
</ul>
<p>对<code>template</code>的解析步骤大致分为以下几步：</p>
<ul>
<li>将<code>html</code>文档片段解析成<code>ast</code>描述符</li>
<li>将<code>ast</code>描述符解析成字符串</li>
<li>生成<code>render</code>函数</li>
</ul>
<p>生成<code>render</code>函数，挂载到<code>vm</code>上后，再调用<code>mountComponent</code>开始开始渲染</p>
<p><strong>mountComponent方法源码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  el: ?Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="comment">// 如果没有获取解析的render函数，则会抛出警告</span></span><br><span class="line">  <span class="comment">// render是解析模板文件生成的</span></span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">	....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行beforeMount钩子</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ....</span><br><span class="line">      <span class="comment">//调用_render方法生成vnode</span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      ....</span><br><span class="line">      <span class="comment">//调用_update方法将虚拟dom转化成真实dom并放入页面</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">      .....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 定义更新函数</span></span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听当前组件状态，当有数据变化时，更新组件</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    <span class="title function_">before</span> () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据更新引发的组件更新</span></span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法主要执行在<code>vue</code>初始化时声明的<code>_render</code>，<code>_update</code>方法，<code>_render</code>的作用主要是生成<code>vnode</code></p>
<p><code>_render</code>方法内部其实使用的是我们模板解析后得到的<code>render</code>函数，最终返回一个vnode。</p>
<p><strong>_render方法源码</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// render函数来自于组件的option</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_update</code>主要功能是调用<code>patch</code>，将<code>vnode</code>转换为真实<code>DOM</code>，并且更新到页面中。</p>
<h2 id="手写一个简单的Vue"><a href="#手写一个简单的Vue" class="headerlink" title="手写一个简单的Vue"></a>手写一个简单的Vue</h2><p>了解了Vue实例的挂载过程后，我们应该就能够模拟实现一个简单的Vue。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>你好啊&#123;&#123;str&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    &#123;&#123;num&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;num&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app =  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    	<span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    	<span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">     	 <span class="attr">str</span>: <span class="string">&#x27;tom&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      	 <span class="attr">num</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">    	&#125;,</span></span><br><span class="line"><span class="language-javascript">    	<span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">      		<span class="title function_">add</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        		<span class="variable language_">this</span>.<span class="property">num</span>++</span></span><br><span class="line"><span class="language-javascript">      		&#125;</span></span><br><span class="line"><span class="language-javascript">    	&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span><span class="comment">//假设是个对象，不是函数data()</span></span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span><br><span class="line">         <span class="variable language_">this</span>.$compile(<span class="variable language_">this</span>.<span class="property">$el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    $compile(node) &#123;</span><br><span class="line">      <span class="comment">//childNodes返回这个dom元素的所有子节点，包括文本结点</span></span><br><span class="line">      node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//nodeType 结点类型</span></span><br><span class="line">        <span class="comment">// 1 表示元素结点</span></span><br><span class="line">        <span class="comment">// 3 表示文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//递归进行模板解析</span></span><br><span class="line">          <span class="variable language_">this</span>.$compile(item)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是文本结点,进行模板替换</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$replace(item)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    $replace(item)&#123;</span><br><span class="line">      <span class="comment">//非贪婪匹配</span></span><br><span class="line">      <span class="comment">//通过textContent拿到文本结点的内容</span></span><br><span class="line">      item.<span class="property">textContent</span> = item.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">            <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key.<span class="title function_">trim</span>()]<span class="comment">//必须返回用来替换的字符串</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>vue2的生命周期函数很好实现，无非就是在特定时期调用特定的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;</span><br><span class="line">        <span class="keyword">if</span>(options.<span class="property">beforeCreate</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeCreate</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">beforeCreate</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(options.<span class="property">created</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">created</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">created</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(options.<span class="property">beforeMount</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeMount</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">beforeMount</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">$el</span>= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>);</span><br><span class="line">		<span class="variable language_">this</span>.$compile(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">		<span class="keyword">if</span>(options.<span class="property">mounted</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">mounted</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">mounted</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a><strong>添加事件</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    $compile(node) &#123;</span><br><span class="line">      <span class="comment">//childNodes返回这个dom元素的所有子节点，包括文本结点</span></span><br><span class="line">      node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//nodeType 结点类型</span></span><br><span class="line">        <span class="comment">// 1 表示元素结点</span></span><br><span class="line">        <span class="comment">// 3 表示文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//@click</span></span><br><span class="line">          <span class="keyword">if</span> (item.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;@click&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">//最终还是使用了原生语法</span></span><br><span class="line">            item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="comment">// 如果此处使用的不是箭头函数，this的指向就是item了,我们要让this的指向变为vue实例。</span></span><br><span class="line">              <span class="comment">// item.getAttribute(&#x27;@click&#x27;).trim() 获取@click属性的值</span></span><br><span class="line">              <span class="comment">// 获取到这个属性的值，去除前后空格，假设是一个已有的方法名</span></span><br><span class="line">              <span class="comment">// 调用这个方法，同时修改函数的指向，使它指向vue实例，同时传入事件对象e</span></span><br><span class="line">              <span class="keyword">const</span> method = item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;@click&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">methods</span>[method].<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//递归</span></span><br><span class="line">          <span class="variable language_">this</span>.$compile(item)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$replace(item)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//把this.$data中的数据代理到this上</span></span><br><span class="line">    $proxy() &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">$data</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">          <span class="comment">//想要访问this.key，就返回this.$data[key]</span></span><br><span class="line">          <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">//想要修改this.key，就修改this.$data[key]</span></span><br><span class="line">          <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="comment">//数据未改变直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$data</span>[key]===newVal)&#123;</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$data</span>[key] = newVal</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="添加响应式"><a href="#添加响应式" class="headerlink" title="添加响应式"></a>添加响应式</h3><img src="..\images\前端面试-vue\响应式.png" style="zoom: 80%;" />

<p>至此，我们修改数据，视图显然是不会更新的，即没有实现<code>数据驱动视图更新的效果</code>，简单来说，就是没有实现<strong>响应式</strong>。</p>
<p>想要实现响应式，<strong>我们需要监听数据，并收集依赖</strong></p>
<p>所谓<strong>收集依赖</strong>，就是要知道<code>data</code>中的某个属性，到底在哪些文本结点(或者计算属性)中使用过了，换句话说，就是这些文本结点依赖data中的那个数据；这个数据改变时，我们需要<strong>监听</strong>到这个数据的变化，然后通知依赖这个数据的文本结点(或者计算属性)更新内容。</p>
<p><strong>依赖收集</strong>主要是在<code>模板解析</code>过程中进行的，在监听到数据的<code>getter</code>被触发的时候，收集它的依赖。</p>
<p>我们定义一个<code>Watcher</code>类来记录<code>文本结点</code>，<code>文本结点内部未编译前的字符串</code>，和它<code>依赖的数据(vm.key)</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">vm,key,node,str</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span> = key</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span> = node</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">str</span> = str</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">str</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">            <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>]</span><br><span class="line">         &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;<span class="comment">//其实如果data是函数的话，还要调用函数。</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Watcher</span> = &#123;&#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span>(options.<span class="property">beforeCreate</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeCreate</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">beforeCreate</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//把this.$data中的数据代理到this上</span></span><br><span class="line">        <span class="variable language_">this</span>.$proxy()</span><br><span class="line">        <span class="comment">//监听this.$data中的数据的变化</span></span><br><span class="line">        <span class="variable language_">this</span>.$observe()</span><br><span class="line">		<span class="keyword">if</span>(options.<span class="property">created</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">created</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">created</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        .......</span><br><span class="line">		<span class="keyword">if</span>(options.<span class="property">beforeMount</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeMount</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">beforeMount</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">$el</span>= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>);</span><br><span class="line">        <span class="comment">//编译模板</span></span><br><span class="line">		<span class="variable language_">this</span>.$compile(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">        ......</span><br><span class="line">		<span class="keyword">if</span>(options.<span class="property">mounted</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">mounted</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">			options.<span class="property">mounted</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    $compile(node) &#123;</span><br><span class="line">      <span class="comment">//childNodes返回这个dom元素的所有子节点，包括文本结点和元素结点</span></span><br><span class="line">      node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//nodeType 结点类型</span></span><br><span class="line">        <span class="comment">// 1 表示元素结点</span></span><br><span class="line">        <span class="comment">// 3 表示文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//@click</span></span><br><span class="line">          <span class="keyword">if</span> (item.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;@click&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">//本质基于原生js语法</span></span><br><span class="line">            item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> method = item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;@click&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">methods</span>[method].<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//如果是文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$replace(item)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    $replace(item)&#123;</span><br><span class="line">      item.<span class="property">textContent</span> = item.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">            <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">          	key = key.<span class="title function_">trim</span>()</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$Watcher</span>[key])&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>,key,item,item.<span class="property">textContent</span>))</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key] = []</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>,key,item,item.<span class="property">textContent</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>[key]<span class="comment">//返回用来替换的字符串,就是data中的值</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用来给数据添加代理</span></span><br><span class="line">	$proxy() &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">$data</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">          <span class="comment">//想要访问this.key，就返回this.$data[key]</span></span><br><span class="line">          <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">//想要修改this.key，就修改this.$data[key]</span></span><br><span class="line">          <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="comment">//数据未改变直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$data</span>[key]===newVal)&#123;</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$data</span>[key] = newVal</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//用来给数据添加监听，即监听this.$data中数据的改变</span></span><br><span class="line">    $observe()&#123;</span><br><span class="line">        <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">$data</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//先取出值，防止无限递归</span></span><br><span class="line">            <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">$data</span>,key,&#123;</span><br><span class="line">                <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> value</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_">set</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">                    <span class="comment">//get,set中的this指向的是this.$data</span></span><br><span class="line">                    <span class="keyword">if</span>(value===newVal)&#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果newVal是obj，还要递归添加响应式。</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">typeof</span> newVal == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">                        <span class="variable language_">this</span>.$observe(newVal)</span><br><span class="line">                    &#125;</span><br><span class="line">                    value = newVal</span><br><span class="line">                    <span class="comment">//通知依赖更新</span></span><br><span class="line">                    vm.<span class="property">$Watcher</span>[key].<span class="title function_">forEach</span>(<span class="function"><span class="params">w</span>=&gt;</span>&#123;</span><br><span class="line">                        w.<span class="title function_">update</span>()</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a><strong>双向绑定</strong></h3><p><code>双向绑定</code>并不等同于<code>响应式</code>了，这两个东西是有区别的。</p>
<p><code>响应性</code>简单来讲就是当更改响应式数据时，视图会随即自动更新，即<code>数据驱动视图更新</code>。而实现这个功能的原理就是<code>劫持(监听)数据</code>，<code>收集依赖</code>，当数据发生变化时，执行相应的依赖（副作用&#x2F;更新视图）。</p>
<p><code>双向绑定</code>是数据变化驱动视图更新，视图更新触发数据变化。其实就是<code>v-model</code>的功能，而我们知道<code>v-model</code>只是一个语法糖。因此如果要问<code>双向绑定</code>的原理，思路应该是<code>如何实现这个语法糖</code>。</p>
<p>只需完善<code>$compile</code>方法和<code>update</code>方法。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, key, node, str</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span> = node</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">str</span> = str</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//更新</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//如果不是文本结点，即没有模板字符串，更新的是元素结点的属性值</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">str</span> === <span class="literal">undefined</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>]</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">str</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">      <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;<span class="comment">//只考虑data是对象的情况</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$Watcher</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">beforeCreate</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeCreate</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      options.<span class="property">beforeCreate</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把this.$data中的数据代理到this上</span></span><br><span class="line">    <span class="variable language_">this</span>.$proxy()</span><br><span class="line">    <span class="comment">//监听this.$data中的数据改变</span></span><br><span class="line">    <span class="variable language_">this</span>.$observe()</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">created</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">created</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      options.<span class="property">created</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">beforeMount</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeMount</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      options.<span class="property">beforeMount</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>);</span><br><span class="line">    <span class="comment">//模板解析</span></span><br><span class="line">    <span class="variable language_">this</span>.$compile(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">mounted</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">mounted</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      options.<span class="property">mounted</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  $compile(node) &#123;</span><br><span class="line">    <span class="comment">//childNodes返回这个dom元素的所有子节点，包括文本结点</span></span><br><span class="line">    node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//nodeType 结点类型</span></span><br><span class="line">      <span class="comment">// 1 表示元素结点</span></span><br><span class="line">      <span class="comment">// 3 表示文本结点</span></span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//@click</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;@click&#x27;</span>)) &#123;</span><br><span class="line">          <span class="comment">//本质还是使用了原生语法</span></span><br><span class="line">          item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果此处使用的不是箭头函数，this的指向就是item了,我们要让this的指向变为vue实例。</span></span><br><span class="line">            <span class="comment">// item.getAttribute(&#x27;@click&#x27;).trim() 获取@click属性的值</span></span><br><span class="line">            <span class="comment">// 获取到这个属性的值，去除前后空格，假设是一个已有的方法名</span></span><br><span class="line">            <span class="comment">// 调用这个方法，同时修改函数的指向，使它指向vue实例，同时传入事件对象e</span></span><br><span class="line">            <span class="keyword">const</span> method = item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;@click&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">methods</span>[method].<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//v-model</span></span><br><span class="line">        <span class="keyword">if</span>(item.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>))&#123;</span><br><span class="line">          <span class="keyword">const</span> key = item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">          item.<span class="property">value</span> = <span class="variable language_">this</span>[key] <span class="comment">//赋值</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$Watcher</span>.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, key, item))</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key] = []</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, key, item))</span><br><span class="line">          &#125;</span><br><span class="line">          item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>[key] = item.<span class="property">value</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="variable language_">this</span>.$compile(item)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果是文本结点</span></span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$replace(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  $replace(item) &#123;</span><br><span class="line">    <span class="comment">//非贪婪匹配</span></span><br><span class="line">    <span class="comment">//通过textContent拿到文本结点的内容</span></span><br><span class="line">    <span class="comment">//如果文本节点中没有使用模板字符串，则匹配不到任何内容，回调函数中的代码也不会执行。</span></span><br><span class="line">    item.<span class="property">textContent</span> = item.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">      <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">      key = key.<span class="title function_">trim</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$Watcher</span>[key]) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, key, item, item.<span class="property">textContent</span>))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key] = []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, key, item, item.<span class="property">textContent</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>[key]<span class="comment">//返回用来替换的字符串,就是data中的值</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来给数据添加代理</span></span><br><span class="line">  $proxy() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">$data</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">        <span class="comment">//想要访问this.key，就返回this.$data[key]</span></span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//想要修改this.key，就修改this.$data[key]</span></span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">          <span class="comment">//数据未改变直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$data</span>[key] === newVal) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">$data</span>[key] = newVal</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来给数据添加监听，即监听this.$data中数据的改变</span></span><br><span class="line">  $observe() &#123;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">$data</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//先取出值，防止无限递归</span></span><br><span class="line">      <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">$data</span>, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">          <span class="comment">//set函数内部的this指向this.$data</span></span><br><span class="line">          <span class="keyword">if</span> (value === newVal) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(<span class="keyword">typeof</span> newVal == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.$observe(newVal)</span><br><span class="line">          &#125;</span><br><span class="line">          value = newVal</span><br><span class="line">          vm.<span class="property">$Watcher</span>[key].<span class="title function_">forEach</span>(<span class="function"><span class="params">w</span> =&gt;</span> &#123;</span><br><span class="line">            w.<span class="title function_">update</span>()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> app =  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">str</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">    <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">num</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="Vue-observable你有了解过吗？说说看"><a href="#Vue-observable你有了解过吗？说说看" class="headerlink" title="Vue.observable你有了解过吗？说说看"></a>Vue.observable你有了解过吗？说说看</h2><p><code>Vue.observable</code>，让一个对象变成响应式数据。<code>Vue</code> 内部会用它来处理 <code>data</code> 函数返回的对象</p>
<p>在 <code>Vue 2.x</code> 中，被传入的对象会直接被 <code>Vue.observable</code> 变更，它和被返回的对象是同一个对象，这一点，看看前面对<code>defineReactive</code>方法的介绍就很容易理解了。</p>
<p>在 <code>Vue 3.x</code> 中，则会返回一个可响应的代理对象，而对源对象直接进行变更仍然是不可响应的，因为在vue3中响应式的实现是基于<code>Proxy</code>这个构造函数，传入一个对象，会返回一个<code>新的</code>代理对象，对代理对象的修改会映射到源对象。</p>
<p><strong>使用场景</strong></p>
<p>创建一个<code>js</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入vue</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue</span></span><br><span class="line"><span class="string">// 创建state对象，使用observable让state对象可响应</span></span><br><span class="line"><span class="string">export let state = Vue.observable(&#123;</span></span><br><span class="line"><span class="string">  name: &#x27;</span>张三<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">  &#x27;</span>age<span class="string">&#x27;: 38</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>在<code>.vue</code>文件中直接使用即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    姓名：&#123;&#123; name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    年龄：&#123;&#123; age &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName(&#x27;李四&#x27;)&quot;</span>&gt;</span>改变姓名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;setAge(18)&quot;</span>&gt;</span>改变年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; state, mutations &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  // 在计算属性中拿到值</span></span><br><span class="line"><span class="string">  computed: &#123;</span></span><br><span class="line"><span class="string">    name() &#123;</span></span><br><span class="line"><span class="string">      return state.name</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    age() &#123;</span></span><br><span class="line"><span class="string">      return state.age</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  // 调用mutations里面的方法，更新数据</span></span><br><span class="line"><span class="string">  methods: &#123;</span></span><br><span class="line"><span class="string">    changeName(name) &#123;</span></span><br><span class="line"><span class="string">       state.name = name</span></span><br><span class="line"><span class="string">  	&#125;,</span></span><br><span class="line"><span class="string">  	setAge(age) &#123;</span></span><br><span class="line"><span class="string">       state.age = age</span></span><br><span class="line"><span class="string">  	&#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>详细解释</strong></p>
<p><code>依赖收集</code>是组件初始化过程中，模板解析时候的工作，组件模板解析的时候，如果使用到了某个<code>响应式对象</code>的某个属性，就会<code>new</code>一个<code>watcher</code>，存储到<code>Dep.target</code>中，然后取值的时候会触发<code>getter</code>，<code>getter</code>内部会判断<code>Dep.target</code>是否为空，不为空则收集依赖，把这个<code>watcher</code>取出来，<code>push</code>到这个属性（key）的<code>deps</code>（依赖数组）中。然后某个属性值修改的时候就会触发对应的<code>setter</code>，通知这些依赖的<code>watcher</code>更新内容，即调用依赖这个属性（key）的<code>watcher</code>的<code>update</code>方法。</p>
<p>所以说<code>Vue.observable</code>只能给数据添加响应式，但是想要实现数据修改，依赖这些数据的组件也重新渲染，就需要在模板解析过程中收集依赖。</p>
<h2 id="说说Vue的生命周期"><a href="#说说Vue的生命周期" class="headerlink" title="说说Vue的生命周期"></a><strong>说说Vue的生命周期</strong></h2><p>vue的生命周期指的是<strong>vue实例</strong>从创建到销毁的过程，可分为vue实例创建前后，dom挂载前后，数据更新前后，vue实例销毁前后四个阶段。这四个阶段分别对应了<code>8</code>个生命周期函数。</p>
<p>生命周期函数指的是在vue实例特定时间段执行的函数。</p>
<p>这里拿vue2的生命周期函数举例。</p>
<ul>
<li><p>beforeCreate：vue实例刚被创建，能拿到this，部分初始化工作完成，但是<strong>数据代理</strong>还未开始(未调用<code>initState</code>方法)，此时无法通过this获取<strong>data和methods等</strong></p>
</li>
<li><p>created:  <strong>数据代理结束</strong>，能通过this拿到data和methods，但是<strong>模板解析</strong>还未开始（未调用<code>vm.$mount</code>方法），页面展示的是<strong>未经vue编译的dom</strong>。</p>
</li>
<li><p>beforeMount：<strong>template模板解析结束</strong>，但是虚拟dom还未转化成真实dom挂载到页面中。</p>
</li>
<li><p>mounted：把<code>初始的</code>真实DOM放入页面，此时对dom的操作是有效的。</p>
</li>
<li><p>beforeUpdate：此时数据是新的，页面展示的内容是旧的, 因为vue视图是异步更新的。</p>
</li>
<li><p>updated:  此时<code>新旧虚拟dom比较</code>完毕，页面已更新。</p>
</li>
<li><p>beforeDestroy: 实例被销毁前调用，此时实例<code>属性与方法</code>仍然有效</p>
</li>
<li><p>destroyed: 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器;并不能清除DOM，仅仅销毁实例.</p>
</li>
</ul>
<img src="..\images\前端面试-vue\生命周期.png" style="zoom:150%;" />

<p><strong>数据请求在created和mouted的区别</strong></p>
<ul>
<li>这两个阶段<code>数据</code>和<code>方法</code>都已经初始化，都能通过<code>this</code>访问到，因为<code>created</code>的执行时期更早，所以能更早的发送请求，更快的返回数据。</li>
<li>一个组件中有子组件，它们的生命周期函数的执行顺序是先执行父组件的前三个声明周期函数，再执行子组件的前四个生命周期函数，然后在执行哦父组件的<code>mouted</code>函数。</li>
</ul>
<h2 id="说说你对slot的理解？slot使用场景有哪些？"><a href="#说说你对slot的理解？slot使用场景有哪些？" class="headerlink" title="说说你对slot的理解？slot使用场景有哪些？"></a>说说你对slot的理解？slot使用场景有哪些？</h2><p><code>slot</code>的作用就是用来<strong>自定义组件内部的结构</strong></p>
<p><code>slot</code>可以分来以下三种：</p>
<ul>
<li>默认插槽</li>
<li>具名插槽</li>
<li>作用域插槽</li>
</ul>
<h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>子组件用<code>&lt;slot&gt;</code>标签来确定渲染的位置，标签里面可以放<code>DOM</code>结构，当父组件没有往插槽传入内容，标签内<code>DOM</code>结构就会显示在页面</p>
<p>父组件在使用的时候，直接在子组件的标签内写入内容即可</p>
<p>子组件<code>Child.vue</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>默认插槽<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>父组件给子组件传入的自定义结构，可以在子组件的<code>this.$slots</code>属性中拿到。</p>
<img src="..\images\前端面试-vue\slot.png" style="zoom: 67%;" />

<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>默认插槽形如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我们给<code>slot</code>标签添加<code>name</code>属性，默认插槽就变成了具名插槽</p>
<p>当我们需要在子组件内部的多个位置使用插槽的时候，为了把各个插槽区别开，就需要给每个插槽取名。</p>
<p>同时父组件传入自定义结构的时候，也要指明是传递给哪个插槽的。</p>
<p>子组件<code>Child.vue</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span>具名插槽<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 具名插槽⽤插槽名做参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:content</span>&gt;</span>内容...<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>template</code>标签是用来分割，包裹自定义结构的。<code>v-slot</code>属性用来指定这部分结构用来替换哪个插槽。</p>
<p><code>v-slot:default</code>可以简化为<code>#default</code>，<code>v-slot:content</code>可以简化成<code>#content</code></p>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>子组件在<code>slot</code>标签上绑定属性来将子组件的信息传给父组件使用，所有绑定的属性会被收集成一个对象，被父组件的<code>v-slot</code>属性接收。</p>
<p>子组件<code>Child.vue</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">testProps</span>=<span class="string">&quot;子组件的值&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>没传footer插槽<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>父组件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以通过解构获取<code>v-slot=&#123;user&#125;</code>，还可以重命名<code>v-slot=&quot;&#123;user: newName&#125;&quot;</code>和定义默认值<code>v-slot=&quot;&#123;user = &#39;默认值&#39;&#125;&quot;</code></p>
<p>所在<code>slot</code>中也存在’’双向数据传递’’，父组件给子组件传递<code>页面结构</code>，子组件给父组件传递子组件的数据。</p>
<h2 id="你有写过自定义指令吗？自定义指令的应用场景有哪些？"><a href="#你有写过自定义指令吗？自定义指令的应用场景有哪些？" class="headerlink" title="你有写过自定义指令吗？自定义指令的应用场景有哪些？"></a>你有写过自定义指令吗？自定义指令的应用场景有哪些？</h2><h3 id="什么是指令"><a href="#什么是指令" class="headerlink" title="什么是指令"></a>什么是指令</h3><p>在<code>vue</code>中提供了一套为<code>数据驱动视图</code>更为方便的操作，这些操作被称为<code>指令系统</code>。简单的来说，<code>指令系统</code>能够简化dom操作，帮助方便的实现<code>数据驱动视图更新</code>。</p>
<p>我们看到的<code>v-</code>开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能</p>
<p>除了核心功能默认<code>内置的指令</code> (<code>v-model</code> 和 <code>v-show</code>)，<code>Vue</code> 也允许注册<code>自定义指令</code></p>
<p><strong>指令使用的几种方式：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会实例化一个指令，但这个指令没有参数 </span></span><br><span class="line">v-xxx</span><br><span class="line"></span><br><span class="line"><span class="comment">//将值传到指令中</span></span><br><span class="line">v-xxx=<span class="string">&quot;value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串传入到指令中，如v-html=&quot;&#x27;&lt;p&gt;内容&lt;/p&gt;&#x27;&quot;</span></span><br><span class="line">v-xxx=<span class="string">&quot;&#x27;string&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传参数（arg），如v-bind:class=&quot;className&quot;</span></span><br><span class="line">v-<span class="attr">xxx</span>:arg=<span class="string">&quot;value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用修饰符（modifier）</span></span><br><span class="line">v-<span class="attr">xxx</span>:arg.<span class="property">modifier</span>=<span class="string">&quot;value&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注意：指令中传入的都是<strong>表达式</strong>，无论是不是自定义指令，比如<code>v-bind:name = &#39;tom&#39;</code>，传入的是tom这个变量的值，而不是tom字符串，除非写成<code>&quot;&#39;tom&#39;&quot;</code>，传入的才是字符串。</p>
</blockquote>
<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>关于自定义指令，我们关心的就是三大方面，<strong>自定义指令的定义，自定义指令的注册，自定义指令的使用</strong>。</p>
<p><code>自定义指令</code>的使用方式和<code>内置指令</code>相同，我们不再研究，其中的难点就是<code>定义自定义指令</code>部分。</p>
<h4 id="注册自定义指令"><a href="#注册自定义指令" class="headerlink" title="注册自定义指令"></a>注册自定义指令</h4><p>注册一个自定义指令有<code>全局注册</code>与<code>局部注册</code>两种方式</p>
<p>全局注册主要是通过<code>Vue.directive</code>方法进行注册</p>
<p><code>Vue.directive</code>第一个参数是指令的名字（不需要写上<code>v-</code>前缀），第二个参数可以是对象数据，也可以是一个指令函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局注册一个自定义指令 `v-focus`</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>()  <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>局部注册通过在组件配置对象中设置<code>directives</code>属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">  <span class="attr">focus</span>: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">      el.<span class="title function_">focus</span>() <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus /&gt;</span><br></pre></td></tr></table></figure>

<p>在vue3中，局部注册的语法就不同了。如果混合使用<code>选项式api</code>，就可以像vue2一样借助<code>directives</code>属性解决，如果使用的是<code>setup语法糖</code>写法，就需要遵守如下语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用局部注册的自定义指令 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-highlight</span>=<span class="string">&quot;&#x27;yellow&#x27;&quot;</span>&gt;</span>This text will be highlighted in yellow<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-focus</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; onMounted, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; directive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 定义一个高亮指令</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> highlight = <span class="title function_">directive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    el.<span class="property">style</span>.<span class="property">backgroundColor</span> = binding.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 定义一个聚焦指令</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> focus = <span class="title function_">directive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params">el</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    el.<span class="title function_">focus</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>导入<code>directive</code>函数，传入自定义指令，完成组件的局部注册。</p>
<h4 id="定义自定义指令"><a href="#定义自定义指令" class="headerlink" title="定义自定义指令"></a>定义自定义指令</h4><p>自定义指令本质就是一个<strong>包含特定钩子函数的js对象</strong></p>
<p>在vue2中，这些常见的钩子函数包括：</p>
<ul>
<li><p><strong>bind()</strong></p>
<p><code>只调用一次</code>，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置，此时无法通过<code>el</code>拿到父级元素，也就是<code>el.parentNode</code>为空，但是也已经能拿到绑定的dom元素了。</p>
</li>
<li><p><strong>inserted()</strong></p>
<p>绑定指令的元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中，因为父元素可能还没插入文档中呢)，此时可以通过<code>el.parentNode</code>拿到父级元素</p>
</li>
<li><p><strong>mounted()</strong></p>
<p>指令绑定的元素被插入到<code>文档</code>中之后</p>
</li>
<li><p><strong>update()</strong></p>
<p>传入指令的值改变后触发</p>
</li>
<li><p><strong>unbind()</strong></p>
<p>只调用一次，指令与元素<code>解绑</code>时调用</p>
</li>
</ul>
<blockquote>
<p>注意：上述钩子函数在vue3中并不都有效，vue3中的自定义指令钩子函数和生命周期函数一致，具体见官方文档，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://cn.vuejs.org/guide/reusability/custom-directives#directive-hooks">https://cn.vuejs.org/guide/reusability/custom-directives#directive-hooks</a></p>
</blockquote>
<p>所有的钩子函数的参数都有以下：</p>
<ul>
<li><p><strong>el</strong>：指令所绑定的元素，可以用来直接操作 <code>DOM</code>，省去了手动捕获dom的步骤</p>
</li>
<li><p><strong>binding</strong>：</p>
<p>一个对象，包含以下property</p>
<ul>
<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li>
<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>
<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>
<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>，又比如<code>v-for=&quot;(value, key, index) in obj&quot;</code>传入的表达式为<code>&quot;(value, key, index) in obj&quot;</code></li>
<li><code>arg</code>：<strong>传给指令的参数</strong>，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>，又比如<code>v-bind:class = &quot;[&#39;box&#39;]&quot;</code>的参数为<code>class</code></li>
<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code></li>
</ul>
</li>
<li><p><code>vnode</code>：<code>Vue</code> 编译生成的虚拟节点</p>
</li>
<li><p><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用</p>
</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>给某个元素添加节流</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.设置v-throttle自定义指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;throttle&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">bind</span>: <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> throttleTime = binding.<span class="property">value</span>; <span class="comment">// 节流时间</span></span><br><span class="line">    <span class="keyword">if</span> (!throttleTime) &#123; <span class="comment">// 用户若不设置节流时间，则默认2s</span></span><br><span class="line">      throttleTime = <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="comment">//el是绑定指令的元素</span></span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!timer) &#123; <span class="comment">// 第一次执行</span></span><br><span class="line">      	<span class="comment">//开启定时器，占用临界资源</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//一定事件后，释放资源</span></span><br><span class="line">          timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, throttleTime);</span><br><span class="line">        <span class="comment">//同时绑定的另一个监听器也被调用，触发sayHello函数</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果在前throttleTime的时间内已经点击过了，则阻止目标元素绑定的监听器被调用，也就是说，sayHello不会被调用 </span></span><br><span class="line">        <span class="comment">//它不仅会阻止事件继续沿 DOM 树传播，还会阻止在同一阶段内其他监听器的执行，包括目标阶段的监听器。</span></span><br><span class="line">        event &amp;&amp; event.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);<span class="comment">//捕获触发，触发的顺序在冒泡触发之前</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.为button标签设置v-throttle自定义指令</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">v-throttle</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<h2 id="Vue常用的修饰符有哪些有什么应用场景"><a href="#Vue常用的修饰符有哪些有什么应用场景" class="headerlink" title="Vue常用的修饰符有哪些有什么应用场景"></a>Vue常用的修饰符有哪些有什么应用场景</h2><h3 id="修饰符是什么"><a href="#修饰符是什么" class="headerlink" title="修饰符是什么"></a>修饰符是什么</h3><p>在<code>Vue</code>中，修饰符是用来修饰Vue中的指令的，它<strong>处理了许多<code>DOM</code>事件的细节</strong>，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理。</p>
<p><code>vue</code>中修饰符分为以下五种：</p>
<ul>
<li>表单修饰符</li>
<li>事件修饰符</li>
<li>鼠标按键修饰符</li>
<li>键值修饰符</li>
<li>v-bind修饰符</li>
</ul>
<h3 id="修饰符的具体作用"><a href="#修饰符的具体作用" class="headerlink" title="修饰符的具体作用"></a>修饰符的具体作用</h3><h4 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h4><p>在我们填写表单的时候用得最多的是<code>input</code>标签，指令用得最多的是<code>v-model</code></p>
<p>关于表单的修饰符有如下：</p>
<ul>
<li>lazy</li>
<li>trim</li>
<li>number</li>
</ul>
<p><strong>lazy</strong></p>
<p>在我们填完信息，光标离开标签的时候，才会将值赋予给<code>value</code>，也就是在<code>change</code>事件之后再进行信息同步</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">lazy</span>=<span class="string">&quot;value&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>trim</strong></p>
<p>自动过滤用户输入的首尾空格字符，而中间的空格不会过滤</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">trim</span>=<span class="string">&quot;value&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>number</strong></p>
<p>自动将用户的输入值转为数值类型，但如果这个值无法被<code>parseFloat</code>解析，则会返回原来的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.<span class="property">number</span>=<span class="string">&quot;age&quot;</span> type=<span class="string">&quot;number&quot;</span>&gt;</span><br></pre></td></tr></table></figure>



<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p><strong>stop</strong></p>
<p>阻止了<code>事件冒泡</code>，相当于调用了<code>event.stopPropagation</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=<span class="string">&quot;shout(2)&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">//只输出1</span></span><br></pre></td></tr></table></figure>



<p><strong>prevent</strong></p>
<p>阻止了事件的<code>默认行为</code>，相当于调用了<code>event.preventDefault</code>方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form @submit.<span class="property">prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>



<p><strong>self</strong></p>
<p>只当在 <code>event.target</code> 是当前元素自身时触发处理函数，既不是冒泡触发，也不是捕获触发，简单来说就是点击的就是这个元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click.<span class="property">self</span>=<span class="string">&quot;doThat&quot;</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>@click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击</p>
</blockquote>
<p><strong>once</strong></p>
<p>绑定了事件以后只能触发一次，触发一次之后立即解除事件监听。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click.<span class="property">once</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;ok&lt;/button&gt;</span><br></pre></td></tr></table></figure>



<p><strong>capture</strong></p>
<p>使事件触发从包含这个元素的顶层开始往下触发</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click.<span class="property">capture</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span><br><span class="line">    obj1</span><br><span class="line">&lt;div @click.<span class="property">capture</span>=<span class="string">&quot;shout(2)&quot;</span>&gt;</span><br><span class="line">    obj2</span><br><span class="line">&lt;div @click=<span class="string">&quot;shout(3)&quot;</span>&gt;</span><br><span class="line">    obj3</span><br><span class="line">&lt;div @click=<span class="string">&quot;shout(4)&quot;</span>&gt;</span><br><span class="line">    obj4</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 输出结构: 1 2 4 3 </span></span><br></pre></td></tr></table></figure>



<p><strong>passive</strong></p>
<p>在移动端，当我们在监听元素滚动事件的时候，会一直触发<code>onscroll</code>事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给<code>onscroll</code>事件整了一个<code>.lazy</code>修饰符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line">&lt;!-- 而不会等待 <span class="string">`onScroll`</span> 完成  --&gt;</span><br><span class="line">&lt;!-- 这其中包含 <span class="string">`event.preventDefault()`</span> 的情况 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用,因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。</p>
<p><code>passive</code> 会告诉浏览器你不想阻止事件的默认行为</p>
</blockquote>
<p><strong>native</strong></p>
<p>让组件变成像<code>html</code>内置标签那样监听根元素的原生事件，否则组件上使用 <code>v-on</code> 只会监听自定义事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-<span class="attr">on</span>:click.<span class="property">native</span>=<span class="string">&quot;doSomething&quot;</span>&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用.native修饰符来操作普通HTML标签是会令事件失效的</p>
</blockquote>
<h2 id="Vue中组件和插件有什么区别"><a href="#Vue中组件和插件有什么区别" class="headerlink" title="Vue中组件和插件有什么区别"></a>Vue中组件和插件有什么区别</h2><h3 id="组件是什么"><a href="#组件是什么" class="headerlink" title="组件是什么"></a>组件是什么</h3><p>在vue中，组件就是能实现<code>部分功能</code>的html，css，js代码的集合。</p>
<p><strong>优势</strong></p>
<ul>
<li><p>降低整个系统的<code>耦合度</code></p>
<p>在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</p>
</li>
<li><p>提高代码的<code>可维护性</code>，和<code>可复用性</code></p>
<p>由于每个组件的职责单一，并且组件在系统中是被复用的。</p>
</li>
</ul>
<h3 id="插件是什么"><a href="#插件是什么" class="headerlink" title="插件是什么"></a>插件是什么</h3><p>插件通常用来为 <code>Vue</code> 添加全局功能，比如通过全局混入来添加一些组件选项。如<code>vue-router</code></p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>两者的区别主要表现在以下几个方面：</p>
<ul>
<li>编写形式</li>
<li>注册形式</li>
</ul>
<h4 id="编写形式"><a href="#编写形式" class="headerlink" title="编写形式"></a>编写形式</h4><p><strong>组件</strong></p>
<p>编写一个组件，可以有很多方式，我们最常见的就是<code>vue</code>单文件的这种格式，每一个<code>.vue</code>文件我们都可以看成是一个组件。</p>
<p><strong>插件</strong></p>
<p><code>vue</code>插件就是一个实现了 <code>install</code> 方法的对象。这个方法的第一个参数是 <code>Vue</code> 构造函数，第二个参数是一个可选的选项对象(options)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPlugin</span>.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">myGlobalMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">bind</span> (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">    <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params">methodOptions</span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册形式"><a href="#注册形式" class="headerlink" title="注册形式"></a>注册形式</h4><p><strong>组件注册</strong></p>
<p><code>vue</code>组件注册主要分为<code>全局注册</code>与<code>局部注册</code></p>
<p>局注册通过<code>Vue.component</code>方法，第一个参数为组件的名称，第二个参数为传入的配置项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component-name&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>局部注册只需在用到的地方通过<code>components</code>属性注册一个组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component1 = &#123;...&#125;<span class="comment">// 定义一个组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	<span class="attr">components</span>:&#123;</span><br><span class="line">		component1<span class="comment">//局部注册</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在vue3中的组件注册</strong>：</p>
<p>全局注册：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>; <span class="comment">// 引入你的组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;);</span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;MyComponent&#x27;</span>, <span class="title class_">MyComponent</span>); <span class="comment">// 全局注册组件</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>局部注册：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">MyComponent</span> <span class="comment">// 局部注册组件</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>; <span class="comment">// 引入你的组件</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用局部注册的组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>&lt;script setup&gt;</code> 中导入的组件会<strong>自动注册</strong>并在模板中可用，无需显式地在 <code>components</code> 选项中列出它们。</p>
<p><strong>插件注册</strong></p>
<p>插件的注册通过<code>Vue.use()</code>的方式进行注册，第一个参数为<code>插件的名字</code>，第二个参数是可选择的<code>配置项</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(插件名字[,options])</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">use</span> = <span class="keyword">function</span>(<span class="params">plugin,options</span>)&#123;</span><br><span class="line">    <span class="comment">//this指向Vue构造函数</span></span><br><span class="line">    <span class="comment">//在use方法内部，会调用插件的install方法</span></span><br><span class="line">    plugin.<span class="title function_">install</span>(<span class="variable language_">this</span>,options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 注册插件的时候，需要在调用 <code>new Vue()</code> 启动应用<code>之前</code>完成，<code>Vue.use</code>会自动阻止多次注册相同插件，只会注册一次。</p>
</blockquote>
<h2 id="Vue组件通信的方式有哪些"><a href="#Vue组件通信的方式有哪些" class="headerlink" title="Vue组件通信的方式有哪些"></a>Vue组件通信的方式有哪些</h2><p><code>vue</code>中，每个组件之间的都有<code>独自的作用域</code>，组件间的数据是无法共享的\，但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的，要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统。</p>
<h3 id="组件间通信的分类"><a href="#组件间通信的分类" class="headerlink" title="组件间通信的分类"></a>组件间通信的分类</h3><ul>
<li>父子组件之间的通信</li>
<li>兄弟组件之间的通信</li>
<li>祖孙与后代组件之间的通信</li>
<li>非关系组件间之间的通信</li>
</ul>
<h3 id="组件间通信的方案"><a href="#组件间通信的方案" class="headerlink" title="组件间通信的方案"></a>组件间通信的方案</h3><h4 id="props传递数据"><a href="#props传递数据" class="headerlink" title="props传递数据"></a>props传递数据</h4><p>适用场景：父组件传递数据给子组件(父子组件之间的通信)</p>
<p>子组件设置<code>props</code>属性，定义接收父组件传递过来的参数，父组件在使用子组件标签中添加属性来传递值。</p>
<p>子组件接受的数据，会被挂载到子组件实例上，可以直接通过this访问。对于父组件传入，子组件未接受的数据，也能在<code>this.$atrr</code>，即<code>组件实例的属性</code>中拿到，因为未被接受的数据，就会被当作组件自身的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Children.vue</span></span><br><span class="line"><span class="attr">props</span>:&#123;  </span><br><span class="line"> <span class="comment">// 字符串形式  </span></span><br><span class="line"> <span class="attr">name</span>:<span class="title class_">String</span> <span class="comment">// 接收的类型参数  </span></span><br><span class="line"> <span class="comment">// 对象形式  </span></span><br><span class="line"> <span class="attr">age</span>:&#123;    </span><br><span class="line">     <span class="attr">type</span>:<span class="title class_">Number</span>, <span class="comment">// 接收的类型为数值  </span></span><br><span class="line">     <span class="attr">defaule</span>:<span class="number">18</span>,  <span class="comment">// 默认值为18  </span></span><br><span class="line">     <span class="attr">require</span>:<span class="literal">true</span> <span class="comment">// age属性必须传递  </span></span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Children name=&quot;jack&quot; age=18 /&gt;  </span><br></pre></td></tr></table></figure>

<p>要注意的是，props中的数据是父组件的，子组件不能直接修改</p>
<h4 id="emit-触发自定义事件"><a href="#emit-触发自定义事件" class="headerlink" title="$emit 触发自定义事件"></a>$emit 触发自定义事件</h4><p>适用场景：子组件传递数据给父组件(父子组件通信)</p>
<p>子组件通过<code>$emit</code>触发自定义事件，<code>$emit</code>第一个参数为自定义的事件名，第二个参数为传递给父组件的数值</p>
<p>父组件在子组件上绑定事件监听，通过传入的<code>回调函数</code>拿到子组件的传过来的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Children.vue</span><br><span class="line">this.$emit(&#x27;add&#x27;, good)  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Father.vue</span><br><span class="line">&lt;Children @add=&quot;cartAdd($event)&quot; /&gt;  </span><br></pre></td></tr></table></figure>

<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>在 Vue 2 中，<code>this.$refs</code> 是一个对象，它包含了所有通过 <code>ref</code> 属性注册的<code> DOM 元素</code>或<code>组件实例</code>。你可以使用 <code>this.$refs</code> 来直接访问这些元素或组件，从而进行操作，如获取DOM节点、调用子组件的方法，数据等。</p>
<p><strong>注意：</strong><code>this.$refs</code> <code>只能</code>在父组件中，用来引用通过 <code>ref</code> 属性标记的<code>子组件</code>或 DOM 元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> ref=<span class="string">&quot;foo&quot;</span> /&gt;  </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">foo</span>  <span class="comment">// 获取子组件实例，通过子组件实例我们就能拿到对应的数据  </span></span><br></pre></td></tr></table></figure>

<p>同时，子组件也可通过<code>this.$parent</code>拿到父组件实例</p>
<h4 id="EventBus-事件总线"><a href="#EventBus-事件总线" class="headerlink" title="EventBus(事件总线)"></a><strong>EventBus(事件总线)</strong></h4><p>使用场景：兄弟组件传值</p>
<ul>
<li><p>通过共同祖辈<code>$parent</code>或者<code>$root</code>搭建通信</p>
<p>兄弟组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="title function_">on</span>(<span class="string">&#x27;add&#x27;</span>,<span class="variable language_">this</span>.<span class="property">add</span>)   </span><br></pre></td></tr></table></figure>

<p>另一个兄弟组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$parent.emit(&#x27;add&#x27;)   </span><br></pre></td></tr></table></figure></li>
</ul>
<p>本质就是要找到一个<strong>两个兄弟组件都能访问到的vue实例</strong>，这个vue实例的作用好像连接这两个组件的管道，通过这个Vue实例来通行。</p>
<h4 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h4><p>跨层级传递数据，传递方向是<code>单向</code>的，只能顶层向底层传递。</p>
<p>在<code>祖先组件</code>定义<code>provide</code>属性，<code>返回</code>传递的值，在后代组件通过<code>inject</code>接收祖先组件传递过来的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通类型是响应式的复杂类型则不是，这和vue2数据响应式的实现方式有关</span></span><br><span class="line"><span class="comment">// 这里丢失响应式的原因，和解构响应式对象失去响应式的原因是一样的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="comment">// 普通类型（非响应式）</span></span><br><span class="line">      <span class="attr">userInfo</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125; <span class="comment">// 复杂类型（响应式）</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//使用data或者computed中的数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="variable language_">this</span>.<span class="property">color</span>, <span class="comment">// 非响应式</span></span><br><span class="line">      <span class="attr">userInfo</span>: <span class="variable language_">this</span>.<span class="property">userInfo</span>, <span class="comment">// 响应式</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 注入的属性会自动添加到组件的依赖注入链中，因此它们也是响应式的。</span></span><br><span class="line">    <span class="comment">// 如果多个祖先组件都提供了同名的属性，那么最接近的祖先组件提供的属性会被优先使用（就近原则）。</span></span><br><span class="line">	<span class="attr">inject</span>: [<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;userInfo&#x27;</span>],<span class="comment">//书写格式太像props了</span></span><br><span class="line">	<span class="title function_">created</span> () &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>, <span class="variable language_">this</span>.<span class="property">userInfo</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>关于vuex的介绍，详见<a href="http://www.sanye.blog/posts/8b27fabc.html">vue | 三叶的博客</a></p>
<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><h3 id="什么是SPA，和MPA有什么区别？"><a href="#什么是SPA，和MPA有什么区别？" class="headerlink" title="什么是SPA，和MPA有什么区别？"></a>什么是SPA，和MPA有什么区别？</h3><ul>
<li><p>SPA指的是<strong>只有一个页面的web应用程序</strong>，而MPA（多页面应用程序）指的是有多个页面的web应用程序</p>
</li>
<li><p>SPA通过js操作dom来局部更新页面内容；而MPA是通过页面切换来实现整页刷新，整页刷新就需要重新加载整个页面所需<code>资源</code>并重新渲染页面，速度慢；</p>
</li>
<li><p>SPA刷新速度更快，用户体验更好，同时把页面渲染工作交给客户端，减轻了服务端的压力。缺点是不利于搜索引擎优化(SEO)，首次加载速度较慢。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3js.cn/interview/vue/spa.html#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFspa">面试官：你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢 | web前端面试 - 面试官系列</a></p>
<h3 id="如何提高首屏加载速度？"><a href="#如何提高首屏加载速度？" class="headerlink" title="如何提高首屏加载速度？"></a>如何提高首屏加载速度？</h3><p>首屏加载时间，指的是浏览器从<strong>响应用户输入网址</strong>，到<strong>首屏内容</strong>渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容。</p>
<p><strong>首屏加载慢的原因</strong></p>
<ul>
<li>网络延时问题</li>
<li>资源文件体积是否过大</li>
<li>资源是否重复发送请求去加载了</li>
<li>加载脚本的时候，渲染内容堵塞了</li>
</ul>
<p><strong>提高首屏加载速度的方法</strong>：</p>
<ul>
<li><p>使用<strong>路由懒加载</strong></p>
<p>对于非首屏组件，使用路由懒加载，当需要访问这些组件的时候再加载对应的资源。</p>
<p>开发单页面应用程序时，只有一个<code>html</code>页面，打包后也只有一个<code>index.html</code>页面，其他所谓的<code>页面</code>，都是通过<code> JavaScript</code> 动态地修改<code>DOM</code>来实现的。开发过程中，一个页面对应一个或者多个<code>组件</code>，在打包后，每个组件都会转化成对应的<code>css</code>，<code>js</code>代码，其中的<code>js代码</code>不光包括业务逻辑，也负责修改dom，构建页面。</p>
<p>如果使用<code>路由懒加载</code>，我们可以观察到，打包后的js，css文件<code>数量</code>变多了，每个文件的体积也变小了，是因为使用<code>懒加载的组件</code>都被打包成<code>独立的</code>css，js文件了。这样，<code>index.html</code>引入的的<code>js</code>，<code>css</code>文件的体积也会变小，因为只包含<code>首屏组件</code>需要的<code>js，css</code>代码。</p>
</li>
<li><p><strong>缓存</strong>静态资源</p>
<p>对于已经请求过的资源，再次请求直接使用缓存。</p>
</li>
<li><p><strong>压缩</strong>图片等静态资源的大小</p>
</li>
<li><p>使用服务端渲染<strong>SSR</strong></p>
<p>将首页的html结构的拼接工作交给后端服务器</p>
<p>对于vue，推荐使用<code>nuxt.js</code></p>
</li>
<li><p>使用<strong>CDN加速</strong></p>
</li>
<li><p>内联首屏关键css</p>
</li>
</ul>
<h3 id="如何提高SPA的SEO"><a href="#如何提高SPA的SEO" class="headerlink" title="如何提高SPA的SEO"></a><strong>如何提高SPA的SEO</strong></h3><ul>
<li>使用服务端渲染SSR</li>
</ul>
<h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><h3 id="什么是SSR"><a href="#什么是SSR" class="headerlink" title="什么是SSR"></a>什么是SSR</h3><p>指由<code>服务端</code>完成页面的<code> HTML结构拼接</code>的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。</p>
<p>传统web开发，一般就是多页面应用程序，每个页面的html结构都在服务端拼接好。</p>
<p>单页面应用程序（SPA）通过<strong>浏览器执行js代码</strong>来实现页面的html结构的替换，拼接。</p>
<h3 id="解决了什么"><a href="#解决了什么" class="headerlink" title="解决了什么"></a>解决了什么</h3><ul>
<li><p><strong>有利于SPA的SEO</strong></p>
<p>使用服务端渲染，返回的页面就已经包含了一定的页面结构，能够被搜索引擎爬取。</p>
</li>
<li><p><strong>提高的首屏渲染速度</strong></p>
<p>使用服务端渲染，将<code>首屏结构</code>交给服务端来拼接，这样不必等待页面所有<code>js</code>加载完成，就可以看到首屏视图。</p>
</li>
</ul>
<h3 id="怎么实现"><a href="#怎么实现" class="headerlink" title="怎么实现"></a>怎么实现</h3><h2 id="给对象添加属性视图不刷新"><a href="#给对象添加属性视图不刷新" class="headerlink" title="给对象添加属性视图不刷新"></a>给对象添加属性视图不刷新</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>在vue2中，数据的响应式是在vue<strong>实例创建</strong>的时候，使用<strong>Object.defineProperty</strong>来实现的，后续添加属性并没有使用<code>这个方法</code>来添加响应式。</p>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>可以通过**Vue.set()或者this.$set()**来给新增属性添加响应式。</p>
<p>Vue.set( target, propertyName&#x2F;index, value )</p>
<ul>
<li><code> target:&#123;Object | Array&#125;</code></li>
<li><code>propertyName/index:&#123;string | number&#125; </code></li>
<li><code>value:&#123;any&#125; </code></li>
</ul>
<p>这个方法的本质就是<strong>使用Object.defineProperty（）给新添加的属性赋予响应式</strong></p>
<h2 id="v-if和v-for的优先级是什么"><a href="#v-if和v-for的优先级是什么" class="headerlink" title="v-if和v-for的优先级是什么"></a>v-if和v-for的优先级是什么</h2><p>我们查看下<code>vue</code>源码</p>
<p>源码位置：<code>\vue-dev\src\compiler\codegen\index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genElement</span> (<span class="params">el: ASTElement, state: CodegenState</span>): string &#123;</span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">parent</span>) &#123;</span><br><span class="line">    el.<span class="property">pre</span> = el.<span class="property">pre</span> || el.<span class="property">parent</span>.<span class="property">pre</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">staticRoot</span> &amp;&amp; !el.<span class="property">staticProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genStatic</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">once</span> &amp;&amp; !el.<span class="property">onceProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genOnce</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">for</span> &amp;&amp; !el.<span class="property">forProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genFor</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">if</span> &amp;&amp; !el.<span class="property">ifProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genIf</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tag</span> === <span class="string">&#x27;template&#x27;</span> &amp;&amp; !el.<span class="property">slotTarget</span> &amp;&amp; !state.<span class="property">pre</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genChildren</span>(el, state) || <span class="string">&#x27;void 0&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tag</span> === <span class="string">&#x27;slot&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genSlot</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// component or element</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以观察到，<code>v-for</code>的优先级是比<code>v-if</code>高的，这就意味着，当要渲染某个列表项的时候，会先渲染全部的列表项，再判断是否改保留某个列表项。</p>
<p>但在实际开发中，有时可能希望根据<code>某个条件</code>来决定是否渲染<code>整个列表</code>，而不是对列表中的每个项都应用条件，此时如果我们把<code>v-for</code>和<code>v-if</code>写到同一个元素上，即便最终我们并不要渲染整个列表，也会由于<code>v-for</code>的优先级更高，仍然会创建这些元素的 <code>VNode </code>，造成不必要的性能浪费。在这种情况下，可以考虑调整指令的位置或结构。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;shouldShowList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>即便不是根据某个条件来判断是否渲染<code>整个列表</code>，而是每个列表项都使用<code>不同的判断条件</code>，也不建议把<code>v-if</code>和<code>v-for</code>写到一起，而是先<code>筛选</code>出那些<code>需要渲染的列表项</code>，然后再使用<code>v-for</code>渲染。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in filteredItems&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">filteredItems</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="comment">/* your condition */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="v-if和v-show如何理解"><a href="#v-if和v-show如何理解" class="headerlink" title="v-if和v-show如何理解"></a>v-if和v-show如何理解</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>二者都是用来控制页面中元素的显示与隐藏，当表达式值为<code>false</code>的时候，都不会占据页面的位置。</p>
<h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p><code>v-show</code>本质是通过<code>切换css样式</code>来实现元素的显示与隐藏，令<code>display:none</code>让元素隐藏，dom元素还存在。</p>
<p><code>v-if</code>本质则是通过<code>控制dom元素的删除与创建</code>来实现元素的显示与隐藏，因为<code>v-if</code>直接操作<code>dom</code>，所以<code>v-if</code>有更高的性能消耗。</p>
<p><code>v-if</code>才是真正的<code>条件渲染</code>，<code>v-show</code>的值为<code>false</code>的元素，也会被渲染。</p>
<h2 id="说说你对nextTick的理解"><a href="#说说你对nextTick的理解" class="headerlink" title="说说你对nextTick的理解"></a>说说你对nextTick的理解</h2><p>vue数据改变，并不会立即操作dom来更新视图；而是会开启一个<strong>异步更新队列</strong>，将这些<code>更新操作</code>放入其中；在一次<code>事件循环</code>后，进行一次<strong>批量更新</strong>；</p>
<p>如果我们重复修改某个数据，异步更新队列还会进行<strong>去重</strong>操作；对于同一个组件内的多个数据变化，它们会被<strong>合并</strong>成一次更新；</p>
<p>创建新的虚拟dom，与旧的虚拟dom比较，得出最小变更，再把这个最小变更应用到实际dom。</p>
<p>使用方法：<code>Vue.nextTick(()=&gt;&#123;&#125;)</code>或者<code>this.$nextTick(()=&gt;&#123;&#125;)</code></p>
<p>nextTick是<strong>异步api</strong>，会返回一个<strong>promise对象</strong>，传入的回调函数会在<code>dom更新后</code>执行，也可以使用async&#x2F;await来操作dom。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;原始值&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用回调函数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;修改后的值&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;原始的值&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;修改后的值&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用async/await</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;修改后的值&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;原始的值&#x27;</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.$nextTick()<span class="comment">//此时没有传入回调函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;修改后的值&#x27;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3js.cn/interview/vue/nexttick.html">面试官：Vue中的$nextTick有什么作用？ | web前端面试 - 面试官系列</a></p>
<h2 id="说说你对vue中key的理解"><a href="#说说你对vue中key的理解" class="headerlink" title="说说你对vue中key的理解"></a>说说你对vue中key的理解</h2><p>key是给每一个虚拟dom（或者说vnode）的唯一id。在diff过程中，根据key值，可以更<strong>准确</strong>， 更快的找到待比较的虚拟dom，从而优化diff算法，提高dom的复用率。</p>
<p>如果不设置key，那key值默认就都是undefined，将会按顺序进行<strong>新旧虚拟dom</strong>的比较。</p>
<p>详细可参考禹神的vue视频：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/BV1Zy4y1K7SH?spm_id_from=333.788.videopod.episodes&vd_source=00483a04a5a69136669373a8ea522a9b&p=30">030_尚硅谷Vue技术_key作用与原理_哔哩哔哩_bilibili</a></p>
<h2 id="什么是虚拟dom？有什么作用？如何实现？"><a href="#什么是虚拟dom？有什么作用？如何实现？" class="headerlink" title="什么是虚拟dom？有什么作用？如何实现？"></a><strong>什么是虚拟dom？有什么作用？</strong>如何实现？</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>虚拟dom本质就是一个用来<strong>描述真实dom的js对象</strong>，是对真实dom的<strong>高度抽象</strong>。</p>
<h3 id="有什么作用"><a href="#有什么作用" class="headerlink" title="有什么作用"></a>有什么作用</h3><ul>
<li>操作<code>实际dom</code>是非常消耗性能的，频繁操作dom可能导致<strong>页面卡顿</strong>。使用diff算法进行，进行新旧虚拟dom之间的比较，能帮助我得出最小的变更，再把这个变更应用到实际dom中，<strong>从而减少dom的操作次数</strong>。</li>
<li><strong>抽象了原本的渲染过程</strong>，实现了<strong>跨平台的能力</strong>，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI。从 <code>React</code> 到 <code>Vue</code> ，虚拟 <code>DOM</code> 为这两个框架都带来了跨平台的能力（<code>React-Native</code> 和 <code>Weex</code>）</li>
</ul>
<h3 id="在vue中如何创建虚拟dom"><a href="#在vue中如何创建虚拟dom" class="headerlink" title="在vue中如何创建虚拟dom"></a><strong>在vue中如何创建虚拟dom</strong></h3><p><code>createElement</code> 创建 <code>VNode</code> 的过程，每个 <code>VNode</code> 有 <code>children</code>，<code>children</code> 每个元素也是一个<code>VNode</code>，这样就形成了一个虚拟树结构，用于描述真实的<code>DOM</code>树结构。</p>
<p>一个典型的 <code>vnode</code> 对象可能包含以下字段：</p>
<ul>
<li><code>tag</code>: 元素类型（例如 <code>&#39;div&#39;</code>、<code>&#39;span&#39;</code> 等）</li>
<li><code>data</code>: 包含元素的属性、样式、事件处理器等元数据</li>
<li><code>children</code>: 子节点数组，可以是其他 <code>vnode</code> 或文本字符串</li>
<li><code>text</code>: 如果是文本节点，则包含文本内容</li>
<li><code>el</code>: 引用对应的真实DOM节点（仅在某些实现中存在）</li>
</ul>
<h2 id="说说diff算法"><a href="#说说diff算法" class="headerlink" title="说说diff算法"></a>说说diff算法</h2><img src="..\images\前端面试-vue\dom操作优化.png" style="zoom:80%;" />





<h2 id="说说你对keep-alive的理解"><a href="#说说你对keep-alive的理解" class="headerlink" title="说说你对keep-alive的理解"></a>说说你对keep-alive的理解</h2><p>keep-alive是<strong>vue中的内置组件</strong>，包裹动态组件（router-view）时，会缓存不活动的<strong>组件实例</strong>，而不是销毁它们，<strong>防止重复渲染DOM</strong>。</p>
<p>被缓存的组件会额外多出两个生命周期<code>activated</code>和<code>deactivated</code></p>
<p>keep-alive可以使用一些<code>属性</code>来更精细的控制组件缓存。</p>
<ul>
<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件<strong>会</strong>被缓存</li>
<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都<strong>不会</strong>被缓存</li>
<li><code>max</code> - 数字。最多可以缓存多少组件实例，超出这个数字之后，则<strong>删除第一个</strong>被缓存的组件，由此可以推测存在一个缓存队列，先入先出。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;a,b&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正则表达式 (使用 `v-bind`,动态绑定，表示传入的是表达式) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;/a|b/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数组 (使用 `v-bind，动态绑定，表示传入的是表达式`) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>vue3中的keep-alive的语法不同于vue2</p>
<p>基础用法，默认缓存所有页面：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component &#125;&quot;</span>&gt;</span>Component可以理解为用来替代router-view的组件</span><br><span class="line">  //keep-alive包裹的不再是router-view而是具体的组件</span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>精确控制具体哪些组件缓存，因为再vue3中使用组件已经不再需要注册，也不需要给组件命名，所以我们控制组件（页面）缓存的依据变成了<strong>页面的路由对象</strong>，而不是组件的名称。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span>  <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在路由对象中添加meta属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&quot;/keepAliveTest&quot;</span>,</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;keepAliveTest&quot;</span>,</span><br><span class="line">   <span class="attr">meta</span>: &#123;</span><br><span class="line">       <span class="attr">keepAlive</span>: <span class="literal">true</span> <span class="comment">//设置页面是否需要使用缓存</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/keepAliveTest/index.vue&quot;</span>)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component, route &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是就到此位置的话，切换页面的时候会报错：<code>vue3 TypeError: parentComponent.ctx.deactivate is not a function 报错</code></p>
<p>网上提供的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/zhouning7879/article/details/130639409">解决方案</a>就是给每个component提供一个key。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component, route &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;route.name&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;route.meta.isKeepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;route.name&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!route.meta.isKeepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>详细可参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/6978772143748153381">vue3中使用keep-alive目的：掘金</a></p>
<p><strong>组件名称匹配，组件名称指的到底是什么呢？</strong></p>
<p>匹配首先检查<strong>组件自身的</strong> <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的<strong>局部注册名称</strong> (父组件 <code>components</code> 选项的<strong>键值</strong>)，匿名组件不能被匹配。</p>
<p><strong>组件被缓存了，如何获取数据呢？</strong></p>
<p>借助<code>beforeRouteEnter</code>这个<code>组件内的导航守卫</code>，或者<code>activated</code>生命周期函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)&#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="function"><span class="params">vm</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(vm)</span><br><span class="line">        <span class="comment">// 每次进入路由执行</span></span><br><span class="line">        vm.<span class="title function_">getData</span>()  <span class="comment">// 获取数据</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">activated</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">getData</span>() <span class="comment">// 获取数据</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<h2 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h2><p>mixin本质就是一个<strong>js对象</strong>，包含了vue组件<strong>任意功能选项</strong>，如<code>data</code>、<code>components</code>、<code>methods</code>、<code>created</code>、<code>computed</code>等等</p>
<p>，被用来<strong>分发</strong> <code>Vue</code> 组件中的<strong>可复用功能</strong>。</p>
<p>可分<strong>为全局混入和局部混入</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;全局混入&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)<span class="comment">//全局混入</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">mixins</span>:[&#123;<span class="attr">created</span>:<span class="function">()=&gt;</span>&#123;&#125;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果混入组件的时候出现了<strong>功能选项冲突</strong>，一般以组件功能选项为准。</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3js.cn/interview/vue/mixin.html#%E4%B8%80%E3%80%81mixin%E6%98%AF%E4%BB%80%E4%B9%88">面试官：说说你对vue的mixin的理解，有什么应用场景？ | web前端面试 - 面试官系列</a></p>
<p>在<strong>vue3</strong>的组合式api中，混入（mixin）显然就没有用武之地了，转而被<code>composable</code>替代，下面就是一个例子，介绍了在vue3中是如何复用代码的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//useCountDown.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">&#x27;dayjs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//导出一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">countDown</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Time</span> = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> formatTime = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> dayjs.<span class="title function_">unix</span>(<span class="title class_">Time</span>.<span class="property">value</span>).<span class="title function_">format</span>(<span class="string">&#x27;mm分ss秒&#x27;</span>))</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">start</span> = (<span class="params">time</span>) =&gt; &#123;</span><br><span class="line">    <span class="title class_">Time</span>.<span class="property">value</span> = time</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Time</span>.<span class="property">value</span>--</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Time</span>.<span class="property">value</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(n)</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">&#x27;订单超时&#x27;</span>)</span><br><span class="line">        router.<span class="title function_">push</span>(<span class="string">&#x27;/cartList&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; formatTime, start &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常好理解啊，就像大多数编程语言一样，把能实现部分功能的代码<strong>封装成一个函数</strong>，需要的时候再导入这个函数，调用这个函数，和把这些代码直接写在组件中相比，区别只于私有化了变量，需要通过return导出。</p>
<h2 id="跨域是什么？Vue项目中你是如何解决跨域的呢？"><a href="#跨域是什么？Vue项目中你是如何解决跨域的呢？" class="headerlink" title="跨域是什么？Vue项目中你是如何解决跨域的呢？"></a>跨域是什么？Vue项目中你是如何解决跨域的呢？</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p><strong>跨域</strong>本质是<code>浏览器</code>基于<strong>同源策略</strong>的一种<code>安全手段</code>，它是<strong>浏览器</strong>最核心也最基本的安全功能，服务器间通信不会有跨域的问题。</p>
<p>所谓同源（即指在同一个域）具有以下三个相同点</p>
<ul>
<li>协议相同（protocol）</li>
<li>主机相同（host）</li>
<li>端口相同（port）</li>
</ul>
<p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域(非同源产生跨域)</p>
<p>举个例子，我们直接打开 HTML 文件使用的是<code>file:///</code>协议加载，如果文档内部请求了其他<code>网络资源</code>，因为HTTP 请求使用的是 <code>http://</code> 或 <code>https:// </code>协议，协议不同，就发生了跨域。</p>
<p>和<strong>跨站</strong>有什么区别呢？跨站不涉及协议和端口号，<strong>一般情况下，跨站指的就是主域名不同</strong>，比如<code>www.bilibili.com</code>和<code>game.bilibili.com</code>属于同站。</p>
<h3 id="如何解决-1"><a href="#如何解决-1" class="headerlink" title="如何解决"></a>如何解决</h3><ul>
<li>JSONP</li>
<li>CORS</li>
<li>Proxy</li>
</ul>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a><strong>JSONP</strong></h4><p>利用了<code>script</code>标签可以<strong>跨域加载脚本</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">onClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">      script.<span class="property">src</span> = <span class="string">&quot;http://127.0.0.1:8081/api/callback?callback=hello&quot;</span></span><br><span class="line">      <span class="comment">//给script标签对象添加监听事件</span></span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">      <span class="comment">//比addEventListener写法简单</span></span><br><span class="line">      <span class="comment">//原始事件监听模型</span></span><br><span class="line">      script.<span class="property">onload</span> = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">        script.<span class="title function_">remove</span>()<span class="comment">//调用remove方法删除这个标签</span></span><br><span class="line">      &#125;<span class="comment">//脚本加载后立马删除，监听*onload*事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;onClick()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实还有其他标签可以跨域加载资源，貌似大部分标签都可以跨域加载资源…</p>
<p><strong>媒体资源</strong></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>img标签</td>
<td>可以跨域加载图像资源，但是如果给img标签加上crossorigin属性，那么就会以跨域的方式请求图片资源</td>
</tr>
<tr>
<td>audio和video标签</td>
<td>可以跨域加载视频，音频</td>
</tr>
</tbody></table>
<p><strong>前端基础三大文件</strong></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>link标签</td>
<td>可以跨域加载CSS文件</td>
</tr>
<tr>
<td>iframe标签</td>
<td>可以跨域加载HTML页面。</td>
</tr>
<tr>
<td>script标签</td>
<td>可以跨域加载脚本</td>
</tr>
</tbody></table>
<p>jsonp请求有个明显的缺点：只能发送<code>get</code>请求</p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><strong>Proxy</strong></h4><p>代理（Proxy）也称<code>网络代理</code>，是一种特殊的<code>网络服务</code>，允许一个（一般为客户端）通过<code>代理</code>与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。</p>
<p>代理的方式也可以有多种：</p>
<ul>
<li><p><strong>在脚手架中配置</strong></p>
<p>在开发过程中，我们可以在<code>脚手架</code>中配置代理。我们可以通过<code>webpack（或者vite）</code>为我们开起一个<code>本地服务器</code>(devServer，域名一般是<code>localhost:8080</code>)，作为请求的<code>代理对象</code>，所以说，这个本地服务器不仅能<code>部署</code>我们<code>开发打包</code>的资源，还能起到<code>代理</code>作用。</p>
<p>通过该服务器<code>转发</code>请求至目标服务器，得到结果再转发给前端，因为服务器之间通信不存在跨域问题，所以能解决跨域问题。</p>
<p>打包之后的项目文件，因为脱离了代理服务器，所以说这种方式只能在<code>开发环境</code>使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vue.config.js 即vue-cli脚手架（基于webpack）开发的vue项目</span></span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">   <span class="attr">proxy</span>: &#123;</span><br><span class="line">     <span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//匹配所有以/api开头的请求路径</span></span><br><span class="line">       <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>, <span class="comment">// 后端服务器地址</span></span><br><span class="line">       <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 改变请求源，让浏览器认为请求是来自本地</span></span><br><span class="line">       <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;, <span class="comment">// 重写路径，移除前缀</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vite.config.js 即vue-create脚手架（基于vite）开发的vue项目</span></span><br><span class="line"><span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//匹配所有以/api开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>, <span class="comment">// 后端服务器地址</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 改变请求源，让浏览器认为请求是来自本地</span></span><br><span class="line">        <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^\/api/</span>, <span class="string">&#x27;&#x27;</span>), <span class="comment">// 重写路径，移除前缀</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="..\images\前端面试-vue\跨域.png" style="zoom:85%;" />

<p>可以看到，我们要使用代理，在编写接口时，就不能书写完整的路径，比如就不能直接把请求url写成<code>https://www.sanye.blog/books</code>，这样必然跨域，我们应该把请求写为<code>/books</code>，部署到本地服务器后加载网页，发起这个请求前，会先自动与<code>域名</code>拼接，实际的请求就变为<code>http://localhost:8080/books</code>，这样就没跨域，不过确实，这么操作的话，就是在请求本地服务器中的<code>books</code>资源，而不是目标服务器中的，如果我们本地服务器中有这个资源（vue-cli中是public目录下有books文件，无后缀），那么本地服务器就会把这个资源返回给浏览器，<strong>无论我们是否开启了代理</strong>，所以我们实际还要添加<code>/api</code>类似的多余的前缀，确保我们访问的<code>不是</code>本地服务器中的资源，然后本地服务器会帮我们按照配置的规则进行<code>路径重写</code>，得到正确的请求URL，再向目标服务器请求资源。</p>
</li>
<li><p><strong>在服务端开启代理</strong></p>
<p>其实也不是打包后就不能通过代理来解决跨域问题，如果我们把<code>打包后的前端资源</code>部署到<code>本地的服务器</code>，比如使用基于<code>node.js</code>的<code>express</code>框架搭建的<code>本地服务器</code>，我们也可以通过配置代理来解决跨域问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>( <span class="string">&#x27;express &#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">//其实webpack-dev-server开启代理功能的核心也是这个中间件</span></span><br><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>( <span class="string">&#x27;http-proxy-middleware &#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>( . /public)）<span class="comment">//引入静态资源</span></span><br><span class="line">app.<span class="title function_">use</span>( <span class="string">&#x27;/api&#x27;</span> ,<span class="title function_">createProxyMiddleware</span>(&#123;</span><br><span class="line">	<span class="attr">target</span>: <span class="string">&#x27; https:// www.toutiao.com&#x27;</span>,</span><br><span class="line">	<span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line">	<span class="attr">pathRewrite</span>:&#123;</span><br><span class="line">		<span class="string">&#x27;^/api &#x27;</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>总之想要配置代理，就离不开一台允许你配置代理的<code>服务器</code>，把打包后的前端资源托管到<code>其他平台</code>，我们也无法来配置代理，也就无法解决跨域问题。</p>
</li>
</ul>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h4><p>CORS （Cross-Origin Resource Sharing），即跨域资源共享，意思就是虽然你在跨域请求我的资源，但是我还是<code>选择性的</code>共享资源给你，浏览器根据<code>响应头</code>中的<code>特定字段</code>来决定是否拦截<code>跨域请求</code>返回的数据。</p>
<p>因为需要在<code>响应头</code>上做文章，所以这个工作主要是前后端协调后由后端负责，至于前后端如何协调，参考<code>简单请求</code>和<code>复杂请求</code>部分。</p>
<h2 id="如何理解简单请求和复杂请求"><a href="#如何理解简单请求和复杂请求" class="headerlink" title="如何理解简单请求和复杂请求"></a>如何理解简单请求和复杂请求</h2><table>
<thead>
<tr>
<th></th>
<th>简单请求</th>
<th>复杂请求</th>
</tr>
</thead>
<tbody><tr>
<td>请求方法(携带在请求行中)</td>
<td>get，post，head</td>
<td>除get，post，head外的请求方法</td>
</tr>
<tr>
<td>请求头</td>
<td>满足cors安全规范（一般不修改请求头就是安全的）<code>Content-Type</code> 的值仅限于以下三种之一：  <code>application/x-www-form-urlencoded</code> <code>multipart/form-data</code> <code>text/plain</code></td>
<td>设置了自定义的 HTTP 头，或者 <code>Content-Type</code> 不是上述三种之一时</td>
</tr>
</tbody></table>
<p>在非跨域情况下，区分二者并没有什么意义，但是在跨域情况下，发送复杂请求前，会先发送一次<code>预检请求</code>，请求方法为<code>options</code>，</p>
<p>在请求头中携带<code>Origin</code>,<code>Access-Control-Request-Method</code>,<code>Access-Control-Request-Headers</code>字段，询问服务器是否接受来自xxx源，请求方法为xxx，请求头为xxx的<code>跨域复杂请求</code>，如果接受则再发送这样的<code>复杂请求</code>。</p>
<img src="..\images\前端面试-vue\options.jpg" style="zoom:80%;" />



<p>服务端处理代码（以express框架为例）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">options</span>( <span class="string">&#x27;/students &#x27;</span>,<span class="function">(<span class="params"> req,res</span>)=&gt;</span>&#123;</span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> , <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>)</span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods &#x27;</span> , <span class="string">&#x27;GET&#x27;</span>)</span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers &#x27;</span> ,<span class="string">&#x27;school&#x27;</span>）</span><br><span class="line">	res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Max-Age &#x27;</span> , <span class="number">7200</span>)<span class="comment">//告诉浏览器在7200s内不要再发送预检请求询问</span></span><br><span class="line">	res.<span class="title function_">send</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样处理起来明显比较繁琐，实际上我们借助<code>CORS中间件</code>就能统一处理<code>简单请求和复杂请求（包括预检请求）</code>的跨域问题。</p>
<h2 id="vue项目如何部署？有遇到布署服务器后刷新404问题吗"><a href="#vue项目如何部署？有遇到布署服务器后刷新404问题吗" class="headerlink" title="vue项目如何部署？有遇到布署服务器后刷新404问题吗"></a>vue项目如何部署？有遇到布署服务器后刷新404问题吗</h2><h3 id="如何部署"><a href="#如何部署" class="headerlink" title="如何部署"></a>如何部署</h3><p>前后端分离开发模式下，前后端是<code>独立布署</code>的，前端只需要将最后的构建物上传至目标服务器的<code>web</code>容器指定的<code>静态目录</code>下即可，我们知道<code>vue</code>项目在构建后，是生成一系列的静态文件。</p>
<h3 id="404问题"><a href="#404问题" class="headerlink" title="404问题"></a>404问题</h3><p>HTTP 404 错误意味着链接指向的资源不存在，问题在于为什么不存在？且为什么只有<code>history</code>模式下会出现这个问题，而hash模式下不会有?</p>
<p>history模式，刷新页面，<code>前端路由部分</code>会被当作<code>请求URL</code>的一部分发送给服务器，然而服务器<code>并没有相关配置</code>，所以<code>响应404</code>。</p>
<p>而hash模式，前端路由在URL的<code>#</code>后面，不会被当作请求URL的一部分。</p>
<p>要解决使用history路由的项目，必须和<code>后端</code>沟通，当请求的页面不存在时，返回<code>index.html</code>，把页面控制权全交给<code>前端路由</code>，</p>
<p>但是这样有个问题，就是后端服务器不会再响应<code>404</code>错误了，当找不到请求的资源总是会返回index.html，即便请求的资源在前后端中都不存在（即把页面控制权交给前端路由，也没有对应的页面），所以为了避免这种情况，应该在 Vue应用里面<code>覆盖所有的路由情况</code>，最后给出一个 <code>404 页面</code>(虽然说是404页面，但是响应状态码是200，因为返回了<code>index.html</code>)</p>
<h2 id="hash路由和history路由的实现原理，二者有什么区别？"><a href="#hash路由和history路由的实现原理，二者有什么区别？" class="headerlink" title="hash路由和history路由的实现原理，二者有什么区别？"></a>hash路由和history路由的实现原理，二者有什么区别？</h2><img src="..\images\前端面试-vue\前端路由.png" style="zoom:67%;" />

<p><code>哈希路由</code>（Hash-based Routing）和<code> History 路由</code>（History API-based Routing）是前端路由的两种常见实现方式，它们用于在单页面应用程序 (SPA) 中模拟多页面体验，而无需重新加载整个页面。</p>
<h3 id="hash路由"><a href="#hash路由" class="headerlink" title="hash路由"></a>hash路由</h3><h4 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a><strong>是什么</strong></h4><p><code>前端路由</code>被放到<code>url</code>的<code>hash</code>部分，即url中<code>#</code>后面的部分。<code>哈希值</code>改变也不会触发页面<code>重新加载</code>，浏览器也不会将<code>哈希值</code>发送到服务器，因此无论<code>哈希值</code>如何变化，服务器只会返回同一个初始 HTML 文件。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul>
<li>不需要服务器配置支持，因为哈希值不会被发送给服务器。</li>
<li><code>兼容性好</code>，几乎所有浏览器都支持哈希变化事件。</li>
<li>URL 中包含显眼的 <code>#</code> 符号，可能影响美观。</li>
<li>前端路由部分十分明确，方便部署，可以部署在服务器的<code>任何位置</code>。</li>
</ul>
<h4 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a><strong>如何做</strong></h4><img src="..\images\前端面试-js\hash.png" style="zoom:67%;" />

<p>可以直接设置 <code>window.location.hash</code> 属性来<code>改变</code> URL 中的哈希部分，改变 <code>window.location.hash</code> 不会触发<code>页面刷新</code>，但它会添加一个<code>新的历史记录条目</code>。</p>
<p>前端 JavaScript 监听 <code>hashchange</code> 事件来<code>检测</code>哈希的变化，并根据新的哈希值更新页面内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;hashchange&#x27;, function () &#123;</span><br><span class="line">    const hash = window.location.hash.slice(1); // 获取去掉 # 后的部分</span><br><span class="line">    console.log(`Hash changed to: $&#123;hash&#125;`);</span><br><span class="line">    // 根据 hash 更新页面内容</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="history路由"><a href="#history路由" class="headerlink" title="history路由"></a>history路由</h3><h4 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a><strong>是什么</strong></h4><p>使用标准的路径形式，例如 <code>http://example.com/page1</code>，<code>前端路由</code>被放到<code>url</code>中的<code>资源路径</code>部分</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul>
<li><p>没有显眼的<code>#</code>号，更为美观</p>
</li>
<li><p>需要后端支持，否则会出现<code>404</code>问题，因为前端路由会被发送到后端，而后端并未做对应配置。</p>
</li>
<li><p>对较老版本的浏览器兼容性较差（IE10+ 支持 History API）</p>
</li>
<li><p>history路由的项目一般部署在<code>服务器根目录</code>，域名后面的路径就是<code>前端路径</code>，否则需要在<code>前端路由库</code>(比如VueRouter)中做额外配置，确保浏览器能从url中提取出文件路径。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: <span class="string">&#x27;/app/&#x27;</span>, <span class="comment">// 设置基础路径</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 你的路由配置</span></span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>例如，如果用户的 URL 是 <code>http://example.com/app/user/profile</code>，那么前端路由库会将 <code>/user/profile</code> 视为<code>实际的路由路径</code>，而 <code>/app/</code> 则被视为基础路径。</p>
</li>
</ul>
<h4 id="如何做-1"><a href="#如何做-1" class="headerlink" title="如何做"></a><strong>如何做</strong></h4><img src="..\images\前端面试-js\history.png" style="zoom:67%;" />

<p>使用 <code>HTML5</code> 的 History API (<code>history.pushState()</code> 和 <code>history.replaceState()</code>) 来<code>修改</code> URL，而不会触发页面刷新。</p>
<p><strong>history.pushState(stateObj, title, url)</strong></p>
<ul>
<li><p><strong>功能</strong>：</p>
<ul>
<li><p>向浏览器的<code>历史栈</code>中添加一个新的记录，历史栈长度+1，</p>
</li>
<li><p>并更新<code>当前 URL</code>，但不重新加载页面。</p>
</li>
</ul>
</li>
<li><p><strong>参数</strong></p>
<ul>
<li><code>stateObj</code>: 一个对象，用于存储与该状态相关联的数据，可以通过 <code>popstate</code> 事件访问。也可以通过<code>history.state</code>属性访问。</li>
<li><code>title</code>：通常被忽略或设为空字符串（大多数浏览器不支持）。</li>
<li><code>url</code>：新的 URL，可以是相对路径或绝对路径，<strong>但不能改变域名，否则会报错</strong>。</li>
</ul>
<img src="..\images\前端面试-js\a.png" style="zoom:90%;" /></li>
</ul>
<p><strong>history.replaceState(stateObj, title, url)</strong></p>
<ul>
<li><strong>功能</strong>：<ul>
<li>替换当前的历史记录条目，而不是添加新的条目。</li>
<li>它同样更新<code>当前 URL</code> 但不刷新页面。</li>
</ul>
</li>
<li><strong>参数</strong>：与 <code>pushState</code> 相同。</li>
</ul>
<p>监听 <code>popstate</code> 事件来响应浏览器的前进&#x2F;后退按钮操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// History 路由监听</span><br><span class="line">window.addEventListener(&#x27;popstate&#x27;, function (event) &#123;</span><br><span class="line">    console.log(&#x27;URL changed to:&#x27;, event.state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢-？"><a href="#说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢-？" class="headerlink" title="说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢 ？"></a>说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢 ？</h2><p>在划分项目结构的时候，需要遵循一些基本的原则：</p>
<ul>
<li>文件夹和文件夹内部文件的语义一致性</li>
<li>单一入口&#x2F;出口</li>
<li>就近原则，紧耦合的文件应该放到一起，且应以相对路径引用</li>
<li>公共的文件应该以绝对路径的方式从根目录引用</li>
<li><code>/src</code> 外的文件不应该被引入</li>
</ul>
<p><strong>文件夹和文件夹内部文件的语义一致性</strong></p>
<p>我们的目录结构都会有一个文件夹是按照<code>路由模块</code>来划分的，如<code>pages</code>文件夹，这个文件夹里面应该包含我们项目所有的路由模块，并且<code>仅</code>应该包含路由模块，而不应该有别的其他的非路由模块的文件夹</p>
<p>这样做的好处在于一眼就从 <code>pages</code>文件夹看出这个项目的路由有哪些</p>
<p><strong>单一入口&#x2F;出口</strong></p>
<p>举个例子，在<code>pages</code>文件夹里面存在一个<code>seller</code>文件夹，这时候<code>seller</code> 文件夹应该作为一个独立的模块由外部引入，并且 <code>seller/index.js</code> 应该作为外部引入 seller 模块的唯一入口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误用法</span><br><span class="line">import sellerReducer from &#x27;src/pages/seller/reducer&#x27;//可以是reducer，就可以是其他，这样出口就不唯一。</span><br><span class="line"></span><br><span class="line">// 正确用法</span><br><span class="line">import &#123; reducer as sellerReducer &#125; from &#x27;src/pages/seller&#x27;//默认引入seller目录下的index.js文件</span><br></pre></td></tr></table></figure>



<p><strong>就近原则，紧耦合的文件应该放到一起，且应以相对路径引用</strong></p>
<p>使用<code>相对路径</code>可以保证模块内部的独立性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 正确用法</span><br><span class="line">import styles from &#x27;./index.module.scss&#x27;</span><br><span class="line">// 错误用法</span><br><span class="line">import styles from &#x27;src/pages/seller/index.module.scss&#x27;</span><br></pre></td></tr></table></figure>

<p>举个例子</p>
<p>假设我们现在的 seller 目录是在 <code>src/pages/seller</code>，如果我们后续发生了路由变更，需要加一个层级，变成 <code>src/pages/user/seller</code>。</p>
<p>如果我们采用第一种相对路径的方式，那就可以直接将整个文件夹拖过去就好，<code>seller</code> 文件夹内部不需要做任何变更。</p>
<p>但是如果我们采用第二种绝对路径的方式，移动文件夹的同时，还需要对每个 <code>import</code> 的路径做修改</p>
<p>总之就是要体会到相对路径的好处，移动文件也不需要修改路径，只要相对位置没变就好。</p>
<p><strong>&#x2F;src 外的文件不应该被引入</strong></p>
<p><code>vue-cli</code>脚手架已经帮我们做了相关的约束了，正常我们的前端项目都会有个<code>src</code>文件夹，里面放着所有的项目需要的资源，<code>js</code>,<code> css</code>, <code>png</code>, <code>svg</code> 等等。<code>src</code> 外会放一些项目配置，依赖，环境等文件</p>
<p>这样的好处是方便划分项目代码文件和配置文件</p>
<h2 id="Vue如何做权限管理"><a href="#Vue如何做权限管理" class="headerlink" title="Vue如何做权限管理"></a>Vue如何做权限管理</h2><p>权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源</p>
<p>而前端权限归根结底是<code>请求的发起权</code>，请求的发起可能有下面两种形式触发</p>
<ul>
<li>页面加载触发</li>
<li>页面上的按钮点击触发</li>
</ul>
<h3 id="如何做-2"><a href="#如何做-2" class="headerlink" title="如何做"></a>如何做</h3><p>前端权限控制可以分为四个方面：</p>
<ul>
<li>接口权限</li>
<li>按钮权限</li>
<li>菜单权限</li>
<li>路由权限</li>
</ul>
<p><strong>接口权限</strong></p>
<p>接口权限目前一般采用<code>jwt</code>的形式来验证，没有通过的话一般返回<code>401</code>（用户不存在），跳转到登录页面重新进行登录</p>
<p>登录完拿到<code>token</code>，将<code>token</code>存起来，通过<code>axios</code>请求拦截器进行拦截，每次请求的时候头部携带<code>token</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">    config.headers[&#x27;token&#x27;] = cookie.get(&#x27;token&#x27;)</span><br><span class="line">    return config</span><br><span class="line">&#125;)</span><br><span class="line">axios.interceptors.response.use(res=&gt;&#123;&#125;,&#123;response&#125;=&gt;&#123;</span><br><span class="line">    if (response.data.code === 40099 || response.data.code === 40098) &#123; //token过期或者错误</span><br><span class="line">        router.push(&#x27;/login&#x27;)//路由跳转</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="vue3有了解过吗？能说说跟vue2的区别吗？"><a href="#vue3有了解过吗？能说说跟vue2的区别吗？" class="headerlink" title="vue3有了解过吗？能说说跟vue2的区别吗？"></a>vue3有了解过吗？能说说跟vue2的区别吗？</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>关于<code>vue3</code>的重构背景，尤大是这样说的：</p>
<p>「Vue 新版本的理念成型于 2018 年末，当时 Vue 2 的代码库已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，但在这段时期，前端世界已经今昔非比了</p>
<p>在我们更新（和重写）Vue 的主要版本时，主要考虑两点因素：首先是新的 JavaScript 语言特性在主流浏览器中的受支持水平；其次是当前代码库中随时间推移而逐渐暴露出来的一些设计和架构问题」</p>
<p>简要就是：</p>
<ul>
<li>利用新的语言特性(es6)</li>
<li>解决架构问题</li>
</ul>
<h3 id="新增特性"><a href="#新增特性" class="headerlink" title="新增特性"></a>新增特性</h3><p>Vue 3 中需要关注的一些新功能包括：</p>
<ul>
<li><p><strong>fragment</strong></p>
<p>在 Vue 2 中，组件必须有一个根元素。而在 Vue 3 中，组件可以有多个根节点，它们会自动被<code>fragment</code>标签包裹，它不参与渲染。</p>
</li>
<li><p><strong>Teleport</strong></p>
<p><code>Teleport </code>组件的<code>内部结构</code>将会被“传送”到指定的目标容器中</p>
<p>组件标签的<code>to </code>属性，指定目标容器的<code>选择器</code>或 <code>DOM </code>节点</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showToast&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>打开 toast<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- to 属性就是目标位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;#teleport-target&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;visible&quot;</span> <span class="attr">class</span>=<span class="string">&quot;toast-wrap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;toast-msg&quot;</span>&gt;</span>我是一个 Toast 文案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>composition Api</strong></p>
<p>即组合式api，把逻辑紧密联系的代码放到一起，提高了代码的可维护性。</p>
</li>
</ul>
<h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="vue3做了哪些优化？"><a href="#vue3做了哪些优化？" class="headerlink" title="vue3做了哪些优化？"></a>vue3做了哪些优化？</h2><p>这是一个很大的话题，这里只做<code>简要介绍</code>，后续对每个部分都有<code>详细解释</code>。</p>
<ul>
<li><p>更小</p>
<p>Vue3移除了一些不常用的 API，引入<code>tree-shaking</code>，可以将无用模块“剪辑”，仅打包需要的，使<strong>打包的整体体积变小了</strong>。</p>
</li>
<li><p>更快</p>
<p>主要体现在编译方面：</p>
<ul>
<li>diff算法优化</li>
<li>静态提升</li>
<li>事件监听缓存</li>
<li>SSR优化</li>
</ul>
</li>
<li><p>更友好</p>
<p><code>vue3</code>在兼顾<code>vue2</code>的<code>options API</code>的同时还推出了<code>composition API</code>，大大增加了代码的逻辑组织和代码复用能力。</p>
</li>
</ul>
<h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a><strong>优化方案</strong></h3><p><code>vue3</code>从很多层面都做了优化，可以分成三个方面：</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>源码可以从两个层面展开：</p>
<ul>
<li><p>源码管理</p>
<p><code>vue3</code>整个源码是通过 <code>monorepo</code>的方式维护的，根据功能将不同的模块拆分到<code>packages</code>目录下面不同的子目录中</p>
<p>这样使得<code>模块拆分</code>更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。</p>
</li>
<li><p>TypeScript</p>
<p><code>Vue3</code>是基于<code>typeScript</code>编写的，提供了更好的类型检查，能支持复杂的类型推断</p>
</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li><p>体积优化</p>
</li>
<li><p>编译优化</p>
</li>
<li><p>数据劫持优化</p>
<p>在<code>vue2</code>中，数据劫持是通过<code>Object.defineProperty</code>，这个 API 有一些缺陷，<strong>并不能检测对象属性的添加和删除</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>尽管<code>Vue</code>为了解决这个问题提供了 <code>set</code>和<code>delete</code>实例方法，但是对于用户来说，还是增加了一定的心智负担。</p>
<p>相比之下，<code>vue3</code>是通过<code>proxy</code>监听整个对象，那么对于删除还是监听当然也能监听到</p>
<p>同时<code>Proxy</code> 并不能监听到内部深层次的对象变化，而 <code>Vue3</code> 的处理方式是在<code>getter</code> 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归。</p>
</li>
</ul>
<h4 id="语法API"><a href="#语法API" class="headerlink" title="语法API"></a>语法API</h4><p>这里当然说的就是<code>composition API</code>，其两大显著的优化：</p>
<ul>
<li>优化逻辑组织</li>
<li>优化逻辑复用</li>
</ul>
<p>在<code>vue2</code>中，我们是通过<code>mixin</code>实现功能复用，如果多个<code>mixin</code>混合，会存在两个非常明显的问题：<code>命名冲突</code>和<code>数据来源不清晰</code></p>
<p>而在组合式api中，我们可以将一些可复用的代码抽离出来作为<code>一个函数</code>并导出，在需要使用的地方导入后直接调用即可。这个种模块化的方式既解决了<code>命名冲突</code>的问题，也解决了<code>数据来源不清晰</code>的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mouse/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; toRefs, reactive, onUnmounted, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;&#123;</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件中使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入</span></span><br><span class="line"><span class="keyword">import</span> useMousePosition <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMousePosition</span>()<span class="comment">//直接调用</span></span><br><span class="line">        <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h2><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改对象的现有属性，并返回此对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个对象，将这个对象转变成响应式对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="comment">//如果存在嵌套对象的情况，则递归添加响应式。</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">typeof</span> val == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_">observe</span>(val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                <span class="comment">//当给key赋值为对象的时候，还需要在set方法中给这个对象也添加响应式。</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">typeof</span> newVal == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">                    <span class="title function_">observe</span>(newVal)</span><br><span class="line">                &#125;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="comment">//调用update方法，做一些更新视图的工作，依赖这个属性的视图，计算属性，watch都会更新或执行一些逻辑</span></span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrData = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="title function_">observe</span>(arrData)</span><br><span class="line">arrData.<span class="title function_">push</span>() <span class="comment">//无响应</span></span><br><span class="line">arrData.<span class="title function_">pop</span>()  <span class="comment">//无响应</span></span><br><span class="line">arrDate[<span class="number">0</span>] = <span class="number">99</span> <span class="comment">//ok，有响应</span></span><br></pre></td></tr></table></figure>

<p><strong>缺点小结</strong></p>
<ul>
<li><code>Object.defineProperty</code>无法监听到数组方法对数组元素的修改</li>
<li>需要遍历对象每个属性<code>逐个添加监听</code>，而且无法监听到<code>对象属性</code>的<code>添加</code>与<code>删除</code>，如果属性值是嵌套对象，还深层监听，造成性能问题。</li>
</ul>
<h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a>Proxy</h3><p><code>Proxy</code>的监听是<code>整个对象</code>，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了</p>
<p>定义一个响应式方法<code>reactive</code>，这个<code>reactive</code>方法就是vue3中的<code>reactive</code>方法的<strong>简化版</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下简单数据的操作，发现都能劫持</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1.获取</span></span><br><span class="line">state.<span class="property">foo</span> <span class="comment">// 输出获取foo:foo</span></span><br><span class="line"><span class="comment">// 2.设置已存在属性</span></span><br><span class="line">state.<span class="property">foo</span> = <span class="string">&#x27;fooooooo&#x27;</span> <span class="comment">//设置foo:fooooooo</span></span><br><span class="line"><span class="comment">// 3.设置不存在属性</span></span><br><span class="line">state.<span class="property">dong</span> = <span class="string">&#x27;dong&#x27;</span> <span class="comment">// 输出设置dong:dong</span></span><br><span class="line"><span class="comment">// 4.删除属性</span></span><br><span class="line"><span class="keyword">delete</span> state.<span class="property">dong</span> <span class="comment">// 输出删除dong:true</span></span><br></pre></td></tr></table></figure>

<p>再测试嵌套对象情况，这时候发现就不那么 OK 了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">bar</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 获取bar:[object Object] 其实就是获取到了bar:&#123;a:1&#125;啦 这个操作进行了两次属性访问，但是只触发了一次getter</span></span><br><span class="line"><span class="comment">//这就意味着</span></span><br><span class="line">state.<span class="property">bar</span>.<span class="property">a</span> = <span class="number">10</span> </span><br></pre></td></tr></table></figure>

<p>如果要解决，需要在<code>get</code>之上再进行一层代理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="comment">//如果返回的对象是一个object，则给这个对象添加响应式</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> res===<span class="string">&#x27;object&#x27;</span> ? <span class="title function_">reactive</span>(res) : res</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>修改后输出的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取<span class="attr">bar</span>:[object <span class="title class_">Object</span>]</span><br><span class="line">设置<span class="attr">a</span>:<span class="number">10</span></span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Object.defineProperty</code>这个方法存在许多缺点，比如必须<code>遍历对象</code>的所有属性<code>逐个添加监听</code>，而且无法监听对象属性的增加与删除，如果属性的值是<code>引用类型</code>还需要<code>深度监听</code>，造成<code>性能问题</code>。</p>
<p>对于数组，<code>Object.defineProperty</code>方法无法监听到数组方法对数组元素的修改，需要重写数组方法。</p>
<p>而Proxy能监听整个对象的变化，也能监听到数组方法对数组元素的修改。</p>
<h2 id="说说Vue-3-0中Treeshaking特性？"><a href="#说说Vue-3-0中Treeshaking特性？" class="headerlink" title="说说Vue 3.0中Treeshaking特性？"></a>说说Vue 3.0中Treeshaking特性？</h2><h3 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h3><p><code>Tree shaking</code> 是一种通过<strong>清除多余js代码</strong>方式来<code>优化项目打包体积</code>的技术。</p>
<h3 id="如何做-3"><a href="#如何做-3" class="headerlink" title="如何做"></a>如何做</h3><p><code>Tree shaking</code>是基于<code>ES6</code>模块语法（<code>import</code>与<code>exports</code>），主要是借助<code>ES6</code>模块的<code>静态编译</code>思想，在<code>编译时</code>就能确定模块的依赖关系，以及输入和输出的变量。</p>
<p><code>Tree shaking</code>无非就是做了两件事：</p>
<ul>
<li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li>
<li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li>
</ul>
<p>那么为什么使用 CommonJs、AMD 等模块化方案无法支持 Tree Shaking 呢？</p>
<p>因为在 CommonJs、AMD、CMD 等旧版本的 js 模块化方案中，导入导出行为是<strong>高度动态</strong>，难以预测的，只能在<code>代码运行的时候</code>确定模块的依赖关系，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>)&#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">foo</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 ESM 方案则从规范层面规避这一行为，它要求所有的导入导出语句只能出现在<code>模块顶层</code>，可以理解为全局作用域；且导入导出的模块名必须为字符串常量，这意味着下述代码在 ESM 方案下是非法的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>)&#123;</span><br><span class="line">  <span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，ESM 下模块之间的依赖关系是<code>高度确定</code>的，与运行状态无关，编译工具只需要对 ESM 模块做<code>静态语法分析</code>，就可以从代码字面量中推断出哪些模块值未曾被其它模块使用，这是实现 Tree Shaking 技术的必要条件。</p>
<p>更多内容参考：<a href="https://www.sanye.blog/posts/762e27cc.html">前端面试—webpack | 三叶的博客</a></p>
<h2 id="Composition-Api-与-Options-Api-有什么不同？"><a href="#Composition-Api-与-Options-Api-有什么不同？" class="headerlink" title="Composition Api 与  Options Api 有什么不同？"></a>Composition Api 与  Options Api 有什么不同？</h2><h3 id="代码组织方式"><a href="#代码组织方式" class="headerlink" title="代码组织方式"></a>代码组织方式</h3><p>选项式api按照<code>代码的类型</code>来组织代码；而组合式api按照<code>代码的逻辑</code>来组织代码，逻辑紧密关联的代码会被放到一起。</p>
<h3 id="代码复用方式"><a href="#代码复用方式" class="headerlink" title="代码复用方式"></a>代码复用方式</h3><p>在选项式api这，我们使用<code>mixin</code>来实现代码复用，使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候</p>
<p>就存在两个非常明显的问题：</p>
<ul>
<li>命名冲突</li>
<li>数据来源不清晰</li>
</ul>
<p>而在组合式api中，我们可以将一些可复用的代码抽离出来作为<code>一个函数</code>并导出，在需要在使用的地方导入后直接调用即可。这个种<code>模块化</code>的方式，既解决了<code>命名冲突</code>的问题，也解决了<code>数据来源不清晰</code>的问题。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.sanye.blog">三叶sanye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.sanye.blog/posts/f33bd2b9.html">https://www.sanye.blog/posts/f33bd2b9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.sanye.blog" target="_blank">三叶的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vue/">vue</a></div><div class="post-share"><div class="social-share" data-image="/images/cover/%E5%B0%8F%E9%95%87.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/aef189c3.html" title="前端面试---js部分"><img class="cover" src="/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">前端面试---js部分</div></div><div class="info-2"><div class="info-item-1">说说js的数据类型js的数据类型可以分为两类，基本数据类型和引用数据类型 基本数据类型基本数据类型主要有6种：Number,String,Boolean,Symbol,Null,Undefined，后来又添加了一种叫做BigInt  number 最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头） 123let intNum = 55 // 10进制的55let num1 = 070 // 8进制的56let hexNum1 = 0xA //16进制的10  浮点类型则在数值中必须包含小数点，还可通过科学计数法表示。 1234let floatNum1 = 1.1;let floatNum2 = 0.1;let floatNum3 = .1; // 有效，但不推荐let floatNum = 3.125e7; // 等于 31250000  在数值类型中，存在一个特殊数值NaN，意为“不是数值”，用于表示数值运算操作失败了（而不是抛出错误） 12console.log(0/0); // NaNconsole.log(-0/+0); //...</div></div></div></a><a class="pagination-related" href="/posts/c6adabe2.html" title="gprMax"><img class="cover" src="/images/cover/maomao.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">gprMax</div></div><div class="info-2"><div class="info-item-1">定义gpr是Ground Penetrating Radar（探地雷达）的缩写，而gprMax是一款模拟电磁波传播的开源软件，它使用有限差分时域 （FDTD） 方法求解 3D 麦克斯韦方程组。gprMax 专为模拟探地雷达 （GPR） 而设计，但也可用于模拟许多其他应用的电磁波传播。很遗憾，目前为止它还没有图形用户界面（GUI），它的建模关键在于in文件的编写。 安装步骤 详细安装步骤参考：gprMax最详安装步骤及常见问题解答 - 知乎  安装步骤简述：  下载Anaconda，并配置好环境变量， 因为gprMax是基于python语言编写的，所以需要安装python及所需python包 Anaconda 对于 Python 的作用，类似js中的npm，java中的maven。  安装git 目的是使用git克隆github上的gprMax仓库，下载gprMax  下载gprMax包 1git clone...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/8b27fabc.html" title="vue"><img class="cover" src="/images/cover/preview.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="info-item-2">vue</div></div><div class="info-2"><div class="info-item-1"> 关于vue的绝大部分知识点都在前端面试—vue部分 | 三叶的博客这篇文章中讲了，这里就说说基础语法 关于vue的绝大部分知识点都在前端面试—vue部分 | 三叶的博客这篇文章中讲了，这里就说说基础语法    Vue2插值表达式利用表达式进行插值，渲染数据到页面中 123&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&lt;p&gt;&#123;&#123;nickname.toUppercase()&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;age &gt;= 18 ?&#x27;成年’:&#x27;未成年&#x27;&#125;&#125;&lt;/p&gt;  注意：不能写到标签内部，表达式涉及到的数据必须存在。 指令带有v-前缀的特殊标签属性，Vue会根据不同的【指令】，针对标签实现不同的【功能】 v-html设置元素的innerHTML v-if&#x2F;v-show用来控制元素显示隐藏。 v-show&#x3D;”表达式”，表达式值true显示，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/%E4%B8%89%E5%8F%B6.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">三叶sanye</div><div class="author-info-description">记录学习，分享知识</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://space.bilibili.com/660655866?spm_id_from=333.1007.0.0" rel="external nofollow noreferrer" target="_blank" title="Bilibli"><i class="fa-brands fa-bilibili" style="color: #74C0FC;"></i></a><a class="social-icon" href="https://github.com/syhy" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3519450570@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">笔记主要自用，希望也能帮到你😀</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue2"><span class="toc-number">1.</span> <span class="toc-text">Vue2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">说说你对vue的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">前端发展背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">Vue是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.3.</span> <span class="toc-text">Vue核心特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">说说你对vue双向绑定的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF"><span class="toc-number">1.3.</span> <span class="toc-text">Vue的学习路线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91"><span class="toc-number">1.3.1.</span> <span class="toc-text">原生开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E5%BC%80%E5%8F%91%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91"><span class="toc-number">1.3.2.</span> <span class="toc-text">原生开发之组件化开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">非单文件组件使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.4.</span> <span class="toc-text">单文件组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9el%E5%92%8Ctemplate%E5%B1%9E%E6%80%A7%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.4.</span> <span class="toc-text">谈谈对el和template属性的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Vue%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.</span> <span class="toc-text">说说Vue实例挂载过程中发生了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B8%80%E8%A7%88"><span class="toc-number">1.5.1.</span> <span class="toc-text">流程图一览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90"><span class="toc-number">1.5.2.</span> <span class="toc-text">详细分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Vue"><span class="toc-number">1.6.</span> <span class="toc-text">手写一个简单的Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90"><span class="toc-number">1.6.1.</span> <span class="toc-text">模板解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.6.2.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.6.3.</span> <span class="toc-text">添加事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%90%86"><span class="toc-number">1.6.4.</span> <span class="toc-text">添加代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">1.6.5.</span> <span class="toc-text">添加响应式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">1.6.6.</span> <span class="toc-text">双向绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">1.6.7.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-observable%E4%BD%A0%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4%E7%9C%8B"><span class="toc-number">1.7.</span> <span class="toc-text">Vue.observable你有了解过吗？说说看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.8.</span> <span class="toc-text">说说Vue的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9slot%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9Fslot%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">说说你对slot的理解？slot使用场景有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD"><span class="toc-number">1.9.1.</span> <span class="toc-text">默认插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD"><span class="toc-number">1.9.2.</span> <span class="toc-text">具名插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD"><span class="toc-number">1.9.3.</span> <span class="toc-text">作用域插槽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%9C%89%E5%86%99%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E5%90%97%EF%BC%9F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">你有写过自定义指令吗？自定义指令的应用场景有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">1.10.1.</span> <span class="toc-text">什么是指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">如何实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">注册自定义指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">定义自定义指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.10.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.11.</span> <span class="toc-text">Vue常用的修饰符有哪些有什么应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.11.1.</span> <span class="toc-text">修饰符是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%9C%E7%94%A8"><span class="toc-number">1.11.2.</span> <span class="toc-text">修饰符的具体作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">表单修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">事件修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.12.</span> <span class="toc-text">Vue中组件和插件有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.12.1.</span> <span class="toc-text">组件是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.12.2.</span> <span class="toc-text">插件是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">1.12.3.</span> <span class="toc-text">区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.12.3.1.</span> <span class="toc-text">编写形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.12.3.2.</span> <span class="toc-text">注册形式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.13.</span> <span class="toc-text">Vue组件通信的方式有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.13.1.</span> <span class="toc-text">组件间通信的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">1.13.2.</span> <span class="toc-text">组件间通信的方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#props%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">1.13.2.1.</span> <span class="toc-text">props传递数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#emit-%E8%A7%A6%E5%8F%91%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.13.2.2.</span> <span class="toc-text">$emit 触发自定义事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ref"><span class="toc-number">1.13.2.3.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EventBus-%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="toc-number">1.13.2.4.</span> <span class="toc-text">EventBus(事件总线)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#provide-%E4%B8%8E-inject"><span class="toc-number">1.13.2.5.</span> <span class="toc-text">provide 与 inject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vuex"><span class="toc-number">1.13.2.6.</span> <span class="toc-text">Vuex</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPA"><span class="toc-number">1.14.</span> <span class="toc-text">SPA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSPA%EF%BC%8C%E5%92%8CMPA%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.1.</span> <span class="toc-text">什么是SPA，和MPA有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="toc-number">1.14.2.</span> <span class="toc-text">如何提高首屏加载速度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98SPA%E7%9A%84SEO"><span class="toc-number">1.14.3.</span> <span class="toc-text">如何提高SPA的SEO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSR"><span class="toc-number">1.15.</span> <span class="toc-text">SSR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSSR"><span class="toc-number">1.15.1.</span> <span class="toc-text">什么是SSR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.15.2.</span> <span class="toc-text">解决了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.15.3.</span> <span class="toc-text">怎么实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E8%A7%86%E5%9B%BE%E4%B8%8D%E5%88%B7%E6%96%B0"><span class="toc-number">1.16.</span> <span class="toc-text">给对象添加属性视图不刷新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">1.16.1.</span> <span class="toc-text">为什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">1.16.2.</span> <span class="toc-text">如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.17.</span> <span class="toc-text">v-if和v-for的优先级是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E5%92%8Cv-show%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3"><span class="toc-number">1.18.</span> <span class="toc-text">v-if和v-show如何理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">1.18.1.</span> <span class="toc-text">共同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="toc-number">1.18.2.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9nextTick%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.19.</span> <span class="toc-text">说说你对nextTick的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9vue%E4%B8%ADkey%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.20.</span> <span class="toc-text">说说你对vue中key的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9Fdom%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">什么是虚拟dom？有什么作用？如何实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.21.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.21.2.</span> <span class="toc-text">有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8vue%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9Fdom"><span class="toc-number">1.21.3.</span> <span class="toc-text">在vue中如何创建虚拟dom</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4diff%E7%AE%97%E6%B3%95"><span class="toc-number">1.22.</span> <span class="toc-text">说说diff算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.23.</span> <span class="toc-text">说说你对keep-alive的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mixin"><span class="toc-number">1.24.</span> <span class="toc-text">Mixin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9FVue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%A0%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.25.</span> <span class="toc-text">跨域是什么？Vue项目中你是如何解决跨域的呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">1.25.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-1"><span class="toc-number">1.25.2.</span> <span class="toc-text">如何解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP"><span class="toc-number">1.25.2.1.</span> <span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proxy"><span class="toc-number">1.25.2.2.</span> <span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-number">1.25.2.3.</span> <span class="toc-text">CORS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%92%8C%E5%A4%8D%E6%9D%82%E8%AF%B7%E6%B1%82"><span class="toc-number">1.26.</span> <span class="toc-text">如何理解简单请求和复杂请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2%EF%BC%9F%E6%9C%89%E9%81%87%E5%88%B0%E5%B8%83%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8E%E5%88%B7%E6%96%B0404%E9%97%AE%E9%A2%98%E5%90%97"><span class="toc-number">1.27.</span> <span class="toc-text">vue项目如何部署？有遇到布署服务器后刷新404问题吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2"><span class="toc-number">1.27.1.</span> <span class="toc-text">如何部署</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#404%E9%97%AE%E9%A2%98"><span class="toc-number">1.27.2.</span> <span class="toc-text">404问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E8%B7%AF%E7%94%B1%E5%92%8Chistory%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BA%8C%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.28.</span> <span class="toc-text">hash路由和history路由的实现原理，二者有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E8%B7%AF%E7%94%B1"><span class="toc-number">1.28.1.</span> <span class="toc-text">hash路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">1.28.1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.28.1.2.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A"><span class="toc-number">1.28.1.3.</span> <span class="toc-text">如何做</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history%E8%B7%AF%E7%94%B1"><span class="toc-number">1.28.2.</span> <span class="toc-text">history路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">1.28.2.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">1.28.2.2.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A-1"><span class="toc-number">1.28.2.3.</span> <span class="toc-text">如何做</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B%E4%BD%A0%E7%9A%84vue%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E4%BD%A0%E8%AF%A5%E6%80%8E%E4%B9%88%E5%88%92%E5%88%86%E7%BB%93%E6%9E%84%E5%92%8C%E5%88%92%E5%88%86%E7%BB%84%E4%BB%B6%E5%91%A2-%EF%BC%9F"><span class="toc-number">1.29.</span> <span class="toc-text">说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E5%A6%82%E4%BD%95%E5%81%9A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.30.</span> <span class="toc-text">Vue如何做权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A-2"><span class="toc-number">1.30.1.</span> <span class="toc-text">如何做</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue3%E6%9C%89%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F%E8%83%BD%E8%AF%B4%E8%AF%B4%E8%B7%9Fvue2%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">vue3有了解过吗？能说说跟vue2的区别吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.31.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7"><span class="toc-number">1.31.2.</span> <span class="toc-text">新增特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue3"><span class="toc-number">2.</span> <span class="toc-text">Vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue3%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">vue3做了哪些优化？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">2.1.1.</span> <span class="toc-text">优化方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95API"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">语法API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-0%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Proxy-API-%E6%9B%BF%E4%BB%A3-defineProperty-API-%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#defineProperty"><span class="toc-number">2.2.1.</span> <span class="toc-text">defineProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Vue-3-0%E4%B8%ADTreeshaking%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">说说Vue 3.0中Treeshaking特性？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-4"><span class="toc-number">2.3.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A-3"><span class="toc-number">2.3.2.</span> <span class="toc-text">如何做</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Composition-Api-%E4%B8%8E-Options-Api-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">Composition Api 与  Options Api 有什么不同？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">代码组织方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">代码复用方式</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/518e617c.html" title="git"><img src="/images/cover/dog.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git"/></a><div class="content"><a class="title" href="/posts/518e617c.html" title="git">git</a><time datetime="2025-02-09T08:07:36.000Z" title="发表于 2025-02-09 16:07:36">2025-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e255a10a.html" title="计算机网络"><img src="/images/cover/maomao.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/posts/e255a10a.html" title="计算机网络">计算机网络</a><time datetime="2025-02-07T15:08:21.000Z" title="发表于 2025-02-07 23:08:21">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4b0178e0.html" title="数据结构与算法"><img src="/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法"/></a><div class="content"><a class="title" href="/posts/4b0178e0.html" title="数据结构与算法">数据结构与算法</a><time datetime="2025-02-07T14:48:29.000Z" title="发表于 2025-02-07 22:48:29">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d04bd5bc.html" title="操作系统"><img src="/images/cover/%E6%98%9F%E7%A9%BA.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/posts/d04bd5bc.html" title="操作系统">操作系统</a><time datetime="2025-02-06T15:49:56.000Z" title="发表于 2025-02-06 23:49:56">2025-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8b27fabc.html" title="vue"><img src="/images/cover/preview.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue"/></a><div class="content"><a class="title" href="/posts/8b27fabc.html" title="vue">vue</a><time datetime="2025-01-25T14:00:18.000Z" title="发表于 2025-01-25 22:00:18">2025-01-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/cover/1.png);"><div id="footer-wrap"><div class="footer_custom_text"><div id="sanye"><svg class="icon" aria-hidden="true"><use href="#icon-banquan"></use></svg><span>2024 - 2025 By 三叶sanye</span><svg class="icon" aria-hidden="true"><use href="#icon-sanyecao"></use></svg></div><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://unpkg.com/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/time.js"></script><script src="/js/iconfont.js"></script><script defer="defer" id="ribbon" src="https://unpkg.com/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://unpkg.com/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://unpkg.com/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/js/busuanzi.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"display":{"position":"left","width":120,"height":240},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>
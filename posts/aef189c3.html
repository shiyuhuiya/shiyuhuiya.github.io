<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>前端面试---js部分 | 三叶的博客</title><meta name="author" content="三叶sanye"><meta name="copyright" content="三叶sanye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="说说js的数据类型js的数据类型可以分为两类，基本数据类型和引用数据类型 基本数据类型基本数据类型主要有6种：Number,String,Boolean,Symbol,Null,Undefined，后来又添加了一种叫做BigInt  number 最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头） 123let intNum &#x3D; 55 &#x2F;&#x2F; 10进制的55let nu"><meta property="og:type" content="article"><meta property="og:title" content="前端面试---js部分"><meta property="og:url" content="https://www.sanye.blog/posts/aef189c3.html"><meta property="og:site_name" content="三叶的博客"><meta property="og:description" content="说说js的数据类型js的数据类型可以分为两类，基本数据类型和引用数据类型 基本数据类型基本数据类型主要有6种：Number,String,Boolean,Symbol,Null,Undefined，后来又添加了一种叫做BigInt  number 最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头） 123let intNum &#x3D; 55 &#x2F;&#x2F; 10进制的55let nu"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.sanye.blog/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg"><meta property="article:published_time" content="2024-12-13T11:39:03.000Z"><meta property="article:modified_time" content="2025-02-21T08:49:12.139Z"><meta property="article:author" content="三叶sanye"><meta property="article:tag" content="js"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.sanye.blog/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.sanye.blog/posts/aef189c3.html"><link rel="preconnect" href="//unpkg.com"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>(()=>{const t={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:t,getScript:(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach((([e,t])=>n.setAttribute(e,t))),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),getCSS:(e,t)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const o=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=o,btf.activateLightMode=a;const n=t.get("theme"),r=window.matchMedia("(prefers-color-scheme: dark)"),c=window.matchMedia("(prefers-color-scheme: light)");if(void 0===n){if(c.matches)a();else if(r.matches)o();else{const e=(new Date).getHours();e<=6||e>=18?o():a()}r.addEventListener("change",(()=>{void 0===t.get("theme")&&(e.matches?o():a())}))}else"light"===n?a():o();const d=t.get("aside-status");void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:{chs_to_cht:"已切换为繁体中文",cht_to_chs:"已切换为简体中文",day_to_night:"已切换为深色模式",night_to_day:"已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-center"},infinitegrid:{js:"https://unpkg.com/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"前端面试---js部分",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,isShuoshuo:!1}</script><link rel="stylesheet" href="/css/bilibiliBanner.css" media="defer" onload='this.media="screen"'><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/time.css"><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="iron-container iron-circle"><div class="iron-box1 iron-circle iron-center"></div><div class="iron-box2 iron-circle iron-center"></div><div class="iron-box3 iron-circle iron-center"></div><div class="iron-box4 iron-circle iron-center"></div><div class="iron-box5 iron-circle iron-center"></div><div class="iron-box6 iron-circle"><div class="iron-coil" style="--i:0"></div><div class="iron-coil" style="--i:1"></div><div class="iron-coil" style="--i:2"></div><div class="iron-coil" style="--i:3"></div><div class="iron-coil" style="--i:4"></div><div class="iron-coil" style="--i:5"></div><div class="iron-coil" style="--i:6"></div><div class="iron-coil" style="--i:7"></div></div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o=()=>{e.style.overflow="",d.classList.add("loaded")},l=()=>{e.style.overflow="hidden",d.classList.remove("loaded")};l(),window.addEventListener("load",o)})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/%E4%B8%89%E5%8F%B6.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/images/cover/秘密风景.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name iconfont icon-sanyecao">三叶的博客</span></a><a class="nav-page-title" href="/"><span class="site-name iconfont icon-sanyecao">前端面试---js部分</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">前端面试---js部分<a class="post-edit-link" href="https://github.com/shiyuhuiya/shiyuhuiya.github.io/issues_posts/前端面试-js.md" rel="external nofollow noreferrer" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-13T11:39:03.000Z" title="发表于 2024-12-13 19:39:03">2024-12-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-21T08:49:12.139Z" title="更新于 2025-02-21 16:49:12">2025-02-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">前端面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">29k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>104分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-02-21 16:49:12&quot;}" hidden></div><h2 id="说说js的数据类型"><a href="#说说js的数据类型" class="headerlink" title="说说js的数据类型"></a>说说js的数据类型</h2><p>js的数据类型可以分为两类，<strong>基本数据类型</strong>和<strong>引用数据类型</strong></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型主要有6种：<code>Number,String,Boolean,Symbol,Null,Undefined</code>，后来又添加了一种叫做<code>BigInt</code></p><ul><li><p>number</p><p>最常见的<code>整数</code>类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span> <span class="comment">// 10进制的55</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">070</span> <span class="comment">// 8进制的56</span></span><br><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span> <span class="comment">//16进制的10</span></span><br></pre></td></tr></table></figure><p><code>浮点类型</code>则在数值中必须包含<code>小数点</code>，还可通过<strong>科学计数法</strong>表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">.1</span>; <span class="comment">// 有效，但不推荐</span></span><br><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于 31250000</span></span><br></pre></td></tr></table></figure><p>在数值类型中，存在一个特殊数值<code>NaN</code>，意为“不是数值”，用于表示数值运算操作失败了（<strong>而不是抛出错误</strong>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>/<span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span>/+<span class="number">0</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li><li><p>string</p><p>字符串使用双引号（”）、单引号（’）或反引号（&#96;）表示都可以。</p><p>在js中，字符串是<code>不可变</code>的，意思是一旦创建，它们的值就<strong>不能变了</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>;<span class="comment">//这行代码会在内存中创建一个包含 &quot;Java&quot; 的字符串对象，并将引用赋值给变量 lang。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从内存中读取 lang 当前所指向的字符串 &quot;Java&quot;。</span></span><br><span class="line"><span class="comment">//将 &quot;Java&quot; 和 &quot;Script&quot; 拼接成新的字符串 &quot;JavaScript&quot;，并在内存中创建一个新的字符串对象。</span></span><br><span class="line"><span class="comment">//将 lang 变量存储的引用更新为新创建的字符串 &quot;JavaScript&quot;的引用</span></span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lang)</span><br></pre></td></tr></table></figure></li><li><p>Boolean</p><p>Boolean（布尔值）类型有两个字面值： <code>true</code>和<code>false</code></p><p>通过<code>Boolean</code>可以将其他类型的数据转化成布尔值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型                    转换为 <span class="literal">true</span> 的值                    转换为 <span class="literal">false</span> 的值</span><br><span class="line"> <span class="title class_">String</span>                      非空字符串                              <span class="string">&quot;&quot;</span> </span><br><span class="line"> <span class="title class_">Number</span>                   非零数值（包括无穷值）                     <span class="number">0</span> 、 <span class="title class_">NaN</span> </span><br><span class="line"> <span class="title class_">Object</span>                      任意对象                               <span class="literal">null</span></span><br><span class="line"><span class="title class_">Undefined</span>                   N/A （不存在）                         <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>注意：在js中<code>负数</code>转化成布尔值也是<code>true</code></p></li><li><p>Symbol</p><p><code>Symbol</code>关键字的主要用途是用来创造一个<code>唯一</code>的标识符，用作对象属性，确保不会产生<code>属性冲突</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> otherGenericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(genericSymbol == otherGenericSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>传入符号主要为了标识，符号相同并不代表值也相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooSymbol == otherFooSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Symbol 类型的键，并且不会出现在<code>for...in</code> 循环中，也不会被<code>Object.keys()</code>方法返回，因为这种类型的键是<strong>不可枚举</strong>的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Symbol</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 Symbol 作为对象的键</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">normalKey</span>: <span class="string">&#x27;value for normal key&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[sym] = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="comment">// 遍历对象属性，Symbol 键不会出现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 输出: normalKey</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj));<span class="comment">//输出[&#x27;normalKey&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>Object.assign</code>会把Symbol 类型的键也拷贝进去：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Symbol</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 Symbol 作为对象的键</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">normalKey</span>: <span class="string">&#x27;value for normal key&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[sym] = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj2, obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2)<span class="comment">//&#123;normalKey: &#x27;value for normal key&#x27;, Symbol(description): &#x27;123&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>Symbol 类型的<strong>键和值</strong>，都不会包含在<code>序列化</code>的结果中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Symbol</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 Symbol 作为对象的键</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">normalKey</span>: sym</span><br><span class="line">&#125;;</span><br><span class="line">obj[sym] = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))<span class="comment">//&#123;&quot;name&quot;:&quot;tom&quot;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Null</p><p>Null类型同样只有一个值，即特殊值 <code>null</code></p><p>逻辑上讲， null 值表示一个空对象，这也是给<code>typeof</code>传一个 <code>null</code> 会返回 <code>&quot;object&quot;</code> 的原因。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> car); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>Undefined</p><p><code>Undefined</code> 类型只有一个值，就是特殊值 <code>undefined</code>，如果一个变量声明了但是未被赋值，那么这个变量的值就是undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 没有声明过这个变量，报错</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>引用数据类型统称为<code>Object</code></p><p>主要包括以下三种：</p><ul><li><p>Object</p><p>通常使用字面量表示法来创建对象，这样创建的对象是<code>Object</code>构造函数的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Array</p><p>js数组是一组<code>有序</code>的数据，但跟其他语言不同的是，数组中每个槽位可以存储<code>任意类型</code>的数据。并且，数组也是<code>动态大小</code>的，会随着数据添加而自动增长。通常通过<code>字面量表示法</code>创建数组。</p><p>给数组分配一个固定大小，就是分配几个连续的空间，内部元素默认值是<code>undefined</code>；可以调用数组的<code>fill</code>方法修改初始值，比如<code>arr.fill(0)</code>；虽然说数组大小是<code>固定的</code>，但是还是可以往数组中加入元素，改变数组的大小，不过新加入的元素放在<code>已分配空间之后</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="number">2</span>, &#123;<span class="attr">age</span>: <span class="number">20</span> &#125;]</span><br><span class="line">colors.<span class="title function_">push</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>或者通过<code>Array</code>来创建数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>)<span class="comment">//创建一个长度为4的数组，虽然创建的时候指定了长度，但是长度还是可以变化的</span></span><br><span class="line">arr.<span class="title function_">fill</span>(<span class="number">0</span>) <span class="comment">//数组中的每个元素初始值为undefined,我们把它初始化为1</span></span><br><span class="line">arr.<span class="title function_">map</span>(<span class="function"><span class="params">i</span>=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>).<span class="title function_">fill</span>(<span class="number">0</span>))<span class="comment">//把数组中的每个元素替换为数组，实现二维数组的创建。</span></span><br></pre></td></tr></table></figure></li><li><p>Function</p><p>函数实际上是<code>对象</code>，每个函数都是 <code>Function</code>类型的实例，而 <code>Function</code>也有属性和方法，跟其他引用类型一样。</p></li><li><p>其他类型</p><p>除了上述说的三种之外，还包括<code>Date</code>、<code>RegExp</code>、<code>Map</code>、<code>Set</code>等，他们都是<code>Object</code>类型的<code>子类</code>。</p></li></ul><h2 id="typeof和instanceof"><a href="#typeof和instanceof" class="headerlink" title="typeof和instanceof"></a>typeof和instanceof</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 操作符返回一个字符串，表示值的数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> operand</span><br><span class="line"><span class="title function_">typeof</span>(operand)</span><br></pre></td></tr></table></figure><p>这两种使用方法都是可以的。下面是一些例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="property">log</span> <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>主要用来判断某个<code>构造函数</code>是否在某个<code>实例对象</code>的原型链上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> constructor</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><p>typeof返回的是<code>字符串</code>，instanceof返回的是<code>布尔值</code></p></li><li><p>typeof只能能准确判断<code>基本数据</code>的类型，不能<code>准确</code>判断<code>引用数据</code>的类型。</p></li><li><p>intanceof只能准确判断<code>引用数据</code>的类型，不能判断<code>基本数据</code>的类型</p></li></ul><p>可以看到，上述两种方法都有弊端，并不能满足所有场景的需求。</p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h3><p>还有一种通用的判断方式<code>Object.prototype.toString()</code>，简单来说就是<code>Object</code>原型对象上挂载的<code>toString</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>(&#123;&#125;)       <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)  <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>)    <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>)  <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)  <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)  <span class="comment">// &quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到返回的结果是一个字符串，第一位都是<code>object</code>，这与js中<strong>万物皆对象</strong>的思想符合。所有类型的数据都能调用<code>toString()</code>方法，如果是基本数据类型，会先进行数据<code>装箱</code>，转化成<code>对象</code>，再调用这个方法。Object是所有对象的父类（Object在所有对象的原型链上），所以所有对象都能访问到这个方法，那为什么不直接让数据调用这个方法呢？因为对象的原型链上可能还存在<code>同名方法</code>。使用<code>函数.call(对象)</code>的方式，能确保对象调用的就是指定的函数&#x2F;方法。</p><h2 id="谈谈-JavaScript-中的类型转换机制"><a href="#谈谈-JavaScript-中的类型转换机制" class="headerlink" title="谈谈 JavaScript 中的类型转换机制"></a>谈谈 JavaScript 中的类型转换机制</h2><p>前面我们讲到，<code>JS</code>中有六种简单数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>symbol</code>，以及引用类型：<code>object</code></p><p>常见的类型转换有：</p><ul><li>强制转换（显示转换）</li><li>自动转换（隐式转换）</li></ul><h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p>显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：</p><ul><li>Number()</li><li>parseInt()</li><li>String()</li><li>Boolean()</li></ul><h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><p>将任意类型的值转化为<code>数值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"><span class="comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324&#x27;</span>) <span class="comment">// 324</span></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 空字符串转为0，空数组也转换成0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">//对象：通常转换成NaN,除了只包含单个数值的数组和空数组</span></span><br><span class="line"><span class="title class_">Number</span>(&#123;&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">5</span>]) <span class="comment">// 5</span></span><br><span class="line"><span class="title class_">Number</span>([]) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>从上面可以看到，<code>Number</code>转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code></p><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p><code>parseInt</code>相比<code>Number</code>，就没那么严格了，<code>parseInt</code>函数逐个解析字符，遇到不能转换的字符就停下来。这个方法是可以直接被调用的，不许要显式借助其他对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;32a3&#x27;</span>) <span class="comment">//32</span></span><br></pre></td></tr></table></figure><h4 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h4><p>可以将任意类型的值转化成<code>字符串</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值：转为相应的字符串</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">1</span>) <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="comment">//字符串：转换后还是原来的值</span></span><br><span class="line"><span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">//布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="comment">//undefined：转为字符串&quot;undefined&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="comment">//null：转为字符串&quot;null&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>) <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="title class_">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，对于<code>基本数据类型</code>，强制转化成字符串，就是加个<code>双引号</code>就好了，而引用数据类型就不一样了，需要调用<code>toString</code>方法</p><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h4><p>可以将任意类型的值转为<code>布尔值</code>，转换规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="title class_">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// 因为返回的是一个对象Boolean &#123;false&#125;，所以转化成布尔值是true</span></span><br></pre></td></tr></table></figure><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>在隐式转换中，我们可能最大的疑惑是 ：何时发生<code>隐式转换</code>？</p><p>我们这里可以归纳为两种情况发生隐式转换的场景：</p><ul><li>比较运算（<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>）</li><li>算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）</li><li><code>if</code>、<code>while</code>需要布尔值地方</li></ul><p>除了上面的场景，还要求运算符两边的操作数不是同一类型</p><ul><li><p><strong>自动转化成布尔值</strong></p><p>在需要<code>布尔值</code>的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用<code>Boolean</code>函数</p></li><li><p><strong>自动转换成字符串</strong></p><p>遇到预期为<code>字符串</code>的地方，就会将非字符串的值自动转为字符串</p><p>常发生在<code>+</code>运算中，一旦存在字符串，则会进行字符串拼接操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="number">1</span> <span class="comment">// &#x27;51&#x27;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">true</span> <span class="comment">// &quot;5true&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">false</span> <span class="comment">// &quot;5false&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + &#123;&#125; <span class="comment">// &quot;5[object Object]&quot; </span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + [] <span class="comment">// &quot;5&quot; 因为[]转换成字符串是空串</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125; <span class="comment">// &quot;5function ()&#123;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">undefined</span> <span class="comment">// &quot;5undefined&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">null</span> <span class="comment">// &quot;5null&quot;</span></span><br></pre></td></tr></table></figure><p>对于基本数据类型和函数，字符串拼接的时候直接参与拼接，对于其他引用数据类型，需要先调用<code>toString</code>方法。</p></li><li><p><strong>自动转换成数值</strong></p><p>除了左右两边包含字符串的<code>+</code>号，<code>其他运算符</code>都会把参与运算的数据自动转成<code>数值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;2&#x27;</span> <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * <span class="string">&#x27;2&#x27;</span> <span class="comment">// 10</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> - <span class="number">1</span>   <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * []    <span class="comment">// 等价于5*0</span></span><br><span class="line"><span class="literal">false</span> / <span class="string">&#x27;5&#x27;</span> <span class="comment">// 等价于0/5</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> - <span class="number">1</span>   <span class="comment">// 等价于NaN-1</span></span><br><span class="line"><span class="literal">null</span> + <span class="number">1</span> <span class="comment">// 等价于0+1</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// 等价于NaN+1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别"></a><strong>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</strong></h2><p>一个是<code>宽松比较</code>，一个是<code>严格比较</code>；<code>==</code>比较<code>值</code>是否相等，不比较<code>类型</code>是否相同，允许隐式转换。<code>===</code>比较的是<code>值</code>和<code>类型</code>是否相同，都相同才会返回true。</p><p>难点在于<code>==</code>非严格比较，比较规则如下</p><ul><li><p>undefined &#x3D;&#x3D; null 返回true</p><p>在非严格比较中，<code>undefined</code>和<code>null</code>，只与<code>undefined</code>或者<code>null</code>相等。</p></li><li><p>NaN &#x3D;&#x3D; NaN 返回false</p><p><code>NaN</code>和任何数比较，包括本身，都返回false。</p></li><li><p>两个都为<code>简单类型</code>，<strong>字符串</strong>和<strong>布尔值</strong>都会转换成<strong>数值</strong>，再比较。</p></li><li><p>如果一个操作数是<code>对象</code>，另一个操作数不是，则调用对象的 <code>valueOf()</code>方法取得其<strong>原始值</strong>，再根据前面的规则进行比较。</p></li><li><p>两个都为引用类型，则比较它们是否指向同一个对象，也就是比较<strong>地址</strong>是否相同。</p></li></ul><h2 id="Javascript-数字精度丢失的问题"><a href="#Javascript-数字精度丢失的问题" class="headerlink" title="Javascript 数字精度丢失的问题"></a>Javascript 数字精度丢失的问题</h2><h3 id="为什么会出现精度丢失"><a href="#为什么会出现精度丢失" class="headerlink" title="为什么会出现精度丢失"></a>为什么会出现精度丢失</h3><p>对于某些小数，计算机无法用<strong>有限的二进制位精确的表示</strong>，比如0.1用二进制表示思路如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span>*<span class="number">2</span>=<span class="number">0.2</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.2</span>*<span class="number">2</span>=<span class="number">0</span>*<span class="number">4</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.4</span>*<span class="number">2</span>=<span class="number">0.8</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.8</span>*<span class="number">2</span>=<span class="number">1.6</span>&gt;<span class="number">1</span>  --<span class="number">1</span></span><br></pre></td></tr></table></figure><p>假设<code>0.1</code>的二进制表示是<code>0.xxxx</code>，每次对<code>0.1×2</code>，都会让二进制表示中的小数点<code>右移</code>一位(就像我们给十进制小数<code>×10</code>会让小数点右移一样，每个数的权值都变大了)，即<code>x.xxxx</code>，如果<code>0.1×2&lt;1</code>，说明<strong>第一个x为0</strong>，依此类推，<code>0.1</code>的二进制表示为<code>0.0001xxxx</code>，然后我们继续计算后续的x的值。<code>0.1×16 = 1.6</code>,对应的二进制表示为<code>1.xxxx</code>，显然<code>0.xxxx</code>应该表示的是<code>0.6</code>，所以我们就把问题转化为求<code>0.6</code>的二进制表示了。简单的来说，我们只需要对小数不断的<code>×2</code>，如果结果<code>小于1</code>，填入<code>0</code>，反之填入<code>1</code>，然后对乘法的结果<code>-1</code>，然后继续计算，填入的位置是从小数点的高位到地位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.6</span>*<span class="number">2</span>=<span class="number">1.2</span>&gt;<span class="number">1</span>  --<span class="number">1</span></span><br><span class="line"><span class="number">0.2</span>*<span class="number">2</span>=<span class="number">0.4</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.4</span>*<span class="number">2</span>=<span class="number">0.8</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.8</span>*<span class="number">2</span>=<span class="number">1.6</span>&gt;<span class="number">1</span>  --<span class="number">1</span></span><br><span class="line"><span class="number">0.6</span>*<span class="number">2</span>=<span class="number">1.2</span>&gt;<span class="number">1</span>  --<span class="number">1</span></span><br></pre></td></tr></table></figure><p>因此我们可以得出<code>0.1</code>的二进制表示是<code>0.000110011....</code>很明显这是一个<code>无限循环小数</code>，我们<strong>无法用有限的二进制位来精确的存储</strong>这个小数，因为存储的时候，数据就没有被准确的存储，所以下次再取出使用的时候就会有<strong>精度损失</strong>。</p><p>在<code>JavaScript</code>中，现在主流的数值类型是<code>Number</code>，而<code>Number</code>采用的是<code>IEEE754</code>规范中<strong>64位双精度浮点数编码</strong>。</p><p>如何理解这个<code>双</code>字呢，这个<code>双</code>表示使用2个<code>机器字</code>（word）来表示浮点数，通常现代计算机的一个<code>机器字</code>是 32 位，双精度意思就是用<code>64位</code>来表示浮点数。这样的存储结构优点是可以<strong>统一处理整数和小数</strong>，节省存储空间。</p><p>我们先来看看如何将一个浮点数用<code>IEEE754单精度浮点数编码</code>表示，单精度浮点数编码用<code>32位</code>来表示浮点数，第一位是符号位，0表示正数，1表示负数；后8位表示指数位，后23位表示尾数。</p><p>拿<code>0.75</code>这个浮点数举例子，将它转换成二进制是<code>0.11</code>，然后将二进制转换成<code>1.xxx*2^n</code>的形式，就是<code>1.1*2^-1</code>，由于这个数是正数，所以第一位是0，<strong>指数位</strong>是<code>-1</code>，我们将它与127（二进制表示是8个1<code>11111111</code>）相加得到126（<code>11111110</code>），我们把这个操作叫做<strong>偏移</strong>，然后尾数是1，这样我们就可以得到<code>单精度浮点数编码</code>表示：0111111101，然后要凑齐32位，后面补零就好。</p><p>对于双精度浮点数编码，道理其实也是一样的，不同的是，使用1位表示<code>符号位</code>，11位表示<code>指数位</code>，52位表示<code>尾数</code> 。</p><p>具体如何处理可以自行搜索或者参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://vue3js.cn/interview/JavaScript/loss_accuracy.html#%E4%B8%80%E3%80%81%E5%9C%BA%E6%99%AF%E5%A4%8D%E7%8E%B0">面试官：说说 Javascript 数字精度丢失的问题，如何解决？ | web前端面试 - 面试官系列</a></p><h3 id="如何解决精度缺失问题"><a href="#如何解决精度缺失问题" class="headerlink" title="如何解决精度缺失问题"></a>如何解决精度缺失问题</h3><ul><li><p>先把<code>小数</code>转换成<code>整数</code>再参与运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0.2</span></span><br><span class="line"><span class="keyword">let</span> c = a + b</span><br><span class="line"><span class="keyword">let</span> d = (a * <span class="number">10</span> + b * <span class="number">10</span>) / <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c == <span class="number">0.3</span>, d == <span class="number">0.3</span>)<span class="comment">//输出false true</span></span><br></pre></td></tr></table></figure></li><li><p>借助第三方工具库，比如<code>Math.js</code>、<code>BigDecimal.js</code>，通过<code>调用相关方法</code>来模拟加减乘除运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;mathjs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> a = math.<span class="title function_">bignumber</span>(<span class="string">&#x27;0.1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b = math.<span class="title function_">bignumber</span>(<span class="string">&#x27;0.2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> result = math.<span class="title function_">add</span>(a, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">format</span>(result, &#123;<span class="attr">notation</span>: <span class="string">&#x27;fixed&#x27;</span>&#125;)); <span class="comment">// 输出 &quot;0.3&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/bigdecimal.js/0.6.2/bigdecimal.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">bigDecimal</span>(<span class="string">&#x27;0.1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">bigDecimal</span>(<span class="string">&#x27;0.2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> result = a.<span class="title function_">add</span>(b);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="title function_">toString</span>()); <span class="comment">// 输出 &quot;0.3&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="说说-JavaScript-中内存泄漏的几种情况"><a href="#说说-JavaScript-中内存泄漏的几种情况" class="headerlink" title="说说 JavaScript 中内存泄漏的几种情况"></a>说说 JavaScript 中内存泄漏的几种情况</h2><h3 id="内存泄漏是什么"><a href="#内存泄漏是什么" class="headerlink" title="内存泄漏是什么"></a>内存泄漏是什么</h3><p>内存泄漏（Memory leak）指的是在计算机科学中，由于疏忽或错误造成程序<strong>未能释放已经不再使用的内存</strong>。</p><p>对于<code>持续运行的进程</code>，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><p>可以拿电脑游戏来举例，3a大作的体积动辄几十上百GB，但是我们的电脑并没有这么多的内存（外存一般都有几百GB，但是内存一般只有几十GB），我们玩游戏的时候，并不会将游戏的全部资源都放入内存中，而是只将需要用到的资源放入，并释放不再需要的内存。</p><h3 id="垃圾自动回收机制"><a href="#垃圾自动回收机制" class="headerlink" title="垃圾自动回收机制"></a><strong>垃圾自动回收机制</strong></h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>在<code>C</code>语言中，因为是手动管理内存，内存泄露是经常出现的事情。</p><p>这很麻烦，所以大多数语言提供<code>自动内存管理</code>，减轻程序员的负担，这被称为<code>垃圾自动回收机制</code></p><p>js也有垃圾自动回收机制。</p><p><strong>原理</strong>：<code>垃圾收集器</code>会定期（周期性）找出那些不再继续使用的变量，然后释放其内存。</p><h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p>通常情况下有两种实现方式，用来判断哪些变量不再使用：</p><ul><li>标记清除</li><li>引用计数</li></ul><p><strong>标记清除</strong></p><p><code>清除</code>那些被<code>标记</code>的变量，释放它们的内存，是<code>JavaScript</code>最常用的垃圾收回机制，</p><p>当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“</p><p>垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉</p><p>在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了</p><p>随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">0</span>,n = <span class="number">19</span> <span class="comment">// 把 m,n,add() 标记为进入环境。</span></span><br><span class="line"><span class="title function_">add</span>(m, n) <span class="comment">// 把 a, b, c标记为进入环境。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">// a,b,c标记为离开环境，等待垃圾回收。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  a++</span><br><span class="line">  <span class="keyword">var</span> c = a + b</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用计数</strong></p><p>语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是<code>0</code>，就表示这个值不再用到了，因此可以将这块内存释放。</p><p>如果一个值不再需要了，引用数却不为<code>0</code>，垃圾回收机制无法释放这块内存，从而导致内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>[1, 2, 3, 4]</code>是一个值，会占用内存。变量<code>arr</code>是仅有的对这个值的引用，因此引用次数为<code>1</code>。尽管后面的代码没有用到<code>arr</code>，它还是会持续占用内存</p><p>如果需要这块内存被垃圾回收机制释放，只需要设置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>通过设置<code>arr</code>为<code>null</code>，就解除了对数组<code>[1,2,3,4]</code>的引用，引用次数变为 0，就被垃圾回收了。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>有了垃圾自动回收机制，并不代表不用担心内存泄漏问题，对于那些占用内存很大的变量，确保它们不再被使用的时候，不存在对它们的引用。</p><h3 id="常见内存泄漏情况"><a href="#常见内存泄漏情况" class="headerlink" title="常见内存泄漏情况"></a>常见内存泄漏情况</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a><strong>意外的全局变量</strong></h4><ul><li><p><strong>给一个未声明的标识符赋值</strong>，javaScript 引擎会认为你在引用一个已经存在的全局变量；如果找不到这个变量，则会自动在全局对象（浏览器环境中为 <code>window</code>，Node.js 环境中为 <code>global</code>）上创建它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>直接调用构造函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">variable</span> = <span class="string">&quot;potential accidental global&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 调用自己，this 指向了全局对象（window）</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>使用严格模式，可以避免意外的全局变量。</p></li></ul><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h4><p>定时器开启后，除非显式的清除，否则将一直存在，如果定时器中引用了不再使用的变量，又未及时清除定时器，就会造成内存泄漏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = <span class="title function_">getData</span>();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;Node&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">        node.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>如果<code>id</code>为Node的元素从<code>DOM</code>中移除，该定时器仍会存在，同时，因为回调函数中包含对<code>someResource</code>的引用，定时器外面的<code>someResource</code>也不会被释放。</p><p>除了定时器之外，延时器(setTimeout)和事件监听器(addEventListener)如果不使用，都要记得清除或者解绑，否则会持续引用不再需要的回调函数，从而造成内存泄漏，因为函数也是一种类型的数据，也会占用内存。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;XXX&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj, <span class="string">&#x27;闭包内引用obj obj不会被释放&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> unused</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> func = <span class="title function_">bindEvent</span>()</span><br><span class="line"><span class="comment">//解决方法，清除引用</span></span><br><span class="line">func = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>即便函数调用结束了，由于func持续引用unused函数，这个函数的空间不会被释放，又因为unused函数引用obj，obj这个变量的空间也不会被释放。</p><h2 id="说说你对闭包的理解？闭包使用场景"><a href="#说说你对闭包的理解？闭包使用场景" class="headerlink" title="说说你对闭包的理解？闭包使用场景"></a>说说你对闭包的理解？闭包使用场景</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>闭包由一个<code>内部函数</code>和它引用的<code>外部函数</code>的作用域组成。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>创建私有变量</li><li>延长变量的生命周期</li></ul><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//立即执行函数，充当外部函数</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let a = 1;</span><br><span class="line">  function b()&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;//因为没有外部函数，所以没有构成闭包</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="说说你对防抖和节流的理解"><a href="#说说你对防抖和节流的理解" class="headerlink" title="说说你对防抖和节流的理解"></a>说说你对防抖和节流的理解</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>本质上是<code>优化高频率执行代码造成的性能损耗</code>的一种手段。</p><p>如：浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。</p><p>为了优化体验，我们需要限制这类事件的调用次数，对此我们就可以采用 <strong>防抖（debounce）</strong> 和 <strong>节流（throttle）</strong> 的方式来减少调用频率</p><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>定义</strong></p><p>事件被触发后，且在n秒内不再触发该事件，则执行对应的回调函数，如果在n秒内再次触发该事件，则重新开始计时；可以用操作系统中的资源被剥夺来理解，这里的资源就是<code>延时器</code>。</p><p>简单的来说，就是对于频繁触发的事件，只执行最后一次触发对应的事件回调。</p><p><strong>手写防抖函数</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个函数，返回一个实现了防抖的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myDebounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//形成了一个闭包，内部函数引用了外部函数的变量timer,func,wait</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">         <span class="comment">//抢夺资源,清除定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//开启新的定时器</span></span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//修改this指向，传入e</span></span><br><span class="line">        func.<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">        timer = <span class="literal">null</span><span class="comment">//运行完后释放资源</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[type=text]&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="title function_">myDebounce</span>(func, <span class="number">500</span>))</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>定义</strong></p><p>在n秒内无论触发多少次事件，只执行<code>第一次触</code>发对应的<code>回调函数</code></p><p>可以用操作系统中的<code>资源不可被剥夺来理解</code>，这里的资源就是<code>延时器</code>。</p><p>简单的来说就是，对于频繁触发的事件，每间隔一定时间才执行一次事件回调。</p><p><strong>手写节流</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="title function_">myThrottle</span>(func, <span class="number">1000</span>))</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入一个函数，返回一个实现了节流的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myThrottle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="comment">//声明一个定时器</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//返回一个新的函数,这个函数引用了func,wait和timer，构成闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="comment">//如果定时器已经开启直接返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//虽然实际调用的是返回的新函数，但是在函数内部还是调用了传入的func函数，而且我们使用apply模拟了直接调用</span></span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        timer = <span class="literal">null</span><span class="comment">//释放资源</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p>相同点：</p><ul><li>都可以通过使用 <code>setTimeout</code> 实现</li><li>目的都是，降低回调执行频率。节省计算资源</li></ul><p>不同点：</p><ul><li>函数防抖，在一段连续操作结束后，只执行最后一次触发对应的回调。函数节流，在一段连续操作中，每一段时间只执行一次，在频率较高的事件中被使用来提高性能。</li><li>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>防抖在连续的事件，只需触发一次回调的场景有：</p><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li></ul><p>节流在间隔一段时间执行一次回调的场景有：</p><ul><li>滚动加载，加载更多或滚到底部监听</li><li>搜索框，搜索联想功能</li></ul><h2 id="数组的常用方法"><a href="#数组的常用方法" class="headerlink" title="数组的常用方法"></a>数组的常用方法</h2><p>我们可以从<strong>增删查改</strong>，是否会修改原数组这几个角度来给数组的常用方法归类</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a><strong>增</strong></h3><ul><li><p>push()：可以传入任意个数的元素，这些元素会被添加到数组的末尾，返回<code>新数组的长度</code>,会修改原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = []; <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 推入两项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>unshift():也是可以传入任意个数的元素，这些元素会被添加到数组的首部，返回<code>新数组的长度</code>,会修改原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 从数组开头推入两项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>splice():第一个参数传入开始位置，第二个参数传入0，表示不删除元素，后续参数传入插入的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors) <span class="comment">// red,yellow,orange,green,blue(插入的元素从开始下标开始排序)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed) <span class="comment">// []，返回包含被删除元素的数组，因为没有元素被删除所以是空数组</span></span><br></pre></td></tr></table></figure></li><li><p>concat():首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="删"><a href="#删" class="headerlink" title="删"></a><strong>删</strong></h3><ul><li><p>pop()：方法用于删除数组的最后一项，同时减少数组的<code>length</code> 值，返回<code>被删除的项</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>(); <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// green</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>shift()：法用于删除数组的第一项，同时减少数组的<code>length</code> 值，返回<code>被删除的项</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">shift</span>(); <span class="comment">// 取得第一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// red</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>splice()：第一个参数传入开始位置，第二个参数传入要删除元素的个数，返回包含被删除元素的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// green,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed); <span class="comment">// [&quot;red&quot;]，只有一个元素的数组</span></span><br></pre></td></tr></table></figure></li><li><p>slice()：本质是返回一个数组切片，并不会修改原数组，截取区间遵循<code>左闭右开</code>原则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors)   <span class="comment">// red,green,blue,yellow,purple</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// green,blue,yellow,purple</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors3); <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>一般通过下标修改数组元素的值，也可以使用splice先删除元素再添加元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;purple&quot;</span>); <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// red,red,purple,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed); <span class="comment">// green，只有一个元素的数组</span></span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>一般也是通过下标来查找数组元素。</p><ul><li><p>indexOf()：传入一个元素，返回数组中<code>第一个</code>与该元素相等的元素的<code>下标</code>，使用的是<code>严格比较</code>，如果数组中没有该元素，则返回<code>-1</code>，因为<code>NaN</code>不与任何数相等，所以indexOf(NaN)返回值必定为<code>-1</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>,<span class="title class_">NaN</span>];</span><br><span class="line">numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>)) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></li><li><p>includes()：判断某个元素是否在数组中存在，也是严格比较，存在返回<code>true</code>，否则返回<code>false</code>。对<code>NaN</code>做了特殊处理，能判断是它否存在于数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>,<span class="title class_">NaN</span>];</span><br><span class="line">numbers.<span class="title function_">includes</span>(<span class="number">4</span>) <span class="comment">//true</span></span><br><span class="line">numbers.<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">//返回true</span></span><br></pre></td></tr></table></figure></li><li><p>find()：传入一个返回值是 <code>布尔类型</code>的回调函数，用于判断满足某个条件的元素是否存在，存在则返回第一个符合条件的元素，不存在则返回<code>undefined</code>，通常用于判断<code>对象数组</code>中是否存在某个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">27</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>)<span class="comment">// &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>findIndex()：语法和用途和find相同，不过返回的是元素的<code>下标</code>，未找到返回<code>-1</code>。</li></ul><h3 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h3><ul><li><p>reverse()：反转数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure></li><li><p>sort()：给数组排序，sort()方法接受一个比较函数，用于判断哪个值应该排在前面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line">    <span class="comment">//return value1-value2 升序排序</span></span><br><span class="line">    <span class="comment">//return value2-value1 降序排序</span></span><br><span class="line">    <span class="comment">//value1[key]-value2[key] 根据某个属性升序排序，反之降序排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>(compare);</span><br><span class="line"><span class="title function_">alert</span>(values); </span><br></pre></td></tr></table></figure></li></ul><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>join()：把数组中的元素拼<code>接成</code>一个字符串，用传入的符号连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>)); <span class="comment">// red,green,blue</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;||&quot;</span>)); <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><ul><li><p>some()：传入一个返回值为布尔值的回调函数，如果数组中<code>存在</code>满足条件的元素，则该方法返回true，否则返回false。</p></li><li><p>every()：传入一个返回值为布尔值的回调函数，如果数组中<code>每个</code>元素都满足条件，则该方法返回true，否则返回false。</p></li><li><p>forEach()：遍历数组中的每个元素，并执行一定操作，可以<code>修改</code>原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>filter()：传入一个返回值为布尔值的回调函数，返回一个包含所有能让这个回调函数返回值为true的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filterResult); <span class="comment">// 3,4,5,4,3</span></span><br></pre></td></tr></table></figure></li><li><p>map()：根据传入的回调函数和数组中的每一个元素，并返回一个新的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapResult) <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h2><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a><strong>concat</strong></h4><p>用于将一个或多个字符串拼接成一个新字符串，返回一个新的字符串，不会修改原来的字符串，js中的字符串是不可变的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">&quot;world&quot;</span>);<span class="comment">//创建一个新的字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h4 id="slice-substr-substring"><a href="#slice-substr-substring" class="headerlink" title="slice() substr() substring()"></a><strong>slice() substr() substring()</strong></h4><p>作用是返回字符串的切片</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo worl&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>数组中也有<code>slice()</code>方法</p></li><li><p>可以看出<code>slice()</code>和<code>substring()</code>的用法是一致的，当传入两个参数的时候，分别表示的是截取的左右区间（左闭右开）</p></li><li><p>而<code>substr()</code>传入两个参数时，第一个表示参数起始位置，第二个参数表示的是要截取的元素的<code>个数</code>。</p></li><li><p>当只传入一个参数，三者的效果是相同的。</p></li></ul><h4 id="indexOf-startWith-includes"><a href="#indexOf-startWith-includes" class="headerlink" title="indexOf() startWith() includes()"></a><strong>indexOf() startWith() includes()</strong></h4><p>indexOf：从字符串<code>开头</code>去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ），数组中也有这个方法，也许因为字符串本来就可以看成字符数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>startWith()：判断字符串是否以某个字符串开头，返回值为布尔类型。</p><p>includes()：判断字符串中是否包含某个字符串，返回值是布尔类型，数组中也有这个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>由此可见，无论是数组还是字符串中，都有indexOf，includes，slice方法</p></blockquote><h3 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h3><p>把字符串按照指定的分割符，拆分成数组中的每一项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;12+23+34&quot;</span></span><br><span class="line"><span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&quot;+&quot;</span>) <span class="comment">// [12,23,34]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>) <span class="comment">//[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;+&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;+&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h3><p>提及字符串，就不得不提到模板匹配，提起模板匹配就不得不提起<code>正则表达式</code>。</p><h4 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h4><p>接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象（正则表达式），如果你传递一个非正则表达式对象，它会被隐式转换为正则表达式；返回值是数组</p><p><strong>非全局匹配</strong>（传入的正则表达未加修饰符<code>g</code>）</p><p>只会匹配第一个符合条件的字符串片段，下面给出一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches); </span><br></pre></td></tr></table></figure><p><strong>匹配成功的返回结果，包含<code>第一个匹配的字符串片段</code>和<code>更多信息</code></strong></p><img src="..\images\前端面试-js\match.png" style="zoom:80%"><ul><li><code>index</code> 属性：匹配结果在字符串中的开始位置</li><li><code>input</code> 属性：原始字符串</li></ul><p>如果匹配失败则返回<code>null</code></p><p><strong>全局匹配</strong></p><p>匹配所有符合条件的字符串片段，并以数组的形式给出，例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches); </span><br></pre></td></tr></table></figure><p><strong>匹配成功的返回结果，只包含<code>符合条件的字符串片段</code>。</strong></p><img src="..\images\前端面试-js\match2.png" style="zoom:80%"><p>如果匹配失败则返回<code>null</code></p><h4 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">search</span>(regexp)</span><br></pre></td></tr></table></figure><ul><li><code>str</code> 是要进行搜索操作的字符串。</li><li><code>regexp</code> 是一个正则表达式对象。如果你传递一个非正则表达式对象（例如，一个字符串），它将被隐式转换为一个正则表达式对象。</li><li><strong>如果找到匹配项，<code>search()</code> 方法返回<code>第一个匹配项</code>的<code>首字符</code>的下标。</strong></li><li>如果没有找到匹配项，<code>search()</code> 方法返回 <code>-1</code>。</li><li>是否给传入的正则表达式添加修饰符<code>g</code>，对结果没有影响。</li></ul><p>下面举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cas, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">let</span> index = text.<span class="title function_">search</span>(pattern);</span><br><span class="line"><span class="keyword">let</span> index2 = text.<span class="title function_">search</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(index,index2); <span class="comment">//输出5,5</span></span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p><code>replace()</code> 方法用于在字符串中查找匹配的子字符串，并用新的子字符串替换它，这个方法不会改变原始字符串，因为JavaScript中的字符串是不可变的，它会返回一个新的字符串作为结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">replace</span>(regexp|substr, newSubstr|<span class="keyword">function</span>)</span><br></pre></td></tr></table></figure><ul><li><code>regexp</code> (正则表达式)：一个<code>RegExp</code>对象或者其字面量。标识要查找的子字符串。请注意全局搜索需要使用<code>g</code>标志。</li><li><code>substr</code> (字符串)：将被替换的子字符串。</li><li><code>newSubstr</code> (字符串)：新子字符串，用于替换匹配项的字符串。</li><li><code>function</code> (函数)：用于<code>创建新子字符串的函数</code>，该函数将被每一个匹配项调用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.<span class="title function_">replace</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: &quot;Hello JavaScript!&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello world! Welcome to the world of programming.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.<span class="title function_">replace</span>(<span class="regexp">/world/g</span>, <span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: &quot;Hello JavaScript! Welcome to the JavaScript of programming.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World! Welcome to the world of Programming.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.<span class="title function_">replace</span>(<span class="regexp">/world/gi</span>, <span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: &quot;Hello JavaScript! Welcome to the JavaScript of Programming.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;20 apples, 15 bananas, and 3 cherries&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.<span class="title function_">replace</span>(<span class="regexp">/\d+/g</span>, <span class="keyword">function</span>(<span class="params">number</span>) &#123;<span class="comment">// \d+ 是匹配一个或多个数字的正则表达式</span></span><br><span class="line">    <span class="keyword">return</span> number * <span class="number">2</span>; <span class="comment">// 将每个数字乘以2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: &quot;40 apples, 30 bananas, and 6 cherries&quot;</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝浅拷贝"><a href="#深拷贝浅拷贝" class="headerlink" title="深拷贝浅拷贝"></a>深拷贝浅拷贝</h2><p>当我们拷贝一个基本类型的数据，拷贝的就是它的<code>值</code>，此时没有深浅拷贝一说，只有当我们拷贝一个对象的时候，才有深浅拷贝的说法。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝顾名思义，就是浅层次的拷贝，只拷贝<code>一层</code>。当我们要拷贝一个对象的时候，对于这个对象的所有属性，如果属性的值是<code>基本数据类型</code>，那我们直接拷贝<code>值</code>，如果属性值为<code>引用数据类型</code>，则拷贝<code>地址</code>。示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">//只拷贝obj自身的属性</span></span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(prop))&#123;</span><br><span class="line">            newObj[prop] = obj[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出浅拷贝的手动实现也是非常简单的。</p><p><strong>浅拷贝常见方法</strong></p><ul><li><p><code>Object.assign</code></p><p>只会拷贝对象中<strong>可枚举的自有属性</strong>，不会拷贝其继承自原型链上的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">nature</span>: [<span class="string">&#x27;smart&#x27;</span>, <span class="string">&#x27;good&#x27;</span>],</span><br><span class="line">  <span class="attr">names</span>: &#123;</span><br><span class="line">    <span class="attr">name1</span>: <span class="string">&#x27;fx&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj[f] = <span class="string">&#x27;cindy&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(obj2, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj)<span class="comment">//&#123;age: 18, nature: Array(2), names: &#123;…&#125;, Symbol(): &#x27;cindy&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2 == newObj) <span class="comment">//返回true，说明返回的就是原对象（传入的第一个对象）</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用<code>扩展运算符</code>实现的拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fxArr = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> fxArrs = [...fxArr]</span><br><span class="line">fxArrs[<span class="number">1</span>] = <span class="string">&quot;love&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArr) <span class="comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArrs) <span class="comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>对一个对象进行深拷贝，拷贝多层。当我们要深拷贝一个对象的时候，对于这个对象的所有属性，如果属性的值是<code>基本数据类型</code>，那我们直接拷贝<code>值</code>，如果属性值为<code>引用数据类型</code>，则我们递归拷贝这个引用类型。特点是深拷贝得到的对象与原对象没有任何<strong>公共的内存空间</strong>。</p><p><strong>深拷贝常见方法</strong></p><ul><li><p>_.cloneDeep()</p><p>借助第三方库<code>lodash</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">f</span> === obj2.<span class="property">b</span>.<span class="property">f</span>);<span class="comment">// false,验证是深度拷贝</span></span><br></pre></td></tr></table></figure></li><li><p>手写简单深拷贝</p><p>核心在于把值为基本类型的属性当作<strong>递归出口</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是null或者不是object类型(基础数据类型)，则直接返回，这是一个递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理Array</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneArr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; obj.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            cloneArr[i] = <span class="title function_">deepClone</span>(obj[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理Object</span></span><br><span class="line">    <span class="keyword">let</span> cloneObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            cloneObj[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>JSON.stringify()</code></p><p>但是这种方式存在<strong>弊端</strong>，会忽略值为<code>undefined</code>，<code>symbol</code>，<code>函数</code>的属性，因为这些值都是<code>不可被序列化</code>的，不会出现在序列化的字符串中。除此之外，使用Symbol作为键的属性也不会包含在序列化的结果中，<strong>因为JSON标准不支持Symbol类型的键</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title class_">Symbol</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name1</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">name3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;,</span><br><span class="line">  <span class="attr">name4</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">  <span class="attr">name5</span>: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[name] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123;name5: &quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>浅拷贝和深拷贝都创建出一个新的对象，这个新的对象与原对象内容完全相同，浅拷贝新旧对象可能存在公共的空间，修改新对象属性可能会影响原对象，而深拷贝新旧对象则不存在公共的空间，修改数据不会相互影响。</p><h2 id="说说js中的事件模型"><a href="#说说js中的事件模型" class="headerlink" title="说说js中的事件模型"></a>说说js中的事件模型</h2><h3 id="事件与事件流"><a href="#事件与事件流" class="headerlink" title="事件与事件流"></a>事件与事件流</h3><p>事件就是用户与页面或者浏览器进行的<strong>交互操作</strong>；</p><p>事件流都会经历三个阶段：</p><ul><li>事件<code>捕获阶段</code>(capture phase)</li><li>处于<code>目标阶段</code>(target phase)</li><li>事件<code>冒泡阶段</code>(bubbling phase)</li></ul><p>当我们在某个元素上触发某个事件的时候（这个与我们直接交互的元素叫做<code>目标元素</code>）,然后事件流就会从顶级元素开始，通常是<code>DOM</code>元素，流向目标元素，这个向下流动的过程叫做<code>事件捕获</code>，再流回顶级元素，这个向上流动的过程叫做<code>事件冒泡</code>。事件监听通常是在冒泡阶段触发的。</p><h3 id="事件模型分类"><a href="#事件模型分类" class="headerlink" title="事件模型分类"></a>事件模型分类</h3><p>有三大类：<code>原始事件模型</code>，<code>标准事件模型</code>，ie事件模型（很少用了）</p><ul><li><p><strong>原始事件模型（DOM0级）</strong></p><p><strong>绑定方式</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;fun()&quot;</span>&gt; <span class="comment">//里面的js代码会被执行，所以不要写成函数名，而是可执行的js代码</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[type=button]&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = fun;<span class="comment">//相当于给dom元素添加属性，传入一个函数，注意不要写成onClick</span></span><br></pre></td></tr></table></figure><p>link标签也可以添加onload属性，link标签加载后再执行相关逻辑，比如修改media类型。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./txt.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;setTimeout(()=&gt;&#123;this.media=&#x27;all&#x27;&#125;,2000)&quot;</span>&gt;</span></span><br><span class="line">//this指向link标签，是linnk标签对应的dom对象</span><br></pre></td></tr></table></figure><p>link标签加载完毕后再参与渲染，这也会存在样式闪烁问题。</p><p><strong>解绑方式：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>绑定速度快</li><li>只支持冒泡触发，不支持捕获触发</li><li><code>同一个类型</code>的事件(比如click事件)只能绑定一次，<strong>后面绑定的会覆盖前面绑定的</strong>。</li></ul></li><li><p><strong>标准事件模型（DOM2级）</strong></p><p><strong>绑定方式：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.addEventListener(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure><p>参数如下：</p><ul><li><code>eventType</code>指定事件类型(不要加on)</li><li><code>handler</code>是事件处理函数</li><li><code>useCapture</code>是一个<code>boolean</code>用于指定是否在<code>捕获阶段</code>进行处理，默认值为<code>false</code>，与IE浏览器保持一致</li></ul><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;p&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&#x27;span&#x27;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &lt;/p &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onClickFn</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tagName = event.<span class="property">currentTarget</span>.<span class="property">tagName</span>;</span><br><span class="line">    <span class="keyword">var</span> phase = event.<span class="property">eventPhase</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(tagName, phase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">false</span>);</span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击后输出</span></span><br><span class="line">P <span class="number">3</span></span><br><span class="line"><span class="variable constant_">DIV</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>几个常见事件属性</strong></p><ul><li><code>event.currentTarget</code> ，当前事件流所在的元素，是一个<code>dom</code>对象。</li><li><code>event.eventPhase</code>，代表当前执行阶段的整数值。1为捕获阶段、2为事件对象触发阶段、3为冒泡阶段。</li><li><code>event.target</code>，代表目标元素，即触发事件的元素。</li><li><code>event.stopPropagation</code>，阻止事件冒泡。</li><li><code>event.stopImmediatePropagation()</code>，这个方法不仅做了<code>stopPropagation()</code>所做的所有事情——即阻止事件冒泡到父元素，而且还会<strong>完全停止同一个事件的所有后续处理</strong>。这意味着，在当前元素上为该事件类型注册的<strong>所有其它监听器都不会被调用</strong>。</li></ul><p><strong>解绑方式</strong>：</p><p>传入的回调函数必须是<code>具名函数</code>，<strong>内容相同的两个匿名函数不会被认为相等</strong>。</p><p>解绑事件监听器的作用是<strong>释放内存空间</strong>，否则事件监听器将会一直存在，持续引用对应的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.<span class="title function_">removeEventListener</span>(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure><p><strong>特性：</strong></p><ul><li><p>可以在一个<code>DOM</code>元素上绑定多个事件处理器，各自并不会冲突</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage1, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage2, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage3, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>如果在<code>目标元素</code>上绑定了多个对<code>同一事件</code>的监听，则<code>捕获触发</code>对应的事件回调会先于<code>冒泡触发</code>对应的事件回调被执行</p><p>如果是都是在<code>同一阶段触发</code>，比如都是冒泡触发，则按声明顺序执行回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是第一个添加的监听&#x27;</span>)</span><br><span class="line">&#125;,)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是第二个添加的监听&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>点击box，控制台输出的顺序是：</p><p><code>&#39;我是第二个添加的监听&#39;</code></p><p><code>&#39;我是第一个添加的监听&#39;</code></p></li></ul></li><li><p>IE事件模型（基本不用，现在再vscode中都无法使用）</p><p>IE事件模型只有2个过程，没有事件捕获阶段:</p><ul><li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。</li><li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li></ul><p><strong>绑定方式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.attachEvent(eventType, handler)</span><br></pre></td></tr></table></figure><p><strong>解绑方式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.<span class="title function_">detachEvent</span>(eventType, handler)</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">attachEvent</span>(‘onclick’, showMessage);</span><br><span class="line">btn.<span class="title function_">detachEvent</span>(‘onclick’, showMessage);</span><br></pre></td></tr></table></figure></li></ul><h2 id="资源加载事件"><a href="#资源加载事件" class="headerlink" title="资源加载事件"></a>资源加载事件</h2><p><strong>DOMContentLoaded</strong></p><p>这个是<code>Document</code>对象的事件，在DOM内容完全加载和解析完毕后触发，不等待样式表、图像等<code>外部资源</code>的加载。</p><p><strong>window的load事件</strong></p><p>则是在所有资源（包括图片、样式表等）都<strong>加载完毕</strong>后才触发，要注意的是，<code>load</code> 事件并<strong>不等待所有的异步请求完成</strong>，比如通过 JavaScript 发起的 AJAX 请求或 Fetch API 请求，甚至不等待动态加载的内容（如通过 JavaScript 动态插入的图片或其他资源）。</p><h2 id="讲讲事件代理"><a href="#讲讲事件代理" class="headerlink" title="讲讲事件代理"></a>讲讲事件代理</h2><p>事件代理也叫<code>事件委托</code>，当我们要监听某个元素某个事件的时候，我们可以选择不给这个元素添加事件监听，而是给这个元素的<code>父元素或者祖先元素</code>添加对该事件的监听。然后在<code>事件冒泡</code>阶段触发该事件监听对应的回调函数。<strong>我们可以说，事件委托是基于事件冒泡的</strong></p><p>当你给DOM元素绑定事件处理器时，JavaScript引擎必须保留对该函数的引用，以便在事件触发时可以调用它。这意味着只要事件处理器存在，其对应的函数就不会被垃圾回收机制回收，从而一直占用着内存。</p><p>如果事件处理器使用了闭包（例如，在定义事件处理器的函数内部访问外部变量），那么这些外部变量也不能被垃圾回收，因为闭包会持有对外部作用域的引用。这进一步增加了内存占用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">textContent</span>);</span><br><span class="line">&#125;);<span class="comment">//比如这个事件监听器中的回调函数就会一直被引用</span></span><br></pre></td></tr></table></figure><p>事件代理的优点：</p><ul><li><p>不必为每个<code>目标元素</code>绑定事件监听，<strong>减少了页面所需内存</strong>。</p></li><li><p>自动绑定，解绑事件监听，减少了重复的工作。</p></li></ul><p>事件代理的局限性:</p><ul><li><code>focus</code>、<code>blur</code>这些事件<code>[输入框的事件]</code><strong>没有事件冒泡机制</strong>，所以无法进行委托绑定事件。</li><li><code>mousemove</code>、<code>mouseout</code>这样的事件，虽然有事件冒泡，但触发频率很高，而且只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的</li></ul><h2 id="在script标签中添加async和defer有什么作用和区别"><a href="#在script标签中添加async和defer有什么作用和区别" class="headerlink" title="在script标签中添加async和defer有什么作用和区别"></a>在script标签中添加async和defer有什么作用和区别</h2><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async 属性用于告诉浏览器脚本是异步的，可以并行下载，而不会阻塞页面的解析，即异步下载，不阻塞页面解析。</p><p>脚本下载完成后<code>立即执行</code>，不保证脚本的执行顺序，如果页面未加载完成，<code>可能阻塞页面加载</code>。</p><p>适用于独立的脚本，如第三方分析脚本，这些脚本不需要等待其他脚本执行完毕。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>defer 属性用于告诉浏览器脚本应该<code>延迟</code>到整个页面解析完成后执行，也是异步下载，不阻塞页面解析，所有脚本在页面解析完成，即DOM树构建完毕，后按引入顺序执行。适用于依赖于 DOM 的脚本，如需要操作 DOM 的脚本，这些脚本需要确保 DOM 已经完全加载。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>都能让浏览器<strong>异步下载脚本</strong>；async类型的脚本在下载完后<strong>立即执行</strong>，可能会阻塞页面渲染；defer类型的脚本下载完后会等到页面解析完成后，即 DOM 树构建完毕后，再按顺序执行。</p><h2 id="说说你对事件循环的理解"><a href="#说说你对事件循环的理解" class="headerlink" title="说说你对事件循环的理解"></a>说说你对事件循环的理解</h2><h3 id="同步与异步任务"><a href="#同步与异步任务" class="headerlink" title="同步与异步任务"></a>同步与异步任务</h3><p>首先，<code>JavaScript</code>是一门<strong>单线程的语言</strong>，意味着同一时间内只能做一件事，这样就存在<strong>线程阻塞</strong>的问题，而解决阻塞的方法就是将任务划分为<code>同步任务</code>和<code>异步任务</code></p><ul><li>同步任务：立即执行的任务，同步任务一般会直接进入到<code>主线程</code>中执行</li><li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等，交给<code>宿主环境</code>去执行，时机成熟后放入<code>任务队列</code>中</li></ul><h3 id="微任务与宏任务"><a href="#微任务与宏任务" class="headerlink" title="微任务与宏任务"></a>微任务与宏任务</h3><p><code>异步任务</code>又可以<strong>细分</strong>为<code>微任务</code>和<code>宏任务</code>，任务队列也被划分为微任务队列和宏任务队列。</p><p>什么是微任务，什么是宏任务？</p><p><strong>宏任务</strong>是指<code>时间粒度</code>比较大的任务（就是js操作比较多，需要更多的时间来执行，无法迅速完成的任务），<strong>微任务</strong>则反之。常见的宏任务有<code>setTimeout()</code>，常见的微任务有<code>Promise.then()</code></p><p>在执行下一个宏任务之前，会先查看<code>微任务队列中</code>是否有需要执行的<code>微任务</code>，如果有则先把微任务执行完，再开启新的宏任务。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p><code>宏任务</code>是事件循环的基本单位，一个宏任务中可以同时包含<code>同步任务</code>，<code>宏任务</code>，<code>微任务</code>；</p><p><code>事件循环</code>指的是，js引擎先执行<code>宏任务</code>中包含的<code>同步任务</code>，再查找并执行微任务队列中的所有微任务，再查找宏任务队列，开启新的宏任务，如此循环往复的过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li>宏任务：执行整体代码（相当于<code>&lt;script&gt;</code>中的代码，整体是一个宏任务）：<ol><li>输出: <code>script start</code></li><li>遇到 setTimeout，加入宏任务队列，当前宏任务队列(setTimeout)</li><li>遇到 promise，加入微任务，当前微任务队列(promise1)</li><li>输出：<code>script end</code></li></ol></li><li>微任务：执行微任务队列（promise1）<ol><li>输出：<code>promise1</code>，then 之后产生一个微任务，加入微任务队列，当前微任务队列（promise2）</li><li>执行 then，输出<code>promise2</code></li></ol></li><li><strong>执行渲染操作，更新界面（敲黑板划重点）。</strong></li><li>宏任务：执行 setTimeout<ol><li>输出：<code>setTimeout</code></li></ol></li></ol><p>参考文章：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/a/1190000044769124">程序员 - 一次搞懂-JS事件循环之宏任务和微任务 - 个人文章 - SegmentFault 思否</a></p><h3 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h3><p><code>async</code> 是异步的意思，<code>await</code> 则可以理解为等待</p><p>放到一起可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await</code> 是用来等待异步方法执行</p><p><strong>async</strong></p><p>无论如何，<code>async</code>函数返回的总是一个<code>promise</code>对象，下面两种方法是等效的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;TEST&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会自动包装成resolved类型的promise对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncF</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;TEST&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>await</strong></p><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise</code> 对象，返回该对象的结果。如果不是 <code>Promise</code> 对象，就<code>直接返回</code>对应的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//等同于return 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// 直接输出123</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//等同于return 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="number">123</span>) &#125;, <span class="number">3000</span>) &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">f</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)<span class="comment">//输出状态为pending的promise对象</span></span><br><span class="line">res.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// 3s后输出123</span></span><br></pre></td></tr></table></figure><p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码，后面的代码成为异步任务(如果阻塞的是是同步代码就成为<code>微任务</code>)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn2</span>() <span class="comment">// fn2函数的执行不会被阻塞</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>) <span class="comment">// 被阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn2</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p><h2 id="说说你对BOM的理解"><a href="#说说你对BOM的理解" class="headerlink" title="说说你对BOM的理解"></a>说说你对BOM的理解</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p><code>BOM</code> (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象</p><p>其作用就是跟<code>浏览器</code>做一些交互效果,比如如何进行页面的<code>后退</code>，<code>前进</code>，<code>刷新</code>，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率</p><img src="..\images\前端面试-js\bom.png" style="zoom:85%"> <img src="..\images\前端面试-js\BOM2.png" style="zoom:67%"><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p><code>Bom</code>的核心对象是<code>window</code>，它表示浏览器的一个实例，<code>location</code>，<code>navigator</code>等后续介绍的对象都是<code>window</code>的属性。</p><p>在浏览器中，<code>window</code>对象有双重角色，即是浏览器窗口的一个接口，又是全局对象</p><p>因此所有在<code>全局作用域</code>中声明的<code>变量</code>、<code>函数</code>都会变成<code>window</code>对象的<code>属性</code>和<code>方法</code></p><ul><li><p><code>window.scrollTo(x,y)</code>：如果有滚动条，将横向滚动条移动到相对于窗体宽度为x个像素的位置，将纵向滚动条移动到相对于窗体高度为y个像素的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">500</span>);<span class="comment">//将页面垂直滚动到距离页面顶部500像素的位置，而水平滚动条不会发生变化。</span></span><br></pre></td></tr></table></figure></li><li><p><code>window.scrollBy(x,y)</code>： 如果有滚动条，将<code>横向滚动条</code>向左移动x个像素，将<code>纵向滚动条</code>向下移动y个像素</p></li></ul><ul><li><p><code>window.open()</code> ：</p><p><code>window.open()</code>既可以导航到一个特定的<code>url</code>，也可以打开一个新的浏览器窗口。</p><p><code>window.open()</code> 会返回<code>新窗口的引用</code>，也就是新窗口的 <code>window</code> 对象，当使用 <code>window.open()</code> 方法打开新窗口时，如果返回值是 <code>null</code>，<strong>这通常意味着浏览器阻止了该弹窗的创建</strong>。现代浏览器为了防止恶意网站滥用弹窗，通常会限制<code>非用户交互</code>触发的弹窗。如果你在页面加载时或没有明确的用户动作（如点击事件）的情况下调用 <code>window.open()</code>，浏览器可能会认为这是未经请求的弹窗，并阻止它。</p><p>比如直接在script标签中书写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;sanye.blog&#x27;</span>)<span class="comment">//被浏览器阻止</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    myWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;http://www.vue3js.cn&#x27;</span>, <span class="string">&#x27;_blank&#x27;</span>)</span><br><span class="line">&#125;)<span class="comment">//可行</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newWindow = <span class="variable language_">window</span>.<span class="title function_">open</span>(url, target, features[, replace]);</span><br></pre></td></tr></table></figure><p><strong>url</strong> (可选)</p><ul><li>类型: <code>String</code></li><li>描述: 新窗口要加载的 <code>URL</code> 地址。如果省略或设置为 <code>null</code>，则会打开一个空白窗口。</li></ul><p><strong>target</strong> (可选)</p><ul><li>类型: <code>String</code></li><li>描述: 指定新窗口的<code>目标位置</code>。它可以是以下预定义值之一：<ul><li><code>_self</code>: 在<code>当前框架</code>中加载页面（默认行为）。</li><li><code>_blank</code>: 在<code>新的窗口</code>或标签页中加载页面。</li><li><code>_parent</code>: 在父框架中加载页面。如果当前页面不在框架(iframe)内，则与 <code>_self</code> 的行为相同，在当前标签页中加载新页面。</li><li><code>_top</code>: 在整个窗口中加载页面，取消所有框架。</li><li>或者是一个由开发者定义的名称，用来标识<code>特定的窗口</code>或 <code>&lt;iframe&gt;</code>。</li></ul></li></ul><p><strong>features</strong> (可选)</p><ul><li>类型: <code>String</code></li><li>描述: 一系列用<code>逗号分隔</code>的<code>字符串</code>，用于指定新窗口的各种<code>属性</code>和<code>行为</code>。每个特征可以带有或不带参数<ul><li><code>width=600</code>: 设置窗口宽度为 600 像素。</li><li><code>height=400</code>: 设置窗口高度为 400 像素</li></ul></li></ul><p><strong>replace</strong> (可选)</p><ul><li>类型: <code>Boolean</code></li><li>描述: 如果设置为 <code>true</code>，则新加载的页面将<code>替换历史记录中的当前条目</code>；如果为 <code>false</code> 或<code>未提供</code>，则会在历史记录中添加一个<code>新条目</code>。这对于防止用户多次点击<code>后退</code>按钮返回到同一个页面非常有用。</li></ul></li><li><p><code>window.close()</code> ：仅用于关闭通过 <code>window.open()</code> 打开的窗口</p><p>如果尝试关闭一个<code>不同域名</code>下的窗口，可能会遇到<code>跨域限制</code>。在这种情况下，<code>window.close()</code> 可能不会工作，因为浏览器的安全模型会阻止你操作不属于同一源的窗口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myWin.<span class="title function_">close</span>()<span class="comment">//关闭myWin窗口</span></span><br></pre></td></tr></table></figure></li><li><p>新创建的 <code>window</code> 对象有一个 <code>opener</code> 属性，该属性指向打开他的<code>原始窗口对象</code></p></li></ul><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>是一个<code>对象</code>，包含了许多属性，一个<code>url</code>地址例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//www.wrox.com:80/WileyCDA/?q=javascript#contents</span></span><br></pre></td></tr></table></figure><p><code>location</code>属性描述如下：</p><table><thead><tr><th>属性名</th><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>hash</td><td>“#contents”</td><td>url中，#后面的字符，没有则返回空串</td></tr><tr><td>host</td><td><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.wrox.com/">www.wrox.com:80</a></td><td>服务器名称和端口号</td></tr><tr><td>hostname</td><td><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.wrox.com/">www.wrox.com</a></td><td>域名，不带端口号</td></tr><tr><td>href</td><td><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.wrox.com/WileyCDA/?q=javascript#contents">http://www.wrox.com:80/WileyCDA/?q=javascript#contents</a></td><td>完整url</td></tr><tr><td>pathname</td><td>“&#x2F;WileyCDA&#x2F;“</td><td>服务器下面的文件路径</td></tr><tr><td>port</td><td>80</td><td>url的端口号，没有则为空</td></tr><tr><td>protocol</td><td>http:</td><td>使用的协议</td></tr><tr><td>search</td><td>?q&#x3D;javascript</td><td>url的查询字符串，通常为？后面的内容</td></tr></tbody></table><ul><li>除了 <code>hash</code>之外，只要修改<code>location</code>的一个属性，就会导致页面重新加载新<code>URL</code></li><li><code>location.reload()</code>，此方法可以重新刷新当前页面。这个方法会根据<code>最有效的方式</code>刷新页面，如果页面自上一次请求以来没有改变过，页面就会从<code>浏览器缓存</code>中重新加载，这一点和浏览器的<code>缓存策略</code>相关。如果要<code>强制</code>从服务器中重新加载，传递一个参数<code>true</code>即可。</li></ul><h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p><code>navigator</code> 对象主要用来获取<code>浏览器的属性</code>，区分浏览器类型。属性较多，且兼容性比较复杂。</p><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p>保存的纯粹是<code>客户端能力</code>信息，也就是浏览器窗口外面的<code>客户端显示器</code>的信息，比如像素宽度和像素高度。</p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history是window对象的一个属性，它本身也是个对象，提供了许多api，主要用来操作浏览器<code>URL</code>的历史记录，允许我们<strong>编程式</strong>控制页面被在历史记录之间跳转，也允许我们<strong>修改</strong>历史记录。</p><p>检查一个页面并在控制台输入history，即可查看当前页面的<code>state</code>，<code>scrollRestoraion</code>等信息。</p><img src="..\images\前端面试-js\a.png" style="zoom:80%"><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>history.back()</td><td>跳转到前一个页面，如果没有前一个页面，则不做响应，不会改变history.length</td></tr><tr><td>history.forward()</td><td>跳转到后一个页面，如果当前就最新页面，则不做响应，不会改变history.length</td></tr><tr><td>history.go()</td><td>传入数字，<code>正数</code>表示前进几个页面，<code>负数</code>表示后退几个页面，<code>0</code>表示刷新页面，不会改变history.length</td></tr><tr><td>history.length</td><td>获取当前窗口页面历史记录跳数，它是一个只读属性，无法直接修改。</td></tr><tr><td>history.pushState()</td><td>往<strong>历史记录栈顶</strong>添加一条记录，历史记录条数加1，但是<strong>不会跳转页面</strong>。在当前页面调用这个api，你能明显的看到<strong>url改变了</strong>，但是页面没有跳转。接收三个参数，历史记录对象（state），页面标题，URL路径。</td></tr><tr><td>history.replaceState()</td><td>不会增加历史记录数目，<strong>会修改当前历史记录</strong></td></tr><tr><td>history.state</td><td>访问<strong>当前页面</strong>的状态对象。</td></tr><tr><td>history.scrollRestoraion</td><td>如果值为<strong>auto</strong>，则在前进或者后退的时候，<strong>滚动条</strong>会回到原来的位置。如果值为<strong>manual</strong>，则不会恢复。默认值是auto即后退到历史页面的时候，滚动条会回到原来的位置。可以通过在页面（html文件）内部的js代码中使用history.scrollRestoraion来修改这个页面滚动条的恢复方式。</td></tr></tbody></table><h2 id="DOM常见的操作有哪些"><a href="#DOM常见的操作有哪些" class="headerlink" title="DOM常见的操作有哪些"></a>DOM常见的操作有哪些</h2><h3 id="DOM是什么"><a href="#DOM是什么" class="headerlink" title="DOM是什么"></a>DOM是什么</h3><p><code>浏览器</code>根据<code>html</code>标签生成的<code>js对象</code>，所有的<code>标签属性</code>都可以在上面找到（所以说node中没有dom），修改这个对象属性会<code>自动映射</code>到标签上。关键词：浏览器，html标签，js对象，属性映射。</p><h3 id="DOM常见的操作"><a href="#DOM常见的操作" class="headerlink" title="DOM常见的操作"></a>DOM常见的操作</h3><ul><li>创建节点</li><li>获取结点</li><li>更新节点</li><li>添加节点</li><li>删除节点</li></ul><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p><strong>createElement</strong></p><p>创建<code>元素结点</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divEl = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>createTextNode</strong></p><p>创建文本结点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textEl = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;content&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>createAttribute</strong></p><p>创建属性节点，可以是自定义属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个元素结点</span></span><br><span class="line"><span class="keyword">var</span> elem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建一个属性结点</span></span><br><span class="line"><span class="keyword">var</span> attr = <span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(<span class="string">&#x27;href&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置属性结点的值</span></span><br><span class="line">attr.<span class="property">value</span> = <span class="string">&#x27;http://example.com&#x27;</span>;</span><br><span class="line"><span class="comment">// 将属性结点添加到元素结点</span></span><br><span class="line">elem.<span class="title function_">setAttributeNode</span>(attr);</span><br><span class="line"><span class="comment">// 添加一些文本到元素</span></span><br><span class="line">elem.<span class="property">textContent</span> = <span class="string">&#x27;链接&#x27;</span>;</span><br></pre></td></tr></table></figure><p>虽然可以直接使用<code>elem.href = &#39;http://example.com&#39;;</code>或<code>elem.setAttribute(&#39;href&#39;, &#39;http://example.com&#39;);</code>来达到相同的效果，但是了解<code>如何创建和操作属性结点</code>可以帮助更好地理解DOM的操作机制。</p><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><p>可以通过<code>捕获</code>的方式获取dom结点，也可以通过一个<code>dom结点的属性</code>来获取另一个dom结点</p><p><strong>querySelector</strong></p><p>传入任何有效的<code>css</code> 选择器，即获得<code>首个</code>符合条件的Dom元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.element&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#element&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[name=username]&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div + p &gt; span&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果页面上没有指定的元素时，返回 <code>null</code></p><p><strong>querySelectorAll</strong></p><p>传入任何有效的<code>css</code> 选择器，返回一个<code>伪数组</code>，包含全部符合匹配条件的DOM元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> notLive = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>其他方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id属性值&#x27;</span>);返回拥有指定id的对象的引用</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;class属性值&#x27;</span>);返回拥有指定<span class="keyword">class</span>的对象集合</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;标签名&#x27;</span>);返回拥有指定标签名的对象集合</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;name属性值&#x27;</span>); 返回拥有指定名称的对象结合</span><br><span class="line"><span class="variable language_">document</span>/element.<span class="title function_">querySelector</span>(<span class="string">&#x27;CSS选择器&#x27;</span>);  仅返回第一个匹配的元素</span><br><span class="line"><span class="variable language_">document</span>/element.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;CSS选择器&#x27;</span>);   返回所有匹配的元素</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>;  获取页面中的<span class="variable constant_">HTML</span>标签</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>; 获取页面中的<span class="variable constant_">BODY</span>标签</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">all</span>; 获取页面中的所有元素节点的对象集合型,不是标准<span class="variable constant_">DOM</span>的一部分，它的行为可能在不同的浏览器中表现不同</span><br></pre></td></tr></table></figure><p>我们仅通过观察是<code>...Element...</code>还是，<code>...Elements...</code>就能判断出返回的结果是集合还是单独的元素</p><p>除此之外，每个<code>DOM</code>元素还有<code>parentNode</code>、<code>childNodes</code>、<code>firstChild</code>、<code>lastChild</code>、<code>nextSibling</code>、<code>previousSibling</code>属性，关系图如下图所示。</p><img src="..\images\前端面试-js\dom.png" style="zoom:80%"><p><strong>parentNode和parentElement</strong></p><p><code>parentNode</code> 返回指定节点的父节点，这个父节点可以是<strong>任何类型的节点</strong>，包括文档类型节点、元素节点、文本节点等。但是，在实际应用中，除了元素节点外，其他类型的节点很少作为父节点存在。</p><p><code>parentElement</code> 仅返回指定节点的父元素节点（即类型为<code>HTMLElement</code>的节点）。如果指定节点的父节点<strong>不是一个元素节点</strong>（例如，它可能是一个文本节点或文档片段），则 <code>parentElement</code> 返回 <code>null</code>，即<code>先捕获再判断类型</code>。</p><p>简单的来说，就是一个对父节点的类型有要求，一个没有。</p><p><strong>childNodes和children</strong></p><p><code>childNodes</code> 返回一个实时的<code>NodeList</code>对象，包含了指定节点的所有直接子节点(一级子节点)，包括元素节点、文本节点、注释节点等所有类型的节点。</p><p><code>children</code> 返回一个实时的 <code>HTMLCollection</code> 对象，只包含指定节点的<code>直接元素子节点（一级元素结点）</code>（即标签）。不包括文本节点、注释节点等其他类型的节点。</p><p><strong>获取页面上的所有结点</strong></p><p>一个简单的方法是从文档的根节点（<code>document</code> 或 <code>document.documentElement</code>，后者指的是 <code>&lt;html&gt;</code> 元素）开始，然后递归地访问每个节点的 <code>childNodes</code>。</p><p><strong>获取页面上的所有元素结点</strong></p><ul><li><p>使用 <code>document.getElementsByTagName(&#39;*&#39;)</code>：这将返回一个包含文档中所有元素的实时 <code>HTMLCollection</code></p></li><li><p>使用 <code>document.querySelectorAll()</code>：通过传递 <code>&#39;*&#39;</code> 选择器，你可以获得一个静态的 <code>NodeList</code>，它包含了文档中的所有元素结点。</p></li></ul><h4 id="更新结点"><a href="#更新结点" class="headerlink" title="更新结点"></a>更新结点</h4><p><strong>innerHTML</strong></p><p>不但可以修改一个<code>DOM</code>节点的<code>文本内容</code>，如果传入的是html片段，还会被解析成dom结点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p&quot;&gt;...&lt;/p &gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// &lt;p id=&quot;p&quot;&gt;ABC&lt;/p &gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>innerText、textContent</strong></p><p>自动对字符串进行<code>HTML</code>编码，就是把小于号转化成<code>&amp;lt;</code>大于号转化成<code>&amp;gt;</code>保证无法设置任何<code>HTML</code>标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p &gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本:</span></span><br><span class="line">p.<span class="property">innerText</span> = <span class="string">&#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p &gt;</span></span><br></pre></td></tr></table></figure><p>两者的区别在于读取属性时，<code>innerText</code>不返回<code>隐藏元素</code>的文本(即 <code>display: none</code> 或者 <code>visibility: hidden</code>)，而<code>textContent</code>返回所有文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;可见文本&lt;/p&gt;</span><br><span class="line">  &lt;p style=&quot;display: none;&quot;&gt;隐藏文本&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const element = document.getElementById(&#x27;example&#x27;);</span><br><span class="line">  console.log(element.innerText);     // 输出: &quot;可见文本&quot;</span><br><span class="line">  console.log(element.textContent);  // 输出: &quot;可见文本\n隐藏文本&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="添加结点"><a href="#添加结点" class="headerlink" title="添加结点"></a>添加结点</h4><p><strong>appendChild</strong></p><p>把一个节点添加到父节点的最后一个子节点之后，<strong>如果这个添加的结点已经在页面中存在，那么这个结点会先从原位置删除</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript&lt;/p &gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme&lt;/p &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加一个<code>p</code>元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> js = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line">js.<span class="property">innerHTML</span> = <span class="string">&quot;JavaScript&quot;</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">list.<span class="title function_">appendChild</span>(js);</span><br></pre></td></tr></table></figure><p>在<code>HTML</code>结构变成了下面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript&lt;/p &gt;  <span class="comment">&lt;!-- 添加元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>insertBefore</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentElement.<span class="title function_">insertBefore</span>(newElement, referenceElement)</span><br></pre></td></tr></table></figure><p>子节点会插入到<code>referenceElement</code>之前</p><ul><li><code>parentElement</code>: 这是要操作的目标元素，新的子节点将被添加到这个元素的<code>子节点列表</code>中。</li><li><code>newElement</code>: 这是你想要插入的<code>新元素节点</code>。</li><li><code>referenceElement</code>: 这是在新元素插入之前所依据的<code>参考元素</code>。新元素会被放置在这个<code>参考元素</code>之前。如果这个参数为 <code>null</code>，则新元素会被插入到父元素的最后，就像使用 <code>appendChild()</code> 一样。</li></ul><p><strong>setAttribute</strong></p><p>在指定元素中<code>添加一个属性</code>节点，如果元素中已有该属性改变属性值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;white&#x27;</span>);<span class="comment">//第一个参数属性名，第二个参数属性值。</span></span><br></pre></td></tr></table></figure><h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><p><strong>removeChild</strong></p><p>删除一个节点，首先要获得<code>该节点本身</code>以及它的<code>父节点</code>，然后，调用父节点的<code>removeChild</code>把自己删掉，也就是说，一个结点是不能删除自身的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">const</span> self = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;to-be-removed&#x27;</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">const</span> parent = self.<span class="property">parentNode</span>;</span><br><span class="line"><span class="comment">// 删除并返回被删除的dom元素</span></span><br><span class="line"><span class="keyword">const</span> removed = parent.<span class="title function_">removeChild</span>(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>删除后的节点虽然不在<code>文档树</code>中了，但其实它还在<code>内存中</code>，可以随时再次被添加到别的位置。</p><h2 id="如何实现触底加载，下拉刷新？"><a href="#如何实现触底加载，下拉刷新？" class="headerlink" title="如何实现触底加载，下拉刷新？"></a>如何实现触底加载，下拉刷新？</h2><p>要明白如何实现功能，我们首先要搞清楚dom元素的一些<strong>定位，宽高属性</strong></p><ul><li><p>client</p><p><code>clientWidth/clientHeight</code>：可视区域的宽&#x2F;高+内边距，不包含<code>border</code></p></li><li><p>scroll</p><p><code>scrollWidth/scrollHeight</code>：有滚动条元素的元素整体的宽高。</p></li></ul><p>举个例子，我们在一个高度为<code>600px</code>的盒子<code>box</code>里放两个背景颜色不同，高度都是<code>400px</code>的盒子<code>box1</code>,<code>box2</code>，并给<code>box</code>添加css属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>:auto </span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">补充一下overflow属性的值</span><br><span class="line">visible（默认值）:内容不会被裁剪，而是会呈现在元素框之外。</span><br><span class="line">hidden:内容会被裁剪，并且超出的部分不会显示。浏览器不会为溢出内容提供任何滚动机制。</span><br><span class="line">scroll:即使内容并未溢出,也提供滚动条</span><br><span class="line">auto:如果内容溢出了元素框，则浏览器会根据需要提供滚动条。如果内容没有溢出，则不显示滚动条</span><br><span class="line"></span><br><span class="line">单个方向上的溢出控制</span><br><span class="line">overflow-x：控制水平方向上的溢出。</span><br><span class="line">overflow-y: 控制垂直方向上的溢出。</span><br></pre></td></tr></table></figure><p>这样<code>box</code>盒子就出现了滚条，可以实现内容的滚动，内部盒子也不会影响外部盒子的布局（开启了<code>BFC</code>，可以观察添加该条属性前后，body高度的变化，从800px变为600px）。然后我们访问box盒子（有滚动条的盒子）的<code>clientHeight</code>属性和<code>scrollHeight</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box.<span class="property">clientHeight</span> <span class="comment">//600px</span></span><br><span class="line">box.<span class="property">scrollHeight</span> <span class="comment">//800px</span></span><br></pre></td></tr></table></figure><p>这样是不是就很容易理解client和scroll之间的区别呢。对于没有滚动条的元素，clientWidth&#x2F;clientHeight与scrollWidth&#x2F;scrollHeight的值是一一相等的。</p><p>当我们不断地给<code>body</code>添加元素，<code>body</code>的高度总有超过浏览器窗口高度的时候，此时<code>body</code>标签的父元素，<code>html</code>标签会自动开启滚动条，<code>html.clientHeight</code>就是<strong>浏览器窗口</strong>的高度。</p><ul><li><p>scroll</p><p>scroll开头的属性中，还有两个重要的属性。</p><p>scrollLeft&#x2F;scrollTop：表示<strong>具有滚动条的元素</strong>，顶部滚动出<code>可视区域</code>的高度，或者左部滚动出<code>可视区域</code>的宽度，对于不具有滚动条的元素，这两个属性的值都是<code>0</code>。这两个属性是可读写的，将元素的 <code>scrollLeft</code> 和 <code>scrollTop</code> 设置为 0，可以重置元素的滚动位置。</p></li></ul><p>常见的属性中除了以client，scroll开头的属性，还有以<code>offset</code>开头的属性</p><ul><li><p>offset</p><p><code>offsetWidth/offsetHeight</code>：可视区域的宽&#x2F;高+内边距+border+滚动条，这两个属性通常被拿来与<code>clientWidth/clientHeight</code>属性比较,都是可视区域的宽高，不过范围有所不同。</p><p><code>offsetLeft/offsetHeight</code>：元素左部&#x2F;顶部距离<strong>最近的定位元素</strong>的距离，相对的<strong>不是视口</strong>，通常是固定的，不会随滚动条改变而改变。</p></li></ul><img src="..\images\前端面试-js\offset.png" style="zoom:80%"><h3 id="如何实现触底加载"><a href="#如何实现触底加载" class="headerlink" title="如何实现触底加载"></a>如何实现触底加载</h3><p><strong>方法1</strong></p><p>如果<code>html</code>元素<strong>顶部滚出可视区域的高度</strong>+html元素的<strong>可视区域高度</strong>，大于html标签的<strong>整体高度</strong>，则判定为触底，其实这个时候就是页面已经滑到底部了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (html.<span class="property">scrollTop</span> + html.<span class="property">clientHeight</span> &gt;= html.<span class="property">scrollHeight</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触底&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：实现起来非常简单。</p><p>缺点：只能判断最后一个元素是否触底，不能判断<strong>非底部元素</strong>是否触底（如果body很长，那么非底部元素也是有触底事件的）</p><p><strong>方法2</strong></p><p>使用<code>IntersectionObserver API</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params">entries, observer</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//每观察一个元素，entries的大小就会+1</span></span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;元素进入视口&#x27;</span>);</span><br><span class="line">      <span class="comment">//entry.target：表示被观察的元素。</span></span><br><span class="line">      observer.<span class="title function_">unobserve</span>(entry.<span class="property">target</span>); <span class="comment">// 一旦进入视口，停止观察</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二个参数指明元素完全出现在视口再触发回调函数，符合触底的思想</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(func,&#123;<span class="attr">threshold</span>:<span class="number">1</span>&#125;);</span><br><span class="line">observer.<span class="title function_">observe</span>(target) <span class="comment">//观察某个元素</span></span><br></pre></td></tr></table></figure><p>关于<code>IntersectionObserver</code>更详细的介绍参考下文。</p><p>优点：不仅能精确控制某个元素是否触底，令<code>threshold</code>的值为0，还能实现<strong>图片懒加载</strong>的效果，即图片一出现在视口，就发送请求获取图片。</p><p>缺点：需要调用api实现起来麻烦。</p><h3 id="如何实现下拉刷新"><a href="#如何实现下拉刷新" class="headerlink" title="如何实现下拉刷新"></a>如何实现下拉刷新</h3><p>监听<code>window</code>的<code>touchstart</code>,<code>touchmove</code>,<code>touchend</code>,通过<code>e.touches[0].pageY</code>获得触碰位置。<code>touchend</code>事件触发后，计算移动的距离，判断是否需要刷新数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> start</span><br><span class="line"><span class="keyword">let</span> distance = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> load</span><br><span class="line"><span class="keyword">let</span> tip</span><br><span class="line"><span class="comment">//在一次下拉操作中，这个回调函数只会执行一次</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">//存储第一次触摸屏幕距离视口顶部的距离</span></span><br><span class="line">  start = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientY</span></span><br><span class="line">  <span class="comment">//还未开始加载</span></span><br><span class="line">  load = <span class="literal">false</span></span><br><span class="line">  <span class="comment">//还未提示正在下拉</span></span><br><span class="line">  tip = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//在一次下拉操作中，这个回调函数会被执行多次</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">//记录下拉的距离</span></span><br><span class="line">  distance = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientY</span> - start</span><br><span class="line">  <span class="comment">//如果下拉的距离大于0且未提示过正在下拉刷新，则提示</span></span><br><span class="line">  <span class="keyword">if</span> (distance &gt; <span class="number">0</span> &amp;&amp; !tip) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正在进行下拉刷新操作&#x27;</span>)</span><br><span class="line">    <span class="comment">//本次下拉操作不再提示正在下拉刷新</span></span><br><span class="line">    tip = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果下拉的距离超过设定的距离且未提示过松手释放，则提示</span></span><br><span class="line">  <span class="keyword">if</span> (distance &gt; <span class="number">50</span> &amp;&amp; !load) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;松手释放&#x27;</span>)</span><br><span class="line">    <span class="comment">////本次下拉操作不再提示松手释放</span></span><br><span class="line">    load = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//在一次下拉操作中，这个回调函数只会执行一次</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">//如果下拉的距离超过了指定距离，则松手后开始更新</span></span><br><span class="line">  <span class="keyword">if</span> (load) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正在进行更新操作&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="如何判断一个元素是否在可视区域中？"><a href="#如何判断一个元素是否在可视区域中？" class="headerlink" title="如何判断一个元素是否在可视区域中？"></a>如何判断一个元素是否在可视区域中？</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：</p><ul><li>图片的懒加载</li><li><strong>列表的无限滚动</strong></li><li>计算广告元素的曝光情况</li><li>可点击链接的预加载</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="借助dom的布局属性"><a href="#借助dom的布局属性" class="headerlink" title="借助dom的布局属性"></a><strong>借助dom的布局属性</strong></h4><p>当一个元素的<code>html</code>标签的<code>scrollTop</code>属性，加上<code>视口的高度</code>，大于等于一个元素的<code>offsetTop</code>属性，那么这个元素就出现在视口中。如何获取视口的高度呢？有三种方式：</p><ul><li><code>window.innerHeight</code></li><li><code>document.documentElement.clientHeight</code>：<code>html标签</code>的高度就可以认为是<strong>视口的高度</strong></li><li><code>document.body.clientHeight</code> ：<code>body</code>标签的高度通常等于<code>html标签</code>的<code>高度</code>，所以也可以被认为是视口的高度。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="property">offsetTop</span> - <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> &lt;= <span class="title function_">viewPortHeight</span>(视口高度)</span><br></pre></td></tr></table></figure><p><strong>然而这么做有一个前提，那就是el的最近的定位元素是<code>html</code>标签。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPortOfOne</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// viewPortHeight 兼容所有浏览器写法</span></span><br><span class="line">    <span class="keyword">const</span> viewPortHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span> </span><br><span class="line">    <span class="keyword">const</span> offsetTop = el.<span class="property">offsetTop</span><span class="comment">//元素距离html标签顶部的距离，前提html确实是最近的定位元素</span></span><br><span class="line">    <span class="keyword">const</span> html = <span class="variable language_">document</span>.<span class="property">documentElement</span></span><br><span class="line">    <span class="keyword">const</span> scrollTop = html.<span class="property">scrollTop</span></span><br><span class="line">    <span class="keyword">return</span> offsetTop - scrollTop &lt;= viewPortHeight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h4><p><code>Intersection(交叉，交集) Observer</code> 即，重叠观察者，从这个命名就可以看出它用于<code>判断两个元素是否重叠</code>，因为不用进行<code>scroll</code>事件的监听，性能方面相比<code>getBoundingClientRect</code>会好很多。</p><p>使用步骤主要分为两步：<code>创建观察者</code>和<code>传入被观察者</code></p><p><strong>创建观察者</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="comment">// 表示重叠面积占被观察者的比例，从 0 - 1 取值，</span></span><br><span class="line">  <span class="comment">// 1 表示完全被包含</span></span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">1.0</span>, </span><br><span class="line">  <span class="attr">root</span>:<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#scrollArea&#x27;</span>) <span class="comment">// 必须是目标元素的父级元素，如果省略，浏览器的视口（viewport）作为根容器</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params">entries, observer</span>) =&gt; &#123; ....&#125;</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, options);</span><br></pre></td></tr></table></figure><p>通过<code>new IntersectionObserver</code>创建了观察者 <code>observer</code>，传入的回调函数 <code>callback</code> <strong>在重叠比例超过 <code>threshold</code> 时会被执行</strong></p><p>关于<code>callback</code>回调函数常用属性如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上段代码中被省略的 callback</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="keyword">function</span>(<span class="params">entries, observer</span>) &#123; </span><br><span class="line">    <span class="comment">//entries是一个数组，包含了所有被观察的对象</span></span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        entry.<span class="property">isIntersecting</span>      <span class="comment">// 布尔值，表示两元素是否重叠</span></span><br><span class="line">        entry.<span class="property">time</span>;               <span class="comment">// 触发的时间</span></span><br><span class="line">        entry.<span class="property">intersectionRatio</span>;  <span class="comment">// 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）</span></span><br><span class="line">        entry.<span class="property">target</span>;             <span class="comment">// 被观察者</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>传入被观察者</strong></p><p>通过 <code>observer.observe(target)</code> 这一行代码即可<strong>简单的注册被观察者</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.target&#x27;</span>);</span><br><span class="line">observer.<span class="title function_">observe</span>(target);</span><br></pre></td></tr></table></figure><h4 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h4><p>调用dom的getBoundingClientRect方法，返回值是一个 <code>DOMRect</code>对象，拥有<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>x</code>, <code>y</code>, <code>width</code>, 和 <code>height</code>属性。</p><ul><li><code>x</code>: 元素左边缘相对于<code>视口左边界</code>的距离，通常情况下等于left</li><li><code>y</code>: 元素上边缘相对于<code>视口顶部</code>的距离，通常情况下等于top</li><li><code>top</code>: 元素上边缘相对于<code>视口顶部</code>的距离。</li><li><code>right</code>: 元素右边缘相对于<code>视口左边界</code>的距离。</li><li><code>bottom</code>: 元素下边缘相对于<code>视口顶部</code>的距离。</li><li><code>left</code>: 元素左边缘相对于视口左边界的距离。</li><li><code>width</code>: 元素的宽度，包括填充和边框，但不包括外边距。</li><li><code>height</code>: 元素的高度，包括填充和边框，但不包括外边距。</li></ul><p>如果一个元素在视窗之内的话，那么它一定满足下面四个条件：</p><ul><li>top 大于等于 0</li><li>left 大于等于 0</li><li><strong>bottom 小于等于视窗高度，就是元素底部距离视口顶部的距离，小于等于视口高度，这个是最常用的判断条件</strong></li><li>right 小于等于视窗宽度</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个布尔值，判断元素是否在视口中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPort</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> viewWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">  <span class="keyword">const</span> viewHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    top,</span><br><span class="line">    right,</span><br><span class="line">    bottom,</span><br><span class="line">    left,</span><br><span class="line">  &#125; = element.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    top &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    left &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    right &lt;= viewWidth &amp;&amp;</span><br><span class="line">    bottom &lt;= viewHeight</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获得元素的即时位置，<strong>每次页面滚动</strong>都要重新调用这个方法来获得最新的位置信息。</p><h3 id="实现图片的懒加载"><a href="#实现图片的懒加载" class="headerlink" title="实现图片的懒加载"></a>实现图片的懒加载</h3><p>下面使用<code>IntersectionObserver</code>实现了一个图片懒加载指令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> lazy = &#123;</span><br><span class="line">    <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries,observer</span>)=&gt;</span>&#123;</span><br><span class="line">            entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>)=&gt;</span>&#123;</span><br><span class="line">                entry.<span class="property">target</span>.<span class="property">src</span> = binding.<span class="property">value</span></span><br><span class="line">                observer.<span class="title function_">unobserve</span>(entry.<span class="property">target</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,&#123;<span class="attr">threshold</span>:<span class="number">0</span>&#125;)</span><br><span class="line">        observer.<span class="title function_">observe</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现列表的无限滚动"><a href="#实现列表的无限滚动" class="headerlink" title="实现列表的无限滚动"></a>实现列表的无限滚动</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> infinite = &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        el.<span class="title function_">getBoundingClientRect</span>().<span class="property">bottom</span> &lt;=</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        binding.<span class="title function_">value</span>()<span class="comment">//调用传入的回调函数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new操作符到底做了什么"><a href="#new操作符到底做了什么" class="headerlink" title="new操作符到底做了什么"></a>new操作符到底做了什么</h2><ul><li>创建一个新的对象</li><li>让这个对象的<code>[[prototype]]</code>属性等于构造函数的<code>prototype</code>，即让新创建的对象的原型等于构造函数的原型对象。</li><li>调用这个对象的<code>constructor</code>方法</li></ul><p>如果构造函数的<code>返回值</code>是<strong>基本类型</strong>，那么这个返回值不起任何效果，但是如果构造函数的返回值是<strong>引用类型</strong>，new操作返回的对象就是构造函数返回的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line"> 	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Parent</span>()) <span class="comment">//Parent &#123;name: &#x27;parent&#x27;, play: Array(3)&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line"> 	this.name = &#x27;parent&#x27;;</span><br><span class="line">    this.play = [1, 2, 3];</span><br><span class="line">    return [1,2,3]</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Parent()) //输出[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>手写<code>new</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">constructor, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">//方法1</span></span><br><span class="line">  <span class="comment">// const obj = Object.create(constructor.prototype)</span></span><br><span class="line">  <span class="comment">//方法2</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="comment">//新对象原型指向构造函数原型对象</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = constructor.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="comment">//让这个对象调用constructor方法，并传入参数</span></span><br><span class="line">  <span class="keyword">const</span> res = obj.<span class="title function_">constructor</span>(<span class="params">...args</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> res == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myNew</span>(<span class="title class_">Parent</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="number">30</span>)) <span class="comment">//Parent &#123;name: &#x27;tom&#x27;, age: 30&#125;</span></span><br></pre></td></tr></table></figure><h2 id="在js中如何实现继承"><a href="#在js中如何实现继承" class="headerlink" title="在js中如何实现继承"></a>在js中如何实现继承</h2><p>继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码</p><p>在子类别继承父类别的同时，可以<code>重新定义</code>某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。</p><p>如果大家学过<code>java</code>，想必对继承的概念都非常熟悉了。</p><p>那在js这门语言中是如何实现继承呢?</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>让父类的一个<code>实例</code>作为子类的<code>原型对象</code>，这样子类的原型对象的原型确实是父类的原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent1&#x27;</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br></pre></td></tr></table></figure><p>这样就满足<code>Child.prototype._proto_ = Parent.prototype</code>，在原型链上确实是符合继承关系，但是这也<strong>只是</strong>在原型链上实现了继承，<code>Child.prototype.constructor</code>也不指向<code>Child</code>的构造函数，而是指向Parent的构造函数，而且这个构造函数还不是原型对象（prototype）自己的属性</p><img src="..\images\前端面试-js\继承.png" style="zoom:80%"><p>正确的情况，<code>Child.prototype</code>的<code>constructor</code>应该是<code>Child.prototype</code><strong>自己的属性</strong>（ownProperty）</p><p>正确的状态，比如Parent构造函数</p><img src="..\images\前端面试-js\继承2.png" style="zoom:80%"><p>总的来说，原型链继承的问题包括， 子类的原型对象<strong>没有自己的构造函数，还存在多余的属性</strong>。</p><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">    this.name = &#x27;parent1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">function Child()&#123;</span><br><span class="line">    Parent1.call(this);</span><br><span class="line">    this.type = &#x27;child&#x27;</span><br><span class="line">&#125;</span><br><span class="line">let child = new Child();</span><br></pre></td></tr></table></figure><p>构造函数继承也只是实现了构造函数上的继承，比原型链继承还低智，就纯粹在<code>Child</code>的构造函数中调用了<code>Parent</code>的构造函数，并让<code>this</code>指向Child构造函数内部的this，在这个例子中，<code>Parent1.call(this)</code>完全可以被替换为 <code>this.name = &#39;parent1&#39;;</code>这种继承方式唯一的作用，拿这个例子来讲，就是把父类<code>Parent</code>的name属性终于变成<code>子类Child实例</code>自己的属性了（对象本身就有的，而不是原型对象上的，可以通过<code>hasOwnProperty</code>方法来判断）。</p><img src="..\images\前端面试-js\构造函数继承.png" style="zoom:85%"><h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><p>组合式继承就是把前面两种方式，即<code>原型链继承</code>和<code>构造函数继承</code>，这两种不完美的方法结合了起来，并更正了<code>Child</code>原型对象的指向。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 第二次调用 Parent()</span></span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用 Parent()</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="comment">// 手动挂上构造器，指向自己的构造函数，更正指向</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child</span>())</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-js\组合继承.png" style="zoom:80%"><p>可以看到 <code>Child.prototype.constructor</code>指向是正确的，创建的<code>Child</code>实例也有自己的<code>name</code>和<code>play</code>属性，但是实例的原型对象上有多余的属性比如name和paly。</p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>是对组合式继承的<strong>优化</strong>，不再使用父类(<code>Parent</code>)的<code>实例</code>作为子类(<code>Child</code>)的原型对象(<code>Prototype</code>)，而是使用**Object.create()**方法单独为子类创造一个原型对象。</p><p><code>Object.create()</code>能以传入的对象为<code>对象原型</code>，创造一个新的对象。</p><p>示例：<code>Object.create(Parent.prototype)</code></p><p>以Parent的原型对象为对象原型，创造一个新的对象，意思就是<strong>创造的对象</strong>的<code>_proto_</code>属性&#x3D;<code>Parent.prototype</code> ，<strong>就好像创建了一个Parent实例</strong>，所以创建的对象显示的类型也是<code>Parent</code>，不过这个实例对象没有自己的属性（多余的属性比如name，play），再给这个对象添加自己的constructor属性后用来充当原型对象再合适不过了。</p><img src="..\images\前端面试-js\原型链.png" style="zoom:90%"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getFriends</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">//&#123;friends:&quot;child&quot;,name:&quot;parent&quot;,play:[1,2,3],__proto__:Parent&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// parent</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getFriends</span>()); <span class="comment">// child</span></span><br></pre></td></tr></table></figure><h3 id="extends-super"><a href="#extends-super" class="headerlink" title="extends+super"></a>extends+super</h3><p>使用<code>extends</code>关键字实现继承，基于<code>es6</code>新引入的<code>class</code>，本质上使用的也是<code>寄生组合式继承</code>，不过还要配合<code>super</code>关键字使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原型方法，会被挂载到构造函数的原型上</span></span><br><span class="line">  <span class="comment">// 即Person.prototype.getName = function() &#123;&#125;</span></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gamer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="comment">//构造函数不是必须写的，如果不写构造函数就相当于书写了以下代码：</span></span><br><span class="line">  <span class="comment">//constructor(name) &#123;</span></span><br><span class="line">  <span class="comment">//  super(name)</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super(),表示调用父类的构造函数</span></span><br><span class="line">    <span class="comment">// 不调用super就会报错</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> asuna = <span class="keyword">new</span> <span class="title class_">Gamer</span>(<span class="string">&#x27;Asuna&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">asuna.<span class="title function_">getName</span>() <span class="comment">// 成功访问到父类的方法</span></span><br></pre></td></tr></table></figure><h2 id="Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="Javascript本地存储的方式有哪些？区别及应用场景？"></a>Javascript本地存储的方式有哪些？区别及应用场景？</h2><p><code>javaScript</code>本地缓存的方法我们主要讲述以下四种：</p><ul><li>cookie</li><li>sessionStorage</li><li>localStorage</li><li>indexedDB</li></ul><p>其中<code>sessionStorage</code>和<code>localStorage</code>都是<code>H5</code>新增的。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h4><p><code>Cookie</code>是存储在客户端的<code>小型文本文件（txt）</code>，被用来解决 <code>HTTP</code><strong>无状态</strong>导致的问题，。</p><p>作为一段一般不超过 <code>4KB</code> 的小型文本数据（4KB 的大小限制主要针对单个 Cookie），它由一个名称（Name）、一个值（Value）和其它几个用于<code>控制</code> <code>cookie</code>有效期、安全性、使用范围的可选属性组成。</p><p>但是<code>cookie</code>在每次请求中都会被发送，如果不使用 <code>HTTPS</code>并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 <code>cookie</code>保持登录态的网站上，如果 <code>cookie</code>被窃取，他人很容易利用你的 <code>cookie</code>来假扮成你登录网站。</p><img src="..\images\前端面试-js\cookie.png" style="zoom:80%"><p>关于<code>cookie</code>常用的属性如下：</p><ul><li><p><strong>Expires</strong></p><p>用于设置 Cookie 的过期时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Expires</span>=<span class="title class_">Wed</span>, <span class="number">21</span> <span class="title class_">Oct</span> <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> <span class="variable constant_">GMT</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Max-Age</strong></p><p>用于设置在 Cookie 的有效时间（优先级比<code>Expires</code>高，书写方式也比Expires友好）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Max</span>-<span class="title class_">Age</span>=<span class="number">604800</span> <span class="comment">//单位是s</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Domain</strong></p><p>指定了 <code>Cookie</code> 在哪些域名下生效，包含了这些域名的请求，才会自动携带cookie。</p><p>添加cookie的时候，不指定Domain默认就是<code>当前域名</code>；指定了一个域名，则其子域名也总会被包含；</p><p>比如，在<code>https://www.bilibili.com/</code>页面下添加一个cookie但是未指定Domain，则Domain就是<code>www.bilibili.com</code></p><p>如果指定Domain为<code>bilibili.com</code>，则实际为<code>.bilibili.com</code>，表示在<code>bilibili.com</code>所有子域名下这个cookie也生效。</p></li><li><p><strong>Path</strong></p><p>指定了一个 <code>URL</code>路径，只有<strong>包含这个路径的请求</strong>才能携带这个cookie</p></li><li><p><strong>Secure</strong></p><p>标记为 <code>Secure</code>的 <code>Cookie</code>意味着这个cookie包含了重要的信息，不应该被泄漏，只能通过<code>HTTPS</code>请求安全地发送给服务器。</p></li><li><p><strong>HttpOnly</strong></p><p>标记为HttpOnly的请求只能通过<code>http/https</code>协议来操作。</p></li><li><p><strong>SameSite</strong></p><p><code>SameSite</code> 属性用于控制 Cookie 是否应该随<strong>跨站请求</strong>一起发送。它有三个可能的值:</p><ul><li><code>Strict</code>：Cookie 仅在<code>同站</code>请求中发送，即只有当用户从同一站点发起请求时才会包含 Cookie。</li><li><code>Lax</code>：大多数情况下不发送跨站请求中的 Cookie，但在导航到目标站点（如点击链接）时例外。</li><li><code>None</code>：允许跨站请求中发送 Cookie，但要求请求必须通过 <code>HTTPS</code> 发送（即启用安全传输层）。</li></ul></li></ul><p>更多例子参考：<a href="https://www.sanye.blog/posts/c0add594.html">前端面试—网络 | 三叶的博客</a>中的<code>withCredentails</code>部分</p><h4 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a><strong>操作方式</strong></h4><ul><li><p><strong>通过js操作cookie</strong></p><ul><li><p>获取当前页面所有cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span></span><br></pre></td></tr></table></figure><p>返回一个字符串，包含当前页面的所有cookie的键值对，形如：<code>key=val;key2=val2;......;keys=vals</code></p><p>如果要查看当前页面的全部cookie的详细信息，可以选择<code>检查页面</code>，前往<code>应用程序-&gt;存储-&gt;cookie</code>中查看。</p></li><li><p>创建一个cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;key=val;Max-age=3600;Domain=www.sanye.blog&#x27;</span> <span class="comment">//可以继续添加其他限制属性</span></span><br></pre></td></tr></table></figure><p>我们知道，document.cookie，返回一个字符串，包含当前页面的所有cookie的键值对。上述创建cookie的代码的效果貌似是覆盖掉这个字符串，其实不是的，效果真的是添加一个cookie。</p></li><li><p>修改cookie</p><p>关于<code>cookie</code>的修改，首先要确定<code>domain</code>和<code>path</code>属性都是相同的才可以，这两个属性可以理解为用来限制cookie的作用域，其中有一个不同的时候都会创建出一个新的<code>cookie</code>，而不是修改原来的cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;name=bb; domain=aa.net; path=/&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>删除cookie</p><p>最常用的方法就是给<code>cookie</code>设置一个过期的时间，这样<code>cookie</code>过期后会自动被浏览器删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;id=1;Max-age=0&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>通过http操作cookie</strong></p><p><strong>添加cookie</strong></p><p>http通过在响应头中添加<code>Set-Cookie</code>字段在客户端种cookie，如果有多个 Cookie 就在响应头中设置多个 <code>Set-Cookie</code> 字段。</p><p>通过http操作的cookie的方式与js操作cookie的方式在形式上是不同的，但本质上还是相同的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; [<span class="title class_">Expires</span>=&lt;date&gt;]; [<span class="title class_">Max</span>-<span class="title class_">Age</span>=&lt;non-zero-digit&gt;]; [<span class="title class_">Domain</span>=&lt;domain-value&gt;]; [<span class="title class_">Path</span>=&lt;path-value&gt;]; [<span class="title class_">Secure</span>]; [<span class="title class_">HttpOnly</span>]; </span><br></pre></td></tr></table></figure><p><strong>更新或者删除cookie</strong></p><p>要更新现有的Cookie，只需再次发送带有<code>相同名称</code>的新 <code>Set-Cookie</code> 头。这将覆盖旧的同名Cookie。要删除一个Cookie，可以通过设置其 <code>Expires</code> 或 <code>Max-Age</code> 为过去的时间戳来实现</p></li></ul><h4 id="浏览器行为"><a href="#浏览器行为" class="headerlink" title="浏览器行为"></a><strong>浏览器行为</strong></h4><ul><li>浏览器会在每次请求时自动附加与目标URL相匹配的所有Cookies。</li><li>如果某个Cookie被标记为 <code>HttpOnly</code>，那么JavaScript代码不能读取或修改这个Cookie，增加了安全性。</li><li>当一个Cookie过期后，浏览器会自动将其从存储中移除，不再随请求一起发送。</li></ul><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p><code>HTML5</code>新方法，IE8及以上浏览器都兼容</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>持久化的本地存储，除非主动删除数据，否则数据永不过期</p></li><li><p>存储的信息在<code>同一域</code>中是共享的，这个同一域包括<code>子域名</code>，也就是说若两个域名即便只有子域名不同，也不会被认为是同一域名。</p><p>子域名指的是主域名（二级域名+顶级域名）之前的部分，比如<code>www.sanye.blog</code>中的<code>www</code>就是子域名，<code>sanye.blog</code>就是主域名，一般域名购买，购买的就是主域名。</p></li><li><p>当本页操作（新增、修改、删除）了<code>localStorage</code>中的数据的时候，本页面不会触发<code>storage</code>事件，但是别的页面会触发<code>storage</code>事件，这里的其他页面指的是<code>同源</code>的其他页面。</p></li><li><p>大小：5M（跟浏览器厂商有关系）,<code>localStorage</code> 的大小限制主要指的是 <strong>整个域名下所有存储数据的总和</strong>，而不是单个键值对的大小。</p></li><li><p><code>localStorage</code>本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</p></li><li><p>受同源策略的限制</p></li></ul><h4 id="storage事件补充"><a href="#storage事件补充" class="headerlink" title="storage事件补充"></a><strong>storage事件补充</strong></h4><p>假设你有两个标签页（Tab A 和 Tab B）打开了同一个网站 <code>example.com</code>，并且这两个标签页都在使用 <code>localStorage</code> 来存储一些数据。</p><ol><li><p><strong>Tab A</strong> 中执行以下 JavaScript 代码来设置一个新的 <code>localStorage</code> 项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Tab A</strong> 不会触发 <code>storage</code> 事件，因为它就是触发这次变更的<code>操作源</code>。</p></li><li><p><strong>Tab B</strong> 中监听 <code>storage</code> 事件，并打印出事件详情：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;storage&#x27;, function(event) &#123;</span><br><span class="line">  console.log(&#x27;Storage event received:&#x27;, event);</span><br><span class="line">  console.log(&#x27;Key:&#x27;, event.key);</span><br><span class="line">  console.log(&#x27;Old value:&#x27;, event.oldValue);</span><br><span class="line">  console.log(&#x27;New value:&#x27;, event.newValue);</span><br><span class="line">  console.log(&#x27;URL:&#x27;, event.url);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>当你在 <strong>Tab A</strong> 中设置了 <code>localStorage</code> 后，<strong>Tab B</strong> 会立即接收到 <code>storage</code> 事件，并输出类似如下的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Storage event received: StorageEvent &#123;…&#125;</span><br><span class="line">Key: key</span><br><span class="line">Old value: null</span><br><span class="line">New value: value</span><br><span class="line">URL: https://example.com/</span><br></pre></td></tr></table></figure></li><li><p>如果你在 <strong>Tab B</strong> 中也设置了相同的 <code>localStorage</code> 项，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&#x27;key&#x27;, &#x27;newValue&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Tab B</strong> 自身不会触发 <code>storage</code> 事件，但 <strong>Tab A</strong> 会接收到 <code>storage</code> 事件，并显示相应的更新信息。</p></li></ol><h4 id="常见使用语法"><a href="#常见使用语法" class="headerlink" title="常见使用语法"></a><strong>常见使用语法</strong></h4><p>设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;cfangxu&#x27;</span>);</span><br></pre></td></tr></table></figure><p>获取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;username&#x27;</span>)</span><br></pre></td></tr></table></figure><p>获取键名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">key</span>(<span class="number">0</span>) <span class="comment">//获取第一个键名</span></span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;username&#x27;</span>)</span><br></pre></td></tr></table></figure><p>一次性清除所有存储</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure><p><code>localStorage</code> 也不是完美的，它有两个缺点：</p><ul><li>无法像<code>Cookie</code>一样设置过期时间</li><li>只能存入<code>字符串</code>，无法直接存对象，如果尝试存储一个对象，它会自动调用该对象的 <code>toString()</code> 方法，这通常会导致数据丢失或无法正确恢复原始对象；存入对象之前必须先<code>序列化</code>。</li></ul><h4 id="和cookie的区别与联系"><a href="#和cookie的区别与联系" class="headerlink" title="和cookie的区别与联系"></a>和cookie的区别与联系</h4><ul><li><strong>过期时间</strong>：<code>localStorage</code> 无法像<code>Cookie</code>一样设置<code>过期时间</code>，数据在本地的存储是<code>持久化</code>的，除非主动删除数据，否则数据<code>永不过期</code>。</li><li><strong>存取方式</strong>：<code>localStorage</code>中的数据必须<code>手动存取</code>，而<code>cookie</code>中的数据是<code>自动存取</code>的</li><li><strong>同源策略</strong>：<code>localStorage</code>严格遵循同源策略，同源页面才能共享同一份<code>localStorage</code>中的数据；虽然 Cookies 也默认遵循同源策略，但可以通过特定的设置来实现<code>跨子域的数据共享</code>。</li><li><strong>大小限制</strong>：二者都有存储大小的限制，每个<code>cookie</code>的存储大小限制是4kB，而每个页面的<code>localStorage</code>的存储大小限制一般是5MB，明显更大。</li><li><strong>存储类型</strong>：二者只能存储<code>字符串</code>。这意味着如果你想要存储对象或其他复杂的数据结构，需要进行<code>序列化</code>和<code>反序列化</code>操作。</li></ul><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p><code>sessionStorage</code>和 <code>localStorage</code>使用方法基本一致，唯一不同的是<code>生命周期</code>，<strong>一旦页面（会话）关闭，<code>sessionStorage</code> 中的数据将会被删除。</strong></p><h3 id="前端扩展存储方式"><a href="#前端扩展存储方式" class="headerlink" title="前端扩展存储方式"></a>前端扩展存储方式</h3><p>虽然 <code>Web Storage</code>对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。<code>IndexedDB</code>提供了一个解决方案。</p><p><code>indexedDB</code>是一种低级API，用于客户端存储大量结构化数据(包括, 文件&#x2F; blobs)。该API使用<code>索引(index)</code>来实现对该数据的高性能搜索。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>储存量理论上没有上限</li><li>所有操作都是<code>异步</code>的，相比 <code>LocalStorage</code> 同步操作性能更高，尤其是数据量较大时</li><li>原生支持储存<code>JS</code>的对象</li><li>是个正经的数据库，意味着数据库能干的事它都能干</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>操作非常繁琐</li><li>本身有一定门槛</li></ul><p>关于<code>indexedDB</code>的使用基本使用步骤如下：</p><ul><li>打开数据库并且开始一个事务</li><li>创建一个 <code>object store</code></li><li>构建一个请求来执行一些数据库操作，像增加或提取数据等。</li><li>通过监听正确类型的 <code>DOM</code> 事件以等待操作完成。</li><li>在操作结果上进行一些操作（可以在 <code>request</code>对象中找到）</li></ul><p>关于使用<code>indexdb</code>的使用会比较繁琐，大家可以通过使用<code>Godb.js</code>库进行缓存，最大化的降低操作难度</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>标记用户与跟踪用户行为的情况，推荐使用<code>cookie</code></li><li>适合长期保存在本地的数据（令牌），推荐使用<code>localStorage</code></li><li>敏感账号一次性登录，推荐使用<code>sessionStorage</code></li><li>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用<code>indexedDB</code></li></ul><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>是一种创建<strong>交互式网页</strong>应用的<strong>开发技术</strong>, 可以在<strong>不重新加载</strong>整个网页的情况下，<strong>与服务器交换数据</strong>，并且局部更新网页。</p><p><code>Ajax</code>的原理简单来说就是通过<code>XmlHttpRequest(xhr)</code>对象向服务器发送<strong>异步请求</strong>，收到服务器响应的数据后，用<code>Js</code>操作<code>DOM</code>来更新页面。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ul><li><p>创建 <code>Ajax</code>的核心对象 <code>XMLHttpRequest</code>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法初始化一个 HTTP 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(method, url, [<span class="keyword">async</span>][, user][, password])</span><br></pre></td></tr></table></figure><ul><li><code>method</code>：表示当前的请求方式，常见的有<code>GET</code>、<code>POST</code></li><li><code>url</code>：服务端地址</li><li><code>async</code>：布尔值，表示是否异步执行操作，默认为<code>true</code></li><li><code>user</code>: 可选的用户名用于认证用途；默认为<code>null</code></li><li><code>password</code>: 可选的密码用于认证用途，默认为<code>null</code></li></ul></li><li><p>构建请求所需的<code>数据内容</code>，并通过<code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>([body])<span class="comment">//如果请求体中不需要携带数据，什么都不要传入</span></span><br></pre></td></tr></table></figure></li><li><p>通过 <code>XMLHttpRequest</code> 对象提供的 <code>onreadystatechange</code> 事件（即<code>监听(on)准备状态(readystate)改变(change)</code>）监听服务器端的通信状态。</p><p>关于<code>XMLHttpRequest.readyState</code>属性有五个状态，用数字来区分，只要 <code>readyState</code>属性值一变化，就会触发一次 <code>readystatechange</code> 事件。</p><ul><li>0（unsent）：<code>open</code>方法还未调用，连接还未建立。</li><li>1（opened)：<code>open</code>方法调用了，但是还未发送请求（还未调用<code>send</code>方法）</li><li>2（headers_recieved）：请求发送了，<code>响应头</code>和<code>响应状态</code>已经接收到了，但是还未开始下载。</li><li>3（loading）：<code>响应体</code>下载中</li><li>4（done）：响应体下载完毕，请求完成。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">//request的三个常用属性</span></span><br><span class="line"><span class="comment">//request.readyState  查看请求的状态</span></span><br><span class="line"><span class="comment">//request.status 响应状态码</span></span><br><span class="line"><span class="comment">//request.responseText 响应文本</span></span><br><span class="line">request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(request.<span class="property">readyState</span> === <span class="number">4</span>)&#123; <span class="comment">// 整个请求过程完毕</span></span><br><span class="line">        <span class="keyword">if</span>(request.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; request.<span class="property">status</span> &lt;= <span class="number">300</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">responseText</span>) <span class="comment">// 服务端返回的结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request.<span class="property">status</span> &gt;=<span class="number">400</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;错误信息：&quot;</span> + request.<span class="property">status</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于初始化一个 HTTP 请求。这个方法并不发送请求，而是为后续的 request.send() 调用做准备</span></span><br><span class="line">request.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;http://xxxx&#x27;</span>)</span><br><span class="line">request.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure></li><li><p><strong>接受并处理</strong>服务端向客户端响应的数据结果</p></li><li><p>将处理结果<strong>更新</strong>到 <code>HTML</code>页面中</p></li></ul><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><code>axios</code> 是一个基于<code>promise</code>的网络请求库，在浏览器端借助<code>XHR</code>，在<code>node.js</code>中借助<code>http</code>模块</p><p>有如下特点：</p><ul><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换<code>JSON</code> 数据</li><li>客户端支持防御<code>XSRF</code></li></ul><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>在浏览器中可以通过<code>script</code>标签直接引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在node模块化开发环境中，可以通过<code>npm包</code>的形式下载，需要使用的时候再导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --S //安装到开发环境</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>在线文档关于<code>axios</code>的介绍说实话没有让人看下去的动力，这里写点自己的东西。</p><ul><li><p><strong>使用axios.create创建axios实例</strong></p><p>创建出来的实例具有与axios一样的功能，这样就相当于为每个请求都配置了相同的<code>基地址</code>,<code>超时时间</code>，<code>响应头</code>，这不就起到了<code>封装</code>的作用吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//request.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://smart-shop.itheima.net/index.php?s=/api&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;platform&#x27;</span>: <span class="string">&#x27;H5&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>给axios实例添加响应拦截器，请求拦截器。</strong></p><p>响应拦截器返回（return）的数据，其实就是axios请求最终返回的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">  <span class="comment">// 只要有token，就在请求时携带，便于请求需要授权的接口</span></span><br><span class="line">  <span class="comment">// 每次请求都会获取token,也就是说token每次都是现用现取的，如果删除了就取不到了</span></span><br><span class="line">  <span class="keyword">const</span> token = store.<span class="property">getters</span>.<span class="property">token</span></span><br><span class="line">  <span class="keyword">if</span> (token) &#123;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;Access-Token&#x27;</span>] = token</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// 2xx 范围内的状态码(response.status)都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">  <span class="keyword">return</span> response.<span class="property">data</span> <span class="comment">//默认会被包装成resolved类型的promise对象</span></span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error) <span class="comment">//如果直接返回error，也会被包装成resolved类型的promise对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>取消请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios.CancelToken是一个构造函数，用来获得取消令牌源对象。</span></span><br><span class="line"><span class="comment">// source是一个取消令牌源对象。这个对象包含了两个重要的属性：</span></span><br><span class="line"><span class="comment">// token: 这是一个实际的取消令牌。你可以将这个令牌传递给 Axios 请求配置中的 cancelToken 属性，从而使得该请求可以被取消。</span></span><br><span class="line"><span class="comment">// cancel: 这是一个函数，调用它可以取消所有关联了source.token 的请求。</span></span><br><span class="line"><span class="comment">// 你可以选择性地提供一个消息参数，这个消息会作为取消原因包含在取消事件中。</span></span><br><span class="line"><span class="keyword">const</span> source = axios.<span class="property">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;xxxx&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: source.<span class="property">token</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 取消请求 (请求原因是可选的)</span></span><br><span class="line"><span class="comment">// 调用source.cancel(&#x27;取消原因&#x27;) 时，它会将关联的 cancelToken 标记为已取消状态，并记录提供的取消原因（如 &#x27;取消原因&#x27;）</span></span><br><span class="line"><span class="comment">// 这个操作不会直接发送网络请求，而是改变了令牌的状态。</span></span><br><span class="line">source.<span class="title function_">cancel</span>(<span class="string">&#x27;主动取消请求&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>想要取消请求，需要先使用<code>axios.CancelToken</code>生成一个<code>取消令牌源对象source</code>，然后再请求中配置<code>cancelToken</code>属性的值为<code>source.token</code>，当想要取消请求的时候，就调用<code>source.cancel()</code>方法，传入取消请求的原因。</p><p>调用<code>source.cancel(&#39;取消原因&#39;) 时</code>，它会将关联的 <code>cancelToken</code> 标记为已取消状态，并记录提供的取消原因（如 ‘取消原因’）<br>这个操作<strong>不会直接发送网络请求，而是改变了令牌的状态。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="comment">//获得取消请求源对象</span></span><br><span class="line"><span class="keyword">const</span> source = <span class="title class_">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(source.<span class="property">token</span>)<span class="comment">//输出token，结构如下</span></span><br></pre></td></tr></table></figure><img src="..\images\前端面试-vue\取消请求2.png" style="zoom:85%"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="keyword">const</span> source = <span class="title class_">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line">source.<span class="title function_">cancel</span>(<span class="string">&#x27;主动取消&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(source.<span class="property">token</span>)</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-vue\取消请求.png" style="zoom:80%"><p>Axios 的<code>响应拦截器</code>会检查每个正在处理的请求是否关联了被标记为<strong>已取消</strong>的 <code>cancelToken</code>。如果匹配，则立即停止该请求的进一步处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给axios实例，添加响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// 2xx 范围内的状态码都会触发该函数</span></span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 清除loading效果</span></span><br><span class="line">  <span class="title class_">Toast</span>.<span class="title function_">clear</span>();</span><br><span class="line">  <span class="comment">// 判断是否是因为取消操作导致的错误</span></span><br><span class="line">  <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(error)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request canceled:&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他错误处理</span></span><br><span class="line">    <span class="title class_">Toast</span>(<span class="string">&#x27;请求失败，请稍后重试&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简单的来说，我们想要某个请求被取消，那么这个请求必须携带<code>cancelToken</code>，当我们想要取消请求的时候，就调用<code>source.cancel()</code>方法并传入取消的原因，这个操作并不会发送新的请求，而是会修改<code>cancelToken</code>的状态，然后响应拦截器根据<code>cancelToken</code>的状态，判断不再需要处理这个请求，所以说，请求取消，完全不需要后端配合，请求发送后无论如何都会被响应，取消请求只不过是抛弃了响应结果。</p></li><li><p><strong>导出配置好的axios实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure></li><li><p><strong>使用axios发送请求</strong></p><p>我们通常把同一业务功能的<code>api</code>放到一个js文件中，比如和购物车<code>cart</code>相关的接口都放在<code>cart.js</code>文件中，在这些文件中引入导出的axios实例来发送请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import request from &#x27;index.js&#x27;</span><br></pre></td></tr></table></figure><p>发送请求有<strong>两种</strong>常用写法</p><ul><li><p><strong>request({})</strong></p><p>这种写法是直接传入一个<code>配置对象</code>，<code>请求方法(method)</code>等所有信息都包含在内,我们需要对大部分<strong>配置属性</strong>都熟悉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>:</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:</span><br><span class="line">    <span class="attr">data</span>:</span><br><span class="line">    <span class="attr">headers</span>:</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>request.method()</strong></p><p>这种写法是把<code>请求方法</code>提取到外面，然后传入多个参数来实现的。</p><p>第一个参数指定请求的 <strong>URL</strong></p><p>第二个参数，如果是<code>get/delete</code>等请求就是除了<code>请求体</code>外的<code>配置对象</code>，即不包括<strong>data</strong>属性的配置对象。如果是<code>put/post</code>请求，则是<code>data</code>，即<code>请求体</code>数据对象，所以说第二个参数到底是<code>data</code>还是<code>不包括data属性的配置对象</code>，取决于请求的方法。</p><p>第三个参数，只有<code>put/post</code>请求可能需要配置第三个参数，即不包括<code>data</code>属性的配置对象。</p></li><li><p>案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import request from &#x27;@/utils/request&#x27;</span><br><span class="line">//修改购物车商品信息（这里url是模板字符串，因为使用了path参数）</span><br><span class="line">export const updateCartAPI = (&#123; skuId, selected, count &#125;) =&gt; &#123;</span><br><span class="line">  return request.put(`/member/cart/$&#123;skuId&#125;`, &#123; selected, count &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//delete也要传入data，属于接口不符合规范</span><br><span class="line">export const delCartAPI = (ids) =&gt; request(&#123; url: &#x27;/member/cart&#x27;, method: &#x27;delete&#x27;, data: &#123; ids &#125; &#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置对象和<code>接口文档</code>的对应关系</p><ul><li><p>path：需要在<strong>url</strong>中直接配置，嵌入在url的<code>资源路径</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/users/&#123;userId&#125;  ---&gt;  /users/123</span><br></pre></td></tr></table></figure></li><li><p>query：在配置对象的<code>params</code>属性中配置，会被放到url的<code>?</code>之后，并且多个参数之间用与号 <code>&amp;</code> 分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;name:&quot;tom&quot;,age:18&#125;  ---&gt;  /users?name=tom&amp;age=18</span><br></pre></td></tr></table></figure></li><li><p>body：即请求体，在<code>data</code>属性中配置</p></li><li><p>header：在配置对象的<code>headers</code>属性中配置</p></li></ul></li><li><p>配置对象和<code>请求报文</code>的对应关系</p><p>header对应请求报文中的<code>请求头</code>，data对应请求报文中的<code>请求体</code>，method请求方法，资源路径，查询参数等出现在<code>请求行</code>中。</p></li></ul><h3 id="响应结果结构分析"><a href="#响应结果结构分析" class="headerlink" title="响应结果结构分析"></a>响应结果结构分析</h3><img src="..\images\前端面试-js\axios.png" style="zoom:90%"><p>可以注意到status和data是同一级别的数据，在响应拦截器中常常通过<code>response.status</code>来判断执行哪个函数</p><p>响应错误对象的<code>response</code>属性则有与响应成功对象<code>一样</code>的结构</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//request.js</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Toast</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span></span><br><span class="line"><span class="comment">// 创建 axios 实例，将来对创建出来的实例，进行自定义配置</span></span><br><span class="line"><span class="comment">// 好处：不会污染原始的 axios 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://smart-shop.itheima.net/index.php?s=/api&#x27;</span>,<span class="comment">//设置基地址</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span>,<span class="comment">//设置请求超时时间</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;platform&#x27;</span>: <span class="string">&#x27;H5&#x27;</span>,<span class="comment">//固定的请求头，每次请求都会携带</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//给axios实例，添加请求拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">  <span class="comment">// 开启loading，禁止背景点击 (节流处理，防止多次无效触发)</span></span><br><span class="line">  <span class="title class_">Toast</span>.<span class="title function_">loading</span>(&#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;加载中...&#x27;</span>,</span><br><span class="line">    <span class="attr">forbidClick</span>: <span class="literal">true</span>, <span class="comment">// 禁止背景点击</span></span><br><span class="line">    <span class="attr">loadingType</span>: <span class="string">&#x27;spinner&#x27;</span>, <span class="comment">// 配置loading图标</span></span><br><span class="line">    <span class="attr">duration</span>: <span class="number">0</span> <span class="comment">// 不会自动消失</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只要有token，就在请求时携带，便于请求需要授权的接口</span></span><br><span class="line">  <span class="comment">// 每次请求都会获取token,也就是说token每次都是现用现取的，如果删除了就取不到了</span></span><br><span class="line">  <span class="keyword">const</span> token = store.<span class="property">getters</span>[<span class="string">&#x27;user/token&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> (token) &#123;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;Access-Token&#x27;</span>] = token</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给axios实例，添加响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 对响应数据做点什么，默认axios会多包装一层data，需要响应拦截器中处理一下，简化返回数据的结构</span></span><br><span class="line">  <span class="keyword">const</span> res = response.<span class="property">data</span></span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 给错误提示, Toast 默认是单例模式，后面的 Toast调用了，会将前一个 Toast 效果覆盖</span></span><br><span class="line">    <span class="comment">// 同时只能存在一个 Toast</span></span><br><span class="line">    <span class="title class_">Toast</span>(res.<span class="property">message</span>)</span><br><span class="line">    <span class="comment">// 抛出一个错误的promise</span></span><br><span class="line">    <span class="comment">// 即便响应成功了也要包装成错误么，但是我就不想用try-catch处理await的错误，转而使用消息提示，而不是页面爆红。</span></span><br><span class="line">    <span class="comment">// return Promise.reject(res.message)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 正确情况，直接走业务核心逻辑，清除loading效果</span></span><br><span class="line">    <span class="title class_">Toast</span>.<span class="title function_">clear</span>()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出配置好的实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure><h3 id="实现一个简易版的axios"><a href="#实现一个简易版的axios" class="headerlink" title="实现一个简易版的axios"></a>实现一个简易版的axios</h3><p>构建一个<code>Axios</code>构造函数，核心代码为<code>request</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Axios</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">//因为axios实例并没有什么常用的属性，所以这里没有任何初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心方法request，会自动挂载到Axios.prototype上，传入配置对象，立即返回一个promise对象（状态为pending）</span></span><br><span class="line">    <span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">        <span class="comment">//request方法会立即返回一个promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        	<span class="comment">//对象解构赋值，获取到请求url，method（默认值是Get），data，并给这些属性赋予默认值</span></span><br><span class="line">            <span class="comment">//实际请求携带的配置参数可能不止这么点</span></span><br><span class="line">            <span class="keyword">const</span> &#123;url = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;get&#x27;</span>, data = &#123;&#125;&#125; = config;</span><br><span class="line">            <span class="comment">// 发送ajax请求</span></span><br><span class="line">            <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//用于初始化一个 HTTP 请求。这个方法并不发送请求</span></span><br><span class="line">            <span class="comment">//第三个参数是一个布尔值，表示是否异步执行请求，默认为true，表示异步。</span></span><br><span class="line">            xhr.<span class="title function_">open</span>(method, url[, <span class="literal">true</span>]);</span><br><span class="line">            xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">//当请求被响应，根据响应状态码，改变promise对象的状态</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">                <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);<span class="comment">//这一操作，就把异步回调函数内的值传递到外部了，避免依赖这个数据的代码写在回调函数内</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送请求并携带数据</span></span><br><span class="line">            xhr.<span class="title function_">send</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出request方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CreateAxiosFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> axios = <span class="keyword">new</span> <span class="title class_">Axios</span>();</span><br><span class="line">    <span class="keyword">let</span> req = <span class="keyword">function</span>(<span class="params">config</span>)&#123;axios.<span class="title function_">request</span>(config)&#125;;</span><br><span class="line">    <span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到最后的全局变量axios(是一个函数)，说白了这个axios(不是axios实例)就是在冒充axios.request()</span></span><br><span class="line"><span class="keyword">let</span> axios = <span class="title class_">CreateAxiosFn</span>();</span><br></pre></td></tr></table></figure><p>上述代码就已经能够实现<code>axios(&#123;&#125;)</code>这种方式的请求</p><p>下面是来实现下<code>axios.method()</code>这种形式的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methodsArr = [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>, <span class="string">&#x27;post&#x27;</span>];</span><br><span class="line"><span class="comment">//在Axios的prototype上挂载这些方法</span></span><br><span class="line"><span class="comment">//这种写法功能等同于直接在Axios类中一个个定义这些方法，不过更简洁。</span></span><br><span class="line">methodsArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[method] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 处理只可能传入2个参数的方法</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>].<span class="title function_">includes</span>(method)) &#123; <span class="comment">// 2个参数(url[, config])</span></span><br><span class="line">            <span class="comment">//此处的this指向axios实例，所以能调用request方法，同时也说明这些方法本质也是在调用request方法</span></span><br><span class="line">            <span class="comment">//arguments 是一个类数组对象，它包含了传递给函数的所有参数</span></span><br><span class="line">            <span class="comment">//arguments 对象允许你在不知道具体有多少个参数的情况下访问所有传递给函数的参数,即便函数没有声明形参</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">                method,</span><br><span class="line">                <span class="attr">url</span>: <span class="variable language_">arguments</span>[<span class="number">0</span>],</span><br><span class="line">                ...(<span class="variable language_">arguments</span>[<span class="number">1</span>] || &#123;&#125;)<span class="comment">//如果第二个参数没传入，arguments[1]的值就是undefined，然后展开一个空对象</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3个参数(url[,data[,config]])</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">                method,</span><br><span class="line">                <span class="attr">url</span>: <span class="variable language_">arguments</span>[<span class="number">0</span>],</span><br><span class="line">                <span class="attr">data</span>: <span class="variable language_">arguments</span>[<span class="number">1</span>] || &#123;&#125;,<span class="comment">//arguments[1]是一个数据对象，不需要展开</span></span><br><span class="line">                ...<span class="variable language_">arguments</span>[<span class="number">2</span>] || &#123;&#125;<span class="comment">//arguments[2]是剩余配置属性对象，需要展开</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>get，post这些方法与<code>request</code>方法一样，都挂载到<code>Axios.prototype</code>上，虽然这些方法本质是在调用<code>Axios.prototype.request</code>方法，但是它们还是属于<code>同级别</code>的关系。这些方法能通过<code>axios实例</code>调用，但是不能通过<code>axios</code>函数调用，但是我们得到<code>axios</code>应该是函数，我们因该要能通过<code>axios函数</code>调用这些方法。</p><h2 id="文件上传怎么做"><a href="#文件上传怎么做" class="headerlink" title="文件上传怎么做"></a>文件上传怎么做</h2><img src="..\images\前端面试-js\文件上传.png" style="zoom:75%"><h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p>借助input标签，点击选择文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">class</span>=<span class="string">&quot;postImage&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> postImage = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.postImage&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">   postImage.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>])<span class="comment">//是一个File对象</span></span></span><br><span class="line"><span class="language-javascript">   &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>选择文件后可以通过<code>e.target.files</code>获取到文件对象File数组</p><p>为什么是<code>files</code>呢，因为如果我们给input标签添加multiply属性，是允许选择多个文件的，也就是多文件上传，不过这要求用户有一定的电脑操作基础，要知道如何选择多个文件。所以开发过程中的方案其实是<code>多次单文件上传</code>，用一个数组存储每次循环的选择的文件对象。</p><h3 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h3><img src="..\images\前端面试-js\file.png" style="zoom:80%"><p><strong>常见属性</strong>：</p><ul><li>size属性：表示文件的<strong>字节数（B</strong>），可用来限制文件的大小</li><li>type属性：表示文件的类型</li></ul><p><strong>和Blob对象的关系</strong></p><p>属于Blob类的子类，二者可以随意转换；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Blob</span>([file]);<span class="keyword">new</span> <span class="title class_">File</span>([blob],filename)</span><br></pre></td></tr></table></figure><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>故名思义，可以转换文件对象，比如可以把<code>文件对象</code>异步转换成<code>base64</code>格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>()<span class="comment">//创建一个reader对象</span></span><br><span class="line">reader.<span class="title function_">readAsDataUrl</span>(file)<span class="comment">//调用readAsDataUrl方法，传入file对象</span></span><br><span class="line"><span class="comment">//把file对象转化成base64格式是*异步*的，监听reader的onload事件；需要在回调函数中拿到结果result</span></span><br><span class="line">reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(reader.<span class="property">result</span>)&#125;</span><br></pre></td></tr></table></figure><p>Blob对象也可以使用FileReader的语法</p><h3 id="URL-createObjectURL-file-blob"><a href="#URL-createObjectURL-file-blob" class="headerlink" title="URL.createObjectURL(file&#x2F;blob)"></a>URL.createObjectURL(file&#x2F;blob)</h3><p><code>URL.createObjectURL</code>会生成一个指向 Blob 或 File 对象的<code>临时 URL</code>。这个 URL 可以被用作 <code>&lt;img&gt;、&lt;video&gt;、&lt;audio&gt;、&lt;a&gt;</code> 等 HTML 元素的 src 或 href 属性，用来展示。</p><p>允许在<code>不暴露文件的实际路径（网络图片）或内容（base64格式的图片）</code>的前提下，显示文件，增加了<code>安全性</code></p><p>对象 URL 是<code>临时的</code>，浏览器会自动在<code>页面卸载</code>时释放这些 URL。但是，为了确保最佳性能和避免内存泄漏，你应该在不再需要时，显式调用 <code>URL.revokeObjectURL</code>。</p><p>举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;postImage&quot;</span>&gt;</span>更换图片<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">class</span>=<span class="string">&quot;postImage&quot;</span> <span class="attr">id</span>=<span class="string">&quot;postImage&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> postImage = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.postImage&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  postImage.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> url = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>])</span></span><br><span class="line"><span class="language-javascript">    img.<span class="property">src</span>= url</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="..\images\前端面试-js\临时url.png" style="zoom:85%"><h3 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fd = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line">fd.<span class="title function_">append</span>(<span class="string">&#x27;img&#x27;</span>, e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>])</span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">   <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080/upload&quot;</span>,</span><br><span class="line">   <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">   <span class="attr">data</span>: fd<span class="comment">//直接当作请求体对象</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p><code>FormData</code> 对象允许你构造一组键&#x2F;值对，这组键&#x2F;值对可以被轻松地序列化为 <code>application/x-www-form-urlencoded</code> 或 <code>multipart/form-data</code> 格式，非常适合用来<strong>模拟 HTML 表单提交</strong>。</p></li><li><p>使用 <code>append()</code> 方法可以向 <code>FormData</code> 对象中添加字段或<strong>文件</strong>。</p></li><li><p>当 <code>FormData</code> 包含文件(File)时，<code>axios</code> 会自动设置请求头 <code>Content-Type</code> 为 <code>multipart/form-data</code>，这是文件上传的标准格式。</p><p>即便是一个和FormData对象内容<code>完全一致</code>的不同对象也做不到这点。</p></li></ul><h3 id="图像展示方法"><a href="#图像展示方法" class="headerlink" title="图像展示方法"></a>图像展示方法</h3><ul><li>拿到本地图片file对象，转换成<code>base64格式</code>的图片（由图片文件数据编码而来的一个字符串）</li><li>拿到本地图片file对象，生成一个<code>临时url</code>（只能用来展示）</li><li>网络图片链接，会自动发送一个请求获取图片</li></ul><h3 id="文件可上传格式"><a href="#文件可上传格式" class="headerlink" title="文件可上传格式"></a>文件可上传格式</h3><ul><li>file&#x2F;blob（二进制）</li><li>base64（即可展示又可上传，无敌了）</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://www.sanye.blog">三叶sanye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://www.sanye.blog/posts/aef189c3.html">https://www.sanye.blog/posts/aef189c3.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.sanye.blog" target="_blank">三叶的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/js/">js</a></div><div class="post-share"><div class="social-share" data-image="/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/4b58a1f5.html" title="前端面试---css"><img class="cover" src="/images/cover/%E6%B1%9F%E5%8D%97.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">前端面试---css</div></div><div class="info-2"><div class="info-item-1">全文主要参考如下github项目，在此基础上补充了一些自己的东西： https://github.com/febobo/web-interview 项目网站：web前端面试 - 面试官系列 一个非常全面，细致的前端面试题库,十分的推荐，深刻体会到github的强大之处了。 说说css盒模型浏览器在渲染html元素的时候，会把所有元素表示为一个一个矩形的盒子。 盒模型组成 content 即实际内容，显示文本和图像 padding 即内边距，内边距是透明的，取值不能为负，背景图片可以扩展到padding。 border 即边框，由粗细、样式、颜色三部分组成。例如border:1px solid...</div></div></div></a><a class="pagination-related" href="/posts/f33bd2b9.html" title="前端面试---vue部分"><img class="cover" src="/images/cover/%E5%B0%8F%E9%95%87.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">前端面试---vue部分</div></div><div class="info-2"><div class="info-item-1">Vue2推荐一个学习vue的网站：Vue3 说说你对vue的理解前端发展背景最早的网页是没有数据库的，可以理解成就是一张可以在网络上浏览的报纸，就是纯静态页面 直到CGI技术的出现通过 CGI Perl 运行一小段代码与数据库或文件系统进行交互(前后端交互) 后来JSP(Java Server Pages)技术取代了CGI技术，其实就是Java + HTML 1234567891011&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JSP demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/%E4%B8%89%E5%8F%B6.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">三叶sanye</div><div class="author-info-description">记录学习，分享知识</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://space.bilibili.com/660655866?spm_id_from=333.1007.0.0" rel="external nofollow noreferrer" target="_blank" title="Bilibli"><i class="fa-brands fa-bilibili" style="color:#74c0fc"></i></a><a class="social-icon" href="https://github.com/syhy" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:3519450570@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">笔记主要自用，希望也能帮到你😀</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4js%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">说说js的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">引用数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof%E5%92%8Cinstanceof"><span class="toc-number">2.</span> <span class="toc-text">typeof和instanceof</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-number">2.1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-number">2.2.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-prototype-toString"><span class="toc-number">2.4.</span> <span class="toc-text">Object.prototype.toString()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-JavaScript-%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">谈谈 JavaScript 中的类型转换机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">显示转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Number"><span class="toc-number">3.1.1.</span> <span class="toc-text">Number()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parseInt"><span class="toc-number">3.1.2.</span> <span class="toc-text">parseInt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">3.1.3.</span> <span class="toc-text">String()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Boolean"><span class="toc-number">3.1.4.</span> <span class="toc-text">Boolean()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.</span> <span class="toc-text">隐式转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javascript-%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">Javascript 数字精度丢失的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1"><span class="toc-number">5.1.</span> <span class="toc-text">为什么会出现精度丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%BE%E5%BA%A6%E7%BC%BA%E5%A4%B1%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">如何解决精度缺失问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-JavaScript-%E4%B8%AD%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">6.</span> <span class="toc-text">说说 JavaScript 中内存泄漏的几种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.1.</span> <span class="toc-text">内存泄漏是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E8%87%AA%E5%8A%A8%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text">垃圾自动回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.2.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.2.</span> <span class="toc-text">如何实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">6.3.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%83%85%E5%86%B5"><span class="toc-number">6.4.</span> <span class="toc-text">常见内存泄漏情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%A4%96%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">6.4.1.</span> <span class="toc-text">意外的全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">6.4.2.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">6.4.3.</span> <span class="toc-text">闭包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E9%97%AD%E5%8C%85%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.</span> <span class="toc-text">说说你对闭包的理解？闭包使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">7.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.2.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">说说你对防抖和节流的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">8.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96"><span class="toc-number">8.2.</span> <span class="toc-text">防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81"><span class="toc-number">8.3.</span> <span class="toc-text">节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">8.4.</span> <span class="toc-text">区别与联系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.5.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">数组的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E"><span class="toc-number">9.1.</span> <span class="toc-text">增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0"><span class="toc-number">9.2.</span> <span class="toc-text">删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9"><span class="toc-number">9.3.</span> <span class="toc-text">改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5"><span class="toc-number">9.4.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="toc-number">9.5.</span> <span class="toc-text">排序方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">9.6.</span> <span class="toc-text">转换方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="toc-number">9.7.</span> <span class="toc-text">迭代方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">字符串常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">操作方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#concat"><span class="toc-number">10.1.1.</span> <span class="toc-text">concat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slice-substr-substring"><span class="toc-number">10.1.2.</span> <span class="toc-text">slice() substr() substring()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#indexOf-startWith-includes"><span class="toc-number">10.1.3.</span> <span class="toc-text">indexOf() startWith() includes()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86"><span class="toc-number">10.2.</span> <span class="toc-text">字符串拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D"><span class="toc-number">10.3.</span> <span class="toc-text">模板匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#match"><span class="toc-number">10.3.1.</span> <span class="toc-text">match()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#search"><span class="toc-number">10.3.2.</span> <span class="toc-text">search()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replace"><span class="toc-number">10.3.3.</span> <span class="toc-text">replace()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">11.</span> <span class="toc-text">深拷贝浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">11.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">11.2.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">11.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">说说js中的事件模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">12.1.</span> <span class="toc-text">事件与事件流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">事件模型分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"><span class="toc-number">13.</span> <span class="toc-text">资源加载事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">讲讲事件代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8script%E6%A0%87%E7%AD%BE%E4%B8%AD%E6%B7%BB%E5%8A%A0async%E5%92%8Cdefer%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">在script标签中添加async和defer有什么作用和区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async"><span class="toc-number">15.1.</span> <span class="toc-text">async</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-number">15.2.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">15.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">16.</span> <span class="toc-text">说说你对事件循环的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">16.1.</span> <span class="toc-text">同步与异步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="toc-number">16.2.</span> <span class="toc-text">微任务与宏任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">16.3.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E4%B8%8Eawait"><span class="toc-number">16.4.</span> <span class="toc-text">async与await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9BOM%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">17.</span> <span class="toc-text">说说你对BOM的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">17.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window"><span class="toc-number">17.2.</span> <span class="toc-text">window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#location"><span class="toc-number">17.3.</span> <span class="toc-text">location</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#navigator"><span class="toc-number">17.4.</span> <span class="toc-text">navigator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#screen"><span class="toc-number">17.5.</span> <span class="toc-text">screen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history"><span class="toc-number">17.6.</span> <span class="toc-text">history</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">18.</span> <span class="toc-text">DOM常见的操作有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">18.1.</span> <span class="toc-text">DOM是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">18.2.</span> <span class="toc-text">DOM常见的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9"><span class="toc-number">18.2.1.</span> <span class="toc-text">创建节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9"><span class="toc-number">18.2.2.</span> <span class="toc-text">获取节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%BB%93%E7%82%B9"><span class="toc-number">18.2.3.</span> <span class="toc-text">更新结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%BB%93%E7%82%B9"><span class="toc-number">18.2.4.</span> <span class="toc-text">添加结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9"><span class="toc-number">18.2.5.</span> <span class="toc-text">删除结点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%A7%A6%E5%BA%95%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%EF%BC%9F"><span class="toc-number">19.</span> <span class="toc-text">如何实现触底加载，下拉刷新？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%A7%A6%E5%BA%95%E5%8A%A0%E8%BD%BD"><span class="toc-number">19.1.</span> <span class="toc-text">如何实现触底加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0"><span class="toc-number">19.2.</span> <span class="toc-text">如何实现下拉刷新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E4%B8%AD%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">如何判断一个元素是否在可视区域中？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">20.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">20.2.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%9F%E5%8A%A9dom%E7%9A%84%E5%B8%83%E5%B1%80%E5%B1%9E%E6%80%A7"><span class="toc-number">20.2.1.</span> <span class="toc-text">借助dom的布局属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IntersectionObserver"><span class="toc-number">20.2.2.</span> <span class="toc-text">IntersectionObserver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getBoundingClientRect"><span class="toc-number">20.2.3.</span> <span class="toc-text">getBoundingClientRect</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">20.3.</span> <span class="toc-text">实现图片的懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%88%97%E8%A1%A8%E7%9A%84%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8"><span class="toc-number">20.4.</span> <span class="toc-text">实现列表的无限滚动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">21.</span> <span class="toc-text">new操作符到底做了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8js%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">22.</span> <span class="toc-text">在js中如何实现继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">22.1.</span> <span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">22.2.</span> <span class="toc-text">构造函数继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">22.3.</span> <span class="toc-text">组合式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">22.4.</span> <span class="toc-text">寄生组合式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extends-super"><span class="toc-number">22.5.</span> <span class="toc-text">extends+super</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javascript%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">Javascript本地存储的方式有哪些？区别及应用场景？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie"><span class="toc-number">23.1.</span> <span class="toc-text">Cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-4"><span class="toc-number">23.1.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">23.1.2.</span> <span class="toc-text">操作方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA"><span class="toc-number">23.1.3.</span> <span class="toc-text">浏览器行为</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#localStorage"><span class="toc-number">23.2.</span> <span class="toc-text">localStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">23.2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#storage%E4%BA%8B%E4%BB%B6%E8%A1%A5%E5%85%85"><span class="toc-number">23.2.2.</span> <span class="toc-text">storage事件补充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">23.2.3.</span> <span class="toc-text">常见使用语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8Ccookie%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB"><span class="toc-number">23.2.4.</span> <span class="toc-text">和cookie的区别与联系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sessionStorage"><span class="toc-number">23.3.</span> <span class="toc-text">sessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%89%A9%E5%B1%95%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">23.4.</span> <span class="toc-text">前端扩展存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">23.4.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">23.4.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">23.5.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax"><span class="toc-number">24.</span> <span class="toc-text">ajax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">24.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">24.2.</span> <span class="toc-text">实现过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios"><span class="toc-number">25.</span> <span class="toc-text">axios</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">25.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8"><span class="toc-number">25.2.</span> <span class="toc-text">开始使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><span class="toc-number">25.3.</span> <span class="toc-text">常见用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">25.4.</span> <span class="toc-text">响应结果结构分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">25.5.</span> <span class="toc-text">案例分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88%E7%9A%84axios"><span class="toc-number">25.6.</span> <span class="toc-text">实现一个简易版的axios</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">26.</span> <span class="toc-text">文件上传怎么做</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#input%E6%A0%87%E7%AD%BE"><span class="toc-number">26.1.</span> <span class="toc-text">input标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E5%AF%B9%E8%B1%A1"><span class="toc-number">26.2.</span> <span class="toc-text">File对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileReader"><span class="toc-number">26.3.</span> <span class="toc-text">FileReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URL-createObjectURL-file-blob"><span class="toc-number">26.4.</span> <span class="toc-text">URL.createObjectURL(file&#x2F;blob)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FormData"><span class="toc-number">26.5.</span> <span class="toc-text">FormData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%B1%95%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">26.6.</span> <span class="toc-text">图像展示方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8F%AF%E4%B8%8A%E4%BC%A0%E6%A0%BC%E5%BC%8F"><span class="toc-number">26.7.</span> <span class="toc-text">文件可上传格式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/19656fd5.html" title="react">react</a><time datetime="2025-02-20T13:33:23.000Z" title="发表于 2025-02-20 21:33:23">2025-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/518e617c.html" title="git"><img src="/images/cover/dog.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="git"></a><div class="content"><a class="title" href="/posts/518e617c.html" title="git">git</a><time datetime="2025-02-09T08:07:36.000Z" title="发表于 2025-02-09 16:07:36">2025-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e255a10a.html" title="计算机网络"><img src="/images/cover/maomao.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="计算机网络"></a><div class="content"><a class="title" href="/posts/e255a10a.html" title="计算机网络">计算机网络</a><time datetime="2025-02-07T15:08:21.000Z" title="发表于 2025-02-07 23:08:21">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4b0178e0.html" title="数据结构与算法"><img src="/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="数据结构与算法"></a><div class="content"><a class="title" href="/posts/4b0178e0.html" title="数据结构与算法">数据结构与算法</a><time datetime="2025-02-07T14:48:29.000Z" title="发表于 2025-02-07 22:48:29">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d04bd5bc.html" title="操作系统"><img src="/images/cover/%E6%98%9F%E7%A9%BA.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="操作系统"></a><div class="content"><a class="title" href="/posts/d04bd5bc.html" title="操作系统">操作系统</a><time datetime="2025-02-06T15:49:56.000Z" title="发表于 2025-02-06 23:49:56">2025-02-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/images/cover/1.png)"><div id="footer-wrap"><div class="footer_custom_text"><div id="sanye"><svg class="icon" aria-hidden="true"><use href="#icon-banquan"></use></svg><span>2024 - 2025 By 三叶sanye</span><svg class="icon" aria-hidden="true"><use href="#icon-sanyecao"></use></svg></div><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://unpkg.com/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/time.js"></script><script src="/js/iconfont.js"></script><script defer id="ribbon" src="https://unpkg.com/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script src="https://unpkg.com/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://unpkg.com/butterfly-extsrc/dist/click-heart.min.js" async mobile="false"></script><script async data-pjax src="/js/busuanzi.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,display:{position:"left",width:120,height:240},mobile:{show:!0},react:{opacity:.7}})</script></body></html>
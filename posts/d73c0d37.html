<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>前端面试---es6 | 三叶的博客</title><meta name="author" content="三叶sanye"><meta name="copyright" content="三叶sanye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="var,let,const有哪些区别在ES5中，顶层对象（在浏览器中是window）的属性和全局变量是等价的，或者说全局变量会被挂载到window对象中  变量提升 var声明的变量存在变量提升，变量提升只提升变量声明，不提升变量赋值。而let和const不存在变量提升  重复声明 var声明的变量可以被重复声明，后面声明的会覆盖前面声明的。而let和const声明的变量无法被重复声明。  作用域"><meta property="og:type" content="article"><meta property="og:title" content="前端面试---es6"><meta property="og:url" content="https://www.sanye.blog/posts/d73c0d37.html"><meta property="og:site_name" content="三叶的博客"><meta property="og:description" content="var,let,const有哪些区别在ES5中，顶层对象（在浏览器中是window）的属性和全局变量是等价的，或者说全局变量会被挂载到window对象中  变量提升 var声明的变量存在变量提升，变量提升只提升变量声明，不提升变量赋值。而let和const不存在变量提升  重复声明 var声明的变量可以被重复声明，后面声明的会覆盖前面声明的。而let和const声明的变量无法被重复声明。  作用域"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.sanye.blog/images/cover/%E9%9F%B6%E5%8D%8E%E5%88%9D%E9%9F%B3.jpg"><meta property="article:published_time" content="2025-01-04T15:43:09.000Z"><meta property="article:modified_time" content="2025-03-12T15:23:00.437Z"><meta property="article:author" content="三叶sanye"><meta property="article:tag" content="es6"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.sanye.blog/images/cover/%E9%9F%B6%E5%8D%8E%E5%88%9D%E9%9F%B3.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.sanye.blog/posts/d73c0d37.html"><link rel="preconnect" href="//unpkg.com"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>(()=>{const t={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:t,getScript:(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach((([e,t])=>n.setAttribute(e,t))),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),getCSS:(e,t)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)})),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const o=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},a=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=o,btf.activateLightMode=a;const n=t.get("theme"),r=window.matchMedia("(prefers-color-scheme: dark)"),c=window.matchMedia("(prefers-color-scheme: light)");if(void 0===n){if(c.matches)a();else if(r.matches)o();else{const e=(new Date).getHours();e<=6||e>=18?o():a()}r.addEventListener("change",(()=>{void 0===t.get("theme")&&(e.matches?o():a())}))}else"light"===n?a():o();const d=t.get("aside-status");void 0!==d&&document.documentElement.classList.toggle("hide-aside","hide"===d);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"未找到符合您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"复制成功",error:"复制失败",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"null",Snackbar:{chs_to_cht:"已切换为繁体中文",cht_to_chs:"已切换为简体中文",day_to_night:"已切换为深色模式",night_to_day:"已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-center"},infinitegrid:{js:"https://unpkg.com/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"前端面试---es6",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,isShuoshuo:!1}</script><link rel="stylesheet" href="/css/bilibiliBanner.css" media="defer" onload='this.media="screen"'><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/time.css"><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="iron-container iron-circle"><div class="iron-box1 iron-circle iron-center"></div><div class="iron-box2 iron-circle iron-center"></div><div class="iron-box3 iron-circle iron-center"></div><div class="iron-box4 iron-circle iron-center"></div><div class="iron-box5 iron-circle iron-center"></div><div class="iron-box6 iron-circle"><div class="iron-coil" style="--i:0"></div><div class="iron-coil" style="--i:1"></div><div class="iron-coil" style="--i:2"></div><div class="iron-coil" style="--i:3"></div><div class="iron-coil" style="--i:4"></div><div class="iron-coil" style="--i:5"></div><div class="iron-coil" style="--i:6"></div><div class="iron-coil" style="--i:7"></div></div></div></div><script>(()=>{const d=document.getElementById("loading-box"),e=document.body,o=()=>{e.style.overflow="",d.classList.add("loaded")},l=()=>{e.style.overflow="hidden",d.classList.remove("loaded")};l(),window.addEventListener("load",o)})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/%E4%B8%89%E5%8F%B6.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/images/cover/韶华初音.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name iconfont icon-sanyecao">三叶的博客</span></a><a class="nav-page-title" href="/"><span class="site-name iconfont icon-sanyecao">前端面试---es6</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">前端面试---es6<a class="post-edit-link" href="https://github.com/shiyuhuiya/shiyuhuiya.github.io/issues_posts/前端面试-es6.md" rel="external nofollow noreferrer" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-04T15:43:09.000Z" title="发表于 2025-01-04 23:43:09">2025-01-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-12T15:23:00.437Z" title="更新于 2025-03-12 23:23:00">2025-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">前端面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-03-12 23:23:00&quot;}" hidden></div><h1 id="var-let-const有哪些区别"><a href="#var-let-const有哪些区别" class="headerlink" title="var,let,const有哪些区别"></a>var,let,const有哪些区别</h1><p>在ES5中，顶层对象（在浏览器中是<code>window</code>）的属性和全局变量是等价的，或者说全局变量会被挂载到<code>window</code>对象中</p><ul><li><p><strong>变量提升</strong></p><p><code>var</code>声明的变量存在<strong>变量提升</strong>，变量提升只提升<strong>变量声明</strong>，不提升<strong>变量赋值</strong>。而<code>let</code>和<code>const</code>不存在变量提升</p></li><li><p><strong>重复声明</strong></p><p>var声明的变量可以被<code>重复声明</code>，后面声明的会<strong>覆盖</strong>前面声明的。而<code>let</code>和<code>const</code>声明的变量无法被<code>重复声明</code>。</p></li><li><p><strong>作用域</strong></p><p>var声明的变量只会产生<code>函数作用域</code>，不会产生<strong>块级作用域</strong></p><p>let用来声明一个<code>变量</code>，会产生一个<strong>块级作用域</strong>，</p><p>const用来声明一个<code>常量</code>，也会产生一个<strong>块级作用域</strong>。</p></li></ul><h2 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h2><p>只有<code>var声明的变量</code>才存在变量提升，只有<code>具名函数</code>才存在函数提升。</p><p>函数提升优先级比变量提升要高，且不会被变量声明覆盖，但是会被<code>变量赋值</code>覆盖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);<span class="comment">//输出函数ƒ foo()&#123;...&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数声明&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;变量&quot;</span>;<span class="comment">//后声明，后赋值</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数声明&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);<span class="comment">//输出`123`</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数声明&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);<span class="comment">//输出`123`</span></span><br></pre></td></tr></table></figure><p>简单的来说，当输出foo变量会导致输出<code>undefined</code>的时候，那输出的就是foo函数，否则就输出foo变量，<strong>赋值后的变量优先级最高</strong>。</p><h2 id="数组新增了哪些扩展"><a href="#数组新增了哪些扩展" class="headerlink" title="数组新增了哪些扩展"></a>数组新增了哪些扩展</h2><h3 id="扩展运算符-…"><a href="#扩展运算符-…" class="headerlink" title="扩展运算符 …"></a>扩展运算符 …</h3><p>扩展运算符的作用就是把<code>数组</code>变成一个<code>序列</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">//等同于console.log(1,2,3)</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>用来展开数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...arr)<span class="comment">//求数组arr的最大值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>用来合并，拷贝数组</strong></p><p>拷贝数组进行的是<code>浅层次</code>的拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [...arr1,...arr2]</span><br></pre></td></tr></table></figure></li><li><p><strong>将对象转化成数组</strong></p><p>定义了遍历器（Iterator）接口的对象（可迭代对象），都可以用扩展运算符转为真正的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.<span class="title function_">keys</span>()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>如果对没有 <code>Iterator</code> 接口的对象，使用扩展运算符，将会报错，因为这些对象是<code>不可迭代</code>的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure><p>除非写成<code>&#123;...obj&#125;</code>的形式，表示拷贝对象。</p></li></ul><h3 id="构造函数Array的新增方法"><a href="#构造函数Array的新增方法" class="headerlink" title="构造函数Array的新增方法"></a>构造函数Array的新增方法</h3><p>关于构造函数，数组新增的方法有如下：</p><ul><li>Array.from()</li><li>Array.of()</li></ul><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>将两类对象转为真正的数组：类似数组的对象(<code>伪数组</code>)和<code>可迭代对象</code>（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>还可以接受<code>第二个参数</code>，用来对每个元素进行处理，将处理后的值放入返回的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)<span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p>用于将一组值，转换为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br></pre></td></tr></table></figure><p>当参数只有一个的时候，实际上是指定数组的长度</p><p>参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>() <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><h3 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h3><ul><li>find()、findIndex()</li><li>fill()</li><li>entries()，keys()，values()</li><li>includes()</li></ul><h4 id="find-findIndex"><a href="#find-findIndex" class="headerlink" title="find,findIndex"></a>find,findIndex</h4><p><code>find()</code>用于找出，返回第一个符合条件的数组成员</p><p>参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]</span><br><span class="line">a.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 返回10</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findIndex`返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1</span><br><span class="line">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;</span><br><span class="line">  return value &gt; 9;</span><br><span class="line">&#125;) // 2</span><br></pre></td></tr></table></figure><h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p>使用给定值，填充一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure><p>还可以接受第二个和第三个参数，用于指定填充的<code>起始位置</code>和<code>结束位置</code>，左闭右开</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，如果填充的类型为对象，则是浅拷贝，即被填充的数据，使用的都是同一个对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">fill</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">//[&#123;name:&#x27;tom&#x27;&#125;,&#123;name:&#x27;tom&#x27;&#125;] 数组中的这两个对象是同一个对象</span></span><br></pre></td></tr></table></figure><p>除非每次填充都使用新创建的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">fill</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h4 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h4><p>用于判断数组是否包含给定的值，相比<code>indexOf</code>方法，优化了对<code>NaN</code>的判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="函数新增了哪些扩展"><a href="#函数新增了哪些扩展" class="headerlink" title="函数新增了哪些扩展"></a>函数新增了哪些扩展</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>ES6</code>允许为函数的参数设置<code>默认值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">//输出 Hello World</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">//输出 Hello China</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>)  <span class="comment">//输出 Hello</span></span><br></pre></td></tr></table></figure><p>函数的形参是<strong>默认声明</strong>的，不能使用<code>let</code>或<code>const</code>再次声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = <span class="number">5</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>解构赋值</code>过程中也可以给<code>形参</code>添加<code>默认值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line"><span class="title function_">foo</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line"><span class="title function_">foo</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>函数本质也是个对象，有许多属性</p><ul><li><p><code>func.length</code></p><p>将返回没有指定<code>默认值</code>的参数个数，具体情况还得具体分析，感觉很鸡肋。</p></li><li><p><code>func.name</code></p><p>如果把<code>匿名函数</code>赋值给一个变量，则name属性返回这个变量的名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.<span class="property">name</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.<span class="property">name</span> <span class="comment">// &quot;f&quot;</span></span><br></pre></td></tr></table></figure><p>如果将一个<code>具名函数</code>赋值给一个变量，则 <code>name</code>属性都返回这个<code>具名函数</code>原本的名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">bar.<span class="property">name</span> <span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure><p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">foo.<span class="title function_">bind</span>(&#123;&#125;).<span class="property">name</span> <span class="comment">// &quot;bound foo&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个<strong>单独的作用域</strong></p><p>等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的</p><p>下面例子中，<code>y=x</code>会形成一个单独作用域，<code>x</code>没有被定义，所以指向全局变量<code>x</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">y = x</span>) &#123; </span><br><span class="line">  <span class="comment">// 等同于 let y = x  </span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ul><li><p>必须写在<code>当前作用域</code>的<code>作用域顶部</code>才能生效</p></li><li><p>当一个函数被直接调用，无论这个函数在哪儿被直接调用，先看<code>全局作用域</code>中是否开启了严格模式，如果开启了，则this指向<code>undefined</code>，如果未开启，再查看这个被直接调用的函数内部，是否开启了严格模式，如果开启了，则this指向undefined，否则this指向全局对象，在浏览器中指的就是window对象</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">117</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>.<span class="property">num</span>);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">//undefined</span></span><br><span class="line">  <span class="title function_">func1</span>();<span class="comment">//函数func1直接被调用，全局作用域和这个函数内部都未开启严格模式，this指向window输出117</span></span><br><span class="line">&#125;)()<span class="comment">//立即执行函数，属于直接被调用</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">117</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>.<span class="property">num</span>);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">//undefined</span></span><br><span class="line">  <span class="title function_">func1</span>();<span class="comment">//函数func1直接被调用，全局作用域开启了严格模式，this指向undefeined</span></span><br><span class="line"><span class="comment">//立即执行函数，属于直接被调用，全局作用域开启了严格模式，所以this=undefined</span></span><br></pre></td></tr></table></figure><p>只要<code>函数形参</code>使用了<code>默认值</code>、<code>解构赋值</code>、或者<code>扩展运算符</code>，那么函数内部就<strong>不能显式设定为严格模式</strong>，否则会报错。所以说函数内部也不能随便开启严格模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a, b = a</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="keyword">function</span> (<span class="params">&#123;a, b&#125;</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">doSomething</span> = (<span class="params">...a</span>) =&gt; &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="title function_">doSomething</span>(<span class="params">&#123;a, b&#125;</span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>形如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()=&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>更适用于那些本来 需要<code>匿名函数</code>的地方，类似<code>lambda</code>表达式，它和普通<code>匿名函数</code>一样，它属于<code>表达式函数</code>，不存在<code>函数提升</code></p></li><li><p>只有一个<code>参数</code>的时候可以省略括号；只有一行代码且是<code>return</code>语句，可以省略<code>大括号</code>和<code>return</code>关键字，如果返回的是一个对象，则需要加括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item =&gt; item.<span class="property">name</span> <span class="comment">//等同于(item)=&gt;&#123; return item.name &#125;</span></span><br><span class="line">item =&gt; (&#123;<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>没有自己的<strong>环境变量</strong><code>this</code>，内部的this指向被定义的时候<code>外层函数</code>的this，<strong>this指向和如何被调用无关</strong></p></li><li><p>因为没有自己的环境变量<code>this</code>，所以无法使用<code>apply</code>，<code>call</code>，<code>bind</code>等方法改变箭头函数内部的<code>this</code>指向，但是可以<code>调用</code>这些方法。</p></li><li><p>内部也没有<code>arguments</code>对象。<code>arguments</code>在一般函数内部可以直接使用（如同this），即便函数没有形参，也可以给函数传参，传递的所有参数都会被收集到arguments对象</p></li><li><p>没有自己的<code>原型对象（prototype）</code>，所以不能当作<code>构造函数</code>使用，不能用来创造实例。</p></li><li><p>内部不可以使用<code>yield</code>命令，因此箭头函数不能用作 <code>Generator</code> 函数</p></li></ul><h2 id="对象新增了哪些扩展"><a href="#对象新增了哪些扩展" class="headerlink" title="对象新增了哪些扩展"></a>对象新增了哪些扩展</h2><h3 id="属性的简写"><a href="#属性的简写" class="headerlink" title="属性的简写"></a>属性的简写</h3><p>ES6中，当对象键名与对应值名相等的时候，可以进行简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>:foo&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;</span><br></pre></td></tr></table></figure><p>方法也能够进行简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="comment">//这是一种简写方式</span></span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><p>eS6 允许字面量定义对象时，将表达式放在中括号内，当作对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastWord = <span class="string">&#x27;last word&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="string">&#x27;first word&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  [lastWord]: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;first word&#x27;</span>] <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">a[lastWord] <span class="comment">// &quot;world&quot;</span></span><br><span class="line">a[<span class="string">&#x27;last word&#x27;</span>] <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>注意，<code>属性名表达式</code>与<code>属性名简写</code>，不能同时使用，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo]: foo&#125;;</span><br></pre></td></tr></table></figure><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的<code>原型对象</code></p><p>即<code>super=this.__proto__</code></p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>这项特性允许开发者从复杂的数据结构如对象或数组中提取数据，并直接将这些数据赋值给变量。这种机制不仅使得代码更加简洁易读，还提高了开发效率。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;New York&quot;</span>,</span><br><span class="line">        <span class="attr">country</span>: <span class="string">&quot;USA&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ES6的对象解构赋值</span></span><br><span class="line"><span class="keyword">const</span> &#123; firstName, lastName, age &#125; = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstName); <span class="comment">// 输出: John</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lastName);  <span class="comment">// 输出: Doe</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);       <span class="comment">// 输出: 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果你想使用不同的变量名，可以这样做：</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">firstName</span>: localFirstName, <span class="attr">lastName</span>: localLastName &#125; = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localFirstName); <span class="comment">// 输出: John</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localLastName);  <span class="comment">// 输出: Doe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构嵌套对象</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">address</span>: &#123; city, country &#125; &#125; = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(city);   <span class="comment">// 输出: New York</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(country);<span class="comment">// 输出: USA</span></span><br></pre></td></tr></table></figure><p>要注意的是因为使用的是const关键字，所以上述解构赋值得到的数据都是常量。</p><h2 id="如何理解ES6新增Set、Map两种数据结构"><a href="#如何理解ES6新增Set、Map两种数据结构" class="headerlink" title="如何理解ES6新增Set、Map两种数据结构"></a>如何理解ES6新增Set、Map两种数据结构</h2><p><code>Set</code>是一种叫做<code>集合</code>的数据结构，什么是集合？什么又是字典？</p><ul><li>集合<br>是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合</li><li>字典<br>是一些元素的集合。每个元素有一个称作key 的域，不同元素的key各不相同</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>Set</code>本身是一个构造函数，用来生成Set数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br></pre></td></tr></table></figure><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p><code>Set</code>的实例关于增删改查的方法：</p><ul><li><p>add()</p><p>向集合中添加元素，返回 <code>Set</code> 结构本身，所以可以<code>链式调用</code></p><p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加，即会被<code>去重</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">2</span>); <span class="comment">// 2只被添加了一次</span></span><br></pre></td></tr></table></figure></li><li><p>delete()</p><p>删除某个值，返回一个<code>布尔值</code>，表示删除是否成功</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">delete</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>has()</p><p>返回一个<code>布尔值</code>，判断集合中是否存在某个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>clear()</p><p>清除所有成员，没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure></li></ul><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>关于遍历的方法，有如下：</p><ul><li>keys()：返回<code>键名</code>的迭代器</li><li>values()：返回<code>键值</code>的迭代器</li><li>entries()：返回<code>键值对</code>的迭代器</li><li>forEach()：使用回调函数遍历每个成员</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看出Set其实就是键和值相等的Map</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="comment">//每个entry的类型是数组，第一个元素是键名，第二个元素是键值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到其实Set的本质就是Map</span></span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure><p><strong>forEach</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>扩展运算符和<code>Set</code> 结构相结合实现<code>数组</code>或<code>字符串</code>去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 创建一个集合的同时传入一个数组，然后再把这个集合转变成数组，从而起到去重的作用</span></span><br><span class="line"><span class="comment">// 说明Set实例也是可迭代对象，所以能够转化成数组</span></span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]; <span class="comment">// [3, 5, 2]</span></span><br><span class="line"><span class="comment">// 或者let unique = Array.from(new Set(arr)) </span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;352255&quot;</span>;</span><br><span class="line"><span class="comment">//竟然还能传入一个字符串？给字符串去重，因该是把字符串拆分成了字符数组</span></span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(str)].<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// &quot;352&quot;</span></span><br></pre></td></tr></table></figure><p>下面的例子说明无论是map还是map.keys()都能转换成数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">   [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">   [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">   [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...map.<span class="title function_">keys</span>()])<span class="comment">//[1, 2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...map])<span class="comment">// [[1, &#x27;one&#x27;] (2) [2, &#x27;two&#x27;] (2) [3, &#x27;three&#x27;]]</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p><p><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br></pre></td></tr></table></figure><h4 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h4><p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p><ul><li><p>size 属性</p><p><code>size</code>属性返回键值对的个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>set()</p><p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个Map结构</p><p>如果<code>key</code>已经有值，则键值会被<code>更新</code>，否则就新生成该键</p><p>同时返回的是当前<code>Map</code>对象，可采用<code>链式写法</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>).<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>) <span class="comment">// 链式操作</span></span><br></pre></td></tr></table></figure></li><li><p>get()</p><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到key，返回<code>undefined</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line"></span><br><span class="line">const hello = function() &#123;console.log(&#x27;hello&#x27;);&#125;;</span><br><span class="line">m.set(hello, &#x27;Hello ES6!&#x27;) // 键是函数</span><br><span class="line"></span><br><span class="line">m.get(hello)  // Hello ES6!</span><br></pre></td></tr></table></figure></li><li><p>has()</p><p><code>has</code>方法返回一个布尔值，表示某个<code>键</code>是否在当前 Map 对象之中，类似于Obj中的<code>hasOwnProperty</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;edition&#x27;</span>)     <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;years&#x27;</span>)       <span class="comment">// false</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>delete()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete`方法删除某个键，返回`true`。如果删除失败，返回`false</span><br><span class="line">const m = new Map();</span><br><span class="line">m.set(undefined, &#x27;nah&#x27;);</span><br><span class="line">m.has(undefined)     // true</span><br><span class="line"></span><br><span class="line">m.delete(undefined)</span><br><span class="line">m.has(undefined)       // false,删除后不再存在</span><br></pre></td></tr></table></figure></li><li><p>clear()</p><p><code>clear</code>方法清除所有成员，没有返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">clear</span>()</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><ul><li>keys()：返回<code>键名</code>的迭代器</li><li>values()：返回<code>键值</code>的迭代器</li><li>entries()：返回<code>键值对</code>的迭代器</li><li>forEach()：遍历 Map 的所有成员</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个二维数组说是</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;T&#x27;</span>,  <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()，默认调用entries方法得到键值对迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map中的forEach的用法和set中的一样</span></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Map和Obj的区别"><a href="#Map和Obj的区别" class="headerlink" title="Map和Obj的区别"></a>Map和Obj的区别</h4><p>很多时候我们都可以使用Obj来实现Map的功能，毕竟都是键值对的形式，那二者具体有什么区别呢，Map被设计出来有什么优势呢？</p><p><strong>键值对顺序</strong></p><ul><li>**<code>Object</code>**：虽然 ES6 之后的对象保留了属性插入的顺序（对于可枚举属性），但这种顺序性并不是所有情况下都保证的，特别是对于旧版浏览器。</li><li><strong><code>Map</code><strong>：<code>Map</code> 明确</strong>保持键值对插入的顺序</strong>。这意味着你可以依赖于键值对，按照它们被添加的顺序进行迭代</li></ul><p><strong>获取大小</strong></p><ul><li><p><code>Object</code></p><p>没有直接的方法来获取对象中属性的数量。你需要手动计算，例如通<code>Object.keys()</code>计算返回的数组的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">console.log(Object.keys(obj).length); // 输出 2</span><br></pre></td></tr></table></figure></li><li><p><code>Map</code>提供了size属性，可以直接获取键值对的数量。</p></li></ul><p><strong>性能</strong></p><p>在频繁地增删键值对时，<code>Map</code> 的性能通常优于 <code>Object</code>。这是因为 <code>Map</code> 是专门为动态场景设计的，而对象更适合静态结构的数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Set对应数据结构中的<code>集合</code>，Map对应数据结构中的<code>字典</code></li><li>Set本质是键和值相同的Map</li><li>Set和Map都有<code>has，clear，delete</code>这三个方法；</li><li>Set独有的方法的是<code>add</code>，返回Set实例本身，支持链式调用；Map独有的方法是<code>get，set</code>，其中set方法返回的也是Map实例本身，也支持链式调用。</li><li>Set和Map的遍历的方法都包括<code>for...of...</code>和<code>forEach</code>，其中<code>for...of...</code>的对象又包括各种迭代器。</li></ul><h2 id="你是怎么理解es6中-Promise的"><a href="#你是怎么理解es6中-Promise的" class="headerlink" title="你是怎么理解es6中 Promise的"></a>你是怎么理解es6中 Promise的</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>是<code>异步编程</code>的一种<code>解决方案</code>，比传统的解决方案—<code>回调函数</code>，更加合理和更加强大</p><p>因为使用<code>回调函数</code>来解决异步编程问题，存在<code>回调函数地狱问题</code>，即在回调函数中嵌套回调函数，这样就导致代码的可读性变得很差，代码也变得难以维护。</p><p>而使用<code>promise</code>解决异步编程操作有如下优点：</p><ul><li><code>链式操作</code>减低了编码难度</li><li>代码可读性明显增强</li></ul><p>下面我们来正式介绍promise：</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><code>promise</code>对象仅有三种状态</p><ul><li><code>pending</code>（进行中）</li><li><code>fulfilled</code>（已成功）</li><li><code>rejected</code>（已失败）</li></ul><p>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</p><p>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变</p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">//构造器内部代码从给出的resolve, reject中选一个调用，改变promise对象的状态</span></span><br><span class="line">    <span class="comment">//构造器内部的代码会立即执行，但是resolve/reject可能被异步调用</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code></p><ul><li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从<code>pending</code>变为<code>fulfilled</code></li><li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从<code>pending</code>变为<code>rejected</code></li></ul><p><code>Promise</code>构建出来的实例存在以下方法：</p><ul><li>then()</li><li>catch()</li><li>finally()</li></ul><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p><code>then</code>方法会立即调用，但是它传入的回调函数，会等到实例状态发生改变时才被调用，第一个参数是<code>resolved</code>状态会触发的回调函数，第二个参数是<code>rejected</code>状态会触发的回调函数</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例，而且是<strong>立即返回</strong>，也就是<code>promise</code>能链式书写的原因。</p><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p><code>catch()</code>方法用于指定发生错误时的回调函数，本质就是在内部调用<code>then(undefined,onRejected)</code></p><p>通常情况下，我们使用<code>then</code>的时候只传入第一个参数，即成功时的回调函数；然后再搭配<code>catch</code>使用，传入失败时的回调函数。</p><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作，内部其实本质就是在调用<code>then(onFinally,onFinally)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>Promise</code>构造函数存在以下方法：</p><ul><li>all()</li><li>race()</li><li>allSettled()</li><li>resolve()</li><li>reject()</li></ul><p>promise的静态方法的返回值都是promise对象</p><p>关于这几个静态方法的详细介绍，参考手写promise部分。</p><h3 id="手写一个Promise"><a href="#手写一个Promise" class="headerlink" title="手写一个Promise"></a>手写一个Promise</h3><p>为了帮助我们更深入的理解Promise，建议尝试自己手写一个Promise</p><p>参考资料：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/BV1mH4y1Q7Z7?spm_id_from=333.788.videopod.episodes&vd_source=00483a04a5a69136669373a8ea522a9b&p=17">Day02-01.手写promise-核心功能-构造函数_哔哩哔哩_bilibili</a></p><p><strong>任务目标</strong></p><ul><li><p><strong>创建一个myPromise类，处理同步修改promise状态的情况</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPromise</span> &#123;</span><br><span class="line">    state = <span class="variable constant_">PENDING</span><span class="comment">//默认值</span></span><br><span class="line">    result</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">func</span>) &#123;</span><br><span class="line">      <span class="comment">//func是创建promise实例的时候，传入的回调函数</span></span><br><span class="line">      <span class="comment">//这个回调函数接受两个参数resolve，reject，我们在构造函数内部准备这两个方法</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">res</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还没有改变</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">          <span class="comment">//那就改变它的状态为&#x27;fulfilled&#x27;</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">          <span class="comment">//res是传入的值</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">result</span> = res</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">err</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还没有改变</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">          <span class="comment">//那就改变它的状态为&#x27;rejected&#x27;</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">result</span> = err</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//因为用户传入的回调函数func本身也可能报错，所以我们用try-catch捕获一下</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//同步调用传入的回调函数，传入2个在构造函数内部定义好的，能改变promise实例状态的函数</span></span><br><span class="line">        <span class="comment">//由用户决定何时，如何改变promise实例的状态</span></span><br><span class="line">        <span class="title function_">func</span>(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暂时只考虑同步修改promise状态，也就是then方法被调用的时候，promise的状态就已经被确定了</span></span><br><span class="line">    <span class="comment">//这样我们就能立马知道应该调用哪个回调函数</span></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">onFulFilled, onRejected</span>) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">         	<span class="title function_">onFulFilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">            <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//同步修改promise状态</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//因为p的状态在刚被创建的时候就改变了，then方法传入的回调函数也会马上执行，拿到p实例的值</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(res)&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(err)&#125;)<span class="comment">//立即输出1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>处理异步修改promise状态的情况</strong></p><p>如果我们promise的状态是异步改变的，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1s后，再调用resolve方法，把promise实例的状态修改为&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="title function_">resolve</span>(<span class="number">1</span>)&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>创建完实例p后我们同步调用<code>then</code>方法（调用then方法本身是同步的，创建promise对象，创建promise实例调用构造函数本身也是同步的）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(res)&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(err)&#125;)</span><br></pre></td></tr></table></figure><p><code>then</code>方法在内部拿到实例的<code>state</code>后，遗憾的告知传入的2个回调函数，实例的状态还未改变，你们都不能被调用，而且我也不知道你们俩该什么时候被调用，所以<code>then</code>方法把这2个回调函数<strong>托管</strong>给别人，这个人就是<strong>handle数组</strong>。</p><p>我们希望promise状态改变的时候，传入<code>then</code>方法的2个回调函数有一个会被执行，那什么时候promise状态会改变呢？1s之后，还是2s之后？我们貌似找不到一个固定的时间点，其实能让promise状态改变的，就是在构造函数内部定义的那2个函数，它们其中任意一个被调用的时候，就是promise状态被改变的时候，而这2个函数何时被调用，又是由创建promise实例的时候传入的函数决定的。</p><p>所以我们将传入then方法的回调函数，放到在构造函数内部定义的那2个函数中执行，就能完美处理异步的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPromise</span> &#123;</span><br><span class="line">    state = <span class="variable constant_">PENDING</span><span class="comment">//默认值</span></span><br><span class="line">    result</span><br><span class="line">    #handler = []</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">func</span>) &#123;</span><br><span class="line">      <span class="comment">//func是创建promise实例的时候，传入的回调函数</span></span><br><span class="line">      <span class="comment">//这个回调函数接受两个参数resolve，reject，我们在构造函数内部准备这两个方法</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">res</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还没有改变</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">          <span class="comment">//那就改变它的状态为&#x27;fulfilled&#x27;</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">          <span class="comment">//res是传入的值</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">result</span> = res</span><br><span class="line">          <span class="comment">//resolve函数执行之时，就是promise状态改变之时，就是传入then方法的回调函数该被调用的时候</span></span><br><span class="line">          <span class="variable language_">this</span>.#handler.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123; item.<span class="title function_">onFulFilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>) &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">err</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还没有改变</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">          <span class="comment">//那就改变它的状态为&#x27;rejected&#x27;</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">result</span> = err</span><br><span class="line">          <span class="comment">//reject函数执行之时，就是promise状态改变之时，就是传入then方法的回调函数该被调用的时候</span></span><br><span class="line">          <span class="variable language_">this</span>.#handler.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123; item.<span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>) &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//同步调用传入的回调函数，传入2个准备好的能改变promise实例状态的函数</span></span><br><span class="line">      <span class="comment">//因为用户传入的回调函数func本身也可能报错，所以我们用try-catch捕获一下</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">func</span>(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暂时只考虑同步修改promise状态</span></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">onFulFilled, onRejected</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="comment">//执行传入的回调函数，并把值暴露出去</span></span><br><span class="line">        <span class="title function_">onFulFilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="comment">//执行传入的回调函数，并把值暴露出去</span></span><br><span class="line">        <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还未改变,就先把传入的回调函数委托给别人，也可以理解为放入任务队列中</span></span><br><span class="line">        <span class="variable language_">this</span>.#handler.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onFulFilled</span><br><span class="line">          , onRejected</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="number">123</span>) &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(res) &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(err) &#125;)<span class="comment">//1s后输出123</span></span><br></pre></td></tr></table></figure></li><li><p><strong>处理then的返回值</strong></p><p>因为then方法是支持<code>链式调用</code>的，<strong>意味着then方法的返回值也是一个promise对象</strong>，如何确定返回的promise实例的<strong>状态和值</strong>呢？</p><p>then方法把传入的<code>回调函数</code>的返回值，包装成<code>promise</code>对象后返回，这就意味着我们不能只简单的调用传入的回调函数，还要关注它们的返回值。</p><p>我们先修改一下then方法，确保能返回一个<code>promise</code>对象，这样书写并不会改变代码原有的功能，<strong>因为构造函数中的代码是立即执行的</strong>，原来的代码也是同步执行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulFilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//原来的代码顶部------------</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="title function_">onFulFilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还未改变</span></span><br><span class="line">        <span class="variable language_">this</span>.#handler.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onFulFilled</span><br><span class="line">          , onRejected</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">//原来的代码底部---------------</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再思考返回的<code>promise</code>对象的状态与值如何确定，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulFilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//无论同步还是异步，我们都把传入的回调函数交给构造函数中定义的那2个函数来执行，简化了代码</span></span><br><span class="line">        <span class="comment">//可以注意到onFulFilled/onRejected, resolve, reject这几个方法都没在then函数中调用</span></span><br><span class="line">        <span class="comment">//但是只要保证“这个函数是这个函数，无论它在哪里被调用，都会起到本来的作用”</span></span><br><span class="line">        <span class="variable language_">this</span>.#handler.<span class="title function_">push</span>(&#123;</span><br><span class="line">          <span class="attr">onFulFilled</span>:<span class="function">()=&gt;</span>&#123;<span class="variable language_">this</span>.<span class="title function_">wrap</span>(onFulFilled, resolve, reject)&#125;</span><br><span class="line">          , <span class="attr">onRejected</span>:<span class="function">()=&gt;</span>&#123;<span class="variable language_">this</span>.<span class="title function_">wrap</span>(onRejected, resolve, reject)&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个wrap方法到底做了什么？</span></span><br><span class="line"><span class="comment">//1.调用传入的回调函数</span></span><br><span class="line"><span class="comment">//2.分析回调函数的返回值，调用用resolve或者reject方法</span></span><br><span class="line"><span class="comment">//传入的resolve,reject，是被用来修改then方法返回的myPromise实例的状态的</span></span><br><span class="line"><span class="title function_">wrap</span>(<span class="params">func, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">//wrap中this的指向等于then的this指向,指向同一个promise对象</span></span><br><span class="line">    <span class="comment">//因为调用传入的onFulFilled/onRejected函数可能会报错，所以使用try-catch捕获</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//需要拿到返回值，来确定then函数返回的promise实例的状态</span></span><br><span class="line">      <span class="keyword">const</span> x = <span class="title function_">func</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      <span class="comment">//如果返回的是一个myPromise对象，它的状态可能是同步改变或者异步改变</span></span><br><span class="line">      <span class="comment">//因为我们已经解决了异步回调的情况的，所以也能通过then方法拿到它的result，</span></span><br><span class="line">      <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">        <span class="comment">//wow，相当于由一个promise对象的状态来确定另一个promise的状态</span></span><br><span class="line">        x.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="title function_">resolve</span>(res) &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="title function_">reject</span>(err) &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果返回值不是myPromise对象，那就简单了，直接resolve</span></span><br><span class="line">        <span class="title function_">resolve</span>(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">//如果报错直接返回状态为rejeted的promise实例</span></span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个1s后状态改变的promise对象</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="number">1</span>) &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(err) &#125;)</span><br><span class="line"><span class="comment">//第一次调用then方法立马返回一个promise对象，但是由于对象的状态还未确定，2s后才会打印出2</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(res) &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(err) &#125;)</span><br></pre></td></tr></table></figure><ul><li>p调用then方法，因为p状态未确定，回调函数被<code>wrap</code>包装，然后push到<code>#handler</code></li><li>虽然传入的回调函数没有立马被调用，但是then方法已经返回了一个状态未改变的promise对象</li><li>第一个then方法返回的对象状态未改变，第2次then的调用执行了，但是没动静</li><li>1s后，因为在构造函数内调用<code>resolve(1)</code>方法，p的状态改变，遍历执行<code>#handler</code>中的待执行的回调函数，执行被包装的回调函数</li><li>执行被包装的函数，也就是<code>第一个then</code>传入的第一个回调函数，输出1，再等待1s后，调用<code>resolve(2)</code>方法<br>此时第一个then方法返回的对象状态也被改变，于是第二个then传入的回调函数也被触发，输出2。</li></ul><img src="..\images\前端面试-js\promise.png" style="zoom:67%"></li><li><p>实现<code>catch</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>finally</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">finally</span>(<span class="params">onFinally</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">then</span>(onFinally, onFinally)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>resolve</code>静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">res</span>) &#123;</span><br><span class="line">   <span class="comment">//如果本来就是myPromise实例，则直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (res <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">     <span class="keyword">return</span> res</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="title function_">resolve</span>(res)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>reject</code>静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>race</code>静态方法</p><ul><li><p>返回值是一个promise对象</p></li><li><p>传入一个数组，返回最先兑现的<code>promise</code>，无论是<code>resolve</code>还是<code>reject</code>，只取一个值</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">   <span class="comment">//传入的必须是一个数组</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;arguments is not iterable&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果数组长度为0</span></span><br><span class="line">      <span class="keyword">if</span> (arr.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>([])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//对每个元素都调用then方法（同时），不是myPromise对象则先包裹</span></span><br><span class="line">      <span class="comment">//再等待它们状态的改变，来改变最终返回的promise的状态</span></span><br><span class="line">      arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123; myPromise.<span class="title function_">resolve</span>(i).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="title function_">resolve</span>(res) &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="title function_">reject</span>(err) &#125;) &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>all</code>静态方法</p><ul><li><p>返回值是一个promise对象</p></li><li><p>要求传入的数组中的所有myPromise对象的状态都<code>resolve</code>后，再<code>resolve(//包含所有对象值的数组)</code></p></li><li><p>如果任意一个对象reject了，则reject这个对象的值。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//如果传入的不是数组，报错</span></span><br><span class="line">      <span class="keyword">if</span> (!(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;arguments is not iterable&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arr.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>([])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> result = []</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">      <span class="comment">//要求返回的数组中元素的排列顺序就是传入的顺序</span></span><br><span class="line">      arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">        myPromise.<span class="title function_">resolve</span>(i).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          result[index] = res</span><br><span class="line">          <span class="keyword">if</span> (++count == arr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="title function_">reject</span>(err) &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>any</code>静态方法</p><ul><li>返回值是一个promise对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">any</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;arguments is not iterable&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arr.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>([], <span class="string">&#x27;All promises were rejected&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> errs = []</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">      arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">        myPromise.<span class="title function_">resolve</span>(i).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(res)</span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          errs[index] = err</span><br><span class="line">          <span class="keyword">if</span> (++count == arr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>(errs, <span class="string">&#x27;All promises were rejected&#x27;</span>))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>allSettled</code>方法</p><p>传入Promise都变成已敲定，即可获取兑现的结果</p><p>结果数组<code>[&#123;status: &#39;fulfilled&#39;, value: 1&#125;, &#123;status: &#39;rejected&#39;, value: 3)]</code></p><p>结果数组的顺序，和传入的Promise数组的顺序一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">allSettled</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;arguments is not iterable&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>([])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = []<span class="comment">//一个对象数组</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">      myPromise.<span class="title function_">resolve</span>(i).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        result[index] = &#123; <span class="attr">state</span>: <span class="variable constant_">FULFILLED</span>, <span class="attr">value</span>: res &#125;</span><br><span class="line">        <span class="keyword">if</span> (++count == arr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        result[index] = &#123; <span class="attr">state</span>: <span class="variable constant_">REJECTED</span>, <span class="attr">reason</span>: err &#125;</span><br><span class="line">        <span class="keyword">if</span> (++count == arr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最终代码（简化版）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myPromise</span> &#123;</span><br><span class="line">  state = <span class="string">&#x27;pendding&#x27;</span></span><br><span class="line">  value = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  handler = []</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">func</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">val</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;pendding&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = val</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handler</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">          obj.<span class="title function_">onFulFilled</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">val</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;pendding&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = val</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handler</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">          obj.<span class="title function_">onRejected</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">func</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulFilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">handler</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">        <span class="attr">onFulFilled</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="title function_">wrap</span>(onFulFilled, resolve, reject) &#125;,</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="title function_">wrap</span>(onRejected, resolve, reject) &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">wrap</span>(<span class="params">func, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//这一段是核心代码，但是我们还要考虑返回值</span></span><br><span class="line">      <span class="keyword">const</span> res = <span class="title function_">func</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">      <span class="keyword">if</span> (res <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">        res.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123; <span class="title function_">resolve</span>(res) &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="title function_">reject</span>(err) &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;你好啊&#x27;</span>) &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p的状态改变了&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;你好啊2&#x27;</span>) &#125;, <span class="number">1000</span>) &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2的状态改变了&#x27;</span>) &#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>使用<code>Promise.all()</code>合并多个请求，只需设置一个<code>loading</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initLoad</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// loading.show() //加载loading</span></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getBannerList</span>(),<span class="title function_">getStoreList</span>(),<span class="title function_">getCategoryList</span>()]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        loading.<span class="title function_">hide</span>() <span class="comment">//关闭loading</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        loading.<span class="title function_">hide</span>()<span class="comment">//关闭loading</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据初始化    </span></span><br><span class="line"><span class="title function_">initLoad</span>()</span><br></pre></td></tr></table></figure><p>不过这样取数据也就要从<code>Promise.all</code>的返回的promise对象中取数据了。</p><p>通过<code>race</code>可以设置<code>图片请求超时时间</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求某个图片资源</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">requestImg</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">        <span class="comment">//也是异步回调确定p的状态</span></span><br><span class="line">        img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="title function_">resolve</span>(img);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg&quot;; 正确的</span></span><br><span class="line">        img.<span class="property">src</span> = <span class="string">&quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;图片请求超时&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">5000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span></span><br><span class="line">.<span class="title function_">race</span>([<span class="title function_">requestImg</span>(), <span class="title function_">timeout</span>()])</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">results</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="for-in-和-for-of的区别"><a href="#for-in-和-for-of的区别" class="headerlink" title="for in 和 for of的区别"></a>for in 和 for of的区别</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><p><code>for in</code>语句以任意顺序迭代一个<code>对象</code>的除<code>Symbol</code>以外的<code>可枚举属性</code>，包括<code>继承的</code>可枚举属性</p><p>一个直接创建的对象是非常常见的，它的原型是<code>Object.prototype</code>，上面的属性都是不可枚举的，所以我们使用<code>for in</code>遍历这种对象时，只会得到它的自己的所有可枚举属性。</p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><p>for of语句可以遍历<code>可迭代对象</code>，包括Array，Map，Set，string，TypedArray，arguments对象等等，遍历的是<code>值</code>，<code>继承</code>而来的无法遍历；保证迭代顺序，而一个直接创建的对象是<code>不可迭代</code>的，无法直接使用<code>for of</code>来遍历。</p><h4 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a><strong>可迭代对象</strong></h4><p>即满足了<code>迭代协议</code>的对象，需要存在一个名为<code>[Symbol.iterator]</code>的方法，这个方法<code>返回</code>一个迭代器对象</p><p>直接创建的对象不是可迭代对象，因为没有这个方法，但是我们也可以手动添加这个方法，让它变成<code>可迭代对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">name</span>:<span class="string">&#x27;1&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;21&#x27;</span>,[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> 迭代器对象&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代器对象"><a href="#迭代器对象" class="headerlink" title="迭代器对象"></a><strong>迭代器对象</strong></h4><p>其实迭代器对象就是一个普通对象，包含名为 <code>next()</code> 的方法，并没有想象的那么复杂；next方法返回一个包含<code>两个属性</code>的<code>对象</code>：value 和 done。<code>value</code> 是迭代的当前值，<code>done</code> 是一个布尔值，表示是否已经到达了迭代的末尾。</p><p><img src="/../images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-js/%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1.png"></p><p>那么改如何实现一个<code>迭代器对象</code>呢？</p><ul><li><p><strong>手动创建</strong></p><p>根据迭代器对象的定义，我们可以尝试手动创建一个<code>迭代器对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">//返回一个迭代器对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: arr[index++] &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="string">&#x27;end&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>借助生成器函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">    <span class="comment">//如果生成器函数中有return，return后迭代也就终止了，无论后面还有没有yield</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">      <span class="comment">//直接返回一个迭代器对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">generator</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)<span class="comment">//依次输出1，2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当使用 <code>for...of</code> 遍历一个可迭代对象时，它实际上调用了该对象的 <code>[Symbol.iterator]</code> 方法，<strong>并根据迭代器提供的值进行迭代</strong>。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><p><strong>遍历的东西不同</strong></p><p>for in 遍历的对象的<code>属性</code>，for of遍历的<code>对象的值</code></p></li><li><p><strong>遍历的范围不同</strong></p><p>for in遍历的是<code>对象自己的可枚举属性</code>以及<code>它继承的所有可枚举属性</code></p><p>for of遍历的是<code>对象自己的属性的值</code></p></li><li><p><strong>使用的范围不同</strong></p><p><code>for in</code>可以用于遍历<code>任何对象</code>，而<code>for of</code>只能用来遍历<code>可迭代对象</code></p></li></ul><h2 id="你是怎么理解ES6中-Generator的？使用场景？"><a href="#你是怎么理解ES6中-Generator的？使用场景？" class="headerlink" title="你是怎么理解ES6中 Generator的？使用场景？"></a>你是怎么理解ES6中 Generator的？使用场景？</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>Generator 函数是 ES6 提供的一种<code>异步编程</code>解决方案，语法行为与传统函数完全不同</p><p>回顾下上文提到的解决异步的手段：</p><ul><li>回调函数</li><li>promise</li></ul><p>执行 <code>Generator</code> 函数会返回一个<code>迭代器对象</code>，可以依次遍历 <code>Generator</code> 函数内部的每一个状态</p><p>形式上，<code>Generator</code>函数是一个普通函数，但是有两个特征：</p><ul><li><p><code>function</code>关键字与函数名之间有一个星号</p></li><li><p>函数体内部使用<code>yield(屈服，&#39;叶儿得&#39;)</code>表达式，定义不同的内部状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorldGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>Generator</code> 函数会返回一个<code>迭代器对象</code></p><img src="..\images\前端面试-js\迭代器对象.png" style="zoom:80%"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() === g <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>通过<code>yield</code>关键字可以暂停<code>generator</code>函数返回的<code>迭代器对象</code>的状态</p><img src="../images/前端面试-js/可迭代对象.png" style="zoom:67%"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorldGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> hw = <span class="title function_">helloWorldGenerator</span>();<span class="comment">//并不会输出1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出1 输出&#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出2 输出&#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出3 输出&#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//并不输出4 输出&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><code>done</code>用来判断是否存在下个状态，<code>value</code>对应状态值</p><p>再举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorldGenerator2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;ending&#x27;</span>;<span class="comment">//这里做了修改</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> hw2 = <span class="title function_">helloWorldGenerator2</span>();<span class="comment">//并不会输出1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出1 输出&#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出2 输出&#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出3 输出&#123; value: &#x27;ending&#x27;, done: false &#125; 这里有区别</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出4 输出&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="title function_">yield</span> (x + <span class="number">1</span>));<span class="comment">//y=undefined</span></span><br><span class="line">  <span class="keyword">var</span> z = <span class="title function_">yield</span> (y / <span class="number">3</span>);<span class="comment">//y/3=NaN</span></span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br></pre></td></tr></table></figure><p>通过调用<code>next</code>方法可以带一个参数，该参数就会被当作<code>上一个yield</code>表达式的返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">b.<span class="title function_">next</span>() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125; y=2*12 y/3=8</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125; y=24 z=13 x=5</span></span><br></pre></td></tr></table></figure><p>正因为<code>Generator</code>函数返回<code>Iterator(迭代器)</code>对象，因此我们还可以通过<code>for...of</code>进行遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;、</span><br><span class="line">  <span class="comment">//没有输出6，这是因为 for...of 循环只处理迭代过程中由 yield 产生的值。当迭代器完成（即状态变为 done: true），循环就会终止，并不会检查或处理 return 语句给出的值。</span></span><br><span class="line">  <span class="comment">//不过要注意的是，next是可以取出return的值的，不过for of不行。</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);<span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>原生对象</code>没有<code>遍历接口</code>，通过<code>Generator</code>函数为它加上这个接口，就能使用<code>for...of</code>进行遍历了，<code>for...of</code>本质遍历的就是<code>迭代器对象</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据传入的对象，创造一个生成器函数</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">objectEntries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">//返回一个数组，包含对象自身的所有属性，包括不可枚举属性</span></span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, obj[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Doe&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">//数组解构</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">objectEntries</span>(jane)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><h3 id="异步解决方案"><a href="#异步解决方案" class="headerlink" title="异步解决方案"></a>异步解决方案</h3><p>回顾之前展开异步解决的方案：</p><ul><li>回调函数</li><li>Promise 对象</li><li>generator 函数</li><li>async&#x2F;await</li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>)&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p><code>Promise</code>就是为了解决<code>回调地狱</code>而产生的，将回调函数的<code>嵌套</code>，改成<code>链式调用</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强，<code>Generator</code>就是用来解决这个问题的。</p><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchUser</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟异步操作</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(&#123; id, <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;), <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//定义一个生成器（Generator）</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Start fetching user...&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">yield</span> <span class="title function_">fetchUser</span>(<span class="number">123</span>); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;User fetched:&#x27;</span>, user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用生成器函数，得到一个迭代器对象（iterator）</span></span><br><span class="line"><span class="keyword">const</span> it = <span class="title function_">generatorFunc</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">result</span>) &#123;</span><br><span class="line">   <span class="comment">//如果迭代完，直接返回，跳出函数</span></span><br><span class="line">   <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line">   <span class="comment">//否则对拿到的结果调用then方法</span></span><br><span class="line">   result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">     <span class="comment">//等待promise状态改变后再继续执行代码，并把拿到的值当作上一次yield表达式的值，赋值给user</span></span><br><span class="line">     <span class="title function_">go</span>(it.<span class="title function_">next</span>(value));----------</span><br><span class="line">   &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">     <span class="title function_">go</span>(it.<span class="keyword">throw</span>(error));</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="title function_">go</span>(it.<span class="title function_">next</span>());<span class="comment">//先输出 Start fetching user... 1s后输出User fetched: &#123;id: 123, name: &#x27;Alice&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>虽然<code>生成器</code>提供了处理异步代码的一种方式，但它的使用<code>相对复杂</code>，还是不够简洁，于是就有了<code>async</code>和<code>await</code></p><h4 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h4><p><code>async</code> 函数本质上是构建在<code>生成器</code>之上的<code>语法糖</code>，它们内部实际上使用了 Promise，并且允许你以同步的方式编写异步代码，而不需要显式地处理<code>迭代器</code>或手动调用 <code>next()</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function asyncFunc() &#123;</span><br><span class="line">    console.log(&#x27;Start fetching user...&#x27;);</span><br><span class="line">    let user = await fetchUser(123); // 等待 Promise 完成</span><br><span class="line">    console.log(&#x27;User fetched:&#x27;, user);//后面的代码会等待promise状态改变后再执行。</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc();</span><br></pre></td></tr></table></figure><p>值得注意的是，async函数无论是否有return语句，都会返回一个promise对象。如果return一个非promise值，该值会被包装成已解决的Promise对象；如果没有return语句，默认会返回一个已解决的Promise，其值为<code>undefined</code>；如果返回一个promise对象，那么最终返回的也就是这个promise对象。</p><h2 id="你是怎么理解ES6中Proxy的？使用场景"><a href="#你是怎么理解ES6中Proxy的？使用场景" class="headerlink" title="你是怎么理解ES6中Proxy的？使用场景?"></a>你是怎么理解ES6中Proxy的？使用场景?</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p><code>Proxy</code> 是一个构造函数，用于创建一个对象的<code>代理</code>，从而拦截对该对象的基本操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><p><code>target</code>表示所要拦截的<code>目标对象</code>（任何类型的对象，包括原生数组，函数，甚至另一个代理）</p><p><code>handler</code>是一个<code>属性值</code>一般都是<code>函数</code>的对象，各属性中的函数分别定义了在执行各种操作时代理目标对象的行为</p><p>难点就在于分析这个<code>handler</code>，它可以包括多种<code>拦截属性</code>，下面我们只介绍常见的几种:</p><ul><li>get(target,propKey,receiver)：拦截对象属性的读取</li><li>set(target,propKey,value,receiver)：拦截对象属性的设置</li><li>deleteProperty(target,propKey)：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值</li></ul><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p><code>get</code>接受三个参数，依次为目标对象、属性名和 <code>proxy</code> 实例本身，最后一个参数可选</p><p>用来监听对某个<code>属性</code>的取值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target,propKey)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// &quot;张三&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果一个属性不可写（<code>writable:false</code>），则 Proxy 不能修改该属性，否则会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,<span class="comment">//默认值就是false，表示不可被修改</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span><span class="comment">//默认值就是false，表示不可被删除</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);<span class="comment">//&#123;foo:123&#125;，不过这个属性是不可重写，不可配置的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="comment">// return target[propKey] 返回123，不报错</span></span><br><span class="line">    <span class="comment">// return Reflect.get(target, propKey)  返回123，不报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;<span class="comment">//返回abc，就相当于重写了，报错，</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span></span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p><code>set</code>方法用来拦截对某个属性的<code>赋值操作</code>，可以接受四个参数，依次为<code>目标对象</code>、<code>属性名</code>、<code>属性值</code>和 <code>Proxy</code> 实例本身。</p><p>如果目标对象自身的某个属性，不可写（<code>writable:false</code>），那么<code>set</code>方法将不起作用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,<span class="comment">//默认值</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(obj,prop,value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>)<span class="comment">//bar</span></span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>) <span class="comment">// &quot;bar&quot;,属性值并未被修改</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>，<code>严格模式</code>下，<code>set</code>代理如果没有返回<code>true</code>，就会报错</p><h4 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h4><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法<code>抛出错误</code>或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="title function_">deleteProperty</span> (target, key) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target,key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invariant</span> (<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`无法删除私有属性`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">_prop</span></span><br><span class="line"><span class="comment">// Error: 无法删除私有属性,抛出了异常就不会执行Reflect.deleteProperty(target,key)</span></span><br></pre></td></tr></table></figure><p>注意，<code>目标对象</code>自身的不可配置（<code>configurable:false</code>）属性，不能被<code>deleteProperty</code>方法删除。</p><h3 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.revocable(target, handler);</span><br></pre></td></tr></table></figure><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>Proxy</code>其功能非常类似于设计模式中的<code>代理模式</code>，常用功能如下：。</p><ul><li><p>拦截和监视外部对对象的操作</p></li><li><p>降低函数或类的复杂度</p></li><li><p>在复杂操作前对操作进行校验或对所需资源进行管理</p></li><li><p>使用<code>Proxy</code>实现观察者模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个订阅的方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observe</span> = fn =&gt; queuedObservers.<span class="title function_">add</span>(fn);</span><br><span class="line"><span class="comment">//返回一个代理对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observable</span> = obj =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key</span>)&#123;</span><br><span class="line">        <span class="title function_">observe</span>(func)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">///当数据改变，就调用所有的订阅方法</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">        queuedObservers.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> <span class="title function_">observer</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="你是怎么理解ES6中Module的？使用场景？"><a href="#你是怎么理解ES6中Module的？使用场景？" class="headerlink" title="你是怎么理解ES6中Module的？使用场景？"></a>你是怎么理解ES6中Module的？使用场景？</h2><h3 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h3><p>如果没有模块化，我们代码会怎样？</p><ul><li>变量和方法不容易维护，容易污染<code>全局作用域</code></li><li>通过手动规定<code>script</code>标签的书写顺序来控制资源的<code>加载顺序</code></li><li>资源的<code>依赖关系</code>模糊，代码难以维护。</li></ul><p>而模块化具有如下特点，能解决原生开发过程中的诸多问题</p><ul><li>代码抽象</li><li>代码封装</li><li>代码复用</li><li>依赖管理</li></ul><p><strong>AMD</strong></p><p><code>Asynchronous ModuleDefinition</code>（AMD），异步模块定义，采用<code>异步方式</code>加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.<span class="title function_">config</span>(&#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&quot;js/lib&quot;</span>,</span><br><span class="line">  <span class="attr">paths</span>: &#123;</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;jquery&quot;</span>,<span class="string">&quot;underscore&quot;</span>],<span class="keyword">function</span>(<span class="params">$,_</span>)&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>CommonJs</strong></p><p><code>CommonJS</code> 是一套 <code>nodejs</code> 默认支持的模块规范，用于服务端。</p><p>其有如下特点：</p><ul><li>所有代码都运行在<code>模块作用域</code>，不会污染全局作用域</li><li>模块是<code>同步加载</code>的，即只有加载完成，才能执行后面的操作</li><li>模块在首次执行后就会<code>缓存</code>，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li><li><code>require</code>返回的值是被输出的值的<code>拷贝</code>，模块内部的变化也不会影响这个值</li></ul><p>既然存在了<code>AMD</code>以及<code>CommonJs</code>机制，<code>ES6</code>的<code>Module</code>又有什么不一样？</p><p><code>ES6</code> 在语言标准的层面上，实现了<code>Module</code>，即模块功能，完全可以<strong>取代</strong> <code>CommonJS</code>和 <code>AMD</code>规范，成为<code>浏览器</code>和<code>服务器</code>通用的模块解决方案。</p><p><code>CommonJS</code> 和<code>AMD</code> 模块语法，导入导出的都是<code>整个对象</code>，<code>代码运行时</code>才能确定具体的依赖关系，比如具体使用了模块中的哪些变量。</p><p><code>ES6</code>设计思想是尽量的<code>静态化</code>，使得<code>编译时</code>就能确定模块的依赖关系，以及输入和输出的变量。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>具体使用方式可以参考本博客中<code>nodejs</code>一文。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者:</span> <span class="post-copyright-info"><a href="https://www.sanye.blog">三叶sanye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接:</span> <span class="post-copyright-info"><a href="https://www.sanye.blog/posts/d73c0d37.html">https://www.sanye.blog/posts/d73c0d37.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.sanye.blog" target="_blank">三叶的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/es6/">es6</a></div><div class="post-share"><div class="social-share" data-image="/images/cover/%E9%9F%B6%E5%8D%8E%E5%88%9D%E9%9F%B3.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/4618cb0a.html" title="微信小程序"><img class="cover" src="/images/cover/violet.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">微信小程序</div></div><div class="info-2"><div class="info-item-1">微信小程序有自己开发框架，并且和我们熟悉的vue或者react框架的语法，api区别还是蛮大的，学习成本不低，个人不推荐花太多时间去学习，更推荐uni-app（使用vue的语法开发web应用并多端发布）这类的框架，使用我们熟悉的框架语法开发，还能轻松实现多端发布。当然，wx小程序的知识中也有许多是通用的。 说说你对微信小程序的理解？优缺点？是什么2017年，微信正式推出了小程序，允许外部开发者在微信内部运行自己的代码，开展业务 截至目前，小程序已经成为国内前端的一个重要业务，跟 Web 和手机 App 有着同等的重要性 小程序是一种不需要下载安装即可使用的应用（但实际上还是存在一个轻量级的下载和安装流程，不过用户感知不到），它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用 也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载 注意的是，除了微信小程序，还有百度小程序、微信小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序 背景小程序并非凭空冒出来的⼀个概念，当微信中的...</div></div></div></a><a class="pagination-related" href="/posts/3418e521.html" title="nodejs"><img class="cover" src="/images/cover/dog.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">nodejs</div></div><div class="info-2"><div class="info-item-1">定义nodejs是前端工程化的基础，是开源的，基于谷歌v8引擎构建的js运行环境，运行开发者使用js编写的服务器。 三大模块文件相关 fs模块 封装了与本机文件系统进行交互的方法与属性 fs.readFile() 1fs.readFile(path[, options], callback) 参数1：必选参数，字符串，表示文件路径。 参数2：可选参数，表示以什么编码格式来读取文件。 参数3：必选参数，文件读取完成后，通过回调函数拿到读取的结果，形如(err,dataStr)=&gt;&#123;&#125; 读取成功err为null，否则为错误对象 示例： 1234fs.readFile(&#x27;/path/to/file.txt&#x27;, &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);//data是文件内容的buffer数据流&#125;); fs.writeFile() 1fs.writeFile(file, data[,...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/%E4%B8%89%E5%8F%B6.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">三叶sanye</div><div class="author-info-description">记录学习，分享知识</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://space.bilibili.com/660655866?spm_id_from=333.1007.0.0" rel="external nofollow noreferrer" target="_blank" title="Bilibli"><i class="fa-brands fa-bilibili" style="color:#74c0fc"></i></a><a class="social-icon" href="https://github.com/syhy" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:3519450570@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">笔记主要自用，希望也能帮到你😀</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#var-let-const%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">var,let,const有哪些区别</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="toc-number">1.1.</span> <span class="toc-text">变量提升与函数提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95"><span class="toc-number">1.2.</span> <span class="toc-text">数组新增了哪些扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6-%E2%80%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">扩展运算符 …</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0Array%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">构造函数Array的新增方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-from"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Array.from()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-of"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Array.of()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">新增方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#find-findIndex"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">find,findIndex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fill"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">fill</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#includes"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">includes</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95"><span class="toc-number">1.3.</span> <span class="toc-text">函数新增了哪些扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">箭头函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95"><span class="toc-number">1.4.</span> <span class="toc-text">对象新增了哪些扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E5%86%99"><span class="toc-number">1.4.1.</span> <span class="toc-text">属性的简写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">属性名表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.4.3.</span> <span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">1.4.4.</span> <span class="toc-text">解构赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3ES6%E6%96%B0%E5%A2%9ESet%E3%80%81Map%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">如何理解ES6新增Set、Map两种数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">1.5.1.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">增删改查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">1.5.2.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">增删查改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-1"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map%E5%92%8CObj%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">Map和Obj的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3es6%E4%B8%AD-Promise%E7%9A%84"><span class="toc-number">1.6.</span> <span class="toc-text">你是怎么理解es6中 Promise的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.6.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">1.6.2.</span> <span class="toc-text">状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.3.</span> <span class="toc-text">实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#then"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">then</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#catch"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finally"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">finally</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.4.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAPromise"><span class="toc-number">1.6.5.</span> <span class="toc-text">手写一个Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.6.6.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-in-%E5%92%8C-for-of%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text">for in 和 for of的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-in"><span class="toc-number">1.7.1.</span> <span class="toc-text">for in</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-of"><span class="toc-number">1.7.2.</span> <span class="toc-text">for of</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">可迭代对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">迭代器对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3ES6%E4%B8%AD-Generator%E7%9A%84%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">你是怎么理解ES6中 Generator的？使用场景？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">1.8.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.8.3.</span> <span class="toc-text">异步解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generator"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-await"><span class="toc-number">1.8.3.4.</span> <span class="toc-text">async&#x2F;await</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3ES6%E4%B8%ADProxy%E7%9A%84%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.9.</span> <span class="toc-text">你是怎么理解ES6中Proxy的？使用场景?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">1.9.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handler"><span class="toc-number">1.9.2.</span> <span class="toc-text">handler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#get"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">get()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">set()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deleteProperty"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">deleteProperty</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E4%BB%A3%E7%90%86"><span class="toc-number">1.9.3.</span> <span class="toc-text">取消代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.9.4.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3ES6%E4%B8%ADModule%E7%9A%84%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">你是怎么理解ES6中Module的？使用场景？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">1.10.1.</span> <span class="toc-text">为什么需要模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">1.10.2.</span> <span class="toc-text">使用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/19656fd5.html" title="react"><img src="/images/cover/%E6%B1%9F%E5%8D%97.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="react"></a><div class="content"><a class="title" href="/posts/19656fd5.html" title="react">react</a><time datetime="2025-02-20T13:33:23.000Z" title="发表于 2025-02-20 21:33:23">2025-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/518e617c.html" title="git"><img src="/images/cover/dog.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="git"></a><div class="content"><a class="title" href="/posts/518e617c.html" title="git">git</a><time datetime="2025-02-09T08:07:36.000Z" title="发表于 2025-02-09 16:07:36">2025-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b0415b82.html" title="前端刷题记录"><img src="/images/cover/%E6%98%9F%E7%A9%BA.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="前端刷题记录"></a><div class="content"><a class="title" href="/posts/b0415b82.html" title="前端刷题记录">前端刷题记录</a><time datetime="2025-02-09T07:04:01.000Z" title="发表于 2025-02-09 15:04:01">2025-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e255a10a.html" title="计算机网络"><img src="/images/cover/maomao.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="计算机网络"></a><div class="content"><a class="title" href="/posts/e255a10a.html" title="计算机网络">计算机网络</a><time datetime="2025-02-07T15:08:21.000Z" title="发表于 2025-02-07 23:08:21">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4b0178e0.html" title="数据结构与算法"><img src="/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="数据结构与算法"></a><div class="content"><a class="title" href="/posts/4b0178e0.html" title="数据结构与算法">数据结构与算法</a><time datetime="2025-02-07T14:48:29.000Z" title="发表于 2025-02-07 22:48:29">2025-02-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/images/cover/1.png)"><div id="footer-wrap"><div class="footer_custom_text"><div id="sanye"><svg class="icon" aria-hidden="true"><use href="#icon-banquan"></use></svg><span>2024 - 2025 By 三叶sanye</span><svg class="icon" aria-hidden="true"><use href="#icon-sanyecao"></use></svg></div><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://unpkg.com/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/time.js"></script><script src="/js/iconfont.js"></script><script defer id="ribbon" src="https://unpkg.com/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script src="https://unpkg.com/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://unpkg.com/butterfly-extsrc/dist/click-heart.min.js" async mobile="false"></script><script async data-pjax src="/js/busuanzi.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,display:{position:"left",width:120,height:240},mobile:{show:!0},react:{opacity:.7}})</script></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统 | 三叶的博客</title><meta name="author" content="三叶sanye"><meta name="copyright" content="三叶sanye"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统类型 单批道处理：内存中同时只有一道程序运行，程序之间只能串行  多批道系统：允许多个程序并发运行，操作系统正式诞生，但是对cpu等资源来说，同一时间还是只服务一个进程，但是一旦空闲，就会立马被其他进程占用，即便上一个进程未结束，但是因为已经不需要cpu所以无碍，这样大大提高了资源的利用率；缺点是人机交互不好。   分时操作系统：操作系统以时间片为单位轮流为各个用户&#x2F;作业服务；用">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="https://www.sanye.blog/posts/d04bd5bc.html">
<meta property="og:site_name" content="三叶的博客">
<meta property="og:description" content="操作系统类型 单批道处理：内存中同时只有一道程序运行，程序之间只能串行  多批道系统：允许多个程序并发运行，操作系统正式诞生，但是对cpu等资源来说，同一时间还是只服务一个进程，但是一旦空闲，就会立马被其他进程占用，即便上一个进程未结束，但是因为已经不需要cpu所以无碍，这样大大提高了资源的利用率；缺点是人机交互不好。   分时操作系统：操作系统以时间片为单位轮流为各个用户&#x2F;作业服务；用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.sanye.blog/images/cover/%E6%98%9F%E7%A9%BA.png">
<meta property="article:published_time" content="2025-02-06T15:49:56.000Z">
<meta property="article:modified_time" content="2025-02-12T16:01:43.883Z">
<meta property="article:author" content="三叶sanye">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.sanye.blog/images/cover/%E6%98%9F%E7%A9%BA.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://www.sanye.blog/posts/d04bd5bc.html"><link rel="preconnect" href="//unpkg.com"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-center"},
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/bilibiliBanner.css"  media="defer" onload="this.media='screen'"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/time.css"><link rel="stylesheet" href="/css/iconfont.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="iron-container iron-circle"><div class="iron-box1 iron-circle iron-center"></div><div class="iron-box2 iron-circle iron-center"></div><div class="iron-box3 iron-circle iron-center"></div><div class="iron-box4 iron-circle iron-center"></div><div class="iron-box5 iron-circle iron-center"></div><div class="iron-box6 iron-circle"><div class="iron-coil" style="--i: 0"></div><div class="iron-coil" style="--i: 1"></div><div class="iron-coil" style="--i: 2"></div><div class="iron-coil" style="--i: 3"></div><div class="iron-coil" style="--i: 4"></div><div class="iron-coil" style="--i: 5"></div><div class="iron-coil" style="--i: 6"></div><div class="iron-coil" style="--i: 7"></div></div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/images/%E4%B8%89%E5%8F%B6.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/cover/星空.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name iconfont icon-sanyecao">三叶的博客</span></a><a class="nav-page-title" href="/"><span class="site-name iconfont icon-sanyecao">操作系统</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">操作系统<a class="post-edit-link" href="https://github.com/shiyuhuiya/shiyuhuiya.github.io/issues_posts/操作系统.md" rel="external nofollow noreferrer" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-06T15:49:56.000Z" title="发表于 2025-02-06 23:49:56">2025-02-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-12T16:01:43.883Z" title="更新于 2025-02-13 00:01:43">2025-02-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%A7%91%E4%B8%93%E4%B8%9A%E6%A0%B8%E5%BF%83/">计科专业核心</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-02-13 00:01:43&quot;}" hidden></div><h2 id="操作系统类型"><a href="#操作系统类型" class="headerlink" title="操作系统类型"></a>操作系统类型</h2><ul>
<li><p>单批道处理：内存中同时只有一道程序运行，程序之间只能串行</p>
</li>
<li><p>多批道系统：允许多个程序并发运行，操作系统正式诞生，但是对cpu等资源来说，同一时间还是只服务一个进程，但是一旦空闲，就会立马被其他进程占用，即便上一个进程未结束，但是因为已经不需要cpu所以无碍，这样大大提高了资源的利用率；缺点是人机交互不好。</p>
<img src="..\images\操作系统\多批道.png" style="zoom:50%;" />
</li>
<li><p>分时操作系统：操作系统以<code>时间片</code>为单位轮流为各个用户&#x2F;作业服务；用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在；缺点是无法区分任务的紧急性</p>
</li>
<li><p>实时操作系统：能够<code>优先响应</code>一些紧急任务，某些紧急任务<strong>不需时间片排队</strong>。在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是<code>及时性</code>和<code>可靠性</code></p>
</li>
</ul>
<h2 id="虚拟机管理程序-VMM"><a href="#虚拟机管理程序-VMM" class="headerlink" title="虚拟机管理程序(VMM)"></a>虚拟机管理程序(VMM)</h2><img src="..\images\操作系统\传统计算机.png" style="zoom:33%;" />

<p>传统计算机上，一台计算机只能运行一个操作系统，为了充分利用硬件资源，我们希望在一台计算机上运行多个<code>操作系统</code>。</p>
<p>通过<code>虚拟机管理程序</code>，把一台<code>物理机器</code>虚拟化为多台<code>虚拟机(VM)</code>，<strong>每台虚拟机上都能独立运行一个操作系统</strong>。</p>
<p>虚拟机管理程序又可分为两大类，第一类，虚拟机管理程序直接运行在硬件上，可移植性差；第二类，虚拟机管理程序运行在<code>宿主操作系统上</code>，可移植性高。</p>
<h2 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h2><ul>
<li>处理机（cpu）管理：处理机管理主要是指对中央处理器（CPU）的工作进行有效的组织和调度，以提高系统的效率。这包括进程控制、进程同步、进程通信和进程调度等。通过合理的调度算法，<strong>操作系统确保每个进程都能公平地获得CPU时间</strong>，并高效地完成任务。</li>
<li>存储管理</li>
<li>文件管理</li>
<li>设备管理：比如I&#x2F;O设备管理</li>
<li>作业管理</li>
</ul>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>让cpu从<code>用户态</code>（也叫目态）变为<code>内核态</code>，是<code>内核程序</code>夺回cpu控制权的唯一途径；进程的并发离不开中断。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="内中断（异常）"><a href="#内中断（异常）" class="headerlink" title="内中断（异常）"></a>内中断（异常）</h4><p>内中断也称为异常（Exception），是指由<strong>处理器内部产生的中断信号</strong>，通常是因为执行指令时遇到特殊情况或错误而引起的。内中断主要包含以下几种类型：</p>
<ul>
<li><strong>故障（Fault）</strong>：这种类型的中断表示发生了某种可恢复的错误，比如除以0。CPU会在发生故障后保存现场，并尝试修正问题，然后返回原程序继续执行。</li>
<li><strong>陷入（Trap）</strong>：程序故意引发，比如请求调用操作系统服务(系统调用)。</li>
<li><strong>终止（Abort）</strong>：表示发生了严重的、不可恢复的错误，导致程序无法继续执行，如硬件故障。</li>
</ul>
<h4 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h4><p>外部指令提醒cpu中断，目的是通知CPU有外部事件需要处理，然后cpu进入内核态（运行内核程序的状态），处理收到的中断信号，包括<code>时钟中断（它由硬件定时器周期性地产生，用于维持系统时间、调度进程等关键功能）</code>，<code>i/o中断（i/o操作完成）</code></p>
<h3 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态&#x2F;内核态"></a><strong>用户态&#x2F;内核态</strong></h3><p>处于<code>用户态的进程</code>只能访问用户态的内存空间（用户空间），不能直接访问内核态的内存空间（系统空间）</p>
<h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><h3 id="中断程序"><a href="#中断程序" class="headerlink" title="中断程序"></a>中断程序</h3><p>cpu根据不同的<code>中断信号</code>执行不同的<code>中断程序</code>，本质是内核程序，运行在内核态（也叫管态）</p>
<h3 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h3><p>当CPU正在处理一个优先级较低的中断，又来了一个优先级更高的中断请求，则CPU先停止低优先级的中断处理过程，去响应优先级更高的中断请求，在优先级更高的中断处理完成之后，再继续处理低优先级的中断，这种情况称为中断嵌套，因为低级中断的处理过程被高级中断插入了（低级中断-高级中断-低级中断），所以叫做中断嵌套。</p>
<h3 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h3><p>CPU通过指令限制某些设备发出中断请求，处理中断一般按照<code>中断的优先级</code>对其进行处理，某些时候可以<strong>屏蔽</strong>掉高优先级的中断，中断产生时系统不予响应，未被屏蔽的低优先级中断反而可以响应，<strong>从而改变了中断响应次序</strong> 。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>是操作系统进行<code>资源分配</code>和<code>调度</code>的独立单位</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>特性</p>
<ul>
<li><strong>动态性：最基本的特性</strong></li>
<li>异步性：强调并发运行的进程之间的执行先后顺序是<code>不可预</code>知的</li>
<li>并发性：没有并发就没有异步，现代操作系统中进程是并发执行的</li>
</ul>
<h3 id="程序与进程的区别"><a href="#程序与进程的区别" class="headerlink" title="程序与进程的区别"></a>程序与进程的区别</h3><p>程序是静态的，可执行文件的集合，而进程是动态的。</p>
<h3 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h3><ul>
<li><p><strong>PCB</strong>：也叫进程控制块，<strong>包含了进程相关的所有信息，是进程存在的唯一标识</strong>；方便操作系统管理进程，进程结束会被回收。</p>
<ul>
<li><p><code>pid</code>：每次新建进程，都会给进程分配一个唯一的pid，<strong>用来标识不同的进程</strong></p>
<img src="..\images\操作系统\pid.png" style="zoom:90%;" />
</li>
<li><p>其他进程有关的信息</p>
</li>
</ul>
</li>
<li><p>数据段：程序中定义的变量</p>
</li>
<li><p>程序段：程序代码</p>
</li>
</ul>
<h3 id="进程之间的基本关系"><a href="#进程之间的基本关系" class="headerlink" title="进程之间的基本关系"></a>进程之间的基本关系</h3><ul>
<li>同步：协调进程间的执行顺序，为了解决异步问题，属于<strong>直接制约关系</strong></li>
<li>互斥：避免多个进程同时访问同一资源导致冲突，互斥访问<code>临界资源</code>，<strong>属于间接制约关系，因为中间夹了一个临界资源</strong></li>
</ul>
<h3 id="进程同步-PV操作"><a href="#进程同步-PV操作" class="headerlink" title="进程同步-PV操作"></a>进程同步-PV操作</h3><p>p用来代表wait原语，v用来代表signal原语；使用原语的好处是检查和上锁是一气呵成的；</p>
<ul>
<li>整形信号量：存在循环等待，不满足让权等待，因为资源不足会进程会<strong>循环等待</strong>资源。</li>
<li>记录型信号量：在整形信号量的基础上多了一个<code>等待队列</code>，<code>p操作</code>让资源数减一，如果资源数&lt;0（说明没有空闲资源了），使用<code>block原语</code>阻塞进程，放入等待队列；<code>v操作</code>让资源数+1，如果资源数&lt;&#x3D;0，则使用<code>wakeup原语</code>唤醒一个进程；进程同步的时候指定某个资源的数量为0，<strong>然后先v后p</strong>，即先要执行的进程释放一个资源后，才能运行另一个进程，也就是说，如果一个进程需要另一个进程执行完后才能运行，就能实现进程的同步。</li>
</ul>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程是分配系统资源的单位(包括内存地址空间)，<strong>因此各进程拥有的内存空间相互独立</strong>，进程之间的通信是有一定的延时的。</p>
<p>为了安全起见，进程之间不能直接通信，需要借助操作系统。</p>
<h4 id="共享地址空间"><a href="#共享地址空间" class="headerlink" title="共享地址空间"></a>共享地址空间</h4><p>就是给需要通信的进程分配一个能够共享的内存空间，特点是写入，取出数据可以是在共享空间的<strong>任意位置</strong>的；为避免出错，各个进程对共享空间的访问应该是<strong>互斥</strong>的。</p>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><img src="..\images\操作系统\消息通信.png" style="zoom:50%;" />

<img src="..\images\操作系统\消息.png" style="zoom:50%;" />

<p>通过<em>send</em>和<em>receive</em>原语操作实现</p>
<p><strong>直接传递</strong></p>
<img src="..\images\操作系统\直接传递.png" style="zoom:50%;" />

<p>指明发送到哪个进程，接收哪个进程的信息，消息存储在进程的<code>消息队列(存储着所有发送给这个进程的消息)</code>中，<strong>消息队列存储在PCB中，进程PCB存储在<code>操作系统内核空间</code>中。</strong></p>
<p><strong>间接传递</strong></p>
<p>指明发送到哪个邮箱，接收哪个邮箱的信息（邮箱存储在操作系统内核）</p>
<img src="..\images\操作系统\间接传递.png" style="zoom:50%;" />

<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><img src="..\images\操作系统\管道.png" style="zoom: 50%;" />

<p>半双工，同时只能存在一个方向（水管中的水流也只能是单向的）；<strong>本质是一个共享的文件</strong>，进程向操作系统申请后由操作系统来分配；管道通信逻辑上是个<strong>循环队列</strong>（一端写满了，如果另一端没满，可以往另一端继续写）；区别于<code>共享内存</code>的方式，读入，取出数据都是有限制的。</p>
<p>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</p>
<p>管道写满的时候，写进程阻塞，管道为空的时候，读进程阻塞。</p>
<h3 id="并发-并行-异步"><a href="#并发-并行-异步" class="headerlink" title="并发&#x2F;并行&#x2F;异步"></a>并发&#x2F;并行&#x2F;异步</h3><ul>
<li>异步：并发的进程以独立的，不可预知的速度向前推进。异步性基于进程并发</li>
<li>并发：在同一时间间隔内运行多个进程。宏观看起来同时，实际上是通过<strong>快速切换进程</strong>来模拟同时执行的效果。</li>
<li>并行：多个进程的<strong>同时执行</strong>，需要多个cpu。</li>
</ul>
<h3 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h3><img src="..\images\操作系统\进程状态转换.png" style="zoom: 50%;" />

<ul>
<li>创建态：进程已被创建</li>
<li>就绪态：程序已被创建，随时可以上cpu执行</li>
<li>运行态：程序正在cpu上运行，一个进程占用一个cpu</li>
<li>阻塞态：当进程请求某个资源但是<strong>该资源被占用时</strong>，进程下cpu，变成阻塞态</li>
<li>终止状态：进程运行结束</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>先来先上cpu运行，对<code>短作业</code>不友好（上厕所，你急着上小号但是里面有人在上大号）；非抢占式算法。</p>
<h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><ul>
<li>对长作业不友好，面对远远不断的短作业，可能会导致长作业出现<code>饥饿问题</code>；</li>
<li>一般是非抢占式的，也有抢占式的；</li>
<li><strong>是平均周转时间最短的算法</strong>（平均周转时间&#x3D;（总运行时间+总等待时间）&#x2F;进程数目）；因为各个进程运行时间是固定的，这种算法能让所有进程的<code>总等待时间最短</code>，所以能实现最短的平均周转时间。</li>
</ul>
<h4 id="高响应比优先算法"><a href="#高响应比优先算法" class="headerlink" title="高响应比优先算法"></a>高响应比优先算法</h4><p>既考虑到了<code>等待时间</code>也考虑到了进程长度；一个进程结束时，计算就绪队列中所有进程的<code>响应比</code>，让<strong>响应比最高的进程</strong>上cpu；不会导致饥饿。<code>进程响应比等于：1 + 等待时间/进程运行时间</code></p>
<h4 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h4><p>每个进程分配一个固定的时间段，让它们轮流执行。系统维护一个<strong>就绪队列</strong>，其中包含所有<code>等待CPU时间</code>的进程。当一个进程的时间片结束时，无论它是否已完成，都会被移到队列的末尾，下一个进程开始运行。如果进程在时间片内完成，则从队列中移除。</p>
<p>确保所有进程都能获得一定的CPU时间，避免了饥饿现象。但要注意的是，频繁的上下文切换（进程切换）可能会带来额外的系统开销，尤其是当<code>时间片设置得过短时</code>。</p>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p>每个进程都被赋予一个<code>优先</code>，系<strong>统总是选择当前具有最高优先级（最低数字通常表示最高优先级）的进程执行</strong>。</p>
<h3 id="其他调度"><a href="#其他调度" class="headerlink" title="其他调度"></a>其他调度</h3><ul>
<li><p>进程调度（低级调度）：让就绪状态的进程将获得处理机的过程；发生频率最高的调度</p>
</li>
<li><p>内存调度（中级调度）：把<code>内存中</code>的暂时不需要的<strong>进程</strong>换出，或者把外存的已具备运行条件的就绪进程重新调入内存。暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被<strong>挂起</strong>的进程PCB会被组织成<strong>挂起队列</strong>。就拿手机举例，我们打开后台的某个应用，有的进入的很快，有的进入的很慢，这是因为，因为内存不足，有的后台应用进程已经被<code>移出内存(挂起)</code>了，所以再次进入的速度很慢，而还要一部分后台应用进程还保留在内存中（阻塞态），所以进入速度很快。</p>
<img src="..\images\操作系统\七状态模型.png" style="zoom:40%;" />
</li>
<li><p>作业调度（高级调度）：把作业调入内存，就是让一个<strong>程序</strong>执行，为其创建<strong>进程</strong>，是发生频率最低的调度。</p>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul>
<li><p>传统的进程只能<strong>串行</strong>的执行一系列代码，这就导致<strong>一个进程无法同时执行多个功能</strong>。一个进程内部可以根据<strong>功能不同</strong>划分多个线程，线程之间可以<strong>并发运行</strong>。</p>
</li>
<li><p>引入线程后，进程只作为除CPU之外的系统资源的分配单元(如打印机、内存地址空间等都是分配给进程的)，但不再是调度（上cpu）的基本单位，线程才是。</p>
</li>
</ul>
<h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><ul>
<li>线程是<code>处理机调度</code>的单位</li>
<li>多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个<code>线程ID</code>、<code>线程控制块(TGB)</code></li>
<li>线程也有<code>就绪、阻塞、运行</code>三种基本状态</li>
<li>线程几乎不拥有系统资源；同一进程的不同线程间<code>共享进程的资源</code></li>
<li>由于共享内存地址空间，同一进程中的<strong>线程间通信</strong>甚至无需系统干预，直接使用<code>共享的地址空间</code>就好。</li>
<li><code>同一进程</code>中的线程切换，不会引起<code>进程切换</code></li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小；切换进程，系统开销较大</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>所有进程都在等待其他进程释放资源，导致<strong>所有进程都阻塞的状态</strong></p>
<h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul>
<li>互斥条件：只有对<code>临界资源</code>的争抢才会引发死锁，如果资源可以同时被多个进程访问，那就不存在资源的争抢问题</li>
<li>不可剥夺条件：进程在获取到所需资源但是还没有使用之前，所占有的资源是无法被其他进程剥夺的，<strong>只能主动释放</strong>。</li>
<li>请求和保持：进程会保留已经获得到的资源，并继续请求需要的，未获得到的资源。</li>
<li>循环等待：每个进程在请求别的进程占有的资源的同时，已经获得的资源也被其他进程请求。</li>
</ul>
<h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><h4 id="不允许死锁发生"><a href="#不允许死锁发生" class="headerlink" title="不允许死锁发生"></a>不允许死锁发生</h4><ul>
<li><p>预防死锁：破坏必要条件</p>
<ul>
<li>破坏互斥：把临界资源改造成可以同时使用的资源，比如spooling技术，然而并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</li>
<li>破坏不可剥夺：当某个进程请求新的资源得不到满足时，它必须<strong>立即释放保持的所有资源</strong>，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。但这种策略也有很多缺点。</li>
<li>破坏请求和保持：可以使用<strong>静态分配法</strong>，进程在运行前一次性<strong>申请所有所需资源</strong>，如果申请未满足，就不把进程投入运行，一旦申请通过，<strong>整个运行过程中都占用这些资源</strong>；因为申请的资源多，所以可能因为条件一直得不到满足而造成进程饥饿。</li>
<li>破坏循环等待：使用<strong>顺序资源分配法</strong>，给资源编号，<strong>进程必须按照编号递增的规则请求资源</strong></li>
</ul>
</li>
<li><p>避免死锁：银行家算法</p>
<img src="..\images\操作系统\银行家算法.png" style="zoom:80%;" />

<p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要<strong>考虑到最坏的情况</strong>。</p>
<p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，不过如果没有进程提前释放资源，发生死锁也是将会发生的事情)。</p>
<p>因此可以在资源分配之前<strong>预先判断</strong>这次分配是否会导致系统进入<code>不安全状态</code>，以此决定是否答应资源分配请求。这也是<strong>银行家算法</strong>的核心思想。</p>
</li>
</ul>
<h4 id="允许死锁发生"><a href="#允许死锁发生" class="headerlink" title="允许死锁发生"></a>允许死锁发生</h4><ul>
<li><p>判断是否发生死锁：资源分配图</p>
<ul>
<li>定义一种数据结构存储资源的分配情况，实现一种算法检测是否发生死锁；</li>
<li>用一结点表示资源或者进程，进程指向资源的边，表示请求一个该资源，资源指向进程的边表示给该进程分配了多少资源，资源结点的值表示资源的数量。</li>
<li><strong>如果资源分配图的边能被全部简化，说明没有发生死锁，如果不能说明发送了死锁</strong>，这个简化的过程其实使用了<strong>银行家算法</strong>的思想。</li>
</ul>
</li>
<li><p>解除死锁</p>
<ul>
<li>资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销进程法(或称终止进程法)：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li>进程回退法：让一个或多个死锁进程<strong>回退</strong>到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ul>
</li>
</ul>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个进程长时间无法获得所需资源的状态，可能处于就绪状态也可能处于阻塞状态。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><img src="..\images\操作系统\内存管理.png" style="zoom:50%;" />

<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存可存放数据。<code>程序</code>执行前需要先放到<code>内存中</code>才能被CPU处理—<strong>缓和CPU与硬盘之间的速度矛盾</strong></p>
<img src="..\images\操作系统\内存.png" style="zoom:50%;" />

<h3 id="装入的三种方式"><a href="#装入的三种方式" class="headerlink" title="装入的三种方式"></a>装入的三种方式</h3><p>C语言<code>程序</code>经过<code>编译链接</code>处理后，生成<strong>装入模块</strong>，即<code>可执行文件</code>，它包含多条<code>指令</code>，可以放入内存中执行。</p>
<h4 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h4><p>在编译时，如果知道<code>程序</code>将放到内存中的哪个位置(知道基地址)，编译程序将把目标代码中的逻辑地址（相对地址）全部替换成<code>绝对地址(物理地址)</code>，<code>装入程序</code>按照<code>装入模块</code>中的地址，将程序和数据装入内存。这种方式的灵活性很差。</p>
<img src="..\images\操作系统\绝对装入.png" style="zoom:50%;" />

<h4 id="静态重定位"><a href="#静态重定位" class="headerlink" title="静态重定位"></a>静态重定位</h4><p><strong>在装入一个作业时</strong>，把装入模块中的<code>指令地址</code>和<code>数据地址</code>全部转换成<code>绝对地址（物理地址）</code>，提高了灵活性，但是如果<code>进程的位置改变了</code>（基地址变了），又会出错。</p>
<img src="..\images\操作系统\静态重定位.png" style="zoom:50%;" />

<h4 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h4><p>又称动态运行时装入。<code>编译、链接</code>后的<code>装入模块</code>的地址都是从<code>0</code>开始的。装入程序把装入模块<code>装入内存后</code>，并不会立即把逻辑地址转换为绝对地址（物理地址），而是把<code>地址转换</code>推迟到<code>程序真正要执行时</code>才进行。<strong>因此装入内存后所有的地址依然是逻辑地址</strong>(相对地址)。这种方式需要一个<strong>重定位寄存器</strong>的支持。</p>
<img src="..\images\操作系统\动态重定位.png" style="zoom:45%;" />

<p>采用动态重定位时，运行程序在内存中发生移动。</p>
<p>并且可将程序分配到<strong>不连续的存储区</strong>中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p>
<h3 id="从写入程序到运行"><a href="#从写入程序到运行" class="headerlink" title="从写入程序到运行"></a>从写入程序到运行</h3><img src="..\images\操作系统\从写入程序到运行.png" style="zoom:80%;" />

<ul>
<li>编译：由<code>编译程序</code>将用户<code>源代码</code>编译成若干个目标模块(编译就是把高级语言翻译为机器语言)</li>
<li>链接：由<code>链接程序</code>将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个<strong>完整的装入模块(exe文件)</strong></li>
<li>装入(装载)：由<code>装入程序</code>将<code>装入模块</code>装入<code>内存</code>运行</li>
</ul>
<h3 id="内存的分配与回收"><a href="#内存的分配与回收" class="headerlink" title="内存的分配与回收"></a>内存的分配与回收</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>指的是操作系统为用户进程分配的必须是一个连续的内存空间。</p>
<ul>
<li><p>单一连续分配：内存被分为系统区和用户区；<code>系统区</code>通常位于内存的<code>低地址</code>部分，用于存放操作系统相关数据；<code>用户区</code>用于存放<code>用户进程</code>相关数据。内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区空间。</p>
<img src="..\images\操作系统\单一连续内存分布.png" style="zoom:50%;" />

<p>优点:实现简单；无<code>外部碎片（存在未被分配的空间）</code>；可以采用覆盖技术扩充内存；不一定需要采取内存保护。<br>缺点:只能用于单用户、单任务的操作系统中；有<code>内部碎片（分配的空间内部还有剩余）</code>；<strong>存储器利用率极低</strong>。</p>
</li>
<li><p>固定分区分配：把<code>用户区分</code>为多个大小<code>相等或者不等</code>的区域，每个区域只放一个进程；会存在<code>内部碎片</code>，<code>无外部碎片</code>。</p>
<img src="..\images\操作系统\固定分区分配.png" style="zoom:50%;" />

<p>操作系统需要建立一个数据结构:<strong>分区说明表</strong>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<code>大小、起始地址、状态(是否已分配)</code>。</p>
<p>优点是实现简单，无外部碎片。缺点是当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能。还可能会产生<code>内部碎片</code>，内存利用率低。</p>
<img src="..\images\操作系统\分区表.png" style="zoom:50%;" />
</li>
<li><p>动态分区分配：动态分区分配又称为可变分区分配。这种分配方式<strong>不会预先划分内存分区</strong>，而是在进程装入内存时，根据进程的大小<strong>动态地建立分区，并使分区的大小正好适合进程的需要</strong>。因此系统分区的<code>大小和数目是可变的</code>。</p>
<img src="..\images\操作系统\动态分区分配.png" style="zoom:50%;" />

<p>那系统该使用什么<code>数据结构</code>来记录内存的使用情况呢？常用的两种数据结构是空闲分区表和空闲分区链。</p>
<img src="..\images\操作系统\分区链.png" style="zoom:50%;" />

<p>当很多空闲分区都能满足要求，应该选择哪个分区进行分配？把一个新作业装入内存时，须按照一定的<strong>动态分区分配算法</strong>，从空闲分<br>区表(或空闲分区链)中选出一个分区分配给该作业。由于<code>分配算法算法</code>对系统性能有很大的影响，因此人们对它进行了广泛的研究。</p>
</li>
</ul>
<h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><ul>
<li>内部碎片：给进程分配的空间没有被完全利用</li>
<li>外部碎片：内存中某些空闲分区由于太小而无法被利用；可以通过紧凑技术解决，但是需要改变进程的基地址，依赖于动态重定位。</li>
</ul>
<h4 id="离散分配"><a href="#离散分配" class="headerlink" title="离散分配"></a>离散分配</h4><ul>
<li><p><strong>分页存储</strong></p>
<p>一个<code>进程</code>可以被划分为多个<strong>大小相同的页</strong>，<strong>页号</strong>等于<code>逻辑地址/页面大小</code>，页内偏移量等于<code>逻辑地址%页面大小</code>。</p>
<p>内存被分为<code>多个物理块</code>，每个物理块就是一个<code>页框</code></p>
<p>每个进程都有自己的<strong>页表</strong>，存储在<code>PCB</code>中，记录了这个进程中所有<code>页面</code>与<code>页框</code>的对应关系。</p>
<img src="..\images\操作系统\页表.png" style="zoom: 45%;" />

<p>页表的页号不需要花存储空间存放，可以是隐含的(比如数组的下标就不要被存储)，只需要知道<code>页表基地址</code>和<code>块</code>的大小，可以把页表当作一个数组。块号需要花存储空间存放，存储的只是<strong>内存块的编号</strong>，不是起始地址。</p>
<p>那如何进行地址转换呢？</p>
<img src="..\images\操作系统\地址转换.png" style="zoom:50%;" />

<p><strong>快表</strong></p>
<p>存储在cpu中，<strong>用来加速逻辑地址到物理地址的转化</strong>，如果命中快表，就<strong>不需要访问内存中的页表</strong></p>
<p><strong>页表寄存器</strong></p>
<p>进程页表信息起初存储在<code>进程PCB</code>中，后续调用的时候把<code>页表基地址</code>和<code>长度</code>存储在页表寄存器中，但是页表其他信息还是存储在内存中。</p>
</li>
<li><p><strong>分段存储</strong></p>
<p>划分进程空间的时候是按<code>逻辑</code>划分的，划分为一个一个段；分页对用户是不可见的，分段是可见的，<strong>需要指定的</strong>。</p>
</li>
<li><p><strong>段页式存储</strong></p>
<p>把进程按逻辑划分为段，<strong>但是存储的时候又把每个段划分为页，每个段对应一个页表</strong>，段表存储的则是每个段的页表的位置和页表大小。</p>
</li>
</ul>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><code>传统存储管理</code>，包括前面介绍的<code>连续分配</code>和<code>非连续分配</code>，有许多特征，缺点。</p>
<ul>
<li><strong>一次性</strong>：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：<ul>
<li>作业很大时，不能全部装入内存，<strong>导致大作业无法运行</strong>；</li>
<li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致<strong>多道程序并发度下降</strong>。</li>
</ul>
</li>
<li><strong>驻留性</strong>：一旦作业被装入内存，<strong>就会一直驻留在内存中，直至作业运行结束</strong>。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</li>
</ul>
<p>其实这些问题都可以使用<strong>虚拟存储技术</strong>解决。</p>
<p><code>虚拟存储技术</code>是<code>基于局部性原理</code>：</p>
<ul>
<li><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问，因为程序中存在大量的循环。</li>
<li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问，因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的。</li>
</ul>
<p>基于<code>局部性原理</code>，在程序装入时，可以将程序中<strong>很快会用到的部分</strong>装入内存，暂时用不到的部分留在外存，就可以让程序<code>开始执行</code>。</p>
<p>在程序执行过程中，当所访问的信息<strong>不在内存时</strong>，由<code>操作系统</code>负责将所需信息<code>从外存调入内存</code>，然后继续执行程序。<br>若内存空间不够，由操作系统负责将内存中<strong>暂时用不到的信息</strong>换出到外存。</p>
<p>在<code>操作系统</code>的管理下，在用户看来，似乎有一个比<code>实际内存</code>大得多的内存，这就是<code>虚拟内存</code></p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h4><ul>
<li>多次性：无需在作业运行时一次性全部装入内存，而是允许被<code>分成多次调入内存</code>。</li>
<li>对换性：在作业运行时<code>无需一直常驻内存</code>，而是允许在作业运行过程中，将作业换入、换出。</li>
<li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li>
</ul>
<h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a><strong>如何实现</strong></h4><img src="..\images\操作系统\虚拟内存实现.png" style="zoom:50%;" />

<h3 id="内存分类"><a href="#内存分类" class="headerlink" title="内存分类"></a>内存分类</h3><h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><p>ROM(read only memory)，只读存储器，即：它只能读出信息，<strong>不能写入信息</strong>，计算机关闭电源后其内的信息仍旧保存，一般用它存储固定的<code>系统软件</code>和<code>字库</code>等。</p>
<p><strong>BIOS(basic iput&#x2F;output system)</strong></p>
<p>它提供了<code>硬件初始化</code>和<code>加载操作系统</code>的功能，存储在ROM中；操作系统本身是存储在计算机的<code>外存设备</code>上的，如硬盘或<code>SSD</code>(固态硬盘，Solid State Drive，操作系统通常安装在SSD的C盘上)，并在计算机启动时<strong>被加载到内存中运行</strong>。 </p>
<h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><p>RAM，全称为随机存取存储器（Random Access Memory），</p>
<p>是计算机系统中的一种<strong>主要存储器类型</strong>。它用于<code>临时存储</code>正在运行的程序和数据，以便处理器能够快速访问。RAM的特点是可以被<strong>迅速读写</strong>，并且<strong>支持对任何存储位置的随机访问，即访问时间与存储位置无关</strong>。</p>
<p><strong>主要特性</strong></p>
<ul>
<li><strong>易失性</strong>：RAM是一种易失性存储器，意味着当<strong>电源关闭时，存储在其中的数据会被清除</strong>。因此，它主要用于存储那些需要频繁修改和访问的数据。</li>
<li><strong>高速度</strong>：相比硬盘驱动器或固态硬盘等<code>永久存储设备</code>，RAM提供了<code>更快的数据读写速度</code>，这使得它非常适合用于作为<code>CPU的主存储区域</code>，以加快计算任务的处理速度。</li>
<li><strong>容量与成本</strong>：随着技术的进步，RAM的容量不断增大，同时单位价格也在下降。不过，相较于其他类型的存储介质，相同容量下的RAM通常更昂贵。</li>
</ul>
<h4 id="拓展：外存"><a href="#拓展：外存" class="headerlink" title="拓展：外存"></a>拓展：外存</h4><p>硬盘属于外存，是可<code>读写</code>的，比如C盘，D盘。</p>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><p>一次i&#x2F;o请求对应一个请求包</p>
<h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><p>I&#x2F;O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的<strong>外部设备</strong>，属于计算机中的<strong>硬件部件</strong>。UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。要注意的是，网络通信设备也属于io设备。</p>
<h3 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I&#x2F;O控制器"></a>I&#x2F;O控制器</h3><p><code>cpu</code>和<code>i/o电子部件</code>的中间设备</p>
<img src="..\images\操作系统\IO控制器.png" style="zoom: 40%;" />

<p>IO控制器的组成包括：多种寄存器，I&#x2F;O逻辑，控制器与设备的接口。</p>
<img src="..\images\操作系统\IO设备组成.png" style="zoom: 40%;" />

<h3 id="I-O操作大致过程"><a href="#I-O操作大致过程" class="headerlink" title="I&#x2F;O操作大致过程"></a>I&#x2F;O操作大致过程</h3><p><strong>用户程序→系统调用处理程序→中断处理程序→设备驱动程序</strong></p>
<p>当一个用户程序需要执行I&#x2F;O操作（如读写文件、网络通信等）时，它不能直接访问硬件资源。因此，程序会通过<code>系统调用</code>来<strong>请求操作系统的服务</strong>。系统调用是一种特殊的接口，它允许<code>用户空间的应用程序</code>请求<code>内核</code>提供的服务。当用户程序发出<code>系统调用</code>时，CPU会从用户态切换到<code>内核态</code>，即发生了中断。中断处理程序将 I&#x2F;O 请求传递给相应的<code>设备驱动程序</code>，设备驱动程序运行在<code>内核态</code>，因为需要直接访问硬件资源。</p>
<h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h3><h4 id="程序直接控制"><a href="#程序直接控制" class="headerlink" title="程序直接控制"></a>程序直接控制</h4><img src="..\images\操作系统\程序直接控制.png" style="zoom:50%;" />

<p><strong>需要cpu轮询检查i&#x2F;o设备状态</strong>，此时不能做其他事情，i&#x2F;o和cpu处理只能<code>串行</code></p>
<h4 id="中断驱动"><a href="#中断驱动" class="headerlink" title="中断驱动"></a>中断驱动</h4><p>引入中断机制。由于I&#x2F;O设备速度很慢，因此在CPU发出读&#x2F;写命令后，可将等待I&#x2F;O的进程阻塞，先切换到别的进程执行<code>[进程：我需要IO操作，CPU：我帮你向控制器发命令了，你先下CPU吧，我去忙别的]</code>。当I&#x2F;O完成后，控制器会向CPU发出一个中断信号<code>[控制器：IO操作完毕，CPU大人快来取数据吧]</code>，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断<code>[CPU：别急，等我保存我的工作记录，再来取数据]</code>。处理中断的过程中，CPU从I&#x2F;O控制器读一个字的数据传送到<code>CPU寄存器</code>，再写入<code>主存</code>。接着，CPU恢复等待I&#x2F;O的进程(或其他进程)的运行环境，然后继续执行<code>[CPU：你需要的IO操作完成了，我要继续完成你这个进程了]</code></p>
<p><strong>注意</strong></p>
<ul>
<li>CPU会在每个指令周期的末尾检查中断</li>
<li>中断处理过程中需要保存、恢复进程的运行环境这个过程是需要一定<strong>时间开销</strong>的。可见，如<strong>果中断发生的频率太高，也会降低系统性能。</strong></li>
<li>每次中断只能读入一个字，如果需要读入大量数据，就需要多次中断。</li>
</ul>
<h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>DMA方式(Direct MemoryAccess，直接存储器存取），数据传输的过程不需要经过cpu（不需要通过cpu寄存器写入内存），一次cpu命令能读取一块或者多块连续内存，写入到内存不需要经过cpu，由DMA直接写入。当DMA传输完成后，DMA控制器会通过中断的方式通知CPU数据传输已经完成，以便CPU可以进行后续处理。</p>
<h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>只能用来<code>处理io的处理机</code>，相当于阉割版的cpu，通道没有自己的内存，通道程序(cpu给的任务清单)存储在内存中，通道需要读取内存中的<code>通道程序</code>并运行；引入通道的目的是让数据的传输独立于CPU，使CPU从繁重的I&#x2F;O工作中解脱出来。</p>
<h3 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h3><p>也叫spooling技术，用<strong>软件的方式</strong>模拟<code>脱机技术</code>(脱离主机控制进行输入输出操作，把cpu从繁重的io工作中解放出来)。可以把物理设备虚拟为多个逻辑设备，比如，使用spooling技术改造打印机，对于进程使用打印机的请求，<strong>把它放入打印任务队列中，让进程以为获得了打印机设备</strong>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.sanye.blog">三叶sanye</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.sanye.blog/posts/d04bd5bc.html">https://www.sanye.blog/posts/d04bd5bc.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.sanye.blog" target="_blank">三叶的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post-share"><div class="social-share" data-image="/images/cover/%E6%98%9F%E7%A9%BA.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/4b0178e0.html" title="数据结构与算法"><img class="cover" src="/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数据结构与算法</div></div><div class="info-2"><div class="info-item-1">时间复杂度，空间复杂度非线性结构二叉树二叉树的性质 深度为k的二叉树最多结点数目：深度为k即有k层，第k层的最大结点数等于2^(k-1)，经过等比数列求和后可得到深度为k的二叉树最多有(2^k)-1个结点，这就好比k位二进制能标识的最大的数为(2^k)-1，8位二进制数能表示的最大的数是2^8-1&#x3D;127。 一条边出现表示一个新的结点（除了根节点）：结点数目=边数+1 边数 &#x3D; 出度为1的结点数目+2*出度为2的结点数目* 结点总数&#x3D;出度为1的结点数目+出度为2的结点数目+叶子结点数 结点数目&#x3D;边数+1&#x3D;（出度为1的结点数目+2*出度为2的结点数目）+1，即不需要确定叶子结点的数目，也可以得出结点总数 出度为2的结点数 + 1 &#x3D; 叶子结点数  思路：  思考边数和结点数的关系  思考边数和结点出度之间的关系   二叉树的遍历先序遍历(Preorder)访问顺序：根节点 -&gt; 左子树 -&gt;...</div></div></div></a><a class="pagination-related" href="/posts/8b27fabc.html" title="vue"><img class="cover" src="/images/cover/preview.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">vue</div></div><div class="info-2"><div class="info-item-1"> 关于vue的绝大部分知识点都在前端面试—vue部分 | 三叶的博客这篇文章中讲了，这里就说说基础语法 关于vue的绝大部分知识点都在前端面试—vue部分 | 三叶的博客这篇文章中讲了，这里就说说基础语法    Vue2插值表达式利用表达式进行插值，渲染数据到页面中 123&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&lt;p&gt;&#123;&#123;nickname.toUppercase()&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;age &gt;= 18 ?&#x27;成年’:&#x27;未成年&#x27;&#125;&#125;&lt;/p&gt;  注意：不能写到标签内部，表达式涉及到的数据必须存在。 指令带有v-前缀的特殊标签属性，Vue会根据不同的【指令】，针对标签实现不同的【功能】 v-html设置元素的innerHTML v-if&#x2F;v-show用来控制元素显示隐藏。 v-show&#x3D;”表达式”，表达式值true显示，...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/%E4%B8%89%E5%8F%B6.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">三叶sanye</div><div class="author-info-description">记录学习，分享知识</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://space.bilibili.com/660655866?spm_id_from=333.1007.0.0" rel="external nofollow noreferrer" target="_blank" title="Bilibli"><i class="fa-brands fa-bilibili" style="color: #74C0FC;"></i></a><a class="social-icon" href="https://github.com/syhy" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3519450570@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">笔记主要自用，希望也能帮到你😀</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">操作系统类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F-VMM"><span class="toc-number">2.</span> <span class="toc-text">虚拟机管理程序(VMM)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%9F%E8%83%BD"><span class="toc-number">3.</span> <span class="toc-text">操作系统功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">4.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E4%B8%AD%E6%96%AD%EF%BC%88%E5%BC%82%E5%B8%B8%EF%BC%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">内中断（异常）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E4%B8%AD%E6%96%AD"><span class="toc-number">4.2.2.</span> <span class="toc-text">外中断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81-%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">4.3.</span> <span class="toc-text">用户态&#x2F;内核态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4"><span class="toc-number">4.4.</span> <span class="toc-text">特权指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.5.</span> <span class="toc-text">中断程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B5%8C%E5%A5%97"><span class="toc-number">4.6.</span> <span class="toc-text">中断嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD"><span class="toc-number">4.7.</span> <span class="toc-text">中断屏蔽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.</span> <span class="toc-text">程序与进程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E6%88%90"><span class="toc-number">5.3.</span> <span class="toc-text">进程组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%85%B3%E7%B3%BB"><span class="toc-number">5.4.</span> <span class="toc-text">进程之间的基本关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-PV%E6%93%8D%E4%BD%9C"><span class="toc-number">5.5.</span> <span class="toc-text">进程同步-PV操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">5.6.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">5.6.1.</span> <span class="toc-text">共享地址空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">5.6.2.</span> <span class="toc-text">消息传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">5.6.3.</span> <span class="toc-text">管道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C-%E5%BC%82%E6%AD%A5"><span class="toc-number">5.7.</span> <span class="toc-text">并发&#x2F;并行&#x2F;异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.8.</span> <span class="toc-text">进程状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.9.</span> <span class="toc-text">进程调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.9.1.</span> <span class="toc-text">先来先服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88"><span class="toc-number">5.9.2.</span> <span class="toc-text">短作业优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-number">5.9.3.</span> <span class="toc-text">高响应比优先算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E7%AE%97%E6%B3%95"><span class="toc-number">5.9.4.</span> <span class="toc-text">时间片轮转算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">5.9.5.</span> <span class="toc-text">优先级调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%B0%83%E5%BA%A6"><span class="toc-number">5.10.</span> <span class="toc-text">其他调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">6.0.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">6.0.2.</span> <span class="toc-text">线程的属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">7.1.</span> <span class="toc-text">必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E6%AD%BB%E9%94%81%E5%8F%91%E7%94%9F"><span class="toc-number">7.2.1.</span> <span class="toc-text">不允许死锁发生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%81%E8%AE%B8%E6%AD%BB%E9%94%81%E5%8F%91%E7%94%9F"><span class="toc-number">7.2.2.</span> <span class="toc-text">允许死锁发生</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF"><span class="toc-number">7.3.</span> <span class="toc-text">饥饿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">8.1.</span> <span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">装入的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5"><span class="toc-number">8.2.1.</span> <span class="toc-text">绝对装入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">8.2.2.</span> <span class="toc-text">静态重定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">8.2.3.</span> <span class="toc-text">动态重定位</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%86%99%E5%85%A5%E7%A8%8B%E5%BA%8F%E5%88%B0%E8%BF%90%E8%A1%8C"><span class="toc-number">8.3.</span> <span class="toc-text">从写入程序到运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-number">8.4.</span> <span class="toc-text">内存的分配与回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">8.4.1.</span> <span class="toc-text">连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A2%8E%E7%89%87"><span class="toc-number">8.4.2.</span> <span class="toc-text">碎片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%88%86%E9%85%8D"><span class="toc-number">8.4.3.</span> <span class="toc-text">离散分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">8.5.</span> <span class="toc-text">虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.5.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">8.5.2.</span> <span class="toc-text">特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.5.3.</span> <span class="toc-text">如何实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E7%B1%BB"><span class="toc-number">8.6.</span> <span class="toc-text">内存分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ROM"><span class="toc-number">8.6.1.</span> <span class="toc-text">ROM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RAM"><span class="toc-number">8.6.2.</span> <span class="toc-text">RAM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9A%E5%A4%96%E5%AD%98"><span class="toc-number">8.6.3.</span> <span class="toc-text">拓展：外存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O"><span class="toc-number">9.</span> <span class="toc-text">I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E8%AE%BE%E5%A4%87"><span class="toc-number">9.1.</span> <span class="toc-text">I&#x2F;O设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">9.2.</span> <span class="toc-text">I&#x2F;O控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E6%93%8D%E4%BD%9C%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B"><span class="toc-number">9.3.</span> <span class="toc-text">I&#x2F;O操作大致过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">9.4.</span> <span class="toc-text">I&#x2F;O控制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">9.4.1.</span> <span class="toc-text">程序直接控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8"><span class="toc-number">9.4.2.</span> <span class="toc-text">中断驱动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA"><span class="toc-number">9.4.3.</span> <span class="toc-text">DMA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93"><span class="toc-number">9.4.4.</span> <span class="toc-text">通道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">9.5.</span> <span class="toc-text">假脱机技术</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/518e617c.html" title="git"><img src="/images/cover/dog.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git"/></a><div class="content"><a class="title" href="/posts/518e617c.html" title="git">git</a><time datetime="2025-02-09T08:07:36.000Z" title="发表于 2025-02-09 16:07:36">2025-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e255a10a.html" title="计算机网络"><img src="/images/cover/maomao.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/posts/e255a10a.html" title="计算机网络">计算机网络</a><time datetime="2025-02-07T15:08:21.000Z" title="发表于 2025-02-07 23:08:21">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4b0178e0.html" title="数据结构与算法"><img src="/images/cover/%E7%A7%98%E5%AF%86%E9%A3%8E%E6%99%AF.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法"/></a><div class="content"><a class="title" href="/posts/4b0178e0.html" title="数据结构与算法">数据结构与算法</a><time datetime="2025-02-07T14:48:29.000Z" title="发表于 2025-02-07 22:48:29">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d04bd5bc.html" title="操作系统"><img src="/images/cover/%E6%98%9F%E7%A9%BA.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/posts/d04bd5bc.html" title="操作系统">操作系统</a><time datetime="2025-02-06T15:49:56.000Z" title="发表于 2025-02-06 23:49:56">2025-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/8b27fabc.html" title="vue"><img src="/images/cover/preview.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue"/></a><div class="content"><a class="title" href="/posts/8b27fabc.html" title="vue">vue</a><time datetime="2025-01-25T14:00:18.000Z" title="发表于 2025-01-25 22:00:18">2025-01-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/images/cover/1.png);"><div id="footer-wrap"><div class="footer_custom_text"><div id="sanye"><svg class="icon" aria-hidden="true"><use href="#icon-banquan"></use></svg><span>2024 - 2025 By 三叶sanye</span><svg class="icon" aria-hidden="true"><use href="#icon-sanyecao"></use></svg></div><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://unpkg.com/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/time.js"></script><script src="/js/iconfont.js"></script><script defer="defer" id="ribbon" src="https://unpkg.com/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://unpkg.com/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://unpkg.com/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/js/busuanzi.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"display":{"position":"left","width":120,"height":240},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>
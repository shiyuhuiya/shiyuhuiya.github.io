<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>react</title>
      <link href="/posts/19656fd5.html"/>
      <url>/posts/19656fd5.html</url>
      
        <content type="html"><![CDATA[<h2 id="初识-React"><a href="#初识-React" class="headerlink" title="初识 React"></a>初识 React</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>用于构建用户界面的js库，是一个将数据渲染为html视图的开源js库，由facebook开发的</p><h3 id="为什么要学习react"><a href="#为什么要学习react" class="headerlink" title="为什么要学习react"></a>为什么要学习react</h3><ul><li><p>原生js操作dom繁琐，效率低，</p></li><li><p>使用js直接操作dom，浏览器会进行大量的重绘重排</p></li><li><p>原生js没有组件化编码方案，代码复用率低</p></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>采用<code>组件化</code>模式、<code>声明式编码</code>，提高开发效率及组件复用率。</li><li>在<code>React Native</code>中可以使用React语法进行移动端开发</li><li>使用<code>虚拟DOM</code>+优秀的<code>Diffing</code> 算法，实现<strong>dom的复用</strong>，尽量减少与真实DOM的交互。</li></ul><img src="..\images\react\虚拟dom.png" style="zoom: 40%;" /><h3 id="hello-react"><a href="#hello-react" class="headerlink" title="hello_react"></a>hello_react</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello_react<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 引入react核心库 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入react-dom，用于支持react操作DOM --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 引入babel，用于将jsx转为js --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* 此处一定要写babel */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1. 创建虚拟DOM</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="variable constant_">VDOM</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>; <span class="comment">/* 此处一定不要写引号，因为不是字符串 ，我们写的是jsx语法 */</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2. 渲染虚拟DOM到页面</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="variable constant_">VDOM</span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>上述三个js文件一定要按顺序引入</li><li>我们引入<code>react.development.js</code>在全局就会出现React对象，引入<code>react-dom.development.js</code>在全局出现<code>ReactDOM</code>对象</li><li>script标签的类型一定要是是<code>text/babel</code>，因为我们写的是jsx代码，然后借助浏览器的<code>babel</code>进行代码转换</li></ul><h2 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>jsx是javascript和xml的缩写，xml早期用于存储和传输数据。现在已经被json替代</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>19<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为什么在react中使用jsx不使用js？</p><h3 id="创建虚拟dom"><a href="#创建虚拟dom" class="headerlink" title="创建虚拟dom"></a>创建虚拟dom</h3><p>两种语言创建虚拟dom的语法不同</p><ul><li><p>jsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello,React<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>,&#123;<span class="attr">id</span>:<span class="string">&#x27;title&#x27;</span>&#125;,<span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>,&#123;&#125;,<span class="string">&#x27;Hello,React&#x27;</span>))</span><br></pre></td></tr></table></figure></li></ul><p>显然，使用jsx创建虚拟dom更简单。</p><h3 id="虚拟dom是什么"><a href="#虚拟dom是什么" class="headerlink" title="虚拟dom是什么"></a>虚拟dom是什么</h3><p> 虚拟dom本质就是一个js对象，是对真实dom的高度抽象，我们可以通过输出虚拟dom和真实dom来比较分析它们的区别</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* 此处一定要写babel */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="variable constant_">VDOM</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>; <span class="comment">/* 此处一定不要写引号，因为不是字符串 ，我们写的是jsx语法 */</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">VDOM</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="variable constant_">DOM</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">dir</span>(<span class="variable constant_">DOM</span>)<span class="comment">//不使用log，因为输出的信息太少</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="jsx语法规则"><a href="#jsx语法规则" class="headerlink" title="jsx语法规则"></a>jsx语法规则</h3><ul><li>定义虚拟dom的时候，不要写引号</li><li>在标签中混入js表达式的时候要用<code>&#123;&#125;</code>，一定注意区分:<code>js语句</code>与<code>js表达式</code><ul><li>表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方，下面这些都是表达式:<ul><li>a</li><li>a+b</li><li>demo(1)，函数调用</li><li>arr.map()，函数调用</li><li>function test(){}，函数定义</li></ul></li><li>语句(代码)：下面这些都是语句(代码):<ul><li>if(){}</li><li>for(){}</li><li>switch(){case:xxxx}</li></ul></li></ul></li><li>样式的类名不要用<code>class</code>，而要用<code>className</code>，为了避开es6的class关键字</li><li>内联样式要用<code>style=&#123;&#123;key:value&#125;&#125;</code>的形式书写</li><li>标签必须闭合</li><li>只有一个根标签，类似vue2</li><li>标签首字母如果是小写的，则将该标签转换为html中的同名标签，如果html没有对应的标签则报错</li><li>标签首字母如果是大写的，react就去渲染对应的组件，若该组件没有定义则报错。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.title</span>&#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">background-color</span>:<span class="string">&#x27;red&#x27;</span></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&gt; </span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">const myId =&#x27;aTgUiGu&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">const myData= &#x27;HeLlo,rEact&#x27;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">//1.创建虚拟DOM</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">const VDOM =(</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">&lt;div&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">&lt;h2 className=&quot;</span><span class="attr">title</span>&quot; <span class="attr">id</span>=<span class="string">&#123;myId.toLowercase()&#125;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">                //最外面的大括号表示&#123;color:&#x27;white&#x27;,fontsize:&#x27;29px&#x27;&#125;是一个js表达式</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=</span></span><span class="template-variable">&#123;&#123;<span class="name">color:</span><span class="string">&#x27;white&#x27;</span>,fontsize:<span class="string">&#x27;29px&#x27;</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&gt;</span>&#123;myData.toLowerCase()&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span> <span class="attr">id</span>=<span class="string">&#123;myId.toUppercase()&#125;</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=</span></span><span class="template-variable">&#123;&#123;<span class="name">color:</span><span class="string">&#x27;white&#x27;</span>,fontsize:<span class="string">&#x27;29px&#x27;</span>&#125;&#125;</span><span class="language-xml"><span class="tag">&gt;</span>&#123;myData.toLowerCase()&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">            //标签必须闭合，包括单标签</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>/&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="tag">&lt;<span class="name">Good</span>&gt;</span>123<span class="tag">&lt;/<span class="name">Good</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">//2.渲染虚拟DOM到页面</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml">ReactDoM.render(VDoM,document.getElementById(&#x27;test&#x27;))</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="language-xml"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="jsx小案例"><a href="#jsx小案例" class="headerlink" title="jsx小案例"></a>jsx小案例</h3><h2 id="组件与模块化"><a href="#组件与模块化" class="headerlink" title="组件与模块化"></a>组件与模块化</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>将复杂的js文件拆分成一个一个js文件，每个js文件就是一个模块</p><h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>组件是能实现局部功能的<strong>代码和资源的集合</strong>（html，css，js，images…）</p><h2 id="组件化-1"><a href="#组件化-1" class="headerlink" title="组件化"></a>组件化</h2><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">//1.创建函数式组件</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">function MyComponent()&#123;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">console.log(this);//此处的this是undefined，因为babel编译后开启了严格模式</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">return <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是用函数定义的组件(适用于简单组件的定义)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">&#125;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">//2.渲染组件到页面</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">ReactDOM.render(<span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span>,document.getElementById(&#x27;test))</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">//执行了ReactDom.render(<span class="tag">&lt;<span class="name">Mycomponent</span>/&gt;</span>.......之后，发生了什么?</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">//1.React解析组件标签，找到了MyComponent组件。</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">//2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要注意的点包括：</p><ul><li>函数名必须大写，函数名就是组件名，要符合组件名的规范，</li><li>函数必须有返回值</li><li><code>ReactDom.render</code>的第一个参数必须是，组件标签，而不是组件名。</li></ul><h3 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//1. 创建类式组件</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// render是放在哪里的？ — MyComponent的原型对象上，供实例使用。</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// render中的this是谁？ — MyComponent的实例对象 &lt;= MyComponent组件实例对象。</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;render中的this:&#x27;</span>, <span class="variable language_">this</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是用类定义的组件(适用于【复杂组件】的定义)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//2. 渲染组件到页面</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/*执行了 ReactDOM.render(&lt;MyComponent/&gt;.....之后发生了什么？</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">  1.react解析组件标签，找到了MyComponent组件</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">  2.发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">  3.将render返回的虚拟dom转换成真实dom，随后呈现在页面中</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">  */</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要注意的点包括：</p><ul><li>如果一个类想要成为<code>类式组件</code>，必须继承<code>React.Component</code>类</li><li>这个类必须实现<code>render</code>方法，这个方法必须有返回值</li></ul><h3 id="组件实例的3大属性"><a href="#组件实例的3大属性" class="headerlink" title="组件实例的3大属性"></a>组件实例的3大属性</h3><img src="..\images\react\三大属性.png" style="zoom: 67%;" /><p>组件实例上的所有属性，都是<code>React.Component</code>类的<code>构造函数</code>初始化的，因为我们定义的类并没有构造器。</p><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>可以看到上面实例的state属性是null，如果我们想要修改这个属性，就必须在<code>自定义的组件</code>（类）中添加构造函数。</p><p><strong>初始案例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//1. 创建组件</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//添加构造函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//任何有关this的操作不能写在super前面</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">super</span>(props);<span class="comment">//props应该是一个对象，包含了父类构造函数的所有形参</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">isHot</span>: <span class="literal">false</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风&#x27;</span>&#125;;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//根据原型链上的changeWeather，创造一个同名方法挂载到实例本身上，确保在回调函数中直接调用这个函数时this指向组件实例</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">changeWeather</span> = <span class="variable language_">this</span>.<span class="property">changeWeather</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//调用1+n次，第一次调用是因为初次渲染，后续n次调用是因为数据变化。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> &#123; isHot &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> (</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//传入一个函数作为回调，但是这个回调函数不是通过this调用的，而是直接调用的</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//必须传入的一个函数吗，不能是函数调用吗</span></span></span><br><span class="line"><span class="language-javascript">        <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;,&#123;this.state.wind&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">changeWeather</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//如果这个方法是被组件实例调用的，那么就能访问到state</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//this.state.isHot = !this.state.isHot//不能直接修改state中的数据，视图不会更新</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">isHot</span>:!<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isHot</span>&#125;)<span class="comment">//这是一个合并操作，不是覆盖操作，也就是说，wind属性会保留</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//2. 渲染组件到页面</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要注意的包括以下几点：</p><ul><li>类中的方法都在局部开启了严格模式</li><li>render方法是通过组件实例调用的，不过这个组件实例不是我们手动创建的，这个方法也不是我们手动调用的。</li><li>在react中<code>onClick</code>不能写成onclick，虽然在js原生语法中就是写做<code>onclick</code></li></ul><p><strong>state的精简</strong></p><p>在上述代码中我们为了初始化state等操作，引入了构造函数，其实我们可以<strong>直接省略构造函数</strong> </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//1. 创建组件</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">class</span> <span class="title class_">Weather</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span></span><br><span class="line"><span class="language-javascript"> state = &#123; <span class="attr">isHot</span>: <span class="literal">false</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风&#x27;</span>&#125;;<span class="comment">//这样写效果也是一样的，都会被添加到组件实例自身上</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//调用1+n次，第一次调用是因为初次渲染，后续n次调用是因为数据变化。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> &#123; isHot &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> (</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//传入一个函数作为回调，但是这个回调函数不是通过this调用的，而是直接调用的</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//必须传入的一个函数吗，不能是函数调用吗</span></span></span><br><span class="line"><span class="language-javascript">        <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;,&#123;this.state.wind&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//我们把changeWeather函数写成a=1的形式，这样的话这个方法就不会被挂载到原型对象上了，而是组件实例本身</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//如果我们不写作箭头函数，由于这个函数在点击事件触发后还是会直接调用，this就是undefined</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//但是如果我们写作箭头函数，this的指向就是组件实例，不过为啥呢？</span></span></span><br><span class="line"><span class="language-javascript">    changeWeather=<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//如果这个方法是被组件实例调用的，那么就能访问到state</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//this.state.isHot = !this.state.isHot//不能直接修改state中的数据，视图不会更新</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">isHot</span>:!<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isHot</span>&#125;)<span class="comment">//这是一个合并操作，不是覆盖操作，也就是说，wind属性会保留</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//2. 渲染组件到页面</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 创建组件</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> &#123; name, age, sex &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> (</span></span><br><span class="line"><span class="language-javascript">        <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 渲染组件到页面</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;jerry&quot;</span> <span class="attr">age</span>=<span class="string">&quot;19&quot;</span> <span class="attr">sex</span>=<span class="string">&quot;男&quot;</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test1&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;tom&quot;</span> <span class="attr">age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">sex</span>=<span class="string">&quot;女&quot;</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test2&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;老刘&quot;</span> <span class="attr">age</span>=<span class="string">&quot;30&quot;</span> <span class="attr">sex</span>=<span class="string">&quot;女&quot;</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test3&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出在react中，也是通过给<code>组件标签</code>添加<code>属性</code>来实现给组件传值的，然后这些属性<strong>会被收集到组件实例的props属性</strong>中，值为一个对象。而下面的代码则展示了如何快速的给组件传值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;jerry&quot;</span>,<span class="attr">age</span>:<span class="number">19</span>,<span class="attr">sex</span>:<span class="string">&quot;男&quot;</span>&#125;</span><br><span class="line"><span class="comment">//标签内的大括号表示内部是js表达式</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> &#123;<span class="attr">...obj</span>&#125;/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test1&#x27;</span>));</span><br></pre></td></tr></table></figure><p> <strong>限制传入组件值的类型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;jerry&quot;</span> <span class="attr">age</span>=<span class="string">&quot;19&quot;</span> <span class="attr">sex</span>=<span class="string">&quot;男&quot;</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test1&#x27;</span>));</span><br></pre></td></tr></table></figure><p>通过上述方式传入的name，age等属性值，它们的类型都是字符串，后续如果需要在模板中实现：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;age+1&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>的效果，得到的就是<code>191</code>，即字符串拼接。</p><p>想要对传入组件的值的类型进行限制，并添加默认值，需要添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对标签属性进行类型、必要性的限制</span></span><br><span class="line"><span class="comment">//给Person类，添加propTypes属性</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">propTypes</span>=&#123;</span><br><span class="line"><span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>，<span class="comment">//限制name必传，且为字符串</span></span><br><span class="line"><span class="attr">sex</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>,<span class="comment">//限制sex为字符串</span></span><br><span class="line"><span class="attr">age</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>,<span class="comment">//限制age为数值</span></span><br><span class="line"><span class="attr">speak</span>: <span class="title class_">PropTypes</span>.<span class="property">func</span>,<span class="comment">//限制speak为所数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给Person类添加defaultProps属性</span></span><br><span class="line"><span class="comment">//指定默认标签属性值</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">defaultProps</span> =&#123;</span><br><span class="line"><span class="attr">sex</span>:男<span class="string">&#x27;，//sex默认值为男</span></span><br><span class="line"><span class="string">age:18 //age默认值为18</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>其中的PropTypes对象是通过引入<code> </code>文件后挂载到全局的对象</p><p>可以看出在react中限制给组件传入的值的类型是非常麻烦的。</p><p>其实我们可以把 <code>Person.propTypes = &#123;...&#125;</code>，和<code>Person.defaultProps = &#123;...&#125;</code>的操作写在类的内部，从而简化代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">  // 创建组件</span><br><span class="line">  class Person extends React.Component &#123;</span><br><span class="line">    static propTypes = &#123;</span><br><span class="line">   name: PropTypes.string.isRequired，//限制name必传，且为字符串</span><br><span class="line">   sex: PropTypes.string,//限制sex为字符串</span><br><span class="line">   age: PropTypes.number,//限制age为数值</span><br><span class="line">   speak: PropTypes.func,//限制speak为所数</span><br><span class="line">    &#125;</span><br><span class="line">    static defaultProps = &#123;</span><br><span class="line">   sex:男&#x27;，//sex默认值为男</span><br><span class="line">  age:18 //age默认值为18</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">      const &#123; name, age, sex &#125; = this.props;</span><br><span class="line">      return (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &lt;li&gt;姓名：&#123;name&#125;&lt;/li&gt;</span><br><span class="line">          &lt;li&gt;性别：&#123;sex&#125;&lt;/li&gt;</span><br><span class="line">          &lt;li&gt;年龄：&#123;age&#125;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 渲染组件到页面</span><br><span class="line">  ReactDOM.render(&lt;Person name=&quot;jerry&quot; age=&quot;19&quot; sex=&quot;男&quot;/&gt;, document.getElementById(&#x27;test1&#x27;));</span><br><span class="line">  ReactDOM.render(&lt;Person name=&quot;tom&quot; age=&quot;18&quot; sex=&quot;女&quot;/&gt;, document.getElementById(&#x27;test2&#x27;));</span><br><span class="line">  ReactDOM.render(&lt;Person name=&quot;老刘&quot; age=&quot;30&quot; sex=&quot;女&quot;/&gt;, document.getElementById(&#x27;test3&#x27;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>我们之前在学习react组件的构造器的时候也发现了props的身影：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">//任何有关this的操作不能写在super前面</span></span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>props</code>就是传递给组件实例的参数对象，等价于<code>this.props</code>，如果不写<code>super(props)</code>就无法在构造函数中通过<code>this.props</code>访问到传递给组件实例的参数对象，其实也没啥用(为什么作用不是<code>this.props = props</code>)</p><p>我们可能认为，函数式组件内部没有this，所以并部存在组件实例的三大属性。其实，因为函数可以传参，我们可以在函数式组件中拿到props：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;name,age,sex&#125;= props</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名:&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>性别:&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄:&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure><h4 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 展示左侧输入框的数据</span></span><br><span class="line">  showData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; input1 &#125; = <span class="variable language_">this</span>.<span class="property">refs</span>;</span><br><span class="line">    <span class="title function_">alert</span>(input1.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 展示右侧输入框的数据</span></span><br><span class="line">  showData2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; input2 &#125; = <span class="variable language_">this</span>.<span class="property">refs</span>;</span><br><span class="line">    <span class="title function_">alert</span>(input2.<span class="property">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;input1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;点击按钮提示数据&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span>&gt;</span>点我提示左侧的数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;input2&quot;</span> <span class="attr">onBlur</span>=<span class="string">&#123;this.showData2&#125;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;失去焦点提示数据&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在react中，我们没有必要直接通过<code>document.querySelector</code>来获得dom对象，我们直接给组件标签添加<code>ref</code>属性并传入一个唯一的值key，然后这个标签对应的dom元素就可以通过<code>this.refs.key</code>访问到，这一点和vue2中的语法是很像的。</p><p>然而这种<strong>给ref属性赋值字符串</strong>的语法是不被推荐的，因为被认为是效率低的，推荐的写法是传入<code>回调函数</code>，在传入的回调函数的参数中能拿到对应的dom。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        //获取到dom，并挂载到组件实例上去</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;(c)</span>=&gt;</span>&#123;this.input = c&#125;&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span>&gt;</span>点我提示左侧的数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要注意的是，如果 ref 回调函数是以<strong>内联函数</strong>的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的，<strong>不过这是无关紧要的</strong>，开发过程中仍然可以使用。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./react/react.development.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./react/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./react/prop-types.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./react/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">class</span> <span class="title class_">Component</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    state = &#123; <span class="attr">cold</span>: <span class="literal">false</span> &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    func = <span class="function">() =&gt;</span> &#123; <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">value</span>) &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    changeWeather = <span class="function">() =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">cold</span>: !<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">code</span> &#125;) &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">return</span> (</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">          <span class="tag">&lt;<span class="name">h1</span>&gt;</span>当前天气&#123;this.state.cold ? &#x27;炎热&#x27; : &#x27;寒冷&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">          //内联函数</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;(c)</span> =&gt;</span> &#123; this.input = c; console.log(&quot;@&quot;, c) &#125;&#125; /&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.func&#125;</span>&gt;</span>点击获取输入框的值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>点击改变天气<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      )</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#box&#x27;</span>))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>为了避免这种问题，我们可以传入一个<strong>在类中已经定义好的，挂载到组件实例上的函数</strong>。</p><p>然而，react最推荐的方式是先定义一个容器，然后再把dom放入容器中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myRef = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">&lt;input ref=&#123;<span class="variable language_">this</span>.<span class="property">myRef</span>&#125; type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;点击按饥提示数据&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p>最后通过<code>this.myRef.current</code>就能访问到dom，要注意的是每个容器只能放一个dom，感觉不如document….</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul><li>通过<code>onXxx</code>属性指定事件处理函数(注意大小写)</li><li>React 使用的是自定义(合成)事件,而不是使用的原生 DOM 事件</li><li>React中的事件是通过<code>事件委托</code>方式处理的(委托给组件最外层的元素)</li><li>通过 event.target 得到发生事件的 DOM 元素对象</li></ul><p><strong>受控组件和非受控组件</strong></p><ul><li>受控组件就是表单组件值改变的时候就更新值到state</li><li>而非受控组件就是通过ref获取表单组件dom，然后需要的时候通过dom.value来获得值</li></ul><h2 id="生命周期-旧"><a href="#生命周期-旧" class="headerlink" title="生命周期(旧)"></a>生命周期(旧)</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/babel&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Component</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    state = &#123; <span class="attr">opacity</span>: <span class="number">1</span> &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> opacity =  <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">opacity</span>-<span class="number">0.1</span></span><br><span class="line">        <span class="keyword">if</span>(opacity&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">opacity</span>:<span class="number">1</span>&#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;opacity&#125;)</span><br><span class="line">        &#125;    </span><br><span class="line">      &#125;,<span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timer</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;&#123;opacity:this.state.opacity&#125;&#125;</span>&gt;</span>学不好react怎么办<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;ReactDOM.unmountComponentAtNode(document.querySelector(&#x27;#box&#x27;))&#125;&#125;&gt;不活了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#box&#x27;</span>))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>不能在render函数中开启定时器，通过<code>this.setState</code>来修改状态，因为这个操作会触发render，从而导致无限递归，所以我们把开启定时器的代码写在生命周期函数中。</p><img src="..\images\react\生命周期.png" style="zoom:67%;" /><ul><li><p><code>shouldComponentUpdate</code>：这个钩子的作用就类似一个阀门，如果我们在组件中不写这个钩子，这个钩子默认存在且返回值为<code>true</code>。如果这个钩子的返回值为false，那么数据更新了也不会调用render方法更新视图</p></li><li><p><code>forceUpdate</code>方法的效果是强制组件更新，即便数据没有改变，也不会经过<code>shouldComponentUpdate</code>钩子的判断</p></li><li><p><strong>具有父子组件的页面初次加载的时候</strong>，先按顺序执行父组件的<code>constructor</code>，<code>componentWillMount</code>，<code>render</code>钩子，再按顺序执行子组件的<code>constructor</code>，<code>componentWillMount</code>，<code>render</code>，<code>componentDidMount</code>钩子，再执行父组件的<code>componentDidMount</code>钩子。</p></li><li><p>也就是说，父组件执行到<code>render</code>函数的时候，开始解析子组件，直到子组件的dom创建好了（componentDidMount），父组件再执行后续代码，挂载dom（componentDidMount）。</p></li><li><p>当父组件间中的数据更新(调用setState)，父组件会依次调用<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>，<code>render</code>钩子，然后子组件调用<code>componentWillReceiveProps </code>，<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>，<code>render</code>，<code>componentDidUpdate</code>钩子，再执行父组件的<code>componentDidUpdate</code>的钩子。</p></li><li><p>也就是说父组件如果不是某个组件的子组件，就不存在<code>componentWillReceiveProps</code>钩子。</p></li><li><p>其实如果父组件并没有给子组件传值，父组件重新render也会导致子组件重新render。但是子组件重新render只会调用子组件<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>，<code>render</code>，<code>componentDidUpdate</code>钩子，父组件不会重新渲染。</p></li></ul><img src="..\images\react\生命周期2.png" style="zoom:80%;" /><p>案例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../react/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../react/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../react/prop-types.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../react/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    state = &#123; <span class="attr">car</span>: <span class="string">&#x27;奥迪&#x27;</span> &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A-componentDidMount&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">componentWillMount</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A-componentWillMount&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">shouldComponentUpdate</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A-shouldComponentUpdate&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">componentWillUpdate</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A-componentWillUpdate&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">componentDidUpdate</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A-componentDidUpdate&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">componentWillReceiveProps</span>(<span class="params">props</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A-componentWillReceiveProps&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;A-render&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> (</span></span><br><span class="line"><span class="language-javascript">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">          <span class="tag">&lt;<span class="name">B</span>/&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;()</span>=&gt;</span>&#123;this.setState(&#123;car:&#x27;宝马&#x27;&#125;)&#125;&#125;&gt;换车<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="language-javascript">      )</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">class</span> <span class="title class_">B</span>  <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">componentWillReceiveProps</span>(<span class="params">props</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B-componentWillReceiveProps&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B-componentDidMount&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">componentWillMount</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B-componentWillMount&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">shouldComponentUpdate</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B-shouldComponentUpdate&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">componentWillUpdate</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B-componentWillUpdate&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">componentDidUpdate</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B-componentDidUpdate&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;B-render&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> (</span></span><br><span class="line"><span class="language-javascript">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.car&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="language-javascript">      )</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">A</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#box&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="生命周期-新"><a href="#生命周期-新" class="headerlink" title="生命周期(新)"></a>生命周期(新)</h2><p>在react的17.x版本后，<code>componentWillMount</code>，<code>componentWillUpdate</code>，<code>componentWillReceiveProps</code>这三个钩子已经不推荐使用，因为它们是不重要的，而且经常被错误的使用，并且还可能在未来的异步渲染中引发更多问题，因此17.x版本后这个三个钩子必须加上<code>UNSAFE_</code>前缀，这并不意味这这三个钩子是不安全的，只是为了加长单词长度让人们尽可能的少用它们，并且这三个钩子在未来很可能被删除。</p><img src="..\images\react\新的生命周期.png" style="zoom: 80%;" />]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/posts/518e617c.html"/>
      <url>/posts/518e617c.html</url>
      
        <content type="html"><![CDATA[<p>在此之前，推荐一个前端学习路线：<a href="https://objtube.github.io/front-end-roadmap">https://objtube.github.io/front-end-roadmap</a></p><p>其中对于git部分给了许多宝贵的资源。</p><p><a href="https://liaoxuefeng.com/books/git/what-is-git/birth-of-git/index.html">Git的诞生 - Git教程 - 廖雪峰的官方网站</a></p><p><a href="https://learngitbranching.js.org/">Learn Git Branching</a></p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>一个由Linus使用C语言开发的，免费开源的，<code>分布式</code>的，代码<strong>版本控制系</strong>统，帮助开发团队维护代码。</p><p>可以用来记录代码内容，切换代码版本，多人开发时高效合并代码内容</p><h2 id="分布式vs集中式"><a href="#分布式vs集中式" class="headerlink" title="分布式vs集中式"></a>分布式vs集中式</h2><p><code>集中式版本控制系统</code>，版本库是集中存放在<code>中央服务器</code>的，而干活的时候，用的都是自己的电脑，所以要先从<code>中央服务器</code>取得最新的版本，然后开始干活，干完活了，再把自己的活推送给<code>中央服务器</code>。<code>中央服务器</code>就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p><p><code>集中式版本控制系统</code>最大的毛病就是<code>必须联网</code>才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</p><p>那<code>分布式版本控制系统</code>与<code>集中式版本控制系统</code>有何不同呢？首先，<code>分布式版本控制系统</code>根本没有<code>中央服务器</code>，每个人的电脑上都是一个<code>完整的版本库</code>，这样，你工作的时候，就不需要联网了，<strong>因为版本库就在你自己的电脑上</strong>，那<code>分布式</code>的意思就是，版本库分布在每一台电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改<code>推送</code>给对方，就可以互相看到对方的修改了。</p><p>和集中式版本控制系统相比，分布式版本控制系统的<code>安全性要高很多</code>，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p><p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，<strong>分布式版本控制系统通常也有一台充当中央服务器的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改</strong>，没有它大家也一样干活，只是交换修改不方便而已。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p><ul><li><p>到官网下载安装包运行，不需要手动配置环境变量</p></li><li><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><img src="..\images\git\安装检测.png" style="zoom: 50%;" /></li><li><p>配置身份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;sanye&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxxxx@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p>每次提交代码时需要表明自己的身份，因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上<code>所有的Git仓库</code>都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p></li></ul><h2 id="git仓库"><a href="#git仓库" class="headerlink" title="git仓库"></a>git仓库</h2><p>记录文件状态，内容，和历史记录，就是一个<code>.git隐藏文件</code></p><h3 id="存储的内容"><a href="#存储的内容" class="headerlink" title="存储的内容"></a>存储的内容</h3><ul><li>添加的<code>远程仓库</code>的地址</li><li>本地分支与远程分支的连接（追踪关系）</li><li>git hooks</li><li>暂存区内容和版本库</li></ul><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><ul><li><p>把本地文件夹转换成git仓库：<code>git init</code>，如果使用的是Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。然后当前文件夹下就会出现一个<code>.git</code>目录。这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><img src="..\images\git\初始化.png" style="zoom: 67%;" /></li><li><p>从其他服务器克隆git仓库，不需要<code>git init</code></p></li></ul><h2 id="git的三个区域"><a href="#git的三个区域" class="headerlink" title="git的三个区域"></a>git的三个区域</h2><ul><li>工作区：实际开发中操作的文件夹，就是你在电脑里能看到的目录</li><li>暂存区：提交代码之前的准备区域（暂存改动的文件），可以临时恢复代码内容，与版本库解耦合</li><li>版本库：提交并保存暂存库区的内容，产生一个版本快照，存储在版本库</li></ul><img src="..\images\git\三个区域.png" style="zoom:80%;" /><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="暂存文件"><a href="#暂存文件" class="headerlink" title="暂存文件"></a>暂存文件</h3><ul><li><code>git add &lt;文件名&gt;</code>：暂存指定文件，实际上就是把文件修改添加到<code>暂存区</code></li><li><code>git add .</code>：暂存所有文件，把工作区所有文件添加到<code>暂存区</code></li></ul><h3 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h3><ul><li><code>git commit -m &lt;注释说明&gt;</code>  ：实际上就是把<code>暂存区</code>的所有内容提交到当前分支；</li><li>可以简单理解为，需要提交的文件修改通通放到<code>暂存区</code>，然后，一次性提交暂存区的所有修改。</li><li>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的，即<code>工作区文件</code>和<code>版本库文件</code>保持一致。</li></ul><img src="..\images\git\commit.png" style="zoom:80%;" /><h3 id="回退命令"><a href="#回退命令" class="headerlink" title="回退命令"></a>回退命令</h3><ul><li><p><code>git reset --soft &lt;版本号&gt;</code>：<code>暂存区，工作区</code>的所有文件都不变，只改变 <code>head</code>指向，即回退到上个版本的未提交状态</p></li><li><p><code>git reset --mixed &lt;版本号&gt; </code>：<code>工作区</code>文件不变，暂存区文件被覆盖为<code>回退版本文件</code>（一摸一样 ）。</p></li><li><p><code>git reset --hard  &lt;版本号&gt;</code>：<code>暂存区文件</code>和<code>工作区文件</code>都被覆盖为回退版本文件，但是若<code>暂存区文件</code>本来就和回退版本文件相同，则不会改变工作区文件。</p></li><li><p>都会改变<code>head指针</code>的指向，指向为恢复的提交版本，回退命令可以用来<strong>撤销某次错误的提交</strong>，也可以用来<strong>回退到先前的版本</strong></p></li><li><p>其实除了指定版本号（哈希值），还可以使用<code>相对引用</code>的方式来实现版本回退。</p><img src="..\images\git\reset.png" style="zoom:67%;" /></li></ul><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，<strong>但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</strong></p><p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code></p><img src="..\images\git\revert.png" style="zoom:67%;" /><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ul><li><p>我们通过<code>鼠标右键删除</code>的文件，删除 是工作区的文件，这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了。</p></li><li><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm &lt;文件名&gt;</code> 删掉，这个命令不仅会从你的工作目录中删除 <code>test.txt</code> 文件，还会将其标记为已删除状态，并添加到暂存区（staging area），这意味着你准备在<code>下一次提交时</code>记录这个删除操作。</p></li><li><p>然后再<code>git commit</code>，产生一个新的提交。</p></li><li><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把<code>误删的文件</code>恢复到最新版本（其实直接ctrl+z也行）：</p></li></ul><h3 id="撤销命令"><a href="#撤销命令" class="headerlink" title="撤销命令"></a>撤销命令</h3><ul><li><code>git rm --cached  &lt;文件标识&gt;</code>：文件标识可通过<code>git ls-files</code>查看，这个指令用于<code>移除暂存区的某个文件</code>，用于在commit之前<strong>撤销某个错误的暂存</strong>。</li><li><code>git restore &lt;目标文件&gt;</code>：<code>.</code>表示全部文件，如果你想撤销对某个文件的所有未提交更改，并将其恢复到与<strong>最近一次提交</strong>（HEAD）一致的状态，可以使用这个指令。这个命令不会影响<code>暂存区</code>的内容，只会影响你的<code>工作目录</code>。</li><li><code>git restore --staged &lt;目标文件&gt;</code>：如果你已经将文件添加到了暂存区（即使用了 <code>git add</code>），但之后又想<code>取消该文件的暂存</code>，同时保持工作目录中的修改不变，可以使用这个指令，这会将文件在<code>暂存区的状态重置</code>为与最近一次提交相同，但保留工作目录中的更改。</li></ul><h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><ul><li><code>git ls-files</code>：显示暂存区文件</li><li><code>git log --oneline</code>：显示历史提交记录</li><li><code>git reflog --oneline</code>：查看完整历史的简略信息，<strong>记录了你的每一次命令</strong>（包括，提交，切换，回退等）</li><li><code>git diff HEAD -- readme.txt</code>：可以查看工作区<code>readme.txt</code>文件，和版本库里面最新提交中的<code>readme.txt</code>文件的区别。</li></ul><h2 id="工作区文件状态"><a href="#工作区文件状态" class="headerlink" title="工作区文件状态"></a>工作区文件状态</h2><h3 id="未跟踪（U）"><a href="#未跟踪（U）" class="headerlink" title="未跟踪（U）"></a>未跟踪（U）</h3><p>就比如你新建了一个文件，它就是未跟踪的，你可以直接把它删了，就好像从未新建过一样。</p><h3 id="已跟踪"><a href="#已跟踪" class="headerlink" title="已跟踪"></a>已跟踪</h3><ul><li><p>新添加（A）：第一次被git暂存，之前版本记录没有此文件，<strong>标志着开始被git跟踪</strong></p></li><li><p>未修改（无符号）：三个区域文件内容一致，通常在一次版本提交后</p></li><li><p>已修改（M）：工作区内容or暂存区与版本库内容不同</p></li><li><p>已删除（D）：工作区的一个<code>已经被跟踪</code>的文件被删除，但是版本库or暂存区中仍然存在</p></li><li><p><code>git status</code>：查看文件详细状态</p></li><li><p><code>git status -s</code>：查看文件简略状态</p></li></ul><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每次提交，Git都把它们串成一条<code>时间线</code>，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫<code>主分支</code>，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是<strong>当前分支</strong>。</p><img src="..\images\git\分支.png" style="zoom:80%;" /><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上，就实现了<code>分支切换</code>。</p><img src="..\images\git\分支2.png" style="zoom:80%;" /><p>Git创建，切换一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的<code>修改和提交</code>就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变</p><img src="..\images\git\分支3.png" style="zoom:80%;" /><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并，我们管这种合并叫做<code>fast-forward</code>。</p><img src="..\images\git\分支4.png" style="zoom:80%;" /><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支</p><img src="..\images\git\分支5.png" style="zoom:80%;" /><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure><p>创建一个新的指针，指向<code>当前分支所指向的提交</code>，一般是最新的提交。</p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt; <span class="comment">//切换分支</span></span><br></pre></td></tr></table></figure><p>修改head指针指向</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt; //切换到创建的分支上去（执行了两个操作）</span><br></pre></td></tr></table></figure><p>切换分支后，以后提交的版本记录结点就会挂在<code>当前的新分支</code>上去</p><p>在 Git 2.23 版本中，引入了一个名为 <code>git switch</code> 的新命令，最终会取代 <code>git checkout</code>，因为 <code>checkout</code> 作为单个命令有点超载（它承载了很多独立的功能）。</p><p>除了切换分支，<code>git checkout</code>指令还能让head指针指向具体的提交，而不是分支。只需要执行<code>git checkout 提交的哈希值（输入前几位也行）</code>即可</p><img src="..\images\git\分离head.png" style="zoom: 67%;" /><p>除了指定<code>哈希值</code>来确定提交结点，git还提供了<code>相对引用</code>的方式，这种方式需要借助<code>指针（分支指针或者head指针）</code>。</p><ul><li><p>使用 <code>^</code> 向上移动 1 个提交记录</p><img src="..\images\git\相对引用.png" style="zoom:67%;" /></li><li><p>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></p><p>通过下面这个指令<strong>强制移动分支</strong>指针main到c4的第三级父节点。</p><img src="..\images\git\移动分支指针.png" style="zoom:67%;" /></li></ul><h3 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。然后，我们就可以在<code>dev</code>分支上正常提交</p><h3 id="修改当前分支名"><a href="#修改当前分支名" class="headerlink" title="修改当前分支名"></a>修改当前分支名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -M master //修改当前分支名为master</span><br></pre></td></tr></table></figure><h3 id="合并分支与删除分支"><a href="#合并分支与删除分支" class="headerlink" title="合并分支与删除分支"></a>合并分支与删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;分支名&gt; //把一条分支合并到当前分支，一般是合并到主分支master（要先切换到主分支）</span><br></pre></td></tr></table></figure><p>把一条分支合并到当前分支，一般是合并到主分支master（要先切换到主分支）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;分支名&gt; //删除被合并的分支指针</span><br></pre></td></tr></table></figure><p><strong>要注意的是删除分支并不会删除分支上的任何提交，只是删除一个指针</strong>。</p><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><h4 id="fast-forward"><a href="#fast-forward" class="headerlink" title="fast-forward"></a>fast-forward</h4><p>如果 dev分支基于 master分支创建，然后在 master 分支上没有新的提交，那么将 dev 分支合并回 master分支时，就可以进行 fast-forward 合并。直接让master指向dev指向的提交即可。</p><img src="..\images\git\分支4.png" style="zoom:80%;" /><p>这个时候不会产生<code>新的结点</code>，也不会有合并冲突，之后我们甚至可以删除dev分支</p><p>但是fast-forward有一个缺点，就是删除dev分支后，就看不出曾经有分支的痕迹了。如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>不使用<code>Fast forward</code>模式，merge后就像这样，此时即便删除了dev分支，也能看出分支存在的痕迹，因为删除分支不会删除提交结点。</p><img src="..\images\git\noff.png" style="zoom: 67%;" /><h4 id="Merge-合并"><a href="#Merge-合并" class="headerlink" title="Merge 合并"></a>Merge 合并</h4><img src="..\images\git\分支合并.png" style="zoom: 67%;" /><ul><li><p>Git 会创建一个<strong>新的提交</strong>，称为<code>合并提交</code>。这个提交有<code>两个父节点</code>：一个是<code>目标分支</code>的最新提交，另一个是<code>当前分支</code>的最新提交。</p><img src="..\images\git\分支合并2.png" style="zoom: 67%;" /></li><li><p>在合并两个最新提交的时候可能存在冲突，比如两个提交对<code>同一个文件的相同部分</code>做了<code>不同的修改</code>，这个时候需要<strong>手动解决冲突</strong></p></li><li><p>合并提交包含了解决冲突后的结果，或者在没有冲突的情况下，包含了源分支提交的全部内容</p></li></ul><h3 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><img src="..\images\git\branches.png" style="zoom:90%;" /><h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p>在上文我们看到了，使用<code>git merge</code>合并两个分支出现冲突时，总会产生<code>新的提交</code>，并导致最后的提交记录不是<code>线性的</code>，而是<code>分叉的</code></p><img src="..\images\git\分支合并2.png" style="zoom: 67%;" /><p>而<code>git rebase</code>也能实现合并操作，并且能保证合并后的历史记录是线性的。</p><p>如果我们想把feature1分支合并到master分支，使用rebase，我们需要先切换到feature1分支，然后执行<code>git rebase master</code></p><p>表明<code>当前分支</code>要进行<code>变基操作</code>，以master分支为新的<code>根基</code>，然后feature1分支的所有独有提交，都会把master分支的最新提交，当作父节点，进行一次合并，并按原来的顺序挂载到master分支上。</p><p>如果在变基过程中出现冲突，Git 会暂停变基操作，并提示你解决冲突。你需要手动编辑文件以解决冲突，然后继续变基操作：<code>git rebase --continue</code>，如果决定放弃当前的 rebase 操作，可以使用：<code>git rebase --abort</code></p><p>假设原始的历史记录如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---B---C---D---E (master)</span><br><span class="line">     \</span><br><span class="line">      F---G---H (feature1)</span><br></pre></td></tr></table></figure><p>执行 <code>git checkout feature1</code> 然后 <code>git rebase master</code> 后，历史记录变为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A---B---C---D---E (master)</span><br><span class="line">                 \</span><br><span class="line">                  F&#x27;---G&#x27;---H&#x27; (feature1)</span><br></pre></td></tr></table></figure><p>这里，<code>F</code>, <code>G</code>, <code>H</code> 被重新应用为 <code>F&#39;</code>, <code>G&#39;</code>, <code>H&#39;</code>。尽管它们代表相同的代码更改，但由于基点改变，它们成为了新的提交对象，拥有不同的哈希值。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>不能在刚创建一个仓库的时候就创建，查看分支。<strong>要先进行一次<code>commit</code>操作，才会真正建立<code>master</code>分支</strong>。这是因为分支的指针要指向提交结点的，只有进行了提交，才有指针指向该提交，才算是真正的建立了分支，成为一个有效的对象。</p><h2 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h2><p>保存版本库的历史记录，多人协作</p><h3 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h3><ul><li><p>注册账号</p></li><li><p>由于<code>本地Git仓库</code>和<code>GitHub仓库</code>之间的传输是通过<code>SSH</code>加密的，所以，需要一点设置：</p><ul><li><p>创建SSH Key。在用户主目录下（<code>比如：C:\Users\&lt;用户名&gt;\.ssh</code>），看看有没有<code>.ssh</code>目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后<code>一路回车</code>，使用<code>默认值</code>即可，由于这个Key也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在<code>用户主目录(比如：C:\Users\&lt;用户名&gt;\.ssh)</code>里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><img src="..\images\git\ssh.png" style="zoom:80%;" /></li><li><p>登陆GitHub，打开<code>Account-&gt;settings</code>，<code>SSH Keys</code>页面，然后，点<code>Add SSH Key</code>，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容，点<code>Add Key</code>，你就应该看到已经添加的Key。</p></li><li><p>为什么GitHub需要SSH Key呢？<strong>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的</strong>，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p></li><li><p>当然，GitHub允许你添加<code>多个Key</code>。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p></li></ul></li><li><p>创建一个远程仓库，初始为空，获得<code>远程仓库地址</code>。</p></li><li><p>本地Git仓库添加<code>远程仓库</code>地址</p><ul><li><p><code>git remote add &lt;远程仓库别名&gt; &lt;远程仓库地址&gt;</code>，</p></li><li><p>例如: <code>git remote add origin https://gitee.com/lidongxu/work.git</code></p></li><li><p>远程地址添加一次就行，保存在<code>git仓库</code></p></li></ul></li><li><p>推送本地Git仓库版本记录到远程仓库</p><ul><li><code>git push -u &lt;远程仓库别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code><br>例如，<code>git push -u origin master</code>，这里的master是<code>master:master</code>的简写，指定把<code>本地的哪个分支</code>提交到<code>远程哪个分支名</code>，注意这是一个更新操作，不是合并操作</li><li>在执行此命令前要确保当前本地分支是<code>master</code>分支</li><li>如果远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送到远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支<strong>关联起来</strong>，在以后的<code>推送或者拉取</code>时就可以省去<code>-u</code>。</li><li>第一次使用gitee需要填写登录信息，如果需要修改gitee登录信息，可以在<code>控制面板-&gt;window凭据-&gt;普通凭据</code>处修改，删除。</li></ul></li><li><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息<code>是否真的来自GitHub的服务器</code>，输入<code>yes</code>回车即可。Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了。</p><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p></li></ul><h3 id="移除远程仓库"><a href="#移除远程仓库" class="headerlink" title="移除远程仓库"></a>移除远程仓库</h3><ul><li><code>git remote -v </code>：获取所有远程仓库</li><li><code>git remote remove &lt;远程仓库别名&gt;</code>，移除远程仓库，不同远程仓库的别名不能相同。此处的“删除”其实是<strong>解除了本地和远程的绑定关系</strong>，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</li></ul><h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p><p>你也许还注意到，GitHub给出的地址不止一个，默认的<code>git://</code>使用<code>ssh</code>，速度快，但也可以使用<code>https</code>等其他协议。</p><p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须<code>输入口令</code>，但是在某些只开放<code>http</code>端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p><ul><li><p>新建一个文件并打开，右键打开<code>git bash</code>命令行，执行如下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;远程仓库地址&gt;</span><br></pre></td></tr></table></figure></li><li><p>这个操作建立了<code>本地仓库</code>和<code>远程仓库</code>的连接，git 会自动为远程仓库创建一个<strong>默认的别名</strong>，这个别名叫做 <code>origin</code>，所以可以省略添加远程仓库的操作</p></li><li><p>例如: <code>git clone https://gitee.com/lidongxu/work.git</code></p></li><li><p><code>git clone -b template url</code>，指定克隆<code>远程仓库地址(url)</code>的<code>template分支</code></p></li></ul><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>推送分支，就是把该分支上的<strong>所有本地提交</strong>推送到远程库。推送时，要<code>指定本地分支</code>，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li></ul><h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><ul><li>在本地分支上产生了几个版本记录后，想提交（push）该分支到远程仓库，执行<code>git push origin &lt;branch-name&gt;</code></li><li>如果推送失败，则因为远程分支比你的本地新，需要先用<code>git pull</code>拉取远程代码；</li><li><code>git pull</code> 是<code>git fetch origin</code>和<code>git merge origin/当前分支名</code>两个操作的简写，<strong>也就是说<code>git pull</code> 默认会从 <code>origin</code> 远程仓库拉取<code>与当前分支同名的分支</code>，并将其与<code>本地当前分支</code>合并</strong>。</li><li>同样的<code>git push </code>操作也是默认把<code>本地当前分支</code>推送到<code>origin</code>仓库的同名远程分支。</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li><li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明<code>本地分支</code>和<code>远程分支</code>的<code>链接关系</code>没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</li></ul><h2 id="使用github"><a href="#使用github" class="headerlink" title="使用github"></a>使用github</h2><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。</p><p>但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p><p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<code>https://github.com/twbs/bootstrap</code>，点<code>Fork</code>就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:michaelliao/bootstrap.git</span><br></pre></td></tr></table></figure><p><strong>一定要从自己的账号下clone自己fork的仓库，这样你才能推送修改</strong>。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p><p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><img src="..\images\git\github.png" style="zoom:80%;" /><p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p><p>如果你希望bootstrap的官方库能接受你的修改，你就可以在你的<code>fork的仓库</code>上发起一个<code>pull request</code>（注意不是在官方仓库上发起）到原始仓库。到当然，对方是否接受你的pull request就不一定了。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/posts/e255a10a.html"/>
      <url>/posts/e255a10a.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="通信方式分类"><a href="#通信方式分类" class="headerlink" title="通信方式分类"></a>通信方式分类</h3><ul><li>全双工：数据可以在两个方向上同时传输。比如视频电话，电话。</li><li>半双工：数据可以在两个方向上传输，但不能同时进行，比如对讲机</li><li>单工：数据只能朝一个方向传输，比如广播，电视广播</li></ul><h3 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>电话网络使用的交换方式</p><ul><li>优点：通信前从<code>主叫端</code>到<code>被叫端</code>建立一条专用的<code>物理通路</code>，在通信的全部时间内，两个用户始终占用端到端的线路资源。数据直送，传输速率高。</li><li>缺点：建立&#x2F;释放连接，需要额外的时间开销；线路被通信双方独占，利用率低；线路分配的灵活性差；交换节点不支持<code>差错控制</code>，无法发现传输过程中的发生的数据错误。</li></ul><img src="..\images\计算机网络\电路交换.png" style="zoom:33%;" /><p>因为打长途电话需要占用更多的资源，所以更贵。</p><h4 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h4><p>电报网络使用的交换方式。</p><p>使用了<code>存储转发</code>的思想，把传送的数据单元先存储进<code>中间节点</code>，再根据<code>目的地址</code>转发至下一节点。</p><ul><li>优点：通信前<strong>无需建立连接</strong>；数据以<code>报文</code>为单位被交换节点间“存储转发”；通信线路可以灵活分配；在通信时间内，两个用户无需独占一整条物理线路，相比于电路交换，<strong>线路利用率高</strong>；交换节点支持<code>差错控制</code>(通过校验技术)</li><li>缺点：报文不定长，不方便存储转发管理；长报文的<code>存储转发</code>时间开销大、缓存开销大；长报文容易出错，重传代价高。</li></ul><img src="..\images\计算机网络\报文交换.png" style="zoom:33%;" /><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>基于<code>报文交换</code>技术，出现了<code>分组交换</code>技术，把<code>报文</code>拆分成多个<code>分组</code>，出现<code>数据包</code>丢失只需要重发数据包即可，不需要重发整个数据；存储转发也有时延；适用于当前计算机网络。</p><p>将<code>不定长</code>的报文拆分成<code>定长</code>的分组，然后再进行传输：</p><img src="..\images\计算机网络\分组交换.png" style="zoom:40%;" /><p>如下图所示，各分组可以选择合适的路线，但是最终都被转发给H5（小美），殊途同归；所有分组到达后，然后就会按照<code>分组号</code>进行拼接。在现代网络中，指的<code>路由器</code>就是典型的分组交换机，各个分组能被正确转发到对应主机，得益于IP地址。</p><img src="..\images\计算机网络\分组交换2.png" style="zoom:33%;" /><ul><li><p>优点：通信前无需建立连接；数据以<code>分组</code>为单位被交换节点间“存储转发”，通信线路可以灵活分配；在通信时间内，两个用户无需独占一整条物理线路，相比于电路交换，线路利用率高。交换节点支持<code>差错控制</code>(通过校验技术)。</p><p>相比于报文交换，分组交换改进了如下问题:</p><ul><li>分组定长，方便存储转发管理</li><li>分组的存储转发时间开销小、缓存开销小</li><li>分组不易出错，<code>重传代价低</code></li></ul></li><li><p>缺点：相比于报文交换，控制信息占比增加；相比于电路交换，依然存在<code>存储转发时延</code>；报文被拆分为多个分组，传输过程中可能出现失序、去失问题，增加处理的复杂度。</p></li></ul><p>针对分组交换的缺点，人们提取出了一种解决方案：’虚电路交换’，就是在分组交换的基础上，当通信双方需要交换数据的时候，建立一条<code>连接</code>，我们把这条连接叫做<code>虚电路</code>。</p><h3 id="编码和调制"><a href="#编码和调制" class="headerlink" title="编码和调制"></a>编码和调制</h3><p>我们知道，数据在计算机中的存储形式是二进制（0和1），但当我们想要进行数据传输，却不能直接传输二进制数据，而是需要先把<code>二进制数据</code>转换成可以在<code>信道</code>上传播的<code>信号</code>。可传播的信号可分为<code>数字信号，模拟信号和光信号</code>。</p><p>其中把<code>二进制数据</code>转化成<code>数字信号</code>的过程叫做<code>编码</code>，这个过程的逆过程叫做<code>解码</code></p><p>把<code>二进制数据</code>转化成<code>模拟信号</code>的过程叫做<code>调制</code>，这个过程的逆过程叫做<code>解调</code></p><p>我们电脑的<code>网线插口</code>，对应的其实是<code>有线网络适配器</code>，它可以实现编码和解码的功能。</p><p>我们日常生活中常见的光猫，其实就是<code>光信号</code>的调制-解调器。</p><img src="..\images\计算机网络\编码与调制.png" style="zoom:50%;" /><h3 id="以太网拓扑结构"><a href="#以太网拓扑结构" class="headerlink" title="以太网拓扑结构"></a>以太网拓扑结构</h3><ul><li>点到点：最简单的网络拓扑</li><li>星型：最常见，所有设备（结点）都连接在一个中心点上，拓展性好，故障隔离；缺点是中心结点压力大，中心结点出问题所有连接的设备都断网（单点故障）</li><li>总线型：现在已经不常见，多态设备通过一条线路连接，缺点是两个结点无法同时传输信号，而且总线左右两端要有终端电阻吸收信号，否则信号会反射</li><li>环形：实现简单，但是只要一条线路断了多台设备就断网</li><li>网状拓扑：每个结点都与其他结点有线路连接，优点是一条线路断开影响很小，缺点是结点多了线路连接复杂</li></ul><h3 id="计算机网络的主要组成部分"><a href="#计算机网络的主要组成部分" class="headerlink" title="计算机网络的主要组成部分"></a>计算机网络的主要组成部分</h3><ul><li>通信子网：是指网络中的<em>通信设施</em>，包括传输介质（如电缆、光纤）、通信设备（如路由器、交换机）</li><li>通信协议</li><li>主机</li></ul><h2 id="osi参考模型"><a href="#osi参考模型" class="headerlink" title="osi参考模型"></a>osi参考模型</h2><p>关于osi模型的详细介绍，可以参考<a href="https://www.sanye.blog/posts/c0add594.html">前端面试—网络 | 三叶的博客</a>中的osi七层模型部分。</p><ul><li>应用层： 通过应用程序使用网络服务，传输的单位是<code>报文</code>，http协议就是应用层的协议</li><li>表示层：处理交互数据的表示方法，例如<code>格式转换</code>，数据的加密和解密，以及数据的交换</li><li>会话层： 负责维护两个节点之间会话的建立维护和断开；存在<strong>检查点</strong>机制，当通信失效时候自动在<code>检查点</code>恢复通信</li><li>运输层：提供<code>端到端</code>（也叫进程到进程）的数据传输服务。传输的数据单位为<code>报文段</code>，比如tcp协议，它提供了端到端的<code>错误检测、流量控制、拥塞控制和数据包排序</code>等功能。</li><li>网络层： 传输的数据单位为<code>分组</code> ，提供<code>路由选择</code>功能，以分组为单位实现<code>拥塞控制</code>等功能，实现<code>主机到主机</code>的通信</li><li>数据链路层：传输的数据单位为<code>帧</code>；在物理层的基础上，提供<code>节点</code>到<code>节点</code>之间的服务，采取差错控制（比如CRC校验码）和流量控制（控制数据帧的发送速率，防止拥塞）的方法实现网络互联。</li><li>物理层：单位bit，传输字节流。</li></ul><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><ul><li><p>有线</p><ul><li>双绞线：传输数字信号或者模拟型号</li><li>同轴电缆：传输模拟或数字信号</li><li>光纤：传输<code>光信号</code>，衰减小、带宽高和抗干扰能力强</li></ul></li><li><p>无线</p><ul><li>无线电波</li><li>微波</li></ul></li></ul><h3 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h3><p>6个字节，48位，标识唯一一台计算机。mac地址也叫做<code>物理地址</code>，网卡的<code>硬件地址</code>，而ip地址被称作逻辑地址。</p><h3 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h3><h4 id="中继器（repeater）"><a href="#中继器（repeater）" class="headerlink" title="中继器（repeater）"></a>中继器（repeater）</h4><img src="..\images\计算机网络\中继器.png" style="zoom:50%;" /><p>增强信号，解决信号衰减的问题。</p><p>物理层“电气特性”规定<code>0.5~1.5V</code>是低电平，<code>4.5~5.5V</code>是高电平，不符合此标准的信号视为无效；中继器接收到信号后，会将<code>低电平</code>整形为1V(标准的低电平)，将高电平整形为5V(标准的高电平)，然后再输出。</p><h4 id="集线器（hub）"><a href="#集线器（hub）" class="headerlink" title="集线器（hub）"></a>集线器（hub）</h4><img src="..\images\计算机网络\集线器.png" style="zoom: 40%;" /><p>解决多台主机互联线路复杂的问题，缺点在于是广播的，不安全。</p><img src="..\images\计算机网络\集线器2.png" style="zoom:33%;" /><p><strong>冲突域</strong></p><p>如果两台主机同时发送数据会产生冲突，那么这两台电脑就在同一个冲突域。</p><p>如图，把多个集线器通过一个集线器连接到一起，形成了一个更大的冲突域，我们也可以说，<strong>集线器不能分割冲突域</strong>。</p><img src="..\images\计算机网络\集线器3.png" style="zoom:33%;" /><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><img src="..\images\计算机网络\数据链路层.png" style="zoom: 40%;" /><p><code>帧</code>在<code>物理链路</code>上传播的时候可能会受外界因素的影响发生<code>比特跳变</code>，即产生了差错。</p><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><img src="..\images\计算机网络\封装成帧.png" style="zoom:50%;" /><p>原始SDU可以理解为<code>分组</code>，<code>透明传输</code>指的是<code>网络层的感受</code>：网络层感受不到<code>分组组装成帧</code>和<code>帧拆分成分组</code>的过程，因为这些工作都是数据链路层完成的。</p><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><img src="..\images\计算机网络\差错控制.png" style="zoom:50%;" /><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>控制发送方发送帧的速率别太快，让接收方来得及接收。</p><h3 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h3><img src="..\images\计算机网络\可靠传输.png" style="zoom:50%;" /><h4 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h4><img src="..\images\计算机网络\滑动窗口机制.png" style="zoom: 45%;" /><p>下图介绍了流量控制是如何实现的，由此可以看出，滑动窗口和流量控制密不可分。</p><img src="..\images\计算机网络\确认机制.png" style="zoom: 80%;" /><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><img src="..\images\计算机网络\SW.png" style="zoom: 45%;" /><p>数据帧和确认帧必须编号，因为如果接受方接收到帧并发送ack了，但是ack丢失了，发送方就会重复发送一个帧，此时接收方就无法判断这个帧是不是重复的（到底是接收到ack后发送的新的帧，还是未接收到ack重复发送的帧呢？）。</p><p>因为在停止等待协议中，发送窗口和接受窗口的大小都是1，所以要满足<code>1+1&lt;=2^n</code>解得<code>n&gt;=1</code>，也就是说，至少使用<code>1bit</code>就能给帧编号。</p><img src="..\images\计算机网络\SW2.png" style="zoom: 45%;" /><p>因为在实际生活中，其实接收方也可能发送数据，所以需要区分<strong>帧的类型</strong></p><ul><li><p>发送一帧后，必须<code>收到ack后</code>，才能发送下一个帧</p></li><li><p><strong>超时重传</strong>：<code>发送方</code>每发送一个<code>帧</code>就开启一个计时器，设定一个重传时间，如果发送方超过这个时间没有接收到ack，则<strong>重传该帧</strong>；重传时间应该比帧的平均传输rtt（平均往返时间）更长。</p></li><li><p>发送完一个帧必须保存它的副本，确认接收方接收到了再删除。</p></li></ul><p><strong>差错情况</strong></p><ul><li>发送方发送的<code>数据帧丢失/数据帧错误</code>：设置的<code>重传时间</code>到后，发送方重新发送帧。</li><li>接收方发送的ack丢失：<code>发送方</code>因为在规定时间内没有接收到ack，就会重新发送帧，但是由于<code>接收方</code>已经收到了帧，所以接收方会<code>丢弃收到的重复帧</code>，返回一个ack。</li><li>ack迟到：<code>发送方</code>因为在规定时间内没有接收到ack，就会重新发送帧，但是由于<code>接收方</code>已经收到了帧，所以接收方会<code>丢弃收到的重复帧</code>，返回一个ack；<code>接收方</code>丢弃<code>重复的ack</code>(因为发送了2个ack)。</li></ul><h4 id="后退N帧协议（GBN）"><a href="#后退N帧协议（GBN）" class="headerlink" title="后退N帧协议（GBN）"></a>后退N帧协议（GBN）</h4><p>GBN是<code>go back n</code>的意思，意思就是<code>后退n</code>。要注意的是后退N帧指的<strong>不是滑动窗口后退</strong>，而重新发送n帧。</p><img src="..\images\计算机网络\后退N帧.png" style="zoom:50%;" /><p><strong>特点</strong></p><ul><li>发送方维持一组允许<code>连续发送</code>的帧的序号；发送完一个数据帧，立马发送<code>发送窗口</code>中的下一个数据帧，就像流水线</li><li>发送窗口可以有N个，但是<strong>接收窗口只能有一个</strong></li><li>不对接收到的每个帧进行确认，而是累积确认。</li></ul><h4 id="选择重传协议（SR）"><a href="#选择重传协议（SR）" class="headerlink" title="选择重传协议（SR）"></a>选择重传协议（SR）</h4><p>SR(selective repeat)</p><img src="..\images\计算机网络\SR.png" style="zoom:50%;" /><h3 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h3><img src="..\images\计算机网络\介质访问控制.png" style="zoom:50%;" /><h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h4><p><strong>是什么</strong></p><p>是一种介质访问控制（MAC）协议，要求设备<code>先听再说</code>，或者<code>边听边说</code>（检测到别人说就停止说）。</p><p><strong>冲突检测</strong></p><p>确保能监听到<strong>数据冲突</strong>，则要求<code>数据帧</code>的传输时延至少是传播时延的2倍，就是说受到发生碰撞的信号的时候还没说完（类比生活中自己没说完话然后听到了别人的话但是听不清说的是啥）</p><p><strong>四大要点</strong></p><ul><li>先听再发（检查是否空闲）</li><li>边听边发（检查是否有冲突）</li><li>冲突停止</li><li>延迟后发</li></ul><h3 id="物理设备"><a href="#物理设备" class="headerlink" title="物理设备"></a>物理设备</h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p>两个端口的交换机；左右2个端口连接集线器，每个集线器连接多台主机；根据<em>mac帧</em>的目的地址对帧进行转发<em>和</em>过滤；<code>网桥表</code>的建立是根据转发的帧的<code>源mac地址</code></p><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>一般来说，一个交换机确定一个子网；基于全双工的特点，每个接口构成一个冲突域，整个交换机构成一个广播域；交换机学习后可以知道每台主机在哪个端口，可以对数据帧进行精确转发，所以交换机一般不广播，但是不是不能广播。如果没有MAC地址，交换机将无法有效地进行帧的转发<br><strong>接口类型</strong></p><ul><li>access</li><li>trunk</li></ul><h3 id="局域网LAN"><a href="#局域网LAN" class="headerlink" title="局域网LAN"></a>局域网LAN</h3><ul><li>LAN(local area network)，指某一区域内多台计算机组成的计算机组，使用广播信道，一个局域网一般就是，就是一个网段，就是一个广播域。局域网内的通信不一定总是广播，集线器连接多台主机形成的局域网确实是只能广播，但现代局域网通常使用交换机来实现更为高效的点对点通信。</li><li>局域网可以分为<code>有线局域网</code>和<code>无限局域网(WLAN)</code></li></ul><h3 id="VLAN-虚拟局域网"><a href="#VLAN-虚拟局域网" class="headerlink" title="VLAN(虚拟局域网)"></a>VLAN(虚拟局域网)</h3><p>被用来<strong>划分广播域</strong>；VLAN 可以将一个物理网络（一个实际的局域网&#x2F;广播域）划分为多个逻辑上的广播域，每个 VLAN 内部的设备可以互相通信，但不同 VLAN 之间的设备默认情况下不能<code>直接</code>通信。</p><p><strong>实现</strong></p><ul><li><p>基于交换机来说；先创建几个虚拟局域网，然后可以选择把那些接口放在哪个虚拟局域网上；二层交换机只能<code>划分vlan</code>，但是不能实现不同vlan之间的通信，而三层交换机具有二层交换机的功能，并且增加了路由功能，可以在不同的VLAN之间进行路由，实现不同VLAN之间的通信。</p></li><li><p>路由器：路由器也可以划分广播域，每一个接口对应不同的广播域</p></li></ul><h3 id="arp地址解析协议"><a href="#arp地址解析协议" class="headerlink" title="arp地址解析协议"></a>arp地址解析协议</h3><p>关于arp的详细的介绍，参考<a href="https://www.sanye.blog/posts/c0add594.html">前端面试—网络 | 三叶的博客</a></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><h4 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h4><ul><li>RIP（路由信息协议）<ul><li><strong>跳数（hop）</strong><ul><li>该协议使用<code>跳数</code>来衡量与目标网络的距离，路由器到<code>直连网络</code>的距离为1；到非直连网络的距离为<code>经过的路由器数加+1</code></li><li>rip只允许一条路径上的最大跳数为15，16就等于<code>不可达</code>，也就是最多包含<code>15个路由器</code>，因此rip只适用<code>小型互联网</code></li></ul></li><li>工作原理<ul><li>认为<code>跳数少</code>的路由路径就是好的路由路径</li><li>如果跳数相同，则可以进行等价负载均衡</li><li>只和<code>相邻路由器</code>周期性交换信息（路由表）</li></ul></li><li>工作过程<ul><li>起初只知道和直连网络的的距离为1</li><li>和相邻路由器周期性交换信息（路由表）</li><li>若干次交换后就知道到达本格网络的最短跳数和地址（收敛）</li></ul></li><li>路由环路问题：因为更新路由表的时候只关心相邻路由器<code>能否达到某个网络，距离是不是更短</code>，不关心相邻网络是如何到达该网络的。</li></ul></li><li>OSPF(开放最短路径优先)<ul><li>使用<code>洪泛法</code>向自治系统内所有路由器发送信息，即路出器通过输出端口向<code>所有相邻路由器</code>发送信息，每一个相邻路由器又再次将此信息发往其所有的相邻路由器（广播）最终整个区域内所有路由器都得到了这个信息的一个副本。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态（与哪些路由器相连、以及该链路的代价，距离、时延、带宽等)。</li><li>只有当链路状态发生变化时，路由器才向所有路由器<code>洪泛</code>发送此信息。最后，所有路由器都能建立一个链路状态数据库，即全网拓扑图。</li></ul></li></ul><h4 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h4><ul><li>BGP(border gateway protocol)：边界网关协议<ul><li>BGP只能是力求寻找一条能够到达目的网络且比较好的路由而并非要寻找一条<code>最佳路由</code>，因为不同自治系统内部度量代价的方式可能不同，而且自治系统之间的路由选择还要考虑政治经济等因素</li><li>在配置BGP时，每个自治系统的管理员要选择至少一个<code>路由器</code>作为该自治系统的“BGP发言人”，不同自治系统的BGP发言人要交换路由信息，首先必须建立TCP连接</li></ul></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>划分广播域；划分不同的网段；在不同网段之间传输数据。</p><h3 id="ip-端口"><a href="#ip-端口" class="headerlink" title="ip+端口"></a>ip+端口</h3><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><p>标识唯一一台计算机的网络地址<br><strong>组成</strong></p><ul><li>网络号+主机号；具体那部分是主机号那部分是网络号，由<code>子网掩码</code>指明；</li><li>主机号部分不能全为0，也不能全为1；<code>网段号</code>的主机号部分全为0，<code>广播号</code>的主机部分全为1</li><li><code>0.0.0.0 </code>是一个特殊的 IP 地址，就相当于一个通配符，匹配所有的ip地址，<strong>不能直接对这个ip地址发请求</strong>，向任意ip地址发请求都相当于对这个ip地址发请求</li><li>127.0.0.1等于localhost，是一个<code>回环地址</code>，访问这个地址就是访问本机，专门用来测试，ping这个地址<strong>不进行任何网络传输</strong></li></ul><p><strong>私有ip&#x2F;公有ip</strong></p><ul><li>对于ipv4，能表示的ip地址只有42亿多个，不满足全世界人的对互联网的使用，所以出现了私有ip地址，私有ip地址不在公共网络上注册，仅用于内部。</li><li>路由器内部的<code>DHCP</code>会自动为设备分配私有ip地址，而公有ip地址由运营商分配。</li></ul><p><strong>公有ip地址分类</strong></p><p>常用的可以分为A类，B类，C类，网络号别为前8，16，24位。</p><p>如果给出子网掩码，我们当然能迅速的判断出ip的类型，但是如果只给出ip地址，其实我们也能判断出来。</p><p>A类ip地址第一位必须是<code>0</code>，B类ip地址前2位必须是<code>10</code>，C类ip地址前3位必须是<code>110</code></p><p><strong>私有ip地址分类</strong></p><ul><li>A类：10.0.0.0—10.255.255.255&#x2F;8</li><li>B类：172.16.0.0—172.31.255.255&#x2F;16</li><li><strong>C类：192.168.0.0—192.168.255.255&#x2F;24（最常使用）</strong></li></ul><p>这些ip地址只能用于局域网内的结点，不能分配给互联网上的结点。</p><p><strong>NAT（network address translation）地址转换</strong></p><img src="..\images\计算机网络\NAT.png"  /><ul><li>设备访问互联网时，路由器会把<code>私有ip地址</code>转换成<code>共有ip地址</code>，还会把<code>公有ip地址</code>转化成<code>私有ip地址</code>，这地址转换的功能<strong>内置在路由器</strong>中</li><li>多台电脑公用一个ip那如何区分各台电脑？使用端口映射，路由器会使用一个<code>公网IP</code>地址加上<code>不同的端口号</code>来标识不同的内部主机<br>，比如<code>192.168.1.2:1234 -&gt; 203.0.113.5:10001</code>记录在NAT表中。</li></ul><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a><strong>端口号</strong></h4><p>操作系统借助<code>端口号</code>来区分数据应该发送到哪个应用或者哪个进程。</p><p>为各种公共服务保留的端口范围<code>1 -1023</code>，比如http默认占用<code>80</code>端口，https默认占用<code>443</code>端口，dns默认占用<code>53</code>端口。</p><p>所谓的<code>默认端口</code>，就是这些请求（http&#x2F;https请求，dns请求)的<strong>目标端口号</strong>，服务器端的Web服务进程监听此端口，准备接收来自任意客户端的请求；客户端则通过操作系统分配的一个<code>临时端口(源端口)</code>与服务器通信。</p><h4 id="为什么ip地址和mac地址缺一不可"><a href="#为什么ip地址和mac地址缺一不可" class="headerlink" title="为什么ip地址和mac地址缺一不可"></a>为什么ip地址和mac地址缺一不可</h4><img src="..\images\计算机网络\mac表.png" style="zoom: 25%;" /><img src="..\images\计算机网络\ip表.png" style="zoom:25%;" /><ul><li>mac地址标识唯一一台计算机，不适合大规模通信。起初人们只用mac地址通信，但后来接入网络的设备多了<code>地址表</code>会很长，而且<strong>mac地址不包含位置信息</strong>，所以改用ip地址通信；路由器只需要记住哪个端口对应哪个<code>网段</code>，而每个网段会有<code>多台设备</code>，具体哪个ip地址对应那台主机由交换机记录。</li><li>为什么还需要mac地址？当多台主机通过交换机相连，交换机和路由器相连，外网发送给某台主机的信息首先会被路由器转发到交换机上，交换机根据<code>数据帧的目标MAC地址</code>将数据帧发送到目标主机（交换机的转发需要mac地址，交换机地址表）。</li><li><code>ip地址</code>可以理解为<code>家庭住址</code>，而<code>mac地址</code>就可以理解为住户的姓名，邮递员根据<code>ip地址</code>把包裹交给门卫（具体哪台交换机），门卫再根据<code>mac地址</code>把包裹交给住户（1个公有ip地址可以对应多个私有ip地址，也就是多个mac地址），所以说，mac地址实现了信息通信的最后<code>1公里</code>。</li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><p>传输控制协议，面向连接（虚连接，这个连接是全双工的），面向字节流，提供可靠服务；</p><h4 id="可靠传输-1"><a href="#可靠传输-1" class="headerlink" title="可靠传输"></a>可靠传输</h4><img src="..\images\计算机网络\tcp缓存.png" style="zoom:80%;" /><p>收到确认报文后，就能在缓存中删除报文段<code>321</code>。</p><p><strong>冗余ACK(冗余确认)</strong></p><p>要是等到超时的时候再重传，未免效率较低，有没有一种方法，能在超时事件发生之前，就提醒<code>发送端</code>重传报文段呢?</p><p>每当比期望序号大的<code>失序报文段</code>到达时，发送一个冗余ACK，指明<code>下一个期待</code>字节的序号<br>比如，发送方已发送1，2，3，4，5报文段<br>接收方收到1，返回给1的确认(确认号为报文段2的第一个字节)，2号报文段丢失。<br>接收方收到3，仍返回给1的确认(确认号为报文段2的第一个字节)<br>接收方收到4，仍返回给1的确认(确认号为报文段2的第一个字节)<br>接收方收到5，仍返回给1的确认(确认号为报文段2的第一个字节)<br>发送方收到3个对于报文段1的<code>冗余ACK</code>，认为2报文段丢失，重传2号报文段（快速重传）</p><h4 id="流量控制-1"><a href="#流量控制-1" class="headerlink" title="流量控制"></a>流量控制</h4><p>让发送方发慢一点，否则接收方来不及接收。</p><p>在tcp协议中，发送端不会等待上个报文段的ack，就发送其他报文段，并且使用累计确认的方式；</p><p>接收方把收到的报文段存储在<code>tcp缓存</code>中，交付给应用层则移除，所以发送方发送的速率不能过快，因为应用层处理报文段的速度有限而且缓存大小有限；否则就会丢包。</p><h4 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h4><p><strong>三次握手</strong></p><img src="..\images\计算机网络\三次握手.png" style="zoom:80%;" /><ul><li>A:我要和你建立连接了，发送 SYN包</li><li>B:我准备好了，你来和我建立连接吧，返回SYN包+ACK包</li><li>A:我现在就来和你建立连接，发送ACK包</li></ul><p><strong>四次挥手</strong></p><img src="..\images\计算机网络\四次挥手.png" style="zoom:80%;" /><ul><li><p>A:我要和你断开连接了,发送FIN包</p></li><li><p>B:我把数据传输完了和你断开连接，发送ACK包</p></li><li><p>B:我数据传输完了，返送<code>FIN+ACK</code>包，可以断开连接了，发送的<code>seq=w</code>而不是<code>v+1</code>，因为再发送ACK包之后还可能发送其他数据。</p><p>而ack还是等于<code>u+1</code>，因为客户端在发送<code>FIN请求</code>后没有发送其他数据。</p></li><li><p>A:好我们断开连接吧，发送ACK包，然后进入等待，确保服务端接收到ACK连接，否则服务端的连接始终不会关闭</p></li></ul><h4 id="tcp字段"><a href="#tcp字段" class="headerlink" title="tcp字段"></a>tcp字段</h4><p><strong>控制字段</strong></p><ul><li><strong>SYN,ACK</strong><br>在连接建立时用来同步序号。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个<code>连接请求</code>报文段。对方若同意建立连接，则应在响应的报文段中使<code>SYN=1和ACK=1</code>。因此，SYN置1就表示这是一个连接请求或连接接受报文。 TCP规定，在连接建立后所有传送的报文段都必须把ACK置1 </li><li><strong>FIN</strong><br>用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接</li></ul><p><strong>偏移字段</strong></p><p>用于表示TCP所传输的数据部分应该从TCP包的哪个位开始计算</p><h3 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h3><p>UDP(User Datagram Protocol)，用户数据报协议。</p><ul><li>无连接，没有拥塞控，尽最大努力交付（丢包就丢了吧）;</li><li>面向<code>数据报</code>，即对应用层交下来的<code> 报文</code>，不合并，不拆分，只是在其上面加上<strong>首部</strong>后就交给了下面的网络层。</li><li>开销较小，传输效率较高，可用于广播多播。</li></ul><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><ul><li><p><strong>添加端口号</strong></p><p>都是工作在传输层的协议，都能给<code>报文</code>添加端口号（源端口，目标端口），把报文封装成<code>段</code>。</p></li><li><p><strong>首部开销</strong></p><p><code>TCP报文段</code>首部内容更多，首部更大，<code>UDP报文段</code>首部开销小。</p></li><li><p><strong>报文分段</strong></p><p>如果<code>报文</code>很大，TCP会将报文<strong>分段</strong>，并给这些<code>报文段</code>编号。而UDP则始终把应用层的报文当做一个<code>整体</code>，不进行分片，直接封装。</p></li><li><p><strong>连接建立</strong></p><p>TCP是<code>面向连接</code>的，即发送数据之前需要建立连接，<strong>保证数据可靠性</strong>，而<code>UDP</code>是无连接的，直接发送数据，<strong>不保证数据可靠性</strong>。</p></li><li><p><strong>流量与拥塞控制</strong></p><p>TCP具有<code>流量控制</code>和<code>拥塞控制</code>，而UDP没有。</p></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="文件传输协议（FTP）"><a href="#文件传输协议（FTP）" class="headerlink" title="文件传输协议（FTP）"></a>文件传输协议（FTP）</h3><p>FTP（File Transfer Protoco）</p><p>需要建立<code>两个TCP</code>连接：</p><ul><li>文件服务器<code>21端口</code>与客户端的任意一个端口建立一个连接，叫做<code>控制连接</code>，用来<code>传输控制数据</code>；</li><li>文件服务器<code>20端口</code>与客户端的任意一个端口建立一个连接，叫做<code>数据连接</code>，用来<code>传输文件</code>；</li><li>传输的方式：ASCII，二进制</li></ul><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>基于<code>UDP</code>，占用<code>53</code>端口，关于DNS的详细介绍参考<a href="https://www.sanye.blog/posts/c0add594.html">前端面试—网络 | 三叶的博客</a></p><h3 id="SMTP-POP3"><a href="#SMTP-POP3" class="headerlink" title="SMTP&#x2F;POP3"></a>SMTP&#x2F;POP3</h3><p>邮件协议，第一个是用于发送的协议，第二个是用于接收的协议</p><h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p>HTTP（非加密）：默认端口号为 80；HTTPS（加密）：默认端口号为 443。是无状态的协议，基于tcp连接</p><p>关于http的详细介绍参考<a href="https://www.sanye.blog/posts/c0add594.html">前端面试—网络 | 三叶的博客</a></p><h3 id="C-S模型和P2P模型"><a href="#C-S模型和P2P模型" class="headerlink" title="C&#x2F;S模型和P2P模型"></a>C&#x2F;S模型和P2P模型</h3><ul><li>C&#x2F;S模型：客户端&#x2F;服务器模型，客户端指的是请求服务的主机，服务器指的是提供服务的主机</li><li>P2P模型：每台主机同时是客户端也是服务器，充分利用了主机的上行，下行带宽，比如迅雷。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计科专业核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/posts/4b0178e0.html"/>
      <url>/posts/4b0178e0.html</url>
      
        <content type="html"><![CDATA[<h1 id="时间复杂度，空间复杂度"><a href="#时间复杂度，空间复杂度" class="headerlink" title="时间复杂度，空间复杂度"></a>时间复杂度，空间复杂度</h1><h1 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul><li>深度为k的二叉树最多结点数目：深度为k即有k层，第k层的最大结点数等于<code>2^(k-1)</code>，经过等比数列求和后可得到深度为k的二叉树最多有<code>(2^k)-1</code>个结点，这就好比k位二进制能标识的最大的数为<code>(2^k)-1</code>，8位二进制数能表示的最大的数是2^8-1&#x3D;127。</li><li>一条边出现表示一个新的结点（除了根节点）：<code>结点数目=边数+1</code></li><li>边数 &#x3D; 出度为1的结点数目+<code>2*出度为2的结点数目</code>*</li><li>结点总数&#x3D;出度为1的结点数目+出度为2的结点数目+叶子结点数</li><li>结点数目&#x3D;边数+1&#x3D;（出度为1的结点数目+<code>2*出度为2的结点数目</code>）+1，<strong>即不需要确定叶子结点的数目，也可以得出结点总数</strong></li><li>出度为2的结点数 + 1 &#x3D; 叶子结点数</li></ul><p>思路：</p><ul><li><p>思考<code>边数</code>和<code>结点数</code>的关系</p></li><li><p>思考<code>边数</code>和<code>结点出度</code>之间的关系</p></li></ul><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="先序遍历-Preorder"><a href="#先序遍历-Preorder" class="headerlink" title="先序遍历(Preorder)"></a>先序遍历(Preorder)</h4><p>访问顺序：根节点 -&gt; 左子树 -&gt; 右子树</p><ul><li>访问根节点。</li><li>递归地对左子树进行先序遍历。</li><li>递归地对右子树进行先序遍历。</li></ul><p>假设有一棵二叉树如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \</span><br><span class="line">D   E</span><br></pre></td></tr></table></figure><p>先序遍历的结果为：<code>A, B, D, E, C</code></p><h4 id="中序遍历-Inorder"><a href="#中序遍历-Inorder" class="headerlink" title="中序遍历(Inorder)"></a>中序遍历(Inorder)</h4><p><strong>访问顺序</strong>：左子树 -&gt; 根节点 -&gt; 右子树</p><ul><li>递归地对左子树进行中序遍历。</li><li>访问根节点。</li><li>递归地对右子树进行中序遍历。</li></ul><p>假设有一棵二叉树如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \</span><br><span class="line">D   E</span><br></pre></td></tr></table></figure><p>中序遍历的结果为：<code>D,B,E,A,C</code></p><h4 id="后序遍历（Postorder）"><a href="#后序遍历（Postorder）" class="headerlink" title="后序遍历（Postorder）"></a>后序遍历（Postorder）</h4><p><strong>访问顺序</strong>：左子树 -&gt; 右子树 -&gt; 根节点</p><ul><li>递归地对左子树进行后序遍历。</li><li>递归地对右子树进行后序遍历。</li><li>访问根节点。</li></ul><p>假设有一棵二叉树如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \</span><br><span class="line">D   E</span><br></pre></td></tr></table></figure><p>后序遍历的结果为：<code>D,E,B,C,A</code></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h4><ul><li><p>无右孩子的二叉树，先序序列和后序序列正好相反</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   /</span><br><span class="line">  B</span><br><span class="line"> /</span><br><span class="line">D</span><br></pre></td></tr></table></figure></li><li><p>只有根结点的二叉树或非叶子结点只有右子树的二叉树</p></li></ul><h3 id="常见名词解释"><a href="#常见名词解释" class="headerlink" title="常见名词解释"></a>常见名词解释</h3><p>完全二叉树：即除了最后一层之外，每一层都被完全填满，并且最后一层尽可能靠左填充。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \  /</span><br><span class="line">D   E F  </span><br></pre></td></tr></table></figure><p>满二叉树：每层结点都是满的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \  /\</span><br><span class="line">D   E F G</span><br></pre></td></tr></table></figure><h3 id="二叉排序树-搜索树-查找树"><a href="#二叉排序树-搜索树-查找树" class="headerlink" title="二叉排序树 搜索树 查找树"></a>二叉排序树 搜索树 查找树</h3><p>要求<code>左子树的所有结点的值&lt;根结点的值&lt;右子树所有结点的值</code></p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>二分查找一般要求线性存储，插入删除元素的时间复杂度为<code>O(n)</code>；而使用<code>二叉查找树</code>就能实现插入和删除的时间复杂度为<code>O(logn)</code></p><h4 id="构建二叉搜索树"><a href="#构建二叉搜索树" class="headerlink" title="构建二叉搜索树"></a>构建二叉搜索树</h4><ul><li>同一批数字，按不同的方式排列，构建出来的二叉树可能是<code>不同</code>的，但是都必须满足规则，且<code>中序遍历</code>的序列都是有序的</li><li>如果这批数字本身就是有序的，那么构建出的二叉树就是<code>链表</code>，查找的时间复杂度变为<code>O(n)</code></li></ul><h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><ul><li>如果删除的是叶子结点直接删除</li><li>否则从这个结点的<code>左子树中找出最大</code>的或者<code>右子树最小</code>的作为新的根。</li></ul><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>构建<code>二叉搜索树</code>有时候会出现<code>链表</code>，使得查找的时间复杂度变高；需要寻找一种方法解决这个问题</p><p>平衡二叉树，<code>所有结点</code>的<code>(左子树高度-右子树高度)的绝对值&lt;=1</code>（平衡因子&#x3D;|左子树高度-右子树高度|）</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>能实现在<code>不出现歧义</code>的情况下实现<code>最短编码</code></p><p>哈夫曼编码和二叉树有啥关系？利用二叉树实现哈夫曼编码，这棵树叫做<code>哈夫曼树</code></p><h4 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h4><ul><li>确定结点的值：把每个元素归为一个节点，结点的值是元素的<code>个数</code></li><li>合并结点：找出值最小的两个节点，合并为一个新的父节点，这个父节点的值是两个节点值的和</li><li>合并产生的节点继续参与拼接，<code>重排队列</code>，依此类推，<strong>从下往上</strong>构建一株哈夫曼树</li><li>给路径编号，得到该结点的编号；左边路径编号为0，右边路径编号为1（其实是任意的），<strong>某个节点的编号等于根节点到该节点路径编号的拼接</strong></li></ul><h4 id="哈夫曼树的特点"><a href="#哈夫曼树的特点" class="headerlink" title="哈夫曼树的特点"></a>哈夫曼树的特点</h4><ul><li>结点的度只能是0，2；因为二叉树是<code>叶子结点</code>或者<code>非叶子结点</code>两两合并形成的，度为2的结点都是合并形成的，叶子结点是原来就有的（编码序列）；由这个特点很容易得到<code>叶子结点</code>和<code>非叶子结点</code>的关系</li><li><code>叶子节点数-1=非叶子结点数</code>；边数+1 &#x3D; 结点数 &#x3D; <code>度为2的非叶子结点</code>+叶子结点 &#x3D; <code>(2*度为2的非叶子结点数)</code>+1，<strong>推导出叶子结点数等于非叶子结点数+1</strong></li><li>也就是说如果需要给n个不同的元素编码，也就是有n个叶子结点，最终构建的哈夫曼树会有<code>2*n-1</code>个结点</li></ul><h4 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h4><p><code>所有叶子节点的路径长度*节点的值 的和</code>，其实就是<strong>最终编码长度</strong></p><h4 id="如何实现最短？"><a href="#如何实现最短？" class="headerlink" title="如何实现最短？"></a>如何实现最短？</h4><p>个数越多的元素越晚被合并，到根节点的路径越短，编号越短；正因个数越多的编码越短，就能实现总编码序列最短。</p><h4 id="如何实现无起歧义？"><a href="#如何实现无起歧义？" class="headerlink" title="如何实现无起歧义？"></a>如何实现无起歧义？</h4><p>没有前缀就没有歧义（某个元素的编码不是任何一个元素编码的前缀部分），因为从根结点到任意叶子节点所经过的路径，不会是根结点到其他叶子节点所经过的路径的<strong>前缀</strong>，<strong>因为叶子结点之后不会再有结点</strong>。</p><h2 id="散列表（哈希表）"><a href="#散列表（哈希表）" class="headerlink" title="散列表（哈希表）"></a>散列表（哈希表）</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>取余法</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ul><li>线性探测法：发生冲突时，顺着冲突地址的<code>下一单元</code>查找空位，如果表尾也没有空位，则从<code>表头</code>开始重新查找</li><li>二次探测法：<code>d=1,-1,2^2,-2^2,3^3,-3^3</code>,…….依此类推，往两边查找，所谓二次探测其实是指的是两个方向</li><li>伪随机数列：d&#x3D;伪随机数</li><li>链地址法：每个地址上独有一个链表，发生冲突把后添加的元素挂载<code>链表</code>后面。</li></ul><h3 id="装填因子"><a href="#装填因子" class="headerlink" title="装填因子"></a>装填因子</h3><p><code>装填因子 = 装填元素个数 / 散列表长度</code></p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>多对多的一种数据结构</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li><p>邻接：描述两个结点之间的关系，他们之间有<code>边</code>或者<code>弧</code>相连</p></li><li><p>网：有权图</p></li><li><p>连通图：没有孤立的结点，也许存在环</p></li><li><p>强连通图：每个结点都能到达其他结点；有n个顶点的强连通图最多有<code>n(n-1)</code>条边，也就是每两个结点都有一条边；最少有n条边，就是一个环。</p></li></ul><h3 id="存储方法"><a href="#存储方法" class="headerlink" title="存储方法"></a>存储方法</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><ul><li>用一个<code>一维数组</code>存储结点，记录<code>下标</code>和<code>结点</code>的对应关系</li><li>用一个<code>二维数组</code>表示两结点之间的邻接关系，比如<code>arr[i][j]=1</code>表示有条边从<code>i结点</code>指向<code>j结点</code>，如果等于0就表示没有</li></ul><p>结论：</p><ul><li>无向图的邻接矩阵是<code>对称</code>的</li><li>无向图<code>结点i</code>的度等于arr[i]数组的和</li><li>有向图<code>结点i</code>的出度，等于arr[i]的和，入度等于对应列<code>arr[x][i]</code>的和 </li><li><code>arr[i][j]=x</code>表示有条边从<code>i结点</code>指向<code>j结点</code>，如果等于无穷大就表示没有，<code>x</code>表示该边的<code>权值</code></li></ul><p><strong>优缺点</strong></p><p>增删结点麻烦；空间复杂度和边数无关，只和结点数有关，可能浪费空间</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><img src="..\images\数据结构与算法\邻接表.png" style="zoom:67%;" /><ul><li><p>用一个一维数组记录下标与结点的关系；按编号顺序将顶点数据存储在一维数组中;</p></li><li><p>存储空间大小和结点数，边数都有关；</p></li><li><p>方便计算出度；节约稀疏图的空间</p></li><li><p><strong>邻接表不唯一</strong>，每个链表后续结点的顺序都是可变的</p></li></ul><h4 id="逆邻接表"><a href="#逆邻接表" class="headerlink" title="逆邻接表"></a>逆邻接表</h4><p>方便计算入度；节约稀疏图的空间</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>对于任意无向图有向图，邻接矩阵是唯一的，但是邻接表不是唯一的。</p><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算。</p><p>存在结点重复访问的问题，因为图中出现环是很正常的，解决方法是使用<strong>辅助数组</strong>，记录每个结点的状态</p><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>先序遍历；访问的顺序不是固定的，是随机的</p><h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>从图的某一结点出发，首先依次访问该结点的所有邻接点<code>Vi, Vi2....Vi</code>，再按这些顶点被访问的先后次序，依次访问与它们相邻接的所有<code>未被访问</code>的顶点；重复此过程，直至所有顶点均被访问为止，一般通过队列实现。</p><h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><h4 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h4><p>图中所有<code>点</code>均由<code>边</code>连接在—起，但<code>不存在回路的图</code>；一个图可以有<code>多个生成树</code>；生成树是图的<strong>最小连通子图</strong>（树是图的特例，不存在孤立的结点，不存在环；有n个结点，n-1条边）；可以通过<code>深度/广度优先遍历</code>来构造。</p><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>前提是图的各边有权值，<code>最小</code>指的是路径上各边权值和最小；最小生成树不一定唯一（ok，生成树和最小生成树都不是唯一的）</p><p>如何构造（本质都是用了贪心算法）：</p><ul><li>普利姆算法：<ul><li>选择点；起初选择权值最小的那条边对应的2个结点，再查找这两个节点中的那条和其他结点权值最小的边，纳入这个边另一侧的结点，依此类推。</li><li>时间复杂度O(N*2)；n为结点数，因为所有已包含的结点都要查看是否与所有未包含的结点之间存在权值最小的边;适合稠密图</li></ul></li><li>克鲁斯卡尔算法：<ul><li>选择边；每次选择一条权值最小的边，但是如果选择了不满足连通图，则选择次小的边，依此类推</li><li>时间复杂度O(eloge)e为边数；只需要对所有的边进行排序，排序的时间复杂度为eloge；适合稀疏图</li></ul></li></ul><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><p>区别于最小生成树，不需要包含全部结点。</p><p><strong>如何寻找：</strong></p><ul><li>迪杰斯特拉算法：求单个结点到<em>所有其他结点</em>的最短路径，实话只了解思想不懂得原理和算法实现很容易忘</li><li>弗洛伊德算法：求全部结点到其他结点的最短路径</li></ul><p><strong>区别与联系</strong></p><ul><li>第一步都是记录结点与其他结点的<code>直接距离</code>，对于不可达的结点距离设为无穷远</li><li>迪杰斯特拉算法算法后续选择<code>距离最近的结点纳入</code>；已确定最小距离的结点，然后重新计算这个结点加入后，源结点到其他结点的最小距离，然后再纳入距离最近的结点，依此类推，时间复杂度为O(N^2)</li><li>弗洛伊德算法纳入结点的顺序是随意的，一般按照编号纳入，每纳入一个结点就重新计算每个源节点与其他结点的最小距离。</li></ul><h4 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h4><ul><li><p>aov网：拓扑序列</p><ul><li><p>结点表示活动，边表示制约关系，不能存在回路</p></li><li><p><strong>拓扑排序</strong>：把一个aov图输出为一个线性序列（拓扑序列）每个结点的先后顺序不变；可以通过广度优先遍历（队列）实现，必须从没有入度的结点开始，用来检测aov图中是否存在回路。</p></li></ul></li><li><p>aoe网：关键路径</p><ul><li>边表示活动；边的权值表示活动持续的时间，结点表示事件（既可以表示前一个事件的结束，又可以表示下一个事件的开始）</li><li>入度为0的结点也叫源点，出度为0的结点也叫汇点</li><li>关键路径——源点到汇点<code>路径长度最长</code>的路径。路径长度——路径上各活动持续时间之和。</li></ul></li></ul><h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>定义：数组是一种固定大小的线性结构，它将元素存储在一个连续的内存位置中；</p><p>优点：数组可以通过索引直接访问其元素，因此访问速度快</p><p>缺点：插入和删除操作通常需要移动大量元素。</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表中元素的存储是不连续的，每个结点包含数据和对下一个结点的引用</p><p>增删元素快，查询元素慢</p><p><strong>单循环链表</strong></p><img src="..\images\数据结构与算法\单循环链表.png" style="zoom:67%;" /><p>单循环链表，即单个方向循环的链表</p><p>由图可知，单循环链表删除首结点的操作是:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const first = Q-&gt;rear-&gt;next</span><br><span class="line">Q-&gt;rear-&gt;next = first.next</span><br><span class="line">first.next = null</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出的线性结构</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出的线性结构</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><ul><li>顺序存储（数组）</li><li>链式存储（链表）</li></ul><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><img src="..\images\数据结构与算法\队列.png" style="zoom: 50%;" /><p><code>front</code>指向队头的元素，<code>rear</code>指向下一个空地址，起初这两个指针的指向是相同的。</p><p>入队一个元素，<code>rear++</code>；出队一个元素<code>front--</code>，可以看出front始终指向队列中最先入队的元素。</p><h3 id="循环队列（顺序存储）"><a href="#循环队列（顺序存储）" class="headerlink" title="循环队列（顺序存储）"></a>循环队列（顺序存储）</h3><p>循环队列用来解决队列假满的问题，就是<code>rear=maxsize</code>，但是<code>font!=0</code>，此时虽然队列中还有空间，但是无法放入元素。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>在逻辑上实现循环，实际上存储结构还是数组</li><li>出队一个元素，头指针的指向改变：<code>front=(front+1)%maxsize</code></li><li>入队一个元素，尾指针的变化：<code>rear=(rear+1)%maxsize</code></li><li>这样好像是进出队列就没限制了，但是其实只要保证出队列的时候，是弹出front指针指向的元素就行。</li></ul><h4 id="判断非空"><a href="#判断非空" class="headerlink" title="判断非空"></a>判断非空</h4><p>循环队列虽然能解决假满的问题，又引出一个<strong>新的问题</strong>，当<code>front==rear</code>时存在两种情况，队满和队空，无法判断具体是情况。</p><p><img src="..\images\数据结构与算法\队列假满.png" style="zoom: 50%;" /><img src="..\images\数据结构与算法\队列假满2.png" style="zoom: 50%;" /></p><p>解决办法：</p><ul><li>设置一个标志位，记录元素个数</li><li><strong>少用一个元素空间</strong>：<ul><li>队空：<code>front==rear</code></li><li>队满：<code>(rear+1)%maxsize == front</code> ，即尾指针的下一个位置就是头指针的位置，这个时候就记作队满</li><li>初始状态：<code>front=rear=0</code></li><li>判断元素个数：<code>(rear+maxsize-front)%maxsize</code>，如果rear本来就比front大，那么<code>rear-front&gt;0</code>，加上maxsize求余的结果也不变，反之如果出现rear&lt;front这种<code>异常情况</code>，给rear加上maxsize才能转化出rear原本的下标。</li></ul></li></ul><p><strong>以后如果不是特别说明都认为循环队列少用一个元素空间</strong></p><p>总的来说，我们通过<code>循环队列</code>和<code>少用一个元素空间</code>的方法，完美的解决了<code>队列假满</code>和front&#x3D;&#x3D;rear时状态二义的问题。</p><h3 id="链队（带头结点）"><a href="#链队（带头结点）" class="headerlink" title="链队（带头结点）"></a>链队（带头结点）</h3><p>也是带有头尾两个指针，带有头结点，头节点不存储实际的数据</p><p>起初，两个指针<code>都指向头节点</code>即<code>front=rear=new Node()</code>，后续元素入队则<code>rear.next = new Node()</code>，<code>rear = rear.next</code>，front始终指向头节点。</p><p>我们也注意到，在用链表表示的队列中，尾指针rear指向的竟然是最后一个结点，而在用数组表示的 队列中，rear指向的是下一个元素填入的位置，而不是最后一个元素…..</p><img src="..\images\数据结构与算法\链式队列.png" style="zoom: 33%;" /><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><ul><li><code>const first = front.next</code>(存储队首元素地址)</li><li><code>front.next = first.next</code>(修改头节点的下一个结点)</li><li><code>first.next = null</code>(断开队首元素与队列的连接)</li><li>一般情况下，元素出队<strong>只需要修改头结点</strong>，但如果链队只有一个结点，那么出队不仅要修改头指针，还要修改尾指针，让尾指针指向头节点。</li></ul><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><ul><li><code>const last  = rear</code></li><li><code>rear = new Node()</code></li><li><code>last.next = rear</code></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>可以观察到，对于带头结点的队列，无论插入元素还是弹出元素，头指针(front)始终指向<code>头节点</code>。</p><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>零个或多个字符组成的有限序列，存储的是字符</p><h3 id="名词解释-1"><a href="#名词解释-1" class="headerlink" title="名词解释"></a>名词解释</h3><p>空串：长度为0的串</p><p>空白串：由空白字符组成的串，长度不为0</p><p>子序列：是主串中的字符集合，这些字符的相对顺序与在主串中相同，可以不连续。</p><p>子串：主串中任意个连续字符组成的子序列</p><p>子串位置：子串第一个字符在主串中的位置序号</p><p>真字串：不包含本身的子串</p><p>主串：包含子串的串</p><h3 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h3><ul><li><p>BF算法：暴力算法&#x2F;简单匹配法</p></li><li><p>KMP算法</p></li></ul><h3 id="存储模式"><a href="#存储模式" class="headerlink" title="存储模式"></a>存储模式</h3><ul><li>顺序存储：结构存储密度高</li><li>链式存储结构：存储密度低，因为还要存储下一个节点的地址；操作方便</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆在逻辑上是一种特殊的<code>完全二叉树</code>，分为<code>大根堆</code>和<code>小根堆</code>；大根堆指的是根节点比左右子节点的值大，小根堆反之，至于左右子节点的大小没有限制。</p><img src="..\images\数据结构与算法\大根堆.png" style="zoom:67%;" /><h3 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h3><img src="..\images\数据结构与算法\堆的存储.png" style="zoom: 50%;" /><p>堆通常使用数组来实现，这样可以方便地进行索引操作。</p><p>在数组表示的堆中，对于任意节点 i（索引从 0 开始）：</p><ul><li>根节点索引为i</li><li>左子节点的索引为 <code>2i + 1</code>。</li><li>右子节点的索引为 <code>2i + 2</code>。</li><li>父节点的索引为 <code>(j - 1) / 2</code>（向下取整）。j指的是左右子节点索引</li></ul><h3 id="调整堆"><a href="#调整堆" class="headerlink" title="调整堆"></a>调整堆</h3><h4 id="下滤"><a href="#下滤" class="headerlink" title="下滤"></a>下滤</h4><ul><li>适用于根节点不符合堆序的情况</li><li>弹出堆顶元素，并用末尾元素替代堆顶元素时，适合使用这种方式调整堆。</li></ul><h4 id="上滤"><a href="#上滤" class="headerlink" title="上滤"></a>上滤</h4><ul><li>适合子节点不符合堆序的情况</li><li>新插入的元素使用这种方式调整堆</li></ul><h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><h4 id="自顶向下构建"><a href="#自顶向下构建" class="headerlink" title="自顶向下构建"></a>自顶向下构建</h4><ul><li>已知一串序列，从上到下，从左到右构建二叉树，边构建过程中边调整，也就是上滤</li><li>假设结点数为N，则层数大概为log2(N)；构建堆需要添加N个结点，每个结点最多移动log2(N)次，所以时间复杂度可以助记为Nlog2(N)</li></ul><h4 id="自底向上构建（也叫筛选法）"><a href="#自底向上构建（也叫筛选法）" class="headerlink" title="自底向上构建（也叫筛选法）"></a>自底向上构建（也叫筛选法）</h4><p>已知一串序列，从下到上，从左到右构建二叉树；构建好了再从底部<strong>最后一个非叶子结点</strong>开始调整堆（下滤，意思就是每个非叶子结点都有可能被交换到下一层）；</p><p><strong>时间复杂度为O（N）</strong>，如果是完全二叉树，非叶子结点大概有 结点数目的一半（n&#x2F;2），然后每次<code>heapify</code>最多进行2次比较和2次交换，时间复杂度就是<code>4*(n/2)</code>，无论如何时间复杂度都是<code>O(n)</code></p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a><strong>拓展</strong></h3><ul><li>一棵二叉树，第1层最多有<code>2^0</code>个结点，第2层最多有<code>2^1</code>，第三层最多有<code>2^2</code>…..;每层最多有<code>2^(n-1)</code>个结点（n代表第几层）; 规律和<strong>2进制</strong>一样。</li><li>假设二叉树有n层（n位），结点数目最多为<code>2^n-1</code>，比如8位二进制能表示的最大数就是<code>2^8-1=255</code></li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p>优先队列</p><ul><li><p>队首元素永远是最大&#x2F;最小的，每次弹出或者加入元素都会重新调整队列</p></li><li><p>弹出（下滤）和插入结点（上滤）维护的时间复杂度都为log2(N)</p></li></ul></li><li><p>堆排序：不断弹出堆顶元素并重新调整堆；n个元素，需要建堆n次（第一次初始建堆，后续只需维护），每次 建好后再取走。</p></li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>建堆：一般指的是初次构建，从底往上构建堆的时间复杂度，为O（n）</li><li>调整堆、插入、删除（维护堆）：O(log2（n）) 因为n个结点的堆最多有log2（n）层，调整的时候最多移动有log2（n）-1次</li><li>堆排序：建堆时间复杂度<code>+</code>n次调整时间复杂度，<code>O（n）+O（nlogn）约等于O（nlogn)</code></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在计算机科学中，“堆”也指代一种<code>内存区域</code>，用于<code>动态分配</code>内存，但这与作为数据结构的堆有所不同。</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>逐步排序数组：有n个元素，遍历n-1遍，每次遍历都可能把当前遍历元素插入到已遍历的位置，确保到当前位置位置的元素是有序的，直至遍历到最后一个元素，确保全部元素有序。</p><p>时间复杂度</p><ul><li>遍历n-1遍，每次遍历都可能需要插入，最坏（逆序）时间复杂度为O（n^2);也可能都不需要插入，本来就有序，每次只需要比较一次，时间复杂度为O（n）；平均情况时间复杂度：O(n^2)，和选择排序，冒泡排序坐一桌</li><li>无论是否有序，都要遍历n-1次</li></ul><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>插入排序的一个更高效的改进版本</p><p>步骤：</p><ul><li>根据步长分为多个子表，步长为n就有n组子表</li><li>对每组子表进行直接插入排序</li><li>更改步长为n&#x2F;2，即原来的一半，再对每组子表进行直接插入排序</li><li>依此类推，直至步长缩短为1，进行最后一次插入排序</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span><span class="comment">//初始化为true，即便已经有序也要走一遍检查一下</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span> &amp;&amp; flag; i++) &#123;<span class="comment">//因为可能不需要排序n-1次，对循环退出再加个条件</span></span><br><span class="line">    flag = <span class="literal">false</span><span class="comment">//先假设序列是有序的，不需要再走一遍</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; arr.<span class="property">length</span> - i; j++) &#123;</span><br></pre></td></tr></table></figure><ul><li>从右往左维护，遍历n-1遍</li><li>从第二个元素开始遍历，判断该元素是否小于前一个元素，如果是则交换</li><li>以此类推确保当前遍历位置的元素是遍历到的所有元素中最大的；下次遍历维护好的元素不参与比较</li><li>冒泡冒泡就是让最大的冒泡到最后面，重点在找最大的元素</li></ul><p>时间复杂度：如果序列本身有序，则只走一趟，比较n-1次，不交换元素，时间复杂度为O(n)</p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr3.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr3.<span class="property">length</span>; j++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>从左往右维护，遍历n-1遍；找出最小的元素，和第i个元素交换，第i个元素就是要维护的元素</li><li>比较次数与初始序列无关，时间复杂度和初始序列无关；</li><li>无论初始序列如何，每次遍历都要比较n-1，n-2, n-3,….,1次，总的比较次数为n(n-1)&#x2F;2，时间复杂度为O(n^2)</li><li>算法的排序趟数与初始序列无关,就是要遍历n-1遍</li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>用到了递归的思想，用到了轴的思想，每次只确定一个元素的位置</p><p>每次都以第一个元素为轴，遍历所有其他元素，让所有比第一个元素小的元素在轴的左边，比第一个元素是大的元素在轴的右边，遍历完所有元素就能确定第一个元素该在哪个位置，每次遍历只能确定一个元素的位置，所以还需要递归轴左边的和轴右边的部分，确定所有元素的位置</p><p>时间复杂度：平均情况为nlogn，最坏情况n^2,最坏情况是数组本身就有序，每次快排都要比较n-1,n-2,….,1次，所以时间复杂度为n^2</p><p>空间复杂度：O(1)原地排序</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>用到了二叉树的逻辑结构，对数组中的数据进行层次遍历</p><p>也是每次建堆都能等到最大的&#x2F;最小的元素，就和选择排序每次能得到最小（最大）的元素一样，堆排序其实就是选择排序的优化</p><p>如果是升序排列则是构建大根堆，反之小根堆</p><p>时间复杂度：O(nlogn)，最好最坏情况都是，而且不占用额外空间，缺点是不稳定</p><p>空间复杂度：O(1)原地排序</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>两有序并为1有序，利用了一个元素必然就是有序的这一特点作为递归出口<br>合并有序数组的算法实现也是一个重点，用到了分治的思想，分而治之，对一个数组排序的工作可以划分为多左半部分排序再对右半部分排序，再合并，当一部分划分到只有一个元素时候，这部分自然就是有序的了直接返回即可</p><p>时间复杂度：O(nlogn)，没有最坏情况，而且稳定没缺点就是需要额外空间（递归栈来维护）<br>空间复杂度：需要额外的空间，非O（1）</p><h2 id="如何判断排序方法是否稳定"><a href="#如何判断排序方法是否稳定" class="headerlink" title="如何判断排序方法是否稳定"></a>如何判断排序方法是否稳定</h2><p>大小相同的元素排序后，前后顺序保持不变的就是稳定的</p><p>不稳定的排序算法</p><ul><li>选择排序：比如：[4, 4, 2, 1]-&gt;[1,4,2,4]-&gt;[1,2,4,4]</li><li>希尔排序比如：[2, 2, 1, 3]-&gt;[2,1],[2,3]-&gt;[1,2],[2,3]-&gt;[1,2,2,3]</li><li>快速排序：可能不稳定</li><li>堆排序：可能不稳定</li></ul><p>其他排序算法都是稳定的，口诀：一堆希尔快选</p><h2 id="排序方法的选择"><a href="#排序方法的选择" class="headerlink" title="排序方法的选择"></a>排序方法的选择</h2><p>算法的时间复杂度与初始序列无关的是：选择排序、堆排序、归并排序</p><h2 id="插入-删除的时间复杂度"><a href="#插入-删除的时间复杂度" class="headerlink" title="插入&#x2F;删除的时间复杂度"></a>插入&#x2F;删除的时间复杂度</h2><p>假设有n个元素，则有n+1中插入方式，位置从左到右边分别移动n，n-1，….,0个元素，总共移动（1+n）*n&#x2F;2次，平均每次插入移动n&#x2F;2次，所以插入的时间复杂度是O(n)。删除同理。</p><h2 id="二分查找次数"><a href="#二分查找次数" class="headerlink" title="二分查找次数"></a>二分查找次数</h2><h3 id="快速判断"><a href="#快速判断" class="headerlink" title="快速判断"></a>快速判断</h3><p>假设有100个元素，最大查找次数为n，则有2^n&gt;&#x3D;100，n&#x3D;6为64&lt;100,n&#x3D;7为128&gt;100满足题意</p><h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><p>每查找一次都将区间减半，直到区间长度为1（对于每次查找的中间元素，我们都把它纳入下次查找区间，方便理解，虽然它不可能是要查找的元素，理应不存在这个区间）</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>2^x(x为查找次数)，n为元素个数，x&#x3D;log2(n),这个值就是时间复杂度。</p><h1 id="js中的数据结构"><a href="#js中的数据结构" class="headerlink" title="js中的数据结构"></a>js中的数据结构</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>js中的数据结构都是用类和对象来实现的，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val, next = <span class="literal">null</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val; <span class="comment">// 节点的值</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">next</span> = next; <span class="comment">// 指向下一个节点的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>str.toLowerCase()</strong></p><p>将字符串中的所有<code>大写字母</code>转换为小写，返回一个<code>新的字符串</code>，不会修改原来的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lowerStr = str.<span class="title function_">toLowerCase</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lowerStr); <span class="comment">// 输出: &quot;hello world!&quot;</span></span><br></pre></td></tr></table></figure><p><strong>str.codePointAt</strong>()</p><p>返回字符串指定位置字符的asc编码,如果只是想要知道某个字符的asc编码，让这个字符串只包含一个字母即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> charA = <span class="string">&quot;A&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> codeA = charA.<span class="title function_">codePointAt</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(codeA); <span class="comment">// 输出: 65 (大写字母 &#x27;A&#x27; 的 Unicode 编码)</span></span><br></pre></td></tr></table></figure><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><ul><li>Math.round()：四舍五入</li><li>Math.ceil()：向上取整</li><li>Math.floor()：向下取整</li><li>Math.max()：求最大值</li><li>Math.min()：求最小值</li></ul><p><strong>注意：没有提供Math.sum方法</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计科专业核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/posts/d04bd5bc.html"/>
      <url>/posts/d04bd5bc.html</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统类型"><a href="#操作系统类型" class="headerlink" title="操作系统类型"></a>操作系统类型</h2><ul><li><p>单批道处理：内存中同时只有一道程序运行，程序之间只能串行</p></li><li><p>多批道系统：允许多个程序并发运行，操作系统正式诞生，但是对cpu等资源来说，同一时间还是只服务一个进程，但是一旦空闲，就会立马被其他进程占用，即便上一个进程未结束，但是因为已经不需要cpu所以无碍，这样大大提高了资源的利用率；缺点是人机交互不好。</p><img src="..\images\操作系统\多批道.png" style="zoom:50%;" /></li><li><p>分时操作系统：操作系统以<code>时间片</code>为单位轮流为各个用户&#x2F;作业服务；用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在；缺点是无法区分任务的紧急性</p></li><li><p>实时操作系统：能够<code>优先响应</code>一些紧急任务，某些紧急任务<strong>不需时间片排队</strong>。在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是<code>及时性</code>和<code>可靠性</code></p></li></ul><h2 id="虚拟机管理程序-VMM"><a href="#虚拟机管理程序-VMM" class="headerlink" title="虚拟机管理程序(VMM)"></a>虚拟机管理程序(VMM)</h2><img src="..\images\操作系统\传统计算机.png" style="zoom:33%;" /><p>传统计算机上，一台计算机只能运行一个操作系统，为了充分利用硬件资源，我们希望在一台计算机上运行多个<code>操作系统</code>。</p><p>通过<code>虚拟机管理程序</code>，把一台<code>物理机器</code>虚拟化为多台<code>虚拟机(VM)</code>，<strong>每台虚拟机上都能独立运行一个操作系统</strong>。</p><p>虚拟机管理程序又可分为两大类，第一类，虚拟机管理程序直接运行在硬件上，可移植性差；第二类，虚拟机管理程序运行在<code>宿主操作系统上</code>，可移植性高。</p><h2 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h2><ul><li>处理机（cpu）管理：处理机管理主要是指对中央处理器（CPU）的工作进行有效的组织和调度，以提高系统的效率。这包括进程控制、进程同步、进程通信和进程调度等。通过合理的调度算法，<strong>操作系统确保每个进程都能公平地获得CPU时间</strong>，并高效地完成任务。</li><li>存储管理</li><li>文件管理</li><li>设备管理：比如I&#x2F;O设备管理</li><li>作业管理</li></ul><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>让cpu从<code>用户态</code>（也叫目态）变为<code>内核态</code>，是<code>内核程序</code>夺回cpu控制权的唯一途径；进程的并发离不开中断。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="内中断（异常）"><a href="#内中断（异常）" class="headerlink" title="内中断（异常）"></a>内中断（异常）</h4><p>内中断也称为异常（Exception），是指由<strong>处理器内部产生的中断信号</strong>，通常是因为执行指令时遇到特殊情况或错误而引起的。内中断主要包含以下几种类型：</p><ul><li><strong>故障（Fault）</strong>：这种类型的中断表示发生了某种可恢复的错误，比如除以0。CPU会在发生故障后保存现场，并尝试修正问题，然后返回原程序继续执行。</li><li><strong>陷入（Trap）</strong>：程序故意引发，比如请求调用操作系统服务(系统调用)。</li><li><strong>终止（Abort）</strong>：表示发生了严重的、不可恢复的错误，导致程序无法继续执行，如硬件故障。</li></ul><h4 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h4><p>外部指令提醒cpu中断，目的是通知CPU有外部事件需要处理，然后cpu进入内核态（运行内核程序的状态），处理收到的中断信号，包括<code>时钟中断（它由硬件定时器周期性地产生，用于维持系统时间、调度进程等关键功能）</code>，<code>i/o中断（i/o操作完成）</code></p><h3 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态&#x2F;内核态"></a><strong>用户态&#x2F;内核态</strong></h3><p>处于<code>用户态的进程</code>只能访问用户态的内存空间（用户空间），不能直接访问内核态的内存空间（系统空间）</p><h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><h3 id="中断程序"><a href="#中断程序" class="headerlink" title="中断程序"></a>中断程序</h3><p>cpu根据不同的<code>中断信号</code>执行不同的<code>中断程序</code>，本质是内核程序，运行在内核态（也叫管态）</p><h3 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h3><p>当CPU正在处理一个优先级较低的中断，又来了一个优先级更高的中断请求，则CPU先停止低优先级的中断处理过程，去响应优先级更高的中断请求，在优先级更高的中断处理完成之后，再继续处理低优先级的中断，这种情况称为中断嵌套，因为低级中断的处理过程被高级中断插入了（低级中断-高级中断-低级中断），所以叫做中断嵌套。</p><h3 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h3><p>CPU通过指令限制某些设备发出中断请求，处理中断一般按照<code>中断的优先级</code>对其进行处理，某些时候可以<strong>屏蔽</strong>掉高优先级的中断，中断产生时系统不予响应，未被屏蔽的低优先级中断反而可以响应，<strong>从而改变了中断响应次序</strong> 。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>是操作系统进行<code>资源分配</code>和<code>调度</code>的独立单位</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>特性</p><ul><li><strong>动态性：最基本的特性</strong></li><li>异步性：强调并发运行的进程之间的执行先后顺序是<code>不可预</code>知的</li><li>并发性：没有并发就没有异步，现代操作系统中进程是并发执行的</li></ul><h3 id="程序与进程的区别"><a href="#程序与进程的区别" class="headerlink" title="程序与进程的区别"></a>程序与进程的区别</h3><p>程序是静态的，可执行文件的集合，而进程是动态的。</p><h3 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h3><ul><li><p><strong>PCB</strong>：也叫进程控制块，<strong>包含了进程相关的所有信息，是进程存在的唯一标识</strong>；方便操作系统管理进程，进程结束会被回收。</p><ul><li><p><code>pid</code>：每次新建进程，都会给进程分配一个唯一的pid，<strong>用来标识不同的进程</strong></p><img src="..\images\操作系统\pid.png" style="zoom:90%;" /></li><li><p>其他进程有关的信息</p></li></ul></li><li><p>数据段：程序中定义的变量</p></li><li><p>程序段：程序代码</p></li></ul><h3 id="进程之间的基本关系"><a href="#进程之间的基本关系" class="headerlink" title="进程之间的基本关系"></a>进程之间的基本关系</h3><ul><li>同步：协调进程间的执行顺序，为了解决异步问题，属于<strong>直接制约关系</strong></li><li>互斥：避免多个进程同时访问同一资源导致冲突，互斥访问<code>临界资源</code>，<strong>属于间接制约关系，因为中间夹了一个临界资源</strong></li></ul><h3 id="进程同步-PV操作"><a href="#进程同步-PV操作" class="headerlink" title="进程同步-PV操作"></a>进程同步-PV操作</h3><p>p用来代表wait原语，v用来代表signal原语；使用原语的好处是检查和上锁是一气呵成的；</p><ul><li>整形信号量：存在循环等待，不满足让权等待，因为资源不足会进程会<strong>循环等待</strong>资源。</li><li>记录型信号量：在整形信号量的基础上多了一个<code>等待队列</code>，<code>p操作</code>让资源数减一，如果资源数&lt;0（说明没有空闲资源了），使用<code>block原语</code>阻塞进程，放入等待队列；<code>v操作</code>让资源数+1，如果资源数&lt;&#x3D;0，则使用<code>wakeup原语</code>唤醒一个进程；进程同步的时候指定某个资源的数量为0，<strong>然后先v后p</strong>，即先要执行的进程释放一个资源后，才能运行另一个进程，也就是说，如果一个进程需要另一个进程执行完后才能运行，就能实现进程的同步。</li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程是分配系统资源的单位(包括内存地址空间)，<strong>因此各进程拥有的内存空间相互独立</strong>，进程之间的通信是有一定的延时的。</p><p>为了安全起见，进程之间不能直接通信，需要借助操作系统。</p><h4 id="共享地址空间"><a href="#共享地址空间" class="headerlink" title="共享地址空间"></a>共享地址空间</h4><p>就是给需要通信的进程分配一个能够共享的内存空间，特点是写入，取出数据可以是在共享空间的<strong>任意位置</strong>的；为避免出错，各个进程对共享空间的访问应该是<strong>互斥</strong>的。</p><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><img src="..\images\操作系统\消息通信.png" style="zoom:50%;" /><img src="..\images\操作系统\消息.png" style="zoom:50%;" /><p>通过<em>send</em>和<em>receive</em>原语操作实现</p><p><strong>直接传递</strong></p><img src="..\images\操作系统\直接传递.png" style="zoom:50%;" /><p>指明发送到哪个进程，接收哪个进程的信息，消息存储在进程的<code>消息队列(存储着所有发送给这个进程的消息)</code>中，<strong>消息队列存储在PCB中，进程PCB存储在<code>操作系统内核空间</code>中。</strong></p><p><strong>间接传递</strong></p><p>指明发送到哪个邮箱，接收哪个邮箱的信息（邮箱存储在操作系统内核）</p><img src="..\images\操作系统\间接传递.png" style="zoom:50%;" /><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><img src="..\images\操作系统\管道.png" style="zoom: 50%;" /><p>半双工，同时只能存在一个方向（水管中的水流也只能是单向的）；<strong>本质是一个共享的文件</strong>，进程向操作系统申请后由操作系统来分配；管道通信逻辑上是个<strong>循环队列</strong>（一端写满了，如果另一端没满，可以往另一端继续写）；区别于<code>共享内存</code>的方式，读入，取出数据都是有限制的。</p><p>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</p><p>管道写满的时候，写进程阻塞，管道为空的时候，读进程阻塞。</p><h3 id="并发-并行-异步"><a href="#并发-并行-异步" class="headerlink" title="并发&#x2F;并行&#x2F;异步"></a>并发&#x2F;并行&#x2F;异步</h3><ul><li>异步：并发的进程以独立的，不可预知的速度向前推进。异步性基于进程并发</li><li>并发：在同一时间间隔内运行多个进程。宏观看起来同时，实际上是通过<strong>快速切换进程</strong>来模拟同时执行的效果。</li><li>并行：多个进程的<strong>同时执行</strong>，需要多个cpu。</li></ul><h3 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h3><img src="..\images\操作系统\进程状态转换.png" style="zoom: 50%;" /><ul><li>创建态：进程已被创建</li><li>就绪态：程序已被创建，随时可以上cpu执行</li><li>运行态：程序正在cpu上运行，一个进程占用一个cpu</li><li>阻塞态：当进程请求某个资源但是<strong>该资源被占用时</strong>，进程下cpu，变成阻塞态</li><li>终止状态：进程运行结束</li></ul><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>先来先上cpu运行，对<code>短作业</code>不友好（上厕所，你急着上小号但是里面有人在上大号）；非抢占式算法。</p><h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><ul><li>对长作业不友好，面对远远不断的短作业，可能会导致长作业出现<code>饥饿问题</code>；</li><li>一般是非抢占式的，也有抢占式的；</li><li><strong>是平均周转时间最短的算法</strong>（平均周转时间&#x3D;（总运行时间+总等待时间）&#x2F;进程数目）；因为各个进程运行时间是固定的，这种算法能让所有进程的<code>总等待时间最短</code>，所以能实现最短的平均周转时间。</li></ul><h4 id="高响应比优先算法"><a href="#高响应比优先算法" class="headerlink" title="高响应比优先算法"></a>高响应比优先算法</h4><p>既考虑到了<code>等待时间</code>也考虑到了进程长度；一个进程结束时，计算就绪队列中所有进程的<code>响应比</code>，让<strong>响应比最高的进程</strong>上cpu；不会导致饥饿。<code>进程响应比等于：1 + 等待时间/进程运行时间</code></p><h4 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h4><p>每个进程分配一个固定的时间段，让它们轮流执行。系统维护一个<strong>就绪队列</strong>，其中包含所有<code>等待CPU时间</code>的进程。当一个进程的时间片结束时，无论它是否已完成，都会被移到队列的末尾，下一个进程开始运行。如果进程在时间片内完成，则从队列中移除。</p><p>确保所有进程都能获得一定的CPU时间，避免了饥饿现象。但要注意的是，频繁的上下文切换（进程切换）可能会带来额外的系统开销，尤其是当<code>时间片设置得过短时</code>。</p><h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p>每个进程都被赋予一个<code>优先</code>，系<strong>统总是选择当前具有最高优先级（最低数字通常表示最高优先级）的进程执行</strong>。</p><h3 id="其他调度"><a href="#其他调度" class="headerlink" title="其他调度"></a>其他调度</h3><ul><li><p>进程调度（低级调度）：让就绪状态的进程将获得处理机的过程；发生频率最高的调度</p></li><li><p>内存调度（中级调度）：把<code>内存中</code>的暂时不需要的<strong>进程</strong>换出，或者把外存的已具备运行条件的就绪进程重新调入内存。暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被<strong>挂起</strong>的进程PCB会被组织成<strong>挂起队列</strong>。就拿手机举例，我们打开后台的某个应用，有的进入的很快，有的进入的很慢，这是因为，因为内存不足，有的后台应用进程已经被<code>移出内存(挂起)</code>了，所以再次进入的速度很慢，而还要一部分后台应用进程还保留在内存中（阻塞态），所以进入速度很快。</p><img src="..\images\操作系统\七状态模型.png" style="zoom:40%;" /></li><li><p>作业调度（高级调度）：把作业调入内存，就是让一个<strong>程序</strong>执行，为其创建<strong>进程</strong>，是发生频率最低的调度。</p></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li><p>传统的进程只能<strong>串行</strong>的执行一系列代码，这就导致<strong>一个进程无法同时执行多个功能</strong>。一个进程内部可以根据<strong>功能不同</strong>划分多个线程，线程之间可以<strong>并发运行</strong>。</p></li><li><p>引入线程后，进程只作为除CPU之外的系统资源的分配单元(如打印机、内存地址空间等都是分配给进程的)，但不再是调度（上cpu）的基本单位，线程才是。</p></li></ul><h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><ul><li>线程是<code>处理机调度</code>的单位</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个<code>线程ID</code>、<code>线程控制块(TGB)</code></li><li>线程也有<code>就绪、阻塞、运行</code>三种基本状态</li><li>线程几乎不拥有系统资源；同一进程的不同线程间<code>共享进程的资源</code></li><li>由于共享内存地址空间，同一进程中的<strong>线程间通信</strong>甚至无需系统干预，直接使用<code>共享的地址空间</code>就好。</li><li><code>同一进程</code>中的线程切换，不会引起<code>进程切换</code></li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小；切换进程，系统开销较大</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>所有进程都在等待其他进程释放资源，导致<strong>所有进程都阻塞的状态</strong></p><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul><li>互斥条件：只有对<code>临界资源</code>的争抢才会引发死锁，如果资源可以同时被多个进程访问，那就不存在资源的争抢问题</li><li>不可剥夺条件：进程在获取到所需资源但是还没有使用之前，所占有的资源是无法被其他进程剥夺的，<strong>只能主动释放</strong>。</li><li>请求和保持：进程会保留已经获得到的资源，并继续请求需要的，未获得到的资源。</li><li>循环等待：每个进程在请求别的进程占有的资源的同时，已经获得的资源也被其他进程请求。</li></ul><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><h4 id="不允许死锁发生"><a href="#不允许死锁发生" class="headerlink" title="不允许死锁发生"></a>不允许死锁发生</h4><ul><li><p>预防死锁：破坏必要条件</p><ul><li>破坏互斥：把临界资源改造成可以同时使用的资源，比如spooling技术，然而并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。</li><li>破坏不可剥夺：当某个进程请求新的资源得不到满足时，它必须<strong>立即释放保持的所有资源</strong>，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。但这种策略也有很多缺点。</li><li>破坏请求和保持：可以使用<strong>静态分配法</strong>，进程在运行前一次性<strong>申请所有所需资源</strong>，如果申请未满足，就不把进程投入运行，一旦申请通过，<strong>整个运行过程中都占用这些资源</strong>；因为申请的资源多，所以可能因为条件一直得不到满足而造成进程饥饿。</li><li>破坏循环等待：使用<strong>顺序资源分配法</strong>，给资源编号，<strong>进程必须按照编号递增的规则请求资源</strong></li></ul></li><li><p>避免死锁：银行家算法</p><img src="..\images\操作系统\银行家算法.png" style="zoom:80%;" /><p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要<strong>考虑到最坏的情况</strong>。</p><p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，不过如果没有进程提前释放资源，发生死锁也是将会发生的事情)。</p><p>因此可以在资源分配之前<strong>预先判断</strong>这次分配是否会导致系统进入<code>不安全状态</code>，以此决定是否答应资源分配请求。这也是<strong>银行家算法</strong>的核心思想。</p></li></ul><h4 id="允许死锁发生"><a href="#允许死锁发生" class="headerlink" title="允许死锁发生"></a>允许死锁发生</h4><ul><li><p>判断是否发生死锁：资源分配图</p><ul><li>定义一种数据结构存储资源的分配情况，实现一种算法检测是否发生死锁；</li><li>用一结点表示资源或者进程，进程指向资源的边，表示请求一个该资源，资源指向进程的边表示给该进程分配了多少资源，资源结点的值表示资源的数量。</li><li><strong>如果资源分配图的边能被全部简化，说明没有发生死锁，如果不能说明发送了死锁</strong>，这个简化的过程其实使用了<strong>银行家算法</strong>的思想。</li></ul></li><li><p>解除死锁</p><ul><li>资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法(或称终止进程法)：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li>进程回退法：让一个或多个死锁进程<strong>回退</strong>到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li></ul></li></ul><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一个进程长时间无法获得所需资源的状态，可能处于就绪状态也可能处于阻塞状态。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><img src="..\images\操作系统\内存管理.png" style="zoom:50%;" /><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存可存放数据。<code>程序</code>执行前需要先放到<code>内存中</code>才能被CPU处理—<strong>缓和CPU与硬盘之间的速度矛盾</strong></p><img src="..\images\操作系统\内存.png" style="zoom:50%;" /><h3 id="装入的三种方式"><a href="#装入的三种方式" class="headerlink" title="装入的三种方式"></a>装入的三种方式</h3><p>C语言<code>程序</code>经过<code>编译链接</code>处理后，生成<strong>装入模块</strong>，即<code>可执行文件</code>，它包含多条<code>指令</code>，可以放入内存中执行。</p><h4 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h4><p>在编译时，如果知道<code>程序</code>将放到内存中的哪个位置(知道基地址)，编译程序将把目标代码中的逻辑地址（相对地址）全部替换成<code>绝对地址(物理地址)</code>，<code>装入程序</code>按照<code>装入模块</code>中的地址，将程序和数据装入内存。这种方式的灵活性很差。</p><img src="..\images\操作系统\绝对装入.png" style="zoom:50%;" /><h4 id="静态重定位"><a href="#静态重定位" class="headerlink" title="静态重定位"></a>静态重定位</h4><p><strong>在装入一个作业时</strong>，把装入模块中的<code>指令地址</code>和<code>数据地址</code>全部转换成<code>绝对地址（物理地址）</code>，提高了灵活性，但是如果<code>进程的位置改变了</code>（基地址变了），又会出错。</p><img src="..\images\操作系统\静态重定位.png" style="zoom:50%;" /><h4 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h4><p>又称动态运行时装入。<code>编译、链接</code>后的<code>装入模块</code>的地址都是从<code>0</code>开始的。装入程序把装入模块<code>装入内存后</code>，并不会立即把逻辑地址转换为绝对地址（物理地址），而是把<code>地址转换</code>推迟到<code>程序真正要执行时</code>才进行。<strong>因此装入内存后所有的地址依然是逻辑地址</strong>(相对地址)。这种方式需要一个<strong>重定位寄存器</strong>的支持。</p><img src="..\images\操作系统\动态重定位.png" style="zoom:45%;" /><p>采用动态重定位时，运行程序在内存中发生移动。</p><p>并且可将程序分配到<strong>不连续的存储区</strong>中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</p><h3 id="从写入程序到运行"><a href="#从写入程序到运行" class="headerlink" title="从写入程序到运行"></a>从写入程序到运行</h3><img src="..\images\操作系统\从写入程序到运行.png" style="zoom:80%;" /><ul><li>编译：由<code>编译程序</code>将用户<code>源代码</code>编译成若干个目标模块(编译就是把高级语言翻译为机器语言)</li><li>链接：由<code>链接程序</code>将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个<strong>完整的装入模块(exe文件)</strong></li><li>装入(装载)：由<code>装入程序</code>将<code>装入模块</code>装入<code>内存</code>运行</li></ul><h3 id="内存的分配与回收"><a href="#内存的分配与回收" class="headerlink" title="内存的分配与回收"></a>内存的分配与回收</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>指的是操作系统为用户进程分配的必须是一个连续的内存空间。</p><ul><li><p>单一连续分配：内存被分为系统区和用户区；<code>系统区</code>通常位于内存的<code>低地址</code>部分，用于存放操作系统相关数据；<code>用户区</code>用于存放<code>用户进程</code>相关数据。内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区空间。</p><img src="..\images\操作系统\单一连续内存分布.png" style="zoom:50%;" /><p>优点:实现简单；无<code>外部碎片（存在未被分配的空间）</code>；可以采用覆盖技术扩充内存；不一定需要采取内存保护。<br>缺点:只能用于单用户、单任务的操作系统中；有<code>内部碎片（分配的空间内部还有剩余）</code>；<strong>存储器利用率极低</strong>。</p></li><li><p>固定分区分配：把<code>用户区分</code>为多个大小<code>相等或者不等</code>的区域，每个区域只放一个进程；会存在<code>内部碎片</code>，<code>无外部碎片</code>。</p><img src="..\images\操作系统\固定分区分配.png" style="zoom:50%;" /><p>操作系统需要建立一个数据结构:<strong>分区说明表</strong>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<code>大小、起始地址、状态(是否已分配)</code>。</p><p>优点是实现简单，无外部碎片。缺点是当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能。还可能会产生<code>内部碎片</code>，内存利用率低。</p><img src="..\images\操作系统\分区表.png" style="zoom:50%;" /></li><li><p>动态分区分配：动态分区分配又称为可变分区分配。这种分配方式<strong>不会预先划分内存分区</strong>，而是在进程装入内存时，根据进程的大小<strong>动态地建立分区，并使分区的大小正好适合进程的需要</strong>。因此系统分区的<code>大小和数目是可变的</code>。</p><img src="..\images\操作系统\动态分区分配.png" style="zoom:50%;" /><p>那系统该使用什么<code>数据结构</code>来记录内存的使用情况呢？常用的两种数据结构是空闲分区表和空闲分区链。</p><img src="..\images\操作系统\分区链.png" style="zoom:50%;" /><p>当很多空闲分区都能满足要求，应该选择哪个分区进行分配？把一个新作业装入内存时，须按照一定的<strong>动态分区分配算法</strong>，从空闲分<br>区表(或空闲分区链)中选出一个分区分配给该作业。由于<code>分配算法算法</code>对系统性能有很大的影响，因此人们对它进行了广泛的研究。</p></li></ul><h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><ul><li>内部碎片：给进程分配的空间没有被完全利用</li><li>外部碎片：内存中某些空闲分区由于太小而无法被利用；可以通过紧凑技术解决，但是需要改变进程的基地址，依赖于动态重定位。</li></ul><h4 id="离散分配"><a href="#离散分配" class="headerlink" title="离散分配"></a>离散分配</h4><ul><li><p><strong>分页存储</strong></p><p>一个<code>进程</code>可以被划分为多个<strong>大小相同的页</strong>，<strong>页号</strong>等于<code>逻辑地址/页面大小</code>，页内偏移量等于<code>逻辑地址%页面大小</code>。</p><p>内存被分为<code>多个物理块</code>，每个物理块就是一个<code>页框</code></p><p>每个进程都有自己的<strong>页表</strong>，存储在<code>PCB</code>中，记录了这个进程中所有<code>页面</code>与<code>页框</code>的对应关系。</p><img src="..\images\操作系统\页表.png" style="zoom: 45%;" /><p>页表的页号不需要花存储空间存放，可以是隐含的(比如数组的下标就不要被存储)，只需要知道<code>页表基地址</code>和<code>块</code>的大小，可以把页表当作一个数组。块号需要花存储空间存放，存储的只是<strong>内存块的编号</strong>，不是起始地址。</p><p>那如何进行地址转换呢？</p><img src="..\images\操作系统\地址转换.png" style="zoom:50%;" /><p><strong>快表</strong></p><p>存储在cpu中，<strong>用来加速逻辑地址到物理地址的转化</strong>，如果命中快表，就<strong>不需要访问内存中的页表</strong></p><p><strong>页表寄存器</strong></p><p>进程页表信息起初存储在<code>进程PCB</code>中，后续调用的时候把<code>页表基地址</code>和<code>长度</code>存储在页表寄存器中，但是页表其他信息还是存储在内存中。</p></li><li><p><strong>分段存储</strong></p><p>划分进程空间的时候是按<code>逻辑</code>划分的，划分为一个一个段；分页对用户是不可见的，分段是可见的，<strong>需要指定的</strong>。</p></li><li><p><strong>段页式存储</strong></p><p>把进程按逻辑划分为段，<strong>但是存储的时候又把每个段划分为页，每个段对应一个页表</strong>，段表存储的则是每个段的页表的位置和页表大小。</p></li></ul><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><code>传统存储管理</code>，包括前面介绍的<code>连续分配</code>和<code>非连续分配</code>，有许多特征，缺点。</p><ul><li><strong>一次性</strong>：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：<ul><li>作业很大时，不能全部装入内存，<strong>导致大作业无法运行</strong>；</li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致<strong>多道程序并发度下降</strong>。</li></ul></li><li><strong>驻留性</strong>：一旦作业被装入内存，<strong>就会一直驻留在内存中，直至作业运行结束</strong>。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</li></ul><p>其实这些问题都可以使用<strong>虚拟存储技术</strong>解决。</p><p><code>虚拟存储技术</code>是<code>基于局部性原理</code>：</p><ul><li><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问，因为程序中存在大量的循环。</li><li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问，因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的。</li></ul><p>基于<code>局部性原理</code>，在程序装入时，可以将程序中<strong>很快会用到的部分</strong>装入内存，暂时用不到的部分留在外存，就可以让程序<code>开始执行</code>。</p><p>在程序执行过程中，当所访问的信息<strong>不在内存时</strong>，由<code>操作系统</code>负责将所需信息<code>从外存调入内存</code>，然后继续执行程序。<br>若内存空间不够，由操作系统负责将内存中<strong>暂时用不到的信息</strong>换出到外存。</p><p>在<code>操作系统</code>的管理下，在用户看来，似乎有一个比<code>实际内存</code>大得多的内存，这就是<code>虚拟内存</code></p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a><strong>特征</strong></h4><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被<code>分成多次调入内存</code>。</li><li>对换性：在作业运行时<code>无需一直常驻内存</code>，而是允许在作业运行过程中，将作业换入、换出。</li><li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li></ul><h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a><strong>如何实现</strong></h4><img src="..\images\操作系统\虚拟内存实现.png" style="zoom:50%;" /><h3 id="内存分类"><a href="#内存分类" class="headerlink" title="内存分类"></a>内存分类</h3><h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><p>ROM(read only memory)，只读存储器，即：它只能读出信息，<strong>不能写入信息</strong>，计算机关闭电源后其内的信息仍旧保存，一般用它存储固定的<code>系统软件</code>和<code>字库</code>等。</p><p><strong>BIOS(basic iput&#x2F;output system)</strong></p><p>它提供了<code>硬件初始化</code>和<code>加载操作系统</code>的功能，存储在ROM中；操作系统本身是存储在计算机的<code>外存设备</code>上的，如硬盘或<code>SSD</code>(固态硬盘，Solid State Drive，操作系统通常安装在SSD的C盘上)，并在计算机启动时<strong>被加载到内存中运行</strong>。 </p><h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><p>RAM，全称为随机存取存储器（Random Access Memory），</p><p>是计算机系统中的一种<strong>主要存储器类型</strong>。它用于<code>临时存储</code>正在运行的程序和数据，以便处理器能够快速访问。RAM的特点是可以被<strong>迅速读写</strong>，并且<strong>支持对任何存储位置的随机访问，即访问时间与存储位置无关</strong>。</p><p><strong>主要特性</strong></p><ul><li><strong>易失性</strong>：RAM是一种易失性存储器，意味着当<strong>电源关闭时，存储在其中的数据会被清除</strong>。因此，它主要用于存储那些需要频繁修改和访问的数据。</li><li><strong>高速度</strong>：相比硬盘驱动器或固态硬盘等<code>永久存储设备</code>，RAM提供了<code>更快的数据读写速度</code>，这使得它非常适合用于作为<code>CPU的主存储区域</code>，以加快计算任务的处理速度。</li><li><strong>容量与成本</strong>：随着技术的进步，RAM的容量不断增大，同时单位价格也在下降。不过，相较于其他类型的存储介质，相同容量下的RAM通常更昂贵。</li></ul><h4 id="拓展：外存"><a href="#拓展：外存" class="headerlink" title="拓展：外存"></a>拓展：外存</h4><p>硬盘属于外存，是可<code>读写</code>的，比如C盘，D盘。</p><h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><p>一次i&#x2F;o请求对应一个请求包</p><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h3><p>I&#x2F;O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的<strong>外部设备</strong>，属于计算机中的<strong>硬件部件</strong>。UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作。要注意的是，网络通信设备也属于io设备。</p><h3 id="I-O控制器"><a href="#I-O控制器" class="headerlink" title="I&#x2F;O控制器"></a>I&#x2F;O控制器</h3><p><code>cpu</code>和<code>i/o电子部件</code>的中间设备</p><img src="..\images\操作系统\IO控制器.png" style="zoom: 40%;" /><p>IO控制器的组成包括：多种寄存器，I&#x2F;O逻辑，控制器与设备的接口。</p><img src="..\images\操作系统\IO设备组成.png" style="zoom: 40%;" /><h3 id="I-O操作大致过程"><a href="#I-O操作大致过程" class="headerlink" title="I&#x2F;O操作大致过程"></a>I&#x2F;O操作大致过程</h3><p><strong>用户程序→系统调用处理程序→中断处理程序→设备驱动程序</strong></p><p>当一个用户程序需要执行I&#x2F;O操作（如读写文件、网络通信等）时，它不能直接访问硬件资源。因此，程序会通过<code>系统调用</code>来<strong>请求操作系统的服务</strong>。系统调用是一种特殊的接口，它允许<code>用户空间的应用程序</code>请求<code>内核</code>提供的服务。当用户程序发出<code>系统调用</code>时，CPU会从用户态切换到<code>内核态</code>，即发生了中断。中断处理程序将 I&#x2F;O 请求传递给相应的<code>设备驱动程序</code>，设备驱动程序运行在<code>内核态</code>，因为需要直接访问硬件资源。</p><h3 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h3><h4 id="程序直接控制"><a href="#程序直接控制" class="headerlink" title="程序直接控制"></a>程序直接控制</h4><img src="..\images\操作系统\程序直接控制.png" style="zoom:50%;" /><p><strong>需要cpu轮询检查i&#x2F;o设备状态</strong>，此时不能做其他事情，i&#x2F;o和cpu处理只能<code>串行</code></p><h4 id="中断驱动"><a href="#中断驱动" class="headerlink" title="中断驱动"></a>中断驱动</h4><p>引入中断机制。由于I&#x2F;O设备速度很慢，因此在CPU发出读&#x2F;写命令后，可将等待I&#x2F;O的进程阻塞，先切换到别的进程执行<code>[进程：我需要IO操作，CPU：我帮你向控制器发命令了，你先下CPU吧，我去忙别的]</code>。当I&#x2F;O完成后，控制器会向CPU发出一个中断信号<code>[控制器：IO操作完毕，CPU大人快来取数据吧]</code>，CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断<code>[CPU：别急，等我保存我的工作记录，再来取数据]</code>。处理中断的过程中，CPU从I&#x2F;O控制器读一个字的数据传送到<code>CPU寄存器</code>，再写入<code>主存</code>。接着，CPU恢复等待I&#x2F;O的进程(或其他进程)的运行环境，然后继续执行<code>[CPU：你需要的IO操作完成了，我要继续完成你这个进程了]</code></p><p><strong>注意</strong></p><ul><li>CPU会在每个指令周期的末尾检查中断</li><li>中断处理过程中需要保存、恢复进程的运行环境这个过程是需要一定<strong>时间开销</strong>的。可见，如<strong>果中断发生的频率太高，也会降低系统性能。</strong></li><li>每次中断只能读入一个字，如果需要读入大量数据，就需要多次中断。</li></ul><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><p>DMA方式(Direct MemoryAccess，直接存储器存取），数据传输的过程不需要经过cpu（不需要通过cpu寄存器写入内存），一次cpu命令能读取一块或者多块连续内存，写入到内存不需要经过cpu，由DMA直接写入。当DMA传输完成后，DMA控制器会通过中断的方式通知CPU数据传输已经完成，以便CPU可以进行后续处理。</p><h4 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h4><p>只能用来<code>处理io的处理机</code>，相当于阉割版的cpu，通道没有自己的内存，通道程序(cpu给的任务清单)存储在内存中，通道需要读取内存中的<code>通道程序</code>并运行；引入通道的目的是让数据的传输独立于CPU，使CPU从繁重的I&#x2F;O工作中解脱出来。</p><h3 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h3><p>也叫spooling技术，用<strong>软件的方式</strong>模拟<code>脱机技术</code>(脱离主机控制进行输入输出操作，把cpu从繁重的io工作中解放出来)。可以把物理设备虚拟为多个逻辑设备，比如，使用spooling技术改造打印机，对于进程使用打印机的请求，<strong>把它放入打印任务队列中，让进程以为获得了打印机设备</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 计科专业核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue</title>
      <link href="/posts/8b27fabc.html"/>
      <url>/posts/8b27fabc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于vue的绝大部分知识点都在<a href="https://www.sanye.blog/posts/f33bd2b9.html">前端面试—vue部分 | 三叶的博客</a>这篇文章中讲了，这里就说说基础语法</p><p>关于vue的绝大部分知识点都在<a href="https://www.sanye.blog/posts/f33bd2b9.html">前端面试—vue部分 | 三叶的博客</a>这篇文章中讲了，这里就说说基础语法</p></blockquote><img src="..\images\vue\vue.png" style="zoom:67%;" /><h1 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h1><h2 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h2><p>利用表达式进行插值，渲染数据到页面中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;nickname.toUppercase()&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;age &gt;= 18 ?&#x27;成年’:&#x27;未成年&#x27;&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：不能写到标签内部，表达式涉及到的数据必须存在。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>带有<code>v-前缀</code>的特殊标签属性，Vue会根据不同的【指令】，针对标签实现不同的【功能】</p><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><p>设置元素的innerHTML</p><h3 id="v-if-v-show"><a href="#v-if-v-show" class="headerlink" title="v-if&#x2F;v-show"></a>v-if&#x2F;v-show</h3><p>用来控制元素显示隐藏。</p><p>v-show&#x3D;”表达式”，表达式值true显示， false隐藏</p><p>v-if&#x3D;”表达式”，表达式值true显示， false隐藏</p><p>二者的区别可以参考：<a href="https://www.sanye.blog/posts/f33bd2b9.html">前端面试—vue部分 | 三叶的博客</a></p><h3 id="v-else-v-else-if"><a href="#v-else-v-else-if" class="headerlink" title="v-else&#x2F;v-else-if"></a>v-else&#x2F;v-else-if</h3><p>配合v-if使用，v-show没有这个待遇，语法和C语言的if-else语法差不多。</p><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>注册事件。免去了<code>手动捕获元素</code>，<code>添加事件监听</code>的工作，只需专心书写<code>回调逻辑</code>，极大地简化了事件监听的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v-<span class="attr">on</span>:事件名 = <span class="string">&quot;内联语句&quot;</span><span class="comment">//js代码</span></span><br><span class="line">v-<span class="attr">on</span>:事件名 = <span class="string">&quot;methods中的函数名&quot;</span></span><br><span class="line">@事件名=<span class="string">&quot;&quot;</span> <span class="comment">//简写</span></span><br></pre></td></tr></table></figure><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p><code>动态</code>的设置标签属性src url title …</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v-<span class="attr">bind</span>:属性名 = <span class="string">&quot;表达式&quot;</span></span><br><span class="line">:属性名=<span class="string">&quot;表达式&quot;</span> <span class="comment">//简写</span></span><br></pre></td></tr></table></figure><p><strong>动态样式控制</strong></p><p>借助v-bind指令可以很方便的实现动态控制样式</p><ul><li><p><code>:class = &quot;数组/对象&quot;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;[类名1,类名2,类名3 ]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>//添加到数组中表示这个类名生效</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;类名1:布尔值,类名2:布尔值&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>//布尔值为true表示添加这个类</span><br></pre></td></tr></table></figure></li><li><p><code>:style =&quot;样式对象&quot;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//属性值可以是表达式</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;CSS属性名1:CSS属性值,CSS属性名2:CSS属性值&#125; &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//原生行内写法,属性值不能是表达式，是写死的，用分号分隔样式</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;dispaly:none;width:100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>基于数据循环，多次渲染整个元素，哪个标签需要多次渲染就加到哪个元素身上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in obj&quot;</span>&gt;</span></span><br><span class="line">      Key: &#123;&#123; key &#125;&#125;, Value: &#123;&#123; value &#125;&#125;, Index: &#123;&#123; index &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span>//只有一个变量就是value，两个第二个就是key，三个第三个就是index</span><br></pre></td></tr></table></figure><p>关于给标签添加<code>key</code>的作用，还有<code>v-if</code>和<code>v-for</code>优先级问题以及能否一起使用的问题，参考<a href="https://www.sanye.blog/posts/f33bd2b9.html">前端面试—vue部分 | 三叶的博客</a></p><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>给表单元素使用，双向数据绑定，可以快速获取或设置表单元素内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>本质上是一个语法糖：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;a&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;(e)=&gt;&#123;a = e.target.value&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>应用于其他表单元素:</p><ul><li><p>checkbox：绑定一个布尔值变量，true表示选中</p></li><li><p>radio</p><p>给同一组radio绑定相同的变量，点击哪个就会把哪个的value赋值给变量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>女</span><br></pre></td></tr></table></figure></li></ul><p><strong>sync</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:message.sync</span>=<span class="string">&quot;parentMessage&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>:[<span class="string">&#x27;message&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">updateMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:message&#x27;</span>, newValue);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>sync</code>修饰符通常与<code>v-bind</code>指令一起使用，好处就是<strong>不需要手动在组件上添加自定义事件，也不需要书写对应的回调逻辑</strong>，</p><p>而是使用提供的<code>默认事件</code>，就能实现子组件和父组件通信，从而实现<strong>双向数据通信</strong>，</p><p>简单的来说，在vue2中，v-bind加上sync修饰符仿佛就实现了<code>组件自己v-model指令</code></p><p>因为在vue2中直接给组件使用v-model，就意味着只能传入value，监听的事件只能是input，而借助sync就能指定多个传入子组件的属性</p><p>和对应的事件。所以说<code>sync</code>和<code>v-bind</code>就是用来解决vue2中，v-model应用在组件上的限制。</p><p>在 Vue 3 中，<code>.sync</code> 修饰符<strong>已经被移除</strong>，推荐的做法是使用<code>自定义事件</code>或 <code>v-model </code>来达到类似的效果。</p><p>vue 3 对 <code>v-model</code> 进行了<strong>增强</strong>，使其更加灵活，允许在一个组件上使用<strong>多个</strong> <code>v-model</code> 绑定，并且可以自定义绑定的<code>prop</code> 和 <code>event</code> 名称。</p><p><strong>默认情况</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*父组件*/</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span> /&gt;</span></span><br><span class="line">  /*等价于: <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:modelValue</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">update:modelValue</span>=<span class="string">&quot;(val)=&gt;&#123;modelValue=val&#125;&quot;</span> /&gt;</span>*/</span><br><span class="line">  /*val是子组件传递过来的值*/</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123; <span class="title class_">ChildComponent</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;Hello from parent&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123; message &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*子组件*/</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  /*回调函数直接书写行内代码，其中$event指向原生事件 对象*/</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot;</span> /&gt;</span></span><br><span class="line">  /*等价于<span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;modelValue&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;(e)=&gt;&#123;$emit(&#x27;update:modelValue&#x27;,e.target.value)&#125;&quot;</span> /&gt;</span>*/</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">modelValue</span>: <span class="title class_">String</span> <span class="comment">// 默认情况下，v-model 在组件内使用的 prop 名称为 modelValue</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>$emit</code>是<code>this.$emit</code>的简写，this指向当前<code>组件实例</code>，在模板中可以省略</p></li><li><p><code> $event</code>是在<strong>模板中</strong>的<code>事件处理器</code>中使用的<strong>特殊变量</strong>，用于引用<code>原生的事件对象</code>。</p></li><li><p><code>&lt;input @input=&quot;logValue($event)&quot;&gt;</code>和<code>&lt;input @input=&quot;logValue&quot;&gt;</code>这两种写法效果都是一样的</p></li><li><p>要注意的是，给<code>组件</code>添加事件监听和给<code>dom元素</code>添加事件监听，都传入一个回调函数，但不同的是，Vue 组件中的事件是<code>自定义事件</code>，不是浏览器<code>原生的 DOM 事件</code>，没有与之相关的 <code>event（事件）</code> 对象。</p><p>所以对于<code>组件的自定义事件</code>的回调函数，传入的第一个参数其实是<code>子组件通过emit传递过来的值</code>，后者传入的则是<code>事件对象event</code>。</p></li></ul><p>Vue 3 支持在一个组件上使用多个 <code>v-model</code> 绑定。这可以通过指定<strong>自定义</strong>的 prop 和 event 名称来实现</p><p>在vue2中的<code>:message.sync</code>等价于vue3中的<code>v-model:message</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*父组件*/</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">v-model:title</span>=<span class="string">&quot;pageTitle&quot;</span> <span class="attr">v-model:description</span>=<span class="string">&quot;pageDescription&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123; <span class="title class_">ChildComponent</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> pageTitle = <span class="title function_">ref</span>(<span class="string">&#x27;Default Title&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> pageDescription = <span class="title function_">ref</span>(<span class="string">&#x27;Default Description&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123; pageTitle, pageDescription &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*子组件*/</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    /*因为我们要做的不是直接修改title的值，所以不能使用v-model*/</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;title&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">:value</span>=<span class="string">&quot;description&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;$emit(&#x27;update:description&#x27;, $event.target.value)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">title</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">description</span>: <span class="title class_">String</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="指令修饰符"><a href="#指令修饰符" class="headerlink" title="指令修饰符"></a>指令修饰符</h3><p>参考<a href="https://www.sanye.blog/posts/f33bd2b9.html">前端面试—vue部分 | 三叶的博客</a></p><h2 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a>计算属性computed</h2><ul><li><p>基于现有的数据，计算出来的新属性。依赖的数据变化，自动重新计算。</p></li><li><p>使用起来和普通数据一样： <code>&#123;&#123;计算属性名&#125;&#125;</code></p></li></ul><p>简写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">计算属性名()&#123;</span><br><span class="line"><span class="comment">//基于现有数据,编写求值逻辑</span></span><br><span class="line">        <span class="keyword">return</span> 结果</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">计算属性名:&#123;</span><br><span class="line"><span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//一段代码逻辑（计算逻辑）</span></span><br><span class="line">            <span class="keyword">return</span> 结果</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">set</span>(<span class="params">修改的值</span>)&#123;</span><br><span class="line"><span class="comment">//一段代码逻辑（修改逻辑）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>计算属性一般只用来展示，赋值。如果尝试直接修改计算属性，并不会生效，因为计算属性的值只与其相关的数据有关，但是会把<code>传入的值</code>传递到set函数，set函数拿到这个值可以做一些操作。</p></li><li><p>依赖的数据必须是<strong>响应式的</strong>（即 <code>data</code> 或其他计算属性），不然依赖的数据改变了计算属性也无法发觉，就不会即时更新。</p></li><li><p>当计算属性依赖的任何数据发生变化时，Vue 会标记计算属性为<code>脏</code>，并在下次访问时重新计算其值。计算属性采用<strong>惰性求值</strong>策略（被访问的时候再求值），并具有<strong>缓存机制</strong>（如果依赖的数据未改变，直接使用缓存，而不需要重新计算），只有当依赖的数据发生变化，即被标记为<code>脏</code>，并被访问的时候，才会重新计算其值。</p></li><li><p>同时计算属性也是<strong>响应式的</strong>，当计算属性的值改变，也会通知计算属性的依赖更新。</p></li><li><p>因为计算属性和data的用法是一样的，都属于响应式数据，它们<strong>收集依赖</strong>的方式也是一样的，都是被访问的时候，通过getter方法收集。</p></li><li><p>计算属性在<strong>首次计算</strong>其值时，通过访问响应式数据，触发响应式数据的 <code>getter</code> 方法，成功收集计算属性为它们的依赖。</p></li></ul><h2 id="监听器watch"><a href="#监听器watch" class="headerlink" title="监听器watch"></a>监听器watch</h2><p>用来监视<code>data</code>和<code>计算属性</code>中数据的变化。</p><p>简写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line"><span class="comment">//检测words数据变化</span></span><br><span class="line"><span class="title function_">words</span>(<span class="params">newValue,oldvalue</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;变化了&#x27;</span>,newValue,oldvalue)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测obj中的words数据变化</span></span><br><span class="line"><span class="string">&quot;obj.words&quot;</span>(newValue,oldvalue)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;变化了&#x27;</span>,newValue,oldvalue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//和计算属性配置一样，都是直接放函数</span></span><br></pre></td></tr></table></figure><p>完整写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">数据属性名:&#123;</span><br><span class="line">        <span class="attr">immediate</span>: <span class="literal">true</span><span class="comment">//初始化立刻执行一次handler方法</span></span><br><span class="line">        <span class="attr">deep</span>: <span class="literal">true</span>,<span class="comment">//深度监视</span></span><br><span class="line">        <span class="title function_">handler</span>(<span class="params">newValue，oldValue</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>deep: true</code>，开启对复杂类型深度监视后，可以监听一整个对象，可以监听这个对象中的全部属性，否则监听的只是对象的地址变化。</p><p>通过vue实例的<code>$watch</code>方法也能添加监听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue.$watch(<span class="string">&#x27;监听的数据&#x27;</span>,&#123;<span class="comment">//配置对象&#125;)//完整写法</span></span><br><span class="line">vue.$watch(<span class="string">&#x27;监听的数据&#x27;</span>,<span class="keyword">function</span>(<span class="params">newValue,oldValue</span>)&#123;&#125;) <span class="comment">//简写   </span></span><br></pre></td></tr></table></figure><p>watch监听的数据必须是响应式的，然而在vue2中数据默认都是响应式的。</p><p>watch可以理解为用来自定义扩充某个响应式数据的setter方法体。</p><h2 id="watch和computed的区别与联系"><a href="#watch和computed的区别与联系" class="headerlink" title="watch和computed的区别与联系"></a>watch和computed的区别与联系</h2><ul><li><p>watch，computed和视图，这三者都依赖响应式数据，是响应式数据的三大订阅者，而响应式数据又包括data中的数据和计算属性。</p></li><li><p>在watch里可以写异步操作，但是在computed内部不适合写异步操作，比如无法异步返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        <span class="title function_">sum</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">price</span>*<span class="variable language_">this</span>.<span class="property">num</span>&#125;,<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>computed能做的，用watch也能实现，就是更为麻烦；但是watch能做的，computed不一定能实现，比如延迟几秒更新数据。</p></li></ul><h2 id="method和computed的区别与联系"><a href="#method和computed的区别与联系" class="headerlink" title="method和computed的区别与联系"></a>method和computed的区别与联系</h2><p>我们讨论的是<code>有返回值的方法</code>和<code>computed</code>的区别于联系</p><ul><li>当某个数据属性的值发生变化时，Vue 会自动检测到这个变化，并重新计算依赖于这个数据属性的任何方法，对于计算属性则是标记为’脏’</li><li>计算属性本质就是一个有返回值的方法</li><li>计算属性存在<strong>缓存机制</strong>，无论被使用多少次，只要依赖的数据未改变，计算属性函数只会被调用一次；而方法被使用多少次就会被调用多少次</li><li>method在模板内使用需要显式的调用，而computed直接当成data的使用。</li></ul><h2 id="vue性能优化"><a href="#vue性能优化" class="headerlink" title="vue性能优化"></a>vue性能优化</h2><h3 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h3><ul><li>事件委托：使用事件委托能减少内存占用，减少不必要的重复代码。关于事件委托的介绍，可以参考<a href="https://www.sanye.blog/posts/aef189c3.html">前端面试—js部分 | 三叶的博客</a></li><li>保证key值唯一：有利于diff算法</li><li>组件缓存keep-alive：会缓存不活动的<strong>组件实例</strong>，而不是销毁它们，<strong>防止重复渲染DOM</strong>。</li></ul><h3 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h3><ul><li>路由懒加载（按需加载组件）</li><li>图片懒加载</li></ul><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>model-view-viewmodel</p><h3 id="model"><a href="#model" class="headerlink" title="model"></a>model</h3><p>层负责管理应用程序的业务逻辑和数据，不包含任何的ui逻辑，类似小程序中的逻辑层</p><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>View 负责显示数据给用户；是应用程序直接与用户直接交互的部分，类似小程序中的视图层</p><h3 id="viewmodel"><a href="#viewmodel" class="headerlink" title="viewmodel"></a>viewmodel</h3><p>ViewModel 作为 Model 和 View 之间的桥梁，负责将数据转换成view可以使用的格式。在vue中，这个桥梁（vm）就是vue实例。</p><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="setup（）"><a href="#setup（）" class="headerlink" title="setup（）"></a>setup（）</h2><ul><li><p>vue3中的一个新的<strong>配置项</strong>，值为一个函数，组合式api都写在这里面。</p></li><li><p>执行时机在<code>beforeCreate()</code>之前，也就是在组件创建之前执行代码；而before Create的执行时机又再data函数被调用前。</p></li><li><p>setup中不能使用this，<strong>this的值是undefined</strong>；</p></li><li><p>setup不能是async函数</p></li></ul><h3 id="在组合式api中的写法"><a href="#在组合式api中的写法" class="headerlink" title="在组合式api中的写法"></a>在组合式api中的写法</h3><p>在<code>组合式api</code>中，<code>setup()</code>以下面的方式书写，格式类似生命周期函数。</p><p>setup中准备的<code>数据</code>和<code>函数</code> 需要在setup最后<code>return</code>后，才能在模板中应用 。</p><p>配置了setup，还能配置<code>data</code>和<code>methods</code>，同时在methods里面也能读取到setup中的配置，当data中和setup中存在数据冲突，setup中的数据优先级更高，<strong>但是还是建议vue2的配置和vue3的配置不要混用</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> message = <span class="string">&#x27;hello Vue3&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title function_">logMessage</span> = (<span class="params"></span>) =&gt;&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(message)&#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">return</span> &#123;message,logMessage&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">test</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">message</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">logMessage</span>)<span class="comment">//都可以访问到</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeCreate函数&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实还能返回一个<strong>渲染函数</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;h&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span><span class="comment">//在vue2中我们也接触过的渲染函数。</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> message = <span class="string">&#x27;hello Vue3&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title function_">logMessage</span> = (<span class="params"></span>) =&gt;&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(message)&#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;你好啊&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeCreate函数&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后这个<code>组件</code>就会使用这个函数来渲染，而<strong>忽略模板结构</strong>。</p><h3 id="语法糖写法"><a href="#语法糖写法" class="headerlink" title="语法糖写法"></a>语法糖写法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//独占一个script标签，不需要return</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> message = <span class="string">&#x27;this is a message&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title function_">logMessage</span> = (<span class="params"></span>)=&gt;&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(message)&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="setup的参数"><a href="#setup的参数" class="headerlink" title="setup的参数"></a>setup的参数</h3><p>setup的参数在混合选项式api的时候，也就当不使用<code>setup语法糖</code>开发的时候是有意义的，使用语法糖开发的时候参数都没了。</p><p><code>setup(props,context)</code></p><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>是第一个参数，值为对象，包含组件外部传入组件的，且在组件<strong>内部接收的值</strong>，也就是在<code>props属性</code>中接受的值。</p><p><strong>这个参数的作用就在于，让通过选项式语法中的props属性接收的值，能够在setup函数内部使用。</strong></p><p>这些属性是响应式的，因此当父组件更新 <code>props</code> 时，子组件中的 <code>props</code> 也会自动更新。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template)</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一个人的信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名:&#123;&#123;person.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄:&#123;&#123;person.age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">import &#123; reactive &#125; from &#x27;vue</span><br><span class="line">export default &#123;</span><br><span class="line">name: &#x27;Demo&#x27;</span><br><span class="line">props:[&#x27;msg&#x27;,&#x27;school&#x27;],</span><br><span class="line">setup(props)&#123;</span><br><span class="line">console.log(&#x27;---setup---&#x27;,props)//输出Proxy&#123;msg:&#x27;你好啊&#x27;,school:&#x27;南昌大学&#x27;&#125;</span><br><span class="line">//数据</span><br><span class="line">let person = reactive(&#123;</span><br><span class="line">name:&#x27;张三&#x27;</span><br><span class="line">age:18</span><br><span class="line">&#125;)</span><br><span class="line">//返回一个对象(常用)</span><br><span class="line">return &#123;person&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="context"><a href="#context" class="headerlink" title="context"></a>context</h4><p>第二个参数，上下文对象，包含多个属性</p><ul><li><p>attrs：值为对象，包含组件外部传入组件的，但在组件内部未被接收的值，因为这些值会被当成<strong>组件的属性</strong>，所以存储<code>context.attrs</code>中，类似vue2中的<code>this.$attrs</code>（用来获取组件实例的属性）</p></li><li><p>emit：值为函数，相当于<code>this.$emit</code>，用来触发<code>自定义事件</code></p><p>要注意的是，在vue3中，给组件添加的事件监听，默认都是<code>原生事件</code>，如果需要指定为<code>自定义事件</code>，需要在子组件中通过<code>emits</code>属性声明，或者使用组合式api中的<code>defineEmits(返回emit函数)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="title function_">emit</span>(<span class="string">&#x27;hello&#x27;</span>,<span class="number">666</span>)</span><br></pre></td></tr></table></figure></li><li><p>slots：收到的插槽内容，类似vue2中的<code>this.$slots</code>，可以访问到<code>父组件</code>通过<code>插槽</code>传递的所有内容。<code>this.$slots</code> 是一个对象，其键名对应于<code>插槽的名字</code>（对于默认插槽，键名为 <code>default</code>），值则是包含一组<code> VNode</code> 的数组。</p></li></ul><p>简单的来说，<strong>context参数弥补了在setup函数内部因为不能使用this而确实的部分功能</strong>，比如<code>this.$emit</code>可以被替换为<code>context.emit</code>，<code>this.$slot</code>可以被替换为<code>context.slots</code>。</p><h2 id="reactive和ref"><a href="#reactive和ref" class="headerlink" title="reactive和ref"></a>reactive和ref</h2><p>vue3中数据默认不是响应式的，需要手动添加响应式。</p><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><ul><li>接受<code>对象类型</code>数据的参数传入并返回一个<code>响应式</code>的对象，就是Proxy类型的对象。</li><li>传入一个源对象，经过proxy操作返回一个代理对象，修改代理对象会映射到源对象。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//执行函数传入参数变量接收</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(对象类型数据)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>源码分析：</strong></p><p>修改代理对象会映射到源对象这一点，在传入的第一个参数：配置对象上就能看出，操作对象一直是target。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果目标已经是响应式的，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isReactive</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//关于proxy的介绍，可参考本博客中前端面试-vue一文</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="comment">//收集依赖</span></span><br><span class="line">      <span class="title function_">track</span>(target, key);</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">      <span class="comment">//这说明proxy类型的响应式数据是在系统被取出的时候才递归的添加响应式的，这种方式叫做懒递归或者按需递归添加响应式</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">isObject</span>(result) ? <span class="title function_">reactive</span>(result) : result;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = target[key];</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">      <span class="keyword">if</span> (oldValue !== value) &#123;</span><br><span class="line">        <span class="comment">//通知依赖更新</span></span><br><span class="line">        <span class="title function_">trigger</span>(target, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> hadKey = <span class="title function_">hasOwn</span>(target, key);</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key);</span><br><span class="line">      <span class="keyword">if</span> (hadKey) &#123;</span><br><span class="line">        <span class="comment">//通知依赖更新</span></span><br><span class="line">        <span class="title function_">trigger</span>(target, key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul><li><p>接受<code>简单类型</code>或者<code>复杂类型数据</code>，返回一个<code>响应式对象</code>，就是<code>RefImpl</code>类型的对象，如果传入的值是对象，那<code>ref.value</code>的类型就是proxy。</p></li><li><p>ref在内部其实会使用<code>reactive</code>(如果传入的是一个对象)，总的来说基于<code>proxy</code>实现。</p></li><li><p>实例结构分析：</p><ul><li><p><code>value</code>：不可枚举属性，访问实际是在调用<code>get函数</code>，返回<code>_value</code>中的数据。</p></li><li><p><code>_value</code>：访问value返回的实际数据</p></li><li><p><code>_rawValue</code>：源数据，传入ref的<code>原始数据</code>，<code>raw</code>的中文意思就是”未经加工的，原始的”；当原始数据是简单类型，<code>_rawValue</code>等于<code>_value</code>，当传入的是对象，<code>_rawValue</code>的值始终是对象，<code>_value</code>的值则是<code>proxy</code>对象，修改<code>_value</code>会映射到<code>_rawValue</code>上。</p></li></ul></li></ul><img src="..\images\vue\ref.png" style="zoom:90%;" /><img src="..\images\vue\ref2.png" style="zoom:90%;" /><p>至于value属性对应的getter，setter，存在于<code>[[prototype]]</code>对象中。</p><p>大致源码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">val</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value, __v_isShallow</span>) &#123;</span><br><span class="line">    <span class="comment">//表示是否为浅层响应式，默认为false，如果为 true，则不会递归地将嵌套的对象或数组转换为响应式对象。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">__v_isShallow</span> = __v_isShallow;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">__v_isRef</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//存储原始值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_rawValue</span> = __v_isShallow ? value : <span class="title function_">toRaw</span>(value);<span class="comment">//默认取第二个值</span></span><br><span class="line">    <span class="comment">//在这行代码可以看出ref和reactive密不可分的关系</span></span><br><span class="line">    <span class="comment">//toReactive方法内部很可能会判断value是不是对象，如果是就会调用reactive包装。由此也可以看出ref和reactive之间的联系</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_value</span> = __v_isShallow ? value : <span class="title function_">toReactive</span>(value);<span class="comment">//默认取第二个值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="title function_">trackRefValue</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="comment">//返回的是_value，也就是说其实value取的值就是_value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> useDirectValue = <span class="variable language_">this</span>.<span class="property">__v_isShallow</span> || <span class="title function_">isShallow</span>(newVal) || <span class="title function_">isReadonly</span>(newVal);</span><br><span class="line">    newVal = useDirectValue ? newVal : <span class="title function_">toRaw</span>(newVal);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasChanged</span>(newVal, <span class="variable language_">this</span>.<span class="property">_rawValue</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldVal = <span class="variable language_">this</span>.<span class="property">_rawValue</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = useDirectValue ? newVal : <span class="title function_">toReactive</span>(newVal);<span class="comment">//重新创建一个响应式对象</span></span><br><span class="line">      <span class="title function_">triggerRefValue</span>(<span class="variable language_">this</span>, <span class="number">4</span>, newVal, oldVal);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以观察到，构造函数中并没有初始化<code>value</code>，但是<code>refImpl</code>实例中出现了，我自己测试了一下，发现并没有借助defineProperty：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义一个refImpl类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">refImpl</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_value</span> = val</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">refImpl</span>(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>最后打印p的结构如图：</p><img src="..\images\vue\ref4.png" style="zoom:90%;" /><p>观察到，value属性出现了。</p><p><strong>注意</strong>：</p><ul><li><p>当我们直接给<code>.value</code>赋予一个新的对象，vue会帮我们 <code>重新</code>创建一个响应式对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">_rawValue</span> = newVal;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_value</span> = useDirectValue ? newVal : <span class="title function_">toReactive</span>(newVal);<span class="comment">//重新创建一个响应式对象</span></span><br></pre></td></tr></table></figure></li><li><p>脚本中访问ref数据，需要通过<code>.value</code>，而在<code>template</code>中， <code>.value</code>不需要加（帮我们扒了一层)，就好比在vue2的模板内，可以省略this，比如<code>this.$store</code>在模板内直接写为<code>$store</code>，其实data中的数据能直接在模板中使用也是省略了this。</p></li></ul><h2 id="toRef-和toRefs"><a href="#toRef-和toRefs" class="headerlink" title="toRef()和toRefs()"></a>toRef()和toRefs()</h2><h3 id="响应式丢失"><a href="#响应式丢失" class="headerlink" title="响应式丢失"></a>响应式丢失</h3><p>下面举个例子来说明：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;txt.num++&quot;</span>&gt;</span>num++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;console.log(++age)&quot;</span>&gt;</span>age++<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; obj &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; txt &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; age &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; reactive, toRef, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> obj = <span class="title function_">ref</span>(&#123; <span class="attr">txt</span>: &#123; <span class="attr">num</span>: <span class="number">1</span> &#125;, <span class="attr">age</span>: <span class="number">12</span> &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> txt = obj.<span class="property">value</span>.<span class="property">txt</span><span class="comment">//触发getter</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(txt)<span class="comment">//输出Proxy(Object) &#123;num: 1&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> age = obj.<span class="property">value</span>.<span class="property">age</span></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(age)<span class="comment">//输出12</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们点击<code>num++</code>，发现视图中的<code>obj</code>和<code>txt</code>都被更新了，输出<code>txt</code>发现是个<code>Proxy</code>类型的对象，说明<code>响应式</code>并没有丢失。</p><p>我们点击<code>age++</code>，发现视图中的<code>age</code>并没有随之改变，输出<code>age</code>，发现是简单数据类型，说明响应式丢失了。</p><p>因此我们可以得出，vue3是<code>递归</code>给对象添加响应式的（其实是需要的时候再递归添加），解构对象并<strong>不是所有属性</strong>的响应式都会丢失。</p><p>虽然我们对<code>ref</code>和<code>reactive</code>已经比较了解了，为了保险起见，我们将<code>ref</code>替换为<code>reactive</code>再测试一下，果然，现象完全一样。</p><p>其实在<code>vue2</code>中，也存在着响应式丢失的现象，我们知道vue2是响应式实现是基于<code>Object.defineProperty</code>方法的，当vue2给一个对象添加响应式，如果这个对象中还包含对象，则<strong>也会递归添加响应式</strong>。下面是一个例子来说明这一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">obj</span>:&#123;<span class="attr">a</span>:<span class="string">&#x27;tom&#x27;</span>, <span class="attr">child</span>: &#123;<span class="attr">b</span>:<span class="string">&#x27;cindy&#x27;</span>&#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">obj</span>.<span class="property">a</span>,<span class="variable language_">this</span>.<span class="property">obj</span>.<span class="property">child</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会输出<code>&#39;tom&#39;</code>和一个<strong>响应式对象child</strong>:</p><img src="..\images\vue\丢失响应.png" style="zoom:90%;" /><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef()"></a>toRef()</h3><p><code>toRef()</code> 函数可以将一个响应式对象(ref或者reactive包装的对象)的某个属性转换成一个<code>ObjectRefImpl</code>（注意是<strong>返回一个新的ObjectRefImpl对象，并不会修改任何对象</strong>），从而解决对象解构响应式丢失的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRef, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">ref</span>(&#123;</span><br><span class="line">  <span class="attr">price</span>: <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countRef = <span class="title function_">toRef</span>(a, <span class="string">&#x27;count&#x27;</span>);</span><br><span class="line"><span class="comment">//const priceRef = toRef(b.value, &#x27;price&#x27;);这里一定要加value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改countRef 同时会更新a.count</span></span><br><span class="line">countRef.<span class="property">value</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">count</span>); <span class="comment">// 输出: 1</span></span><br><span class="line"><span class="comment">// 修改 a.count 同时会更新countRef</span></span><br><span class="line">a.<span class="property">count</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(countRef.<span class="property">value</span>); <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure><p><code>a.count</code>和<code>countRef</code>的共用一份源数据。输出<code>countRef</code>：</p><img src="..\images\vue\toRef.png" style="zoom: 80%;" /><p>其中<code>_object</code>参数<code>toRef</code>传入的第一个参数，<code>_key</code>就是<code>toRef</code>传入的第二个参数，当我们访问value的时候，返回的就是<code>_object[_key]</code>，当我们修改value的时候，其实就是在修改<code>_object[_key]</code>，而<code>_object</code>本身就是一个代理对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="variable language_">this</span>.<span class="property">_object</span>[<span class="variable language_">this</span>.<span class="property">_key</span>];</span><br><span class="line">    <span class="keyword">return</span> val === <span class="keyword">void</span> <span class="number">0</span> ? <span class="variable language_">this</span>.<span class="property">_defaultValue</span> : val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_object</span>[<span class="variable language_">this</span>.<span class="property">_key</span>] = newVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs()"></a>toRefs()</h3><p><code>toRefs()</code> 函数可以将整个响应式对象的所有属性都转换为<code>refs</code> 的集合。这对于解构响应式对象特别有用，因为直接解构会导致某些属性<strong>丢失响应性</strong>。直接解构就等同于<strong>取值</strong>然后<strong>赋值给新的变量</strong>，我们取值取的数据<code>来源</code>就是<code>源对象</code>，而源对象中的部分属性值<code>不具有响应式</code>的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">  <span class="attr">version</span>: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//返回一个新的对象，不修改源对象</span></span><br><span class="line"><span class="keyword">const</span> stateAsRefs = <span class="title function_">toRefs</span>(state);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stateAsRefs)</span><br><span class="line"><span class="comment">// 解构赋值，同时保持响应性</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, version &#125; = stateAsRefs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 name 或 version 同时会更新 state 中对应的属性</span></span><br><span class="line">name.<span class="property">value</span> = <span class="string">&#x27;Vue.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">name</span>); <span class="comment">// 输出: Vue.js</span></span><br><span class="line"></span><br><span class="line">version.<span class="property">value</span> = <span class="number">3.0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">version</span>); <span class="comment">// 输出: 3.0</span></span><br></pre></td></tr></table></figure><p>可以看出<code>stateAsRefs</code>对象就是一个普通的对象，不过它的每个属性的值都变成了<code>ObjectRefImpl</code>类型的数据。</p><img src="..\images\vue\toRefs.png" style="zoom:80%;" /><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span>计算返回的结果</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>vue3中的computed属性默认是响应式的</li><li>避免直接修改计算属性的值，计算属性应该是只读的，特殊情况可以配置get，set</li><li>计算属性中不应该有<code>副作用</code>，不建议在计算属性中写dom操作和异步请求</li></ul><p><strong>与vue2计算属性区别：</strong></p><ul><li>vue2使用computed不需要导入，是一个配置属性；vue3中的computed是一个函数，需要按需导入。</li><li>vue2中<code>批量添加</code>计算属性更方便，在vue3中每次获得一个计算属性都要传入一个回调函数，调用一次<code>computed</code>函数</li></ul><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>vue3中的事件监听有蛮多问题的，不太好学。</p><p>watch能正常监听通过<code>ref(基本类型数据)</code>得到的对象的改变，比如<code>ref(0)</code>；但是监听不到<code>ref(引用类型数据)</code>得到的对象的改变，比如<code>ref(&#123; age: 0 &#125;)</code>，虽然这个问题可以通过开启<strong>深度监听</strong>解决（在第三个参数传入<code>&#123; deep: true &#125;</code>），但是存在新旧数据相同的问题。</p><p>watch监听reactive类型的数据默认是<code>深度监听</code>，也存在新旧数据相同的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  &#123; watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//语法--监听一个ref对象</span></span><br><span class="line"><span class="title function_">watch</span>(ref对象,（newValue, oldValue) =&gt;&#123; ... &#125;)<span class="comment">//第一个数据是要监听的数据</span></span><br><span class="line"><span class="comment">//语法--监听多个ref对象</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">    <span class="comment">//通过数组叠加多个监听对象</span></span><br><span class="line">[count,name],</span><br><span class="line">    <span class="comment">//newVal和oldVal是数组</span></span><br><span class="line"><span class="function">(<span class="params">newVal,oldVal</span>)=&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;count或者name变化了&#x27;</span>,newVal,oldVal)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">//精确监听reactive对象的某个属性                                    </span></span><br><span class="line"><span class="comment">//传入一个回调函数，非常不人性                                    </span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span>userInfo.<span class="property">value</span>.<span class="property">age</span>, <span class="function">(<span class="params">newValue，oldValue</span>)=&gt;</span>&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue,oldValue) &#125; )</span><br></pre></td></tr></table></figure><p><strong>与vue2中watch的区别</strong></p><ul><li>vue2中watch是属性，vue3中是需要导入的函数</li><li>在vue2的watch中的函数名就是监听的对象，执行的操作是函数体</li><li>vue2中添加多个监听对象只需要都写在watch:{}中就行，vue3中可以放在数组中整体监听</li></ul><h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><p>在vue3中，既支持<code>选项式</code>生命周期函数，也支持<code>组合式</code>生命周期函数。</p><h3 id="选项式"><a href="#选项式" class="headerlink" title="选项式"></a><strong>选项式</strong></h3><ol><li><code>beforeCreate</code>：实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用。</li><li><code>created</code>：实例创建完成后被调用。此时已完成数据观测 (data observer)，属性和方法的运算，watch&#x2F;event 事件回调。但是尚未挂载，<code>$el</code> 属性目前不可见。</li><li><code>beforeMount</code>：在挂载开始之前被调用，相关的 <code>render</code> 函数首次被调用。</li><li><code>mounted</code>：实例挂载到 DOM 后调用，这时 <code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上。注意，不能保证它在整个组件树完全渲染完成时才调用。</li><li><code>beforeUpdate</code>：在数据更新导致虚拟 DOM 重新渲染和打补丁之前调用。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li><li><code>updated</code>：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</li><li><code>beforeUnmount</code>（在 Vue 2 中称为 <code>beforeDestroy</code>）：在卸载组件实例之前调用。在这个阶段，实例仍然是完全正常的。</li><li><code>unmounted</code>（在 Vue 2 中称为 <code>destroyed</code>）：卸载组件后调用。调用此钩子时，组件实例的所有指令都被解绑，所有事件监听器都被移除，所有子组件实例也都会被销毁。</li></ol><p>简单的来说，vue3的选项式生命周期函数与vue2的生命周期函数的区别仅仅在于最后两个。</p><h3 id="组合式"><a href="#组合式" class="headerlink" title="组合式"></a><strong>组合式</strong></h3><p>在 Vue 3 的组合式 API 中，你可以使用 <code>onXXX</code> 形式的函数来注册生命周期钩子。这些函数可以直接在 <code>setup()</code> 函数或 <code>&lt;script setup&gt;</code> 中使用。</p><ul><li><code>onBeforeMount</code></li><li><code>onMounted</code></li><li><code>onBeforeUpdate</code></li><li><code>onUpdated</code></li><li><code>onBeforeUnmount</code></li><li><code>onUnmounted</code></li></ul><p> Vue 3 中，<code>setup</code> <strong>函数</strong>涵盖了 <code>beforeCreate</code> 和 <code>created</code> <strong>钩子</strong>的功能，因此不再需要这两个钩子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUpdated, onUnmounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 这里相当于 beforeCreate 和 created 的合并作用域</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Setup function: Initialization logic here.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component is mounted!&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onUpdated</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component has been updated!&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component has been unmounted.&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="props与emit"><a href="#props与emit" class="headerlink" title="props与emit"></a>props与emit</h3><h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h4><p>父组件给子组件，添加属性的方式传值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sonComVue</span> <span class="attr">:message</span>=<span class="string">&quot;message&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在子组件，通过props接收，借助于<code>编译器宏</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用编译器宏不需要导入</span></span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span><br><span class="line"><span class="attr">message</span>: <span class="title class_">String</span>,</span><br><span class="line">&#125;)<span class="comment">//defineProps返回一个对象，对象内部的数据可以直接在模板内使用，在script标签中则需要通过props（返回的对象）访问</span></span><br></pre></td></tr></table></figure><h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h4><p>父组件中给子组件标签通过<code>@</code>绑定事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--绑定自定义事件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sonComVue</span> <span class="attr">:message</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">get-message</span>=<span class="string">&quot;getMessage&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子组件内部通过<code>emit</code>方法触发事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">message</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;get-message&#x27;</span>])<span class="comment">//指定哪些事件是自定事件，并返回emit方法</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title function_">sendMsg</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">emit</span>(<span class="string">&#x27;get-message&#x27;</span>, <span class="string">&#x27;this is son msg&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实用<code>v-model</code>也能实现。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sonComVue</span> <span class="attr">v-model:message</span>=<span class="string">&quot;message&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">message</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;update:message&#x27;</span>])<span class="comment">//指定哪些事件是自定事件，并返回emit方法</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title function_">sendMsg</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">emit</span>(<span class="string">&#x27;update:message&#x27;</span>, <span class="string">&#x27;this is son msg&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="与vue2的区别"><a href="#与vue2的区别" class="headerlink" title="与vue2的区别"></a>与vue2的区别</h4><ul><li>无法直接通过this调用<code>$emit</code>函数，需要通过编译器宏获得emit函数。</li><li>在vue2中可以通过<code>&lt;component @click.native&gt;&lt;/component&gt;</code>，表示添加的点击事件是原生事件，而不是自定义事件；在vue3中这种写法被移除了，给组件添加的事件默认是原生的。</li></ul><h3 id="provide与reject"><a href="#provide与reject" class="headerlink" title="provide与reject"></a>provide与reject</h3><p>顶层通过<code>provide</code>提供数据，底层通过<code>inject</code>接收数据</p><h4 id="provide"><a href="#provide" class="headerlink" title="provide"></a>provide</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; provide, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="title function_">ref</span>(<span class="string">&#x27;John Doe&#x27;</span>);</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;user&#x27;</span>, user); <span class="comment">// 提供一个响应式的 user,并把它命名为user</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 返回其他需要暴露给模板的内容</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="inject"><a href="#inject" class="headerlink" title="inject"></a>inject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//返回值就是祖先组件提供的值，如果没有找到 &#x27;user&#x27;，则使用默认值</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="title function_">inject</span>(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;Default User&#x27;</span>); <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h4><p>当使用 <code>provide</code> 提供的数据是响应式的（例如通过 <code>ref</code> 或 <code>reactive</code> 创建），那么在数据更新时，所有通过 <code>inject</code> 接收到该数据的组件都会<code>自动更新</code>。这是因为 <code>provide</code>&#x2F;<code>inject</code> 维护的是对原始数据的引用，我们认为这些组件依赖这些注入的数据。</p><h4 id="与vue2的区别-1"><a href="#与vue2的区别-1" class="headerlink" title="与vue2的区别"></a>与vue2的区别</h4><ul><li>vue2中可以通过<code>inject:[]</code>来批量接收数据，vue3中只能一个一个接收。</li><li>vue2中可以在<code>provide()&#123; return&#123;//传递的数据，格式，键：值&#125;&#125;</code>中批量传递数据，vue3中只能一个一个的传递数据</li></ul><h2 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>调用ref函数生成一个ref对象:<code>const inp = ref(null)</code></li><li>通过ref标识，进行绑定<code>&lt;input ref=&quot;inp&quot; type=&quot;text&quot;&gt;</code></li><li>通过<code>ref对象.value</code>即可访问到绑定的元素</li></ul><h3 id="与vue2中ref-ref的区别与联系"><a href="#与vue2中ref-ref的区别与联系" class="headerlink" title="与vue2中ref&#x2F;$ref的区别与联系"></a>与vue2中ref&#x2F;$ref的区别与联系</h3><ul><li>vue2中通过给<code>子元素</code>添加<code>ref属性</code>并任意赋值命名，然后通过<code>this.$ref.属性名</code>就能获取到绑定的dom或者组件实例</li><li>总的来说，都是给dom元素或者组件添加<strong>ref属性</strong>，然后赋一个值；在vue2中这个值是一个独一无二的名字，在vue3中这个值就是一个<code>RefImpl</code>类型的数据；然后都要拿到dom元素或者组件实例，在vue2中是通过<code>this.$ref.属性名</code>拿到，在vue3中是通过<code>RefImpl.value</code>拿到</li><li>作用范围都是当前组件内</li></ul><h2 id="defineExpose"><a href="#defineExpose" class="headerlink" title="defineExpose()"></a>defineExpose()</h2><p>默认情况下在<code>&lt;script setup&gt;</code>语法糖下，<strong>组件内部的属性和方法是不开放给父组件访问的</strong>，即便能够拿到组件实例也访问不了。</p><p>可以通过<code>defineExpose</code>编译宏指定哪些属性和方法允许访问</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> count = <span class="number">999</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title function_">sayHi</span> = (<span class="params"> </span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打招呼&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineExpose</span>(&#123;count,sayHi&#125;)<span class="comment">//暴露给父组件</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而在vue2中，只要获取到了组件对象，就能访问里面的属性（data）和方法(methods)。</p><h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue-Router"></a>Vue-Router</h1><p>在vue2，vue3项目，使用的路由插件都是<code>vue-router</code>，就是语法有所不同。</p><p>修改地址栏路径时，切换显示匹配的组件</p><h2 id="单页面应用"><a href="#单页面应用" class="headerlink" title="单页面应用"></a>单页面应用</h2><p>所有功能在一个html页面上实现，基于前端路由实现</p><p>优点：按需更新性能高，开发效率高，用户体验好</p><p>缺点：学习成本，首屏加载慢（如果不使用代码分割，加载首屏还会将其他页面的资源一同加载并处理，然后才开始首屏渲染），还不利于SEO。</p><h2 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h2><h3 id="声明式导航router-link"><a href="#声明式导航router-link" class="headerlink" title="声明式导航router-link"></a>声明式导航router-link</h3><p>使用vue-router提供的<strong>全局组件</strong><code>router-link</code>，替代a标签实现跳转，必须配置to属性指定路径（不需要加＃）。本质还是a标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/路径值&quot;</span>&lt;/<span class="attr">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>能高亮，默认就会提供<strong>高亮类名</strong>，可以直接设置高亮样式，不需要手动添加类名，高亮类名包括：</p><ul><li><p>router-link-active（模糊匹配，常用）</p><p><code>to=&quot;/my&quot;</code>可以匹配<code>/my/b</code>，意思是当前页面的前端路由是<code>/my/b</code>，这个高亮类名就会生效。</p></li><li><p>router-link-exact-active（精确匹配）：就必须完全一样，这个高亮类名才会生效。</p></li></ul><h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>()</span><br></pre></td></tr></table></figure><ul><li><p><strong>使用path跳转</strong></p><ul><li><p>push字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;路由路径&#x27;</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/路径?参数名1=参数值1&amp;参数2=参数值2&#x27;</span>)<span class="comment">//传入查询参数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/路径/参数值&#x27;</span>)<span class="comment">//动态路由传参</span></span><br></pre></td></tr></table></figure></li><li><p>push对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;<span class="attr">path</span>: <span class="string">&#x27;路由路径&#x27;</span>&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&#x27;/路径&#x27;</span>,</span><br><span class="line"><span class="attr">query</span>: &#123;参数名<span class="number">1</span>:<span class="string">&#x27;参数值1&#x27;</span>,参数名<span class="number">2</span>:<span class="string">&#x27;参数值2&#x27;</span>&#125;</span><br><span class="line">&#125;)<span class="comment">//传入查询参数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;<span class="attr">path</span>:<span class="string">&#x27;/路径&#x27;</span>, <span class="attr">params</span>:&#123;参数名:参数值&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用name跳转</p><p>适合路径过长的路由，给path路径取名，用name替代path，好处是不用写过长的路径，缺点是只能通过<strong>push对象</strong>的方式跳转，传参，因为没有path无法拼接成合法的url。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>, <span class="comment">// 给首页路由命名为 &#x27;Home&#x27;</span></span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;About&#x27;</span>, <span class="comment">// 给关于页面路由命名为 &#x27;About&#x27;</span></span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">About</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 其他路由...</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;路由名字&#x27;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">this.$router.push(&#123;</span></span><br><span class="line"><span class="string">name:&quot;</span>路由名字<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">query: &#123;参数名1:&#x27;</span>参数值<span class="number">1</span><span class="string">&#x27;,参数名2:&#x27;</span>参数值<span class="number">2</span><span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">this.$router.push(&#123;</span></span><br><span class="line"><span class="string">name:&quot;路由名字&#x27;</span>，</span><br><span class="line"><span class="attr">params</span>: &#123;参数名<span class="number">1</span>:<span class="string">&#x27;参数值1&#x27;</span>,参数名<span class="number">2</span>:<span class="string">&#x27;参数值2&#x27;</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="参数接受"><a href="#参数接受" class="headerlink" title="参数接受"></a>参数接受</h3><ul><li><p>this.$route.query：接收查询参数</p></li><li><p>this.$route.params：接收动态参数</p><p>动态路由传参的前提是<strong>组件配置了动态参数</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about/:a&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">About</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他路由...</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>然后跳转传参：<code>to=&quot;/about/3&quot;</code>，3就会被赋值给a，然后在About组件中，通过<code>this.$route.params.a</code>访问。</p><p>如果跳转不穿参：<code>to=&quot;/about&quot;</code>，就会报错，如果希望<strong>可传参，可不传</strong>，则在动态参数后加上<code>?</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about/:a?&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">About</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他路由...</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>动态路由的其他意义：让不同的路由对应相同的组件。</p></li></ul><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p><code>children</code> 属性用于定义嵌套路由。每个子路由的 <code>path</code> 应该<strong>相对于其父路由</strong>的路径来理解。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;article&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Article</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;collect&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Collect</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;like&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Like</span> &#125;,</span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重定向redirect"><a href="#重定向redirect" class="headerlink" title="重定向redirect"></a>重定向redirect</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: layout,</span><br><span class="line">    <span class="comment">//children 属性用于定义嵌套路由</span></span><br><span class="line">    <span class="attr">children</span>:[&#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">component</span>: home &#125;],</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他路由...</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="路由出口router-view"><a href="#路由出口router-view" class="headerlink" title="路由出口router-view"></a>路由出口router-view</h2><p><code>router-view</code>是vue-router提供的一个全局的组件，是一个可以被替换掉的<code>动态组件</code>。</p><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><img src="..\images\vue\导航守卫.png" style="zoom:67%;" /><h3 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h3><ul><li><strong>无参数</strong>：直接调用 <code>next()</code> 表示允许导航继续进行。</li><li><strong>传递路径或命名路由</strong>：<code>next(&#39;/somePath&#39;)</code> 或 <code>next(&#123; name: &#39;SomeRoute&#39; &#125;)</code> 用于重定向到另一个位置。</li><li>**传递 <code>false</code>**：阻止导航继续进行。</li><li><strong>传递错误对象</strong>：<code>next(error)</code> 触发路由错误处理逻辑。</li></ul><h3 id="局部守卫"><a href="#局部守卫" class="headerlink" title="局部守卫"></a>局部守卫</h3><ul><li><p><strong>组件内部</strong></p><ul><li><p>beforeRouteEnter</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不能获取组件实例 `this`，因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">    <span class="title function_">next</span>(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>beforeRouteLeave</p><p>这个守卫用来<strong>阻止用户离开当前路由</strong>。比如，你可以用它来提示用户是否有<code>未保存的更改</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> answer = <span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (answer) &#123;</span><br><span class="line">      <span class="title function_">next</span>()<span class="comment">//确认离开</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="literal">false</span>)<span class="comment">//取消离开</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个功能类似<code>beforeunload</code> 事件，这个事件可以在用户即将离开页面时触发。这包括关闭窗口、刷新页面、导航到其他页面等操作。你可以使用这个事件来显示一个确认对话框给用户，询问他们是否真的要离开页面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置返回值以显示确认对话框</span></span><br><span class="line">    event.<span class="property">returnValue</span> = <span class="string">&#x27;您确定要离开此页面吗？&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>beforeRouteUpdate</p><p>这个守卫在<strong>当前路由改变，但是该组件被复用时</strong>调用。举例来说，对于一个带有<strong>动态路由参数</strong>的路径 <code>/foo/:id</code>，当你从 <code>/foo/1</code> 导航到 <code>/foo/2</code> 时，由于会使用同一个组件实例，所以 <code>beforeRouteUpdate</code> 守卫会在这种情况下被调用。</p><p>但是如果这个组件实例被缓存了，从别的组件切换到这个组件也不会触发这个钩子。只能借助<code>activated</code>或者<code>beforeRouteEnter</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">    <span class="comment">// 路由改变时重新获取数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">fetchData</span>()</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//获取数据的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>路由独享守卫beforeEnter</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">   <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: home,</span><br><span class="line">   <span class="attr">beforeEnter</span>:<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(to,<span class="keyword">from</span>,next)</span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">   &#125; </span><br><span class="line">&#125;,<span class="comment">//这里的to显然是home组件的路由对象，即this.$route</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><ul><li><p>beforeEach</p><p><code>beforeEach</code> 即<strong>全局前置守卫</strong>，在每次导航时都会触发，无论是从一个路由跳转到另一个路由，还是首次进入应用。所有的路由在真正被访问到之前(解析渲染对应组件页面前)，都会先经过<strong>全局前置守卫</strong>，只有全局前置守卫放行了，才会到达对应的页面，或者说才会开始渲染对应的组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next()表示放行，next(&quot;url&quot;)表示拦截到url</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//前两个是对象(和$route一样  是一个反应式的对象(路由对象))，后一个是函数</span></span><br><span class="line">  <span class="comment">//如果要访问的网站to对象的路径：path 不是&#x27;/pay&#x27;, &#x27;/myorder&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (!paths.<span class="title function_">includes</span>(to.<span class="property">path</span>)) &#123;</span><br><span class="line">    <span class="title function_">next</span>()<span class="comment">//放行</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (store.<span class="property">getters</span>.<span class="property">token</span>) &#123;</span><br><span class="line">      <span class="title function_">next</span>()<span class="comment">//如果登录了，放行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>) <span class="comment">//拦截到 登录页面</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别"></a>$route和$router的区别</h2><p>一个是路由，<strong>表示当前页面的路由对象</strong>；一个是路由器，记录了所有页面的对应的路由路径。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </p><p>在组件内可以通过<code>this.$route</code>或得当前组件对应的路径。</p><h2 id="404"><a href="#404" class="headerlink" title="404"></a>404</h2><p><code>&#123; path: &#39;*&#39;, component: NotFound &#125;</code>，<strong>路由的匹配顺序是声明顺序</strong>，通常写在最后，匹配不到组件就匹配这个组件 。</p><p>当我们使用的路由是history路由的时候，这个页面非常有用，因为后端为了防止使用history路由的页面，将前端路由发送到后端导致响应404，所以每当匹配不到资源的时候，后端都返回<code>index.html</code>，将路由控制权交给前端路由。但是这样也有缺点，就是如果用户请求的路径既不对应后端资源也不对应前端页面，这种情况，确实需要响应404，我们就需要一个404页面来提示用户。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>在vue2中</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//router/index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router &#x27;</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line"><span class="attr">mode</span>: <span class="string">&#x27;history &#x27;</span> ,</span><br><span class="line"><span class="attr">routes</span>: [],</span><br><span class="line">    <span class="attr">base</span>:<span class="string">&#x27;/api/&#x27;</span><span class="comment">//设置基础路径</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p><strong>在vue3中</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//router/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter,createwebHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createwebHistory</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">BASE_URL</span>)<span class="comment">//指定路由模式的同时指定基础路径,</span></span><br><span class="line">    <span class="attr">routes</span>: [],</span><br><span class="line">    <span class="attr">scrollBehavior</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">top</span>: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p><code>import.meta.env.BASE_URL</code>：路由<code>基地址</code>，导入的是vite的环境变量，可以通过修改<code>vite.config.js</code>文件的base属性来改变基地址，不能把<code>import.meta.env.BASE_URL</code>直接替换成<code>&#39;./&#39;</code>这种字面量。</p><p><code>scrollBehavior</code> 是 Vue Router 3.5.0 版本引入的一个功能，允许你定义一个滚动行为的函数，用于在导航时控制页面的滚动位置。</p><p>它和<code>routes</code>这个常见的配置项属于同级别的属性。</p><p><code>scrollBehavior</code> 函数接收三个参数：</p><ol><li><strong>to</strong>：即将进入的路由对象。</li><li><strong>from</strong>：即将离开的路由对象。</li><li><strong>savedPosition</strong>：仅当 <code>popstate</code> 导航（如用户点击浏览器的<code>前进/后退</code>按钮）时可用。这是一个<code>包含滚动位置的对象</code>（如果有保存的话），比如<code>&#123;top:20&#125;</code>。savedPosition记录的是用户点击前进或后退按钮时，的页面滚动位置</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">scrollBehavior</span>(<span class="params">to, <span class="keyword">from</span>, savedPosition</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (savedPosition) &#123;</span><br><span class="line">      <span class="keyword">return</span> savedPosition</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">top</span>: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码会在用户点击浏览器的前进&#x2F;后退按钮时<strong>恢复之前保存的滚动位置</strong>；如果没有保存的位置，则<strong>默认滚动到顶部</strong>。</p><h3 id="创造实例方式"><a href="#创造实例方式" class="headerlink" title="创造实例方式"></a>创造实例方式</h3><ul><li>一个是使用<code>构造函数</code>创建router实例，一个是通过函数创造</li><li>使用的库都是vue-router</li><li>创造实例的时候传入的都是配置项</li></ul><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><ul><li>vue2中控制路由用<code>mode</code>属性，history标识历史模式，hash是默认模式</li><li>vue3中控制路由模式用<code>history</code>属性，<code>createwebHistory</code>表示历史模式，<code>createwebHashHistory</code>表示哈希模式。</li></ul><h3 id="获取router-route对象方式"><a href="#获取router-route对象方式" class="headerlink" title="获取router&#x2F;route对象方式"></a>获取router&#x2F;route对象方式</h3><ul><li><p>vue2在组件中可以通过<code>this.$router/$route</code>获取，在js文件中则通过<strong>直接导入router</strong>的方式实现路由跳转。</p></li><li><p>在vue3中</p><p>在普通js文件中，也是通过<strong>直接导入router</strong>的方式实现路由跳转。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import router from &#x27;@/router&#x27;;</span><br><span class="line">// 执行导航操作</span><br><span class="line">router.push(&#x27;/some-path&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>在组件中（默认使用setup语法糖），通过useRoute, useRouter这两个api分别获取<code>当前页面路由对象</code>和<code>路由器对象</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//这些函数依赖于Vue的响应式系统和组件上下文，只能在组件内使用，在普通js文件中无法使用。</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; useRoute, useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>无论是再vue2还是在vue3中，在template中都能通过<code>$route</code>访问当前页面路由对象。</p></li></ul><h3 id="导航守卫-1"><a href="#导航守卫-1" class="headerlink" title="导航守卫"></a>导航守卫</h3><p>在 Vue 3 中，如果你使用的是 Vue Router 4，在某些情况下，你可以<strong>直接返回值</strong>（return）来代替调用 <code>next()</code>，这使得代码更加简洁，但是也要注意这样会终止导航守卫函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">matched</span>.<span class="title function_">some</span>(<span class="function"><span class="params">record</span> =&gt;</span> record.<span class="property">meta</span>.<span class="property">requiresAuth</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isAuthenticated</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;/login&#x27;</span>; <span class="comment">// 返回字符串作为重定向的目标路径</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">shouldBlockNavigation</span>(to)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 取消导航</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>在vue2开发过程中使用的状态管理工具。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ul><li>某个状态在很多个组件来使用(个人信息)</li><li>多个组件共同维护一份数据比如(购物车)</li><li>数据传递存在困难用vuex就完事了</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>共同维护同一份数据</li><li>响应式变化，响应式变化基于vue的响应式</li><li>操作简洁</li></ul><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>创建vuecli项目时勾选vuex或者手动添加。</p><ul><li>安装vuex</li><li>在src新建文件store，新建文件index.js</li><li>在index文件中初始化插件：Vue.use(Vuex)；创造空仓库，配置仓库。</li><li>导出store对象，最后在创建根实例的时候传入这个store对象，它最终会被注入到每个组件实例中，也就是说<code>this.$store</code>是组件实例<strong>自己的属性</strong>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> user <span class="keyword">from</span> <span class="string">&#x27;@/store/modules/user&#x27;</span></span><br><span class="line"><span class="keyword">import</span> cart <span class="keyword">from</span> <span class="string">&#x27;@/store/modules/cart&#x27;</span></span><br><span class="line"><span class="comment">//注册插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"><span class="comment">//Store显然是一个构造器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="attr">setIndex</span>: <span class="function">(<span class="params">state, index</span>) =&gt;</span> &#123;</span><br><span class="line">      state.<span class="property">index</span> = index</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    user, cart</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//App是一个被vue-loader解析后的js对象</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">//导入router对象,会先把router文件夹里的index.js里的代码运行</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="comment">// 导入store对象</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="comment">//h是createElement函数，用来创建虚拟结点(VNode),返回这个 VNode,告诉 Vue使用 App 组件作为根组件</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="四大属性"><a href="#四大属性" class="headerlink" title="四大属性"></a>四大属性</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>提供唯一的公共数据源</p><p>无论组件内外，都是从store对象出发，来拿到state，不过获取store对象的方式不同。</p><p>组件内的可以通过<code>this.$store</code>拿到，在模板内可以直接使用<code>$store</code>(模板内默认去除this)，后面的3大属性同理。</p><p>组件外则通过import导入:<code>import store from &#39;./store&#39;</code>，直接拿到store实例。</p><p><strong>挂载位置</strong></p><p>模块中的state最终会挂载在根仓库的state中，**无论模块是否开启命名空间(开启命名空间是防止命名冲突)**，但要注意的是根仓库中的属性直接通过<code>this.$store.state</code>就能拿到，比如<code>this.$store.state.index</code>，而模块中的属性需要通过<code>this.$store.state.module</code>才能拿到，路径更长，比如<code>this.$store.state.cart.cartList</code>。</p><p>例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="number">0</span><span class="comment">//根仓库自己的属性</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    user, cart</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modules/cart.js</span></span><br><span class="line"><span class="keyword">const</span> state = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">cartList</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modules/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespace</span>:<span class="literal">false</span>,<span class="comment">//不开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="comment">//页面刚加载完成，或者刷新，从本地存储中获取个人信息，更新info</span></span><br><span class="line">    <span class="comment">// 一旦 info 被初始化，后续对 info 的访问都是直接从 Vuex store 中获取已存储的值，不会再调用 getInfo 函数。</span></span><br><span class="line">    <span class="attr">info</span>: <span class="title function_">getInfo</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\vue\state.png" style="zoom:90%;" /><img src="..\images\vue\state3.png" style="zoom:90%;" /><h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><p>里面是一些修改&#x2F;维护state中的数据的函数，只能通过调用这里的函数来修改数据。</p><p><strong>参数</strong></p><p>第一个参数是state，用来访问state中的数据，也同时说明了mutation只能同步修改数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="attr">setIndex</span>: <span class="function">(<span class="params">state, index</span>) =&gt;</span> &#123;</span><br><span class="line">      state.<span class="property">index</span> = index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//我们在使用mutation中的方法的时候忽略第一个参数,我们传入的参数就是index</span></span><br></pre></td></tr></table></figure><p><strong>挂载位置</strong></p><p>是否开启命名空间，也不影响mutations的挂载位置。但是会影响挂载时候的属性名，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="attr">setIndex</span>: <span class="function">(<span class="params">state, index</span>) =&gt;</span> &#123;</span><br><span class="line">      state.<span class="property">index</span> = index</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    user, cart</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modules/cart.js</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="title function_">setCartList</span>(<span class="params">state, list</span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">toggleCheck</span>(<span class="params">state, goods_id</span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">toggleAllCheck</span>(<span class="params">state,flag</span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">changeCount</span>(<span class="params">state, obj</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  mutations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modules/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">//namespace:true, 未开启命名空间</span></span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">setUserInfo</span>(<span class="params">state, info</span>) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\vue\mutations.png" style="zoom:85%;" /><p>如图所示，cart模块开启了命名空间，所以属性名加上了<code>cart/</code>前缀，而user模块未开启，就不会加上前缀，如同根仓库中的mutations。然后我们使用commit调用mutations中的方法，就有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(属性名,参数)</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;cart/changeCount&#x27;</span>,<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;setIndex&#x27;</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>commit是Store实例的自己的属性，值是函数</p><h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h3><p>相当于计算属性，第一个参数也一般是state，第二个参数可以是getters(用来拿到getters中的属性)</p><p><strong>挂载位置</strong></p><p>是否开启命名空间，也不影响getter的挂载位置。但是会影响挂载时候的属性名，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">token</span>(<span class="params">state</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">user</span>.<span class="property">info</span>.<span class="property">token</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    user, cart</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modules/cart.js</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="title function_">isAllChecked</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> state.<span class="property">cartList</span>.<span class="title function_">every</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">checked</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">numOfAll</span>(<span class="params">state</span>) &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">numOfChecked</span>(<span class="params">state</span>) &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sumPrice</span>(<span class="params">state</span>) &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">selectedGoods</span>(<span class="params">state</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  getters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//modules/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">getters</span>:&#123;</span><br><span class="line">    <span class="title function_">name</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\vue\getters.png" style="zoom:85%;" /><p>如图所示，cart模块开启了命名空间，所以属性名加上了<code>cart/</code>前缀，而user模块未开启，就不会加上前缀，如同根仓库中的getter。</p><p>然后我们访问的时候就有:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[属性名]</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;token&#x27;</span>]</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>.<span class="property">name</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;cart/numOfAll&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>里面是一些异步操作&#x2F;函数</p><p><strong>参数</strong></p><p>第一个参数是context（上下文），可以通过<code>context.commit()</code>调用<code>mutations</code>里的方法，通过<code>context.dispatch()</code>调用<code>actions</code>里的方法；可以通过<code>context.state</code>拿到数据但是不能直接修改数据，总之就是雨露均沾。</p><p><strong>挂载位置</strong></p><p>原理和mutation一样，是否开启命名空间，也不影响actions的挂载位置，都挂载在<code>Store._actions</code>属性中。</p><p>然后调用的时候就有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;属性名&#x27;</span>，参数)<span class="comment">//类似mutations</span></span><br></pre></td></tr></table></figure><p>dispatch是Store实例的自己的属性，值是函数</p><h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><p>在我们了解了各个属性在Store实例中的挂载位置后，我们拿到Store实例后，就知道如何访问，使用这四个属性了。</p><p>其实vuex还提供了辅助函数来简化操作。</p><p>四个属性，分别对应四个辅助函数，mapState，mapMutations，mapActions，mapGetters。</p><p>它们的使用方法是类似的。</p><img src="..\images\vue\state3.png" style="zoom:85%;" /><p>mapState返回的是一个对象，这个对象可以有多个属性，属性的值类型都是函数，都是<strong>计算属性</strong>，内部本质是使用了<code>this.$store</code>来获取state中的数据，<strong>所以只能在组件内使用</strong>，其他辅助函数也是。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;cart&#x27;</span>,[<span class="string">&#x27;cartList&#x27;</span>]),</span><br><span class="line">        ...<span class="title function_">mapState</span>([<span class="string">&#x27;index&#x27;</span>]),</span><br><span class="line">        ...<span class="title function_">mapState</span>(<span class="string">&#x27;user&#x27;</span>,[<span class="string">&#x27;info&#x27;</span>])<span class="comment">//报错，因为user未开启命名空间</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\vue\mutations.png" style="zoom:85%;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setUserInfo</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>&#125;),</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">changeCount</span>()</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">        ...<span class="title function_">mapMutations</span>(<span class="string">&#x27;cart&#x27;</span>,[<span class="string">&#x27;changeCount&#x27;</span>,<span class="string">&#x27;setCartList&#x27;</span>]),</span><br><span class="line">        ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;setIndex&#x27;</span>,<span class="string">&#x27;setUserInfo&#x27;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\vue\getters.png" style="zoom:85%;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">        ...<span class="title function_">mapGetters</span>(<span class="string">&#x27;cart&#x27;</span>,[<span class="string">&#x27;isAllChecked&#x27;</span>,<span class="string">&#x27;numOfAll&#x27;</span>]),</span><br><span class="line">        ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;token&#x27;</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Pinia"><a href="#Pinia" class="headerlink" title="Pinia"></a>Pinia</h1><p>vue的最新<code>状态管理工具</code>，vuex的替代品。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>和Vue3新语法统一，提供符合<code>组合式</code>风格的API</p></li><li><p>提供更加简单的API（去掉了mutation，合并到actions)</p></li><li><p>去掉了<code>modules</code>的概念，替换为一个一个的<code>同级别</code>的store，他们都由pinia管理；</p><img src="..\images\vue\pinia.png" style="zoom: 67%;" /></li><li><p>配合TypeScript更加友好，提供可靠的类型推断。</p></li></ul><h2 id="注册-1"><a href="#注册-1" class="headerlink" title="注册"></a>注册</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App. vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)  <span class="comment">//传入App.vue创建根实例</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">createPinia</span>()) <span class="comment">//注册pinia插件</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>) <span class="comment">//视图的挂载</span></span><br></pre></td></tr></table></figure><h2 id="组合式风格"><a href="#组合式风格" class="headerlink" title="组合式风格"></a>组合式风格</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cart.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="comment">//defineStore返回值的类型是一个函数，导出的就是这个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">100</span>)<span class="comment">//state</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addCount</span> =(<span class="params"></span>) =&gt; &#123;count.<span class="property">value</span>++&#125;<span class="comment">//actions</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">subCount</span> =(<span class="params"></span>) =&gt;&#123;count.<span class="property">value</span>--&#125;<span class="comment">//actions</span></span><br><span class="line"><span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> count.<span class="property">value</span> * <span class="number">2</span>)<span class="comment">//getters</span></span><br><span class="line"><span class="keyword">const</span> msg = <span class="title function_">ref</span>(<span class="string">&#x27;hello pinia&#x27;</span>)<span class="comment">//state</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">count,double,addCount,subCount,msg<span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)<span class="comment">//所以说在仓库里写组合式api风格的代码就行</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>:</p><ul><li>定义的变量就是state属性</li><li>定义的计算属性。即computed，就是getters</li><li>定义的函数，即function()，就是actions，支持异步操作，支持同步操作</li></ul><h2 id="选项式风格"><a href="#选项式风格" class="headerlink" title="选项式风格"></a>选项式风格</h2><p>个人还是一味的使用组合式了….</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="title function_">defineStore</span>(仓库的唯一标识,&#123;<span class="comment">//配置对象&#125; )</span></span><br></pre></td></tr></table></figure><h2 id="持久化插件"><a href="#持久化插件" class="headerlink" title="持久化插件"></a>持久化插件</h2><p>无论是vuex还是pinia，仓库中的数据是保存在内存中的，如果不使用持久化存储，<strong>当页面刷新或者关闭时</strong>，数据就会丢失。这是因为这些状态是存储在 JavaScript 运行时的内存中的，一旦页面卸载（比如刷新或关闭），这些数据就会被销毁。</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i pinia-plugin-persistedstate</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="comment">//导入插件</span></span><br><span class="line"><span class="keyword">import</span> persist <span class="keyword">from</span> <span class="string">&#x27;pinia-plugin-persistedstate&#x27;</span></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line">pinia.<span class="title function_">use</span>(persist)<span class="comment">//注册插件</span></span><br></pre></td></tr></table></figure><p>再指定要持久化的store，对于<code>组合式store</code>，需要在defineStore函数里再传入一个参数（第三个参数），{persist:true}。</p><p>对于<code>选项式store</code>，直接添加属性<code>persist：true</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> category = <span class="title function_">defineStore</span>(<span class="string">&#x27;category&#x27;</span>,<span class="function">() =&gt;</span> &#123;&#125;,&#123;<span class="attr">persist</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> category = <span class="title function_">defineStore</span>(<span class="string">&#x27;category&#x27;</span>,&#123;<span class="attr">persist</span>:<span class="literal">true</span>,<span class="attr">state</span>:&#123;&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><strong>简化了localStorage的相关操作</strong>，会自动使用<code>JSON. stringify/JSON.parse</code>进行<code>序列化/反序列化</code>。值为函数和undefined的属性无法被序列化，Symbol属性和值为Symbol的属性无法被序列化。</li><li>存储到localStorage的键名默认是<code>仓库唯一标识</code>。</li><li>默认把仓库<strong>整个state</strong>做持久化，可以指定具体哪些数据做持久化。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设在stores/counter.js中定义了一个仓库</span></span><br><span class="line"><span class="comment">// stores/counter.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">//选项式风格</span></span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">doubleCount</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">count</span> * <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在组件中使用</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; useCounterStore &#125; <span class="keyword">from</span> <span class="string">&#x27;@/stores/counter&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> counterStore = <span class="title function_">useCounterStore</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//我们可以发现无论是state还是getters还是actions，都可以直接通过store实例访问，非常方便啊</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> count = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> counterStore.<span class="property">count</span>); </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> doubleCount = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> counterStore.<span class="property">doubleCount</span>),</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; counterStore.<span class="title function_">increment</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在纯 JavaScript 文件（非 Vue 组件）中使用 Pinia store 需要一些<strong>额外的步骤</strong>，因为你<strong>没有 Vue 组件的上下文</strong>（比如 <code>setup()</code> 函数）。你需要确保 Pinia 已经被安装并且可以访问到，最好不要写到js文件的<code>全局作用域</code>中。</p><p>所以说vue3中给两大插件pinia，router提供的api；router的<code>useRoute和useRouter</code>只能在组件中使用，pinia的useStore虽然不是只能在组件中调用，但是在js文件中使用起来也是有限制的。</p><p><strong>与vuex的区别</strong></p><p>vue2中要使用vuex中的哪个数据，调用哪个方法，都是单独获取，而Vue3是一个一个<code>store</code>整体导入使用。</p><h1 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>vue使用webpack进行模块化开发，但是webpack的配置工作是一个很繁琐的过程，所以出现了vue-cli这个<strong>脚手架工具</strong>，它可以帮助我们快速创建一个开发vue项目的标准化webpack配置。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm i @vue/cli -g<span class="comment">//全局安装，安装一次就行，之后就可以在任意目录执行以下指令</span></span><br><span class="line">vue --version<span class="comment">//查看Vue版本</span></span><br><span class="line">vue create project-<span class="title function_">name</span>(项目名不能用中文)<span class="comment">//创建项目架子</span></span><br><span class="line">npm run serve <span class="comment">//启动项目，查看package.json可知</span></span><br></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><ul><li><p>node_modules：存储项目的所有 npm 依赖包。</p></li><li><p>public：存放<code>静态资源</code>，如 index.html 和 favicon.ico，这些文件不会被 webpack 处理，而是会直接被打包进最终文件。</p></li><li><p>src：源代码的主要目录</p><ul><li><p>assets：用于存放静态资源文件，如图片、字体等，<strong>会被 webpack 处理</strong>。</p></li><li><p>components ：存放 .vue 单文件组件</p></li><li><p>views：存放页面</p></li><li><p>App.vue：根组件，整个应用的入口点。</p></li><li><p>main.js：应用程序的入口脚本，通常在这里创建 Vue 实例(根实例)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>package.json：项目元数据和依赖关系列表，以及 npm 脚本(script)。</p></li><li><p>vue.config.js：Vue CLI 的可选配置文件，用于<strong>自定义构建设置</strong></p></li><li><p>babel.config.js：<strong>Babel 的配置文件</strong>，用于转换 ES6+ 代码。它可以帮助你将现代 JavaScript 特性（ES6+）转换为向后兼容的 JavaScript 版本。</p></li></ul><h2 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h2><p>是一个轻量级的 Node.js 模块，可以让你快速地启动一个具有 REST API 的 JSON 文件数据库服务器。它提供了一个简单的、可立即使用的后端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g json-server</span><br></pre></td></tr></table></figure><p>在项目根目录下创建一个文件，比如 db.json，并填充一些数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Second Post&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Some comment&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;postId&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在db.json文件所在目录下执行<code>json-server --watch db.json</code>，这会启动一个默认监听在<code>http://localhost:3000</code>的服务器</p><p>使用各种 <code>HTTP 请求工具</code>（如 Postman 或 cURL）或前端框架中的 AJAX 请求来与之交互，比如可以发送一个 GET 请求到<code>http://localhost:3000/posts</code>来获取所有的帖子</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp</title>
      <link href="/posts/e19785da.html"/>
      <url>/posts/e19785da.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>笔记内容主要参考uni-app官方文档，仔细阅读<a href="https://uniapp.dcloud.net.cn/">uni-app官方文档 </a><strong>介绍</strong>和<strong>教程</strong>等部分能获得更多内容。</p></blockquote><h2 id="什么是uni-app"><a href="#什么是uni-app" class="headerlink" title="什么是uni-app"></a>什么是uni-app</h2><p>是一个使用 <code>Vue.js </code>开发所有前端应用的<strong>框架</strong>，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程快应用等多个平台。</p><p>uni-app的由来：<a href="https://uniapp.dcloud.net.cn/history.html">uni-app官网</a></p><h2 id="HBuilderX"><a href="#HBuilderX" class="headerlink" title="HBuilderX"></a>HBuilderX</h2><p>HBuilderX是通用的前端开发工具，但为<code>uni-app</code>做了特别强化，和uni-app属于同一家公司的产品。</p><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><ul><li>插件下载：工具-&gt;插件下载</li><li>快捷方式定制：工具-&gt;预定快捷方案</li><li>tab补全代码：工具-&gt;设置-&gt;语言服务配置</li><li>保存代码格式化：工具-&gt;设置-&gt;编辑器配置</li><li>合并代码时显示最后一行代码：工具-&gt;设置-&gt;编辑器配置</li></ul><h3 id="创建一个uni-app项目"><a href="#创建一个uni-app项目" class="headerlink" title="创建一个uni-app项目"></a>创建一个uni-app项目</h3><p>在点击工具栏里的文件 -&gt; 新建 -&gt; 项目</p><p>选择<code>uni-app</code>类型，输入工程名，选择<strong>模板</strong>，点击创建，即可成功创建。</p><img src="..\images\uni-app\1.png" style="zoom:80%;" /><p>uni-app自带的模板有默认的<code>空项目</code>模板、Hello uni-app 官方组件和API示例，还有一个重要模板是 <code>uni ui</code>项目模板，日常开发推荐使用该模板，已内置大量常用组件。</p><p>也可以使用<code>vue-cli</code>命令行开发，不过个人还是喜欢使用HBuilder。</p><h3 id="运行uni-app"><a href="#运行uni-app" class="headerlink" title="运行uni-app"></a>运行uni-app</h3><p>点击左上角的<code>运行</code>选项，即可选择项目的运行方式</p><img src="..\images\uni-app\3.png" style="zoom:67%;" /><p>如果要运行到手机，需要连接usb，在设置中开启USB调试。如果要运行到手机模拟器，则需要先下载，比如逍遥，雷电模拟器，然后打开这些应用，才能被hbuilder检测到。</p><p>将项目运行到<code>微信开发者工具</code>：</p><ul><li><p>AppID</p><p>在<code>manifest-&gt;微信小程序配置</code>中填写自己的微信小程序的<code> AppID</code>，这个是需要我们去申请的</p></li><li><p>安装路径</p><p>在<code>设置</code>中配置“微信开发者工具”的安装路径，只有配置了微信开发者工具路径，hx才能打开微信开发者工具</p><img src="..\images\uni-app\2.png" style="zoom:80%;" /></li><li><p>开启服务端口</p><p>在微信开发者工具中，通过 <code>设置 -&gt; 安全设置面板</code>，开启微信开发者工具的<code>服务端口</code></p></li></ul><h3 id="发布uni-app"><a href="#发布uni-app" class="headerlink" title="发布uni-app"></a>发布uni-app</h3><h4 id="打包为原生App"><a href="#打包为原生App" class="headerlink" title="打包为原生App"></a>打包为原生App</h4><p>在打包之前也需要在<code>manifest.json</code> 的可视化界面做相关配置。</p><ul><li>在基础配置面板中，获取uni-app 应用标识，并填写应用名称</li><li>切换到 App 图标配置面板，点击浏览按钮，选择合适的图片之后，再点击自动生成所有图标并替换</li></ul><p>在HBuilderX工具栏，点击<code>发行</code>，选择<code>原生app-云端打包</code>（在线打包），云端打包支持安心打包，保护用户隐私，不会上传代码和证书，通过差量包制作方式实现安心打包，缺点是可能需要排队。云打包完成后，在<code>内置控制台</code>点击链接下载 apk 的安装包，并安装到 Android 手机中查看打包的效果。</p><p>虽然安心打包已经满足需求，但如仍然希望自己使用 xcode 或 Android studio 进行离线打包，则在 HBuilderX 发行菜单里找到本地打包菜单，生成离线打包资源，然后参考离线打包文档操作：<a href="https://nativesupport.dcloud.net.cn/AppDocs/README">https://nativesupport.dcloud.net.cn/AppDocs/README</a></p><p>App打包时，注意如果涉及三方sdk，需进行申请并在<code>manifest.json</code>里配置，否则相关功能无法使用。</p><p>iOS App打包需要向Apple申请证书</p><h4 id="发布为Web网站"><a href="#发布为Web网站" class="headerlink" title="发布为Web网站"></a>发布为Web网站</h4><p>在 <code>manifest.json</code> 的可视化界面，进行如下配置</p><img src="..\images\uni-app\4.png" style="zoom: 80%;" /><p>如果使用history路由，就需要<code>后端服务器</code>做对应的配置，具体原因参考<a href="https://www.sanye.blog/posts/f33bd2b9.html">前端面试—vue部分 | 三叶的博客</a>中前端路由部分。</p><p>当我们令运行时的基础路径为<code>/api/</code>，打包后index.html引入文件的路径就会变成如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;/api/assets/index-yJj5sN9l.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">crossorigin</span> <span class="attr">href</span>=<span class="string">&quot;/api/assets/index-Dl1z_jWj.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在HBuilderX工具栏，点击发行，选择<code>网站-H5</code>，点击会弹出这个窗口：</p><img src="..\images\uni-app\5.png" style="zoom: 80%;" /><p>无需在意，直接点击发行，即可生成 H5 的相关资源文件，保存于<code>unpackage/dist/build/web</code> 目录。</p><p>至于部署打包后的网页，其实和部署博客一样，可以借助<code>github-pages+vercel</code>，或者使用dcloud免费的网页托管服务。</p><h4 id="发布为微信小程序"><a href="#发布为微信小程序" class="headerlink" title="发布为微信小程序"></a>发布为微信小程序</h4><ol><li><p>申请微信小程序AppID，参考：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/getstart.html#%E7%94%B3%E8%AF%B7%E5%B8%90%E5%8F%B7">微信教程</a>。</p></li><li><p>在HBuilderX中顶部菜单依次点击 “发行” &#x3D;&gt; “小程序-微信”，输入小程序名称和appid点击发行即可</p><img src="..\images\uni-app\6.png" style="zoom: 80%;" /></li></ol><p>如果手动发行(未勾选<code>自动上传微信平台</code>)，则点击发行按钮后，会在项目的目录 <code>unpackage/dist/build/mp-weixin</code> 生成微信小程序<code>项目代码</code>。打开微信小程序开发者工具，<code>导入</code>生成的微信小程序项目，测试项目代码运行正常后，点击<code>上传</code>按钮，之后按照 <code>提交审核=&gt; 发布</code>小程序标准流程，逐步操作即可，详细查看：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/release.html#%E5%8F%91%E5%B8%83%E4%B8%8A%E7%BA%BF">微信官方教程</a>。</p><p>如果在发行界面勾选了<code>自动上传微信平台</code>，则无需再打开<code>微信工具</code>手动操作，将<code>直接</code>上传到微信服务器提交审核。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>下面只展示基础的项目结构，更详细的结构可以参考官方文档。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">│─components            符合vue组件规范的uni-app组件目录</span><br><span class="line">│  └─comp-a.vue         可复用的a组件</span><br><span class="line">├─pages                 业务页面文件存放的目录</span><br><span class="line">│  ├─index</span><br><span class="line">│  │  └─index.vue       index页面</span><br><span class="line">│  └─list</span><br><span class="line">│     └─list.vue        list页面</span><br><span class="line">├─static                存放应用引用的本地静态资源（如图片、视频等）的目录，注意：静态资源都应存放于此目录</span><br><span class="line">├─uni_modules           存放uni_module 详见</span><br><span class="line">├─unpackage             非工程代码，一般存放运行或发行的编译结果</span><br><span class="line">├─main.js               Vue初始化入口文件</span><br><span class="line">├─App.vue               应用配置，用来配置App全局样式以及监听 应用生命周期</span><br><span class="line">├─pages.json            配置页面路由、导航条、选项卡等页面类信息，详见</span><br><span class="line">├─manifest.json         配置应用名称、appid、logo、版本等打包信息，详见</span><br><span class="line">└─uni.scss              内置的常用样式变量</span><br></pre></td></tr></table></figure><p>微信小程序中的一个页面就是一个文件夹，然后里面有四个文件，分别对应html，css，js，json文件，而在uni-app中，一个vue文件就包含了前三者，然后页面json文件被page.json中的pages.style属性给替代了。</p><h3 id="page-json"><a href="#page-json" class="headerlink" title="page.json"></a><strong>page.json</strong></h3><p>项目页面的配置文件 ，类似微信小程序中的<code>app.json</code>，这种命名方式貌似着重强调了pages属性。</p><p>主要组成：</p><ul><li><p>globalStyles：<code>全局定义</code>页面的样式，会被pages中页面单独定义的样式覆盖</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;globalStyle&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;navigationBarTextStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;navigationBarBackgroundColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#fff&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;backgroundColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#F8F8F8&quot;</span></span><br><span class="line">    <span class="comment">// &quot;navigationStyle&quot;: &quot;custom&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>可以看出，<code>page.json</code>文件中的<code>globalStyles</code>属性替换了微信小程序中的<code>app.json</code>文件中的<code>window</code>属性</p></li><li><p>pages：注册页面的地方；值是一个数组，数组元素是一个一个的页面对象，<strong>第一个页面对象就是首屏</strong>，这些页面都会被打包进<strong>主包</strong>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">//pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/home/home&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;navigationBarTitleText&quot;</span><span class="punctuation">:</span> <span class="string">&quot;推荐&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;navigationStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;custom&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;enablePullDownRefresh&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/classify/classify&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;navigationBarTitleText&quot;</span><span class="punctuation">:</span> <span class="string">&quot;分类&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;navigationStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;custom&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;enablePullDownRefresh&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>页面对象属性：</p><ul><li>path：页面组件路径</li><li>style：定义页面的一些样式，比如配置，<code>&quot;navigationStyle&quot;: &quot;custom&quot;</code>；配置后这个页面的导航栏直接消失了</li></ul><p>可以注意到<code>page.json</code>中的pages的<code>style属性</code>其实就是替换掉了微信小程序中<code>页面的json文件</code></p></li><li><p>tabbar：值是一个对象，用来配置标签栏，和app.json中的语法相同。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;tabBar&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;selectedColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#28b389&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/home/home&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/home.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/home-h.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;推荐&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/classify/classify&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/classify.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/classify-h.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;分类&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/user/user&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/user.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/user-h.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我的&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">     <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>subPackages：用来注册分包，属性的值是一个数组，数组的值是一个一个分包对象，有几个分包对象最终就有几个分包，这个属性的语法也和wx小程序的<code>app.json</code>相同。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;subPackages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;subpkg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span>&#x27;pkgA&#x27;<span class="punctuation">,</span><span class="comment">//分包别名</span></span><br><span class="line">      <span class="comment">//当前分包下所有页面的相对路径</span></span><br><span class="line">      <span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;detail/detail&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;goods_list/goods_list&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;search/search&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p>更多内容参考：<a href="https://uniapp.dcloud.net.cn/collocation/pages.html">pages.json 页面路由 | uni-app官网</a></p><h3 id="static目录"><a href="#static目录" class="headerlink" title="static目录"></a><strong>static目录</strong></h3><p>uni-app编译器根据<code>pages.json</code>扫描需要编译的页面，并根据页面引入的js、css合并打包文件。</p><p>对于本地的图片、字体、视频、文件等资源，如果可以直接识别，那么也会把这些资源文件打包进去，但如果这些资源以<code>变量</code>的方式引用， 比如：<code>&lt;image :src=&quot;url&quot;&gt;&lt;/image&gt;</code>，甚至可能有更复杂的函数计算，此时编译器无法分析。</p><p>那么有了static目录，编译器就会把这个目录<code>整体复制</code>到最终编译包内，样只要运行时确实能获取到这个图片，就可以显示。</p><p>当然这也带来一个注意事项，如果static里有一些没有使用的废文件，也会被打包到编译包里，造成体积变大。</p><p>非 <code>static</code> 目录下的文件（vue组件、js、css 等）<strong>只有被引用时</strong>，才会被打包编译。</p><p><strong>简单的来说就是，static目录下的文件无论是否被引用，都会被打包进最终文件，而非static目录下的文件，只有被引用了，才会被打包进最终文件。</strong></p><h3 id="uni-scss"><a href="#uni-scss" class="headerlink" title="uni.scss"></a>uni.scss</h3><p><code>uni.scss</code>文件的用途是为了<strong>方便整体控制应用的风格</strong>。比如按钮颜色、边框风格，<code>uni.scss</code>文件里<strong>预置了一批scss变量</strong>。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="comment">/* 行为相关颜色 */</span></span><br><span class="line"><span class="variable">$uni-color-primary</span>: <span class="number">#007aff</span>;</span><br><span class="line"><span class="variable">$uni-color-success</span>: <span class="number">#4cd964</span>;</span><br><span class="line"><span class="variable">$uni-color-warning</span>: <span class="number">#f0ad4e</span>;</span><br><span class="line"><span class="variable">$uni-color-error</span>: <span class="number">#dd524d</span>;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p><code>uni.scss</code>是一个特殊文件，在代码中<strong>无需 import</strong> 这个文件即可在scss代码中使用这里的样式变量。uni-app的编译器在webpack配置中特殊处理了这个uni.scss，使得每个scss文件都被注入这个uni.scss，达到<strong>全局可用</strong>的效果。</p><p><strong>简单来说，这就是一个<code>只包含scss变量</code>的文件，会被自动注入到所有scss文件中。</strong></p><p><strong>注意：</strong></p><ol><li>如要使用这些常用变量，需要在 HBuilderX 里面安装 <code>scss</code> 插件；</li><li>使用时需要在 style 节点上加上 <code>lang=&quot;scss&quot;</code>。</li><li>pages.json不支持scss，原生导航栏和tabbar的动态修改只能使用js api</li></ol><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>是 uni-app 的<strong>入口文件</strong>，类似微信小程序中的app.js文件。</p><p><code>main.js</code>主要作用是：</p><ul><li>初始化<code>vue</code>实例</li><li>定义全局组件</li><li>使用需要的插件如 i18n、vuex。</li></ul><p>说白了不就是和vue的入口文件作用一样吗，只不过在语法上略有区别。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vue2</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PageHead</span> <span class="keyword">from</span> <span class="string">&#x27;./components/page-head.vue&#x27;</span> <span class="comment">//全局引用 page-head 组件</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;page-head&#x27;</span>, <span class="title class_">PageHead</span>) <span class="comment">//全局注册 page-head 组件，每个页面将可以直接使用该组件</span></span><br><span class="line"><span class="title class_">App</span>.<span class="property">mpType</span> = <span class="string">&#x27;app&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">...<span class="title class_">App</span></span><br><span class="line">&#125;)</span><br><span class="line">app.$mount() <span class="comment">//挂载 Vue 实例</span></span><br></pre></td></tr></table></figure><h3 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h3><p>所有页面都是在<code>App.vue</code>下进行切换的，是应用入口文件。但<code>App.vue</code>本身不是页面，这里不能编写视图元素，也就是</p><p><strong>没有<code>&lt;template&gt;</code></strong></p><p>而在标准的 Vue.js 项目中，<code>App.vue</code> 通常作为应用的<code>根组件</code>，并且包含 <code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 标签。</p><p>而在 <code>uni-app</code> 中，<code>App.vue</code> 主要扮演的是一个<code>全局配置文件</code>(沦落至此)的角色，而不是具体的页面组件。在uni-app中的作用包括：<strong>监听应用生命周期、配置全局样式</strong>。我们可能有疑问，全局样式配置不是在<code>uni.scss</code>文件中进行的吗？其实不是哈，我们之前也介绍过，这个文件内部只是一些scss变量，很遗憾，这个文件虽然也在项目根目录，但并不像微信小程序中的app.wxss文件一样，用来书写全局样式。</p><p><strong>应用生命周期仅可在<code>App.vue</code>中监听，在页面监听无效</strong>。至此，uni-app中的生命周期就包括了：<strong>组件的生命周期，页面的生命周期和应用的生命周期。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    onLaunch: function() &#123;</span><br><span class="line">      console.log(&#x27;App Launch&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    onShow: function() &#123;</span><br><span class="line">      console.log(&#x27;App Show&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    onHide: function() &#123;</span><br><span class="line">      console.log(&#x27;App Hide&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">  /*每个页面公共css */</span><br><span class="line">  @import &quot;@/common/styles/common.scss&quot;;</span><br><span class="line">  @import &quot;@/uni.scss&quot;;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>至于应用的生命周期有哪些：</p><table><thead><tr><th align="left">函数名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">onLaunch</td><td align="left">当<code>uni-app</code> 初始化完成时触发（全局只触发一次），参数为应用启动参数，同 <a href="https://uniapp.dcloud.net.cn/api/getLaunchOptionsSync.html#getlaunchoptionssync">uni.getLaunchOptionsSync</a> 的返回值</td></tr><tr><td align="left">onShow</td><td align="left">当 <code>uni-app</code> 启动，或从后台进入前台显示，参数为应用启动参数，同 <a href="https://uniapp.dcloud.net.cn/api/getLaunchOptionsSync.html#getlaunchoptionssync">uni.getLaunchOptionsSync</a> 的返回值</td></tr><tr><td align="left">onHide</td><td align="left">当 <code>uni-app</code> 从前台进入后台</td></tr><tr><td align="left">onError</td><td align="left">当 <code>uni-app</code> 报错时触发</td></tr><tr><td align="left">onUniNViewMessage</td><td align="left">对 <code>nvue</code> 页面发送的数据进行监听，可参考 <a href="https://uniapp.dcloud.io/tutorial/nvue-api?id=communication">nvue 向 vue 通讯</a></td></tr><tr><td align="left">onUnhandledRejection</td><td align="left">对未处理的 Promise 拒绝事件监听函数（2.8.1+ app-uvue 暂不支持）</td></tr><tr><td align="left">onPageNotFound</td><td align="left">页面不存在监听函数</td></tr><tr><td align="left">onThemeChange</td><td align="left">监听系统主题变化</td></tr><tr><td align="left">onLastPageBackPress</td><td align="left">最后一个页面按下Android back键，常用于自定义退出</td></tr><tr><td align="left">onExit</td><td align="left">监听应用退出</td></tr></tbody></table><h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><p>uni-app项目中，一个页面就是一个符合<code>Vue SFC（单文件组件）规范</code>的 vue 文件。</p><p>在 uni-app js 引擎版中，后缀名是<code>.vue</code>文件或<code>.nvue</code>文件。 这些页面均<code>全平台支持</code>，差异在于当 uni-app 发行到<strong>App平台</strong>时，<code>.vue</code>文件会使用<code>webview</code>进行渲染，<code>.nvue</code>会使用原生进行渲染，详见：<a href="https://uniapp.dcloud.net.cn/tutorial/nvue-outline">nvue原生渲染</a>。</p><p>一个页面可以同时存在vue和nvue，在<a href="https://uniapp.dcloud.net.cn/collocation/pages.html">pages.json</a>的路由注册中不包含页面文件名后缀，同一个页面可以对应<strong>2</strong>个文件名。重名时优先级如下：</p><ul><li>在非app平台，先使用vue，忽略nvue</li><li>在app平台，使用nvue，忽略vue</li></ul><h3 id="nvue"><a href="#nvue" class="headerlink" title="nvue"></a><strong>nvue</strong></h3><p>nVue（Native Vue）是由 DCloud 公司开发的一个用于构建原生移动应用的框架。它允许开发者使用 Vue.js 语法来编写代码，但最终生成的是真正的原生 UI 组件，而不是 WebView 中的网页。</p><h4 id="weex"><a href="#weex" class="headerlink" title="weex"></a>weex</h4><p>Weex 是由阿里巴巴集团开发的一个跨平台<code> UI 开发框架</code>，它允许开发者使用 Web 技术（如 HTML、CSS 和 JavaScript）来编写一次代码，并将其部署到多个平台，包括 iOS、Android 和 Web。Weex 的设计理念是“Write Once, Run Everywhere”，即编写一次代码，到处运行，这使得它可以成为构建高效、可维护的跨平台应用的理想选择。</p><img src="..\images\uni-app\weex.png" style="zoom: 67%;" /><p><strong>性能优化</strong></p><p>Weex 生成的是<code>原生组件</code>而不是基于<code>WebView</code>的渲染，因此它提供了接近<code>原生应用</code>的性能表现。它也通过将<code> js逻辑</code>与<code>原生渲染引擎</code>分离，实现了高效的更新机制。</p><p>Weex 的 js引擎是在基础 js引擎（如 JavaScriptCore 或 V8）的基础上进行了扩展，以支持特定的 API 和功能。</p><p><strong>对vue开发者友好</strong></p><p>Weex 使用了类似于 Vue.js 的模板语法和组件化开发模式，对于熟悉 Vue.js 的开发者来说非常友好。此外，Weex 还可以直接集成 Vue.js 的生态系统工具链，如 Vue CLI 和 Vuex 等，但是现在很少直接使用weex开发的了。</p><p><strong>缺点</strong></p><p>Weex 提供了一套<code>基础的 API</code> 来访问设备功能，但这些 API 并没有涵盖<code>所有可能的设备功能</code>或<code>第三方服务集成需求</code>。</p><p>为了解决这些问题，一些团队选择<code>扩展 </code>Weex 的功能集，或者转向其他提供<code>更广泛 API 支持</code>的框架，如 <code>React Native</code> 或 <code>Flutter</code>。此外，DCloud 的<code>nVue</code>框架通过<strong>增强对原生 API 的支持</strong>，解决了 Weex 在这方面的一些局限性，使前端工程师能够更加独立地开发完整应用程序。</p><h4 id="nvue如何实现原生渲染？"><a href="#nvue如何实现原生渲染？" class="headerlink" title="nvue如何实现原生渲染？"></a>nvue如何实现原生渲染？</h4><p><code>uni-app</code> 的<code>App 端</code>内置了一个基于 weex 改进的<strong>原生渲染引擎</strong>，提供了原生渲染能力。</p><p>以往的 weex ，有个很大的问题是它只是一个<code>高性能的渲染器</code>，没有足够的 API 能力（比如各种 push sdk 集成、蓝牙等能力调用），使得开发时非常依赖原生工程师协作，而nvue 解决了这个问题，让前端工程师可以直接开发完整 App，并提供丰富的插件生态和云打包</p><p>同时<code>uni-app</code>扩展了 weex 原生渲染引擎的很多排版能力，修复了很多 bug。</p><p>一个 App 中可以同时使用两种页面，比如首页使用 nvue，二级页使用 vue 页面，hello uni-app 示例就是如此。</p><p>具体步骤：</p><p><strong>编译时</strong></p><ol><li><p><strong>代码转换，资源打包</strong>：</p><ul><li><p><code>uni-app</code> 使用其<code>编译工具</code>将Vue组件、样式和 JavaScript 逻辑转换为适合 iOS 或者 Android 平台的格式。</p></li><li><p>对于 UI 部分，Vue 组件被<code>映射</code>到相应的<strong>原生控件</strong>。例如，一个 <code>&lt;button&gt;</code> 元素会被转换成 iOS 上的 <code>UIButton</code> 或 Android 上的 <code>Button</code> 控件。</p></li><li><p>包括图片、字体等<code>静态资源</code>也会被打包进最终的应用程序。</p></li><li><p>编译器还会优化这些资源以减少应用程序的体积并提高加载速度</p></li><li><p>这两个过程都是基于 <strong>Webpack 或 Vite</strong> 来实现的。</p></li></ul></li><li><p><strong>生成原生项目结构</strong></p><ul><li>编译后的代码文件会被组织成结构规范的项目</li><li>这个过程中会<strong>集成</strong>必要的依赖库和服务，如 JavaScript 引擎（V8 或 JavaScriptCore）、通信桥梁等</li></ul></li><li><p><strong>API 和组件注册</strong>：</p></li></ol><ul><li>编译器确保所有使用的 API 和自定义组件都被正确地注册和配置，以便在<code>运行时</code>可以正常工作。</li></ul><p><strong>运行时</strong></p><p>用户安装并<strong>启动应用程序</strong>后，进入运行时阶段（此时原生渲染真正开始发挥作用）</p><p><strong>JavaScript 引擎初始化</strong>：</p><ul><li>应用程序启动时，首先会初始化 JavaScript 引擎（如 V8 或 JavaScriptCore），准备执行业务逻辑代码</li></ul><p><strong>UI 渲染</strong>：</p><ul><li>根据编译时生成的映射关系，JavaScript 引擎与<code>原生渲染引擎</code>协作，动态创建和管理 UI 组件。</li><li>每次视图更新或状态变化时，JavaScript 逻辑会通过<code>通信桥梁</code>告知原生层进行相应的 UI 更新。</li></ul><p><strong>事件处理和数据绑定</strong>：</p><ul><li>用户交互产生的事件（如点击按钮）会被捕获，并通过通信桥梁传递给 JavaScript 层进行处理。</li><li>数据绑定机制确保了<code>模型数据</code>的变化能够实时反映在界面上，反之亦然。</li></ul><p><strong>调用原生功能</strong>：</p><ul><li>如果应用需要访问设备硬件或操作系统服务（如相机、地理位置），则通过<code>预先定义好的 API</code> 或插件来调用原生功能。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>虽然 nvue 也可以多端编译，输出 H5 和小程序，但 nvue 的 <strong>css 写法受限</strong>，<strong>所以如果你不开发 App，那么不需要使用 nvue。</strong></p><p>如果你熟悉 weex 或 react native 开发，那么开发app时， nvue 是你的更优选择，能切实提升你的开发效率，降低成本。</p><p>如果你是 web 前端，不熟悉原生排版，那么建议你仍然以使用 vue 页面为主，在 App 端某些 vue 页面表现不佳的场景下使用 nvue 作为<code>强化补充</code>。这些场景在官方文档中有介绍，太多了就不写了。</p><h4 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h4><ul><li><p>新建 nvue 页面</p><p>在 HBuilderX 的 <code>uni-app</code> 项目中，新建页面，弹出界面右上角可以选择是建立<code>vue</code>页面还是<code>nvue</code>页面，或者 2 个同时建。</p><p>不管是 vue 页面还是 nvue 页面，都需要在<code>pages.json</code>中注册。如果在 HBuilderX 中新建页面是会自动注册的，如果使用其他编辑器，则需要自行在 pages.json 里注册。</p></li><li><p>开发 nvue 页面</p><p><code>nvue</code> 页面结构同 <code>vue</code>, 由 <code>template</code>、<code>style</code>、<code>script</code> 构成。</p><ul><li>template： 模板写法、数据绑定同 vue。组件支持 2 种模式，<ul><li>weex 组件，同 weex 写法，参考：<a href="http://emas.weex.io/zh/docs/components/a.html">weex 内置组件</a>；</li><li>uni-app 组件，同 uni-app 写法。</li><li>App 端 nvue 专用组件，详见<a href="https://uniapp.dcloud.io/component/barcode%E3%80%82">https://uniapp.dcloud.io/component/barcode。</a></li></ul></li><li>style：由于采用原生渲染，<strong>并非所有浏览器的 css 均支持，布局模型只支持 flex 布局</strong>，虽然不会造成某些界面布局无法实现，但写法要注意。详见：<a href="https://uniapp.dcloud.net.cn/tutorial/nvue-css">样式</a></li><li>script：写法同 vue，并支持 3 种 API：<ul><li>nvue API ：仅支持 App 端，uni-app 编译模式也可使用。使用前需先引入对应模块，参考：<a href="https://uniapp.dcloud.net.cn/tutorial/nvue-api">模块引入 API</a></li><li>uni API：<a href="https://uniapp.dcloud.io/api/README">https://uniapp.dcloud.io/api/README</a></li><li>plus API：仅支持 App 端。<a href="http://www.html5plus.org/doc/h5p.html">http://www.html5plus.org/doc/h5p.html</a></li></ul></li></ul></li></ul><p>更多内容参考：<a href="https://uniapp.dcloud.net.cn/tutorial/nvue-outline.html">nvue介绍 | uni-app官网</a></p><h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><p><code>uni-app</code>中的页面，默认保存在工程根目录下的<code>pages</code>目录下。</p><p>每次新建页面，均需在<code>pages.json</code>中配置<code>pages</code>列表；未在<code>pages.json -&gt; pages</code> 中注册的页面，<code>uni-app</code>会在编译阶段进行忽略。</p><p>通过HBuilderX开发 <code>uni-app</code> 项目时，在 <code>uni-app</code> 项目上右键<code>新建页面</code>，HBuilderX会<strong>自动</strong>在<code>pages.json</code>中完成页面注册，开发更方便。</p><p>同时，HBuilderX 还内置了常用的<strong>页面模板</strong>（如图文列表、商品列表等，区别于之前提到的<code>项目模板</code>），选择这些模板，可以大幅提升你的开发效率。</p><p>新建页面时，可以选择<code>是否创建同名目录</code>。创建目录的意义在于：</p><img src="..\images\uni-app\7.png" style="zoom:90%;" /><ul><li><p>如果你的页面较复杂，需要拆分多个<strong>附属的</strong>js、css、组件等文件，则使用目录归纳比较合适。</p></li><li><p>如果只有一个<code>页面文件</code>，大可不必多放一层目录。</p></li></ul><h3 id="删除页面"><a href="#删除页面" class="headerlink" title="删除页面"></a>删除页面</h3><p>删除页面时，需做两件工作：</p><ul><li>删除<code>.vue</code>文件、<code>.nvue</code>、<code>.uvue</code>文件</li><li>删除<code>pages.json -&gt; pages</code>列表项中的配置 （如使用HBuilderX删除页面，会在状态栏<strong>提醒删除</strong>pages.json对应内容，点击后会打开pages.json并定位到相关配置项）</li></ul><h3 id="页面改名"><a href="#页面改名" class="headerlink" title="页面改名"></a>页面改名</h3><p>操作和删除页面同理，依次修改文件和 <code>pages.json</code>。</p><h3 id="页面文件结构分析"><a href="#页面文件结构分析" class="headerlink" title="页面文件结构分析"></a>页面文件结构分析</h3><p>页面文件结构就是vue文件呗，学过vue的都比较熟悉了。</p><p>uni-app 页面基于 vue 规范。一个页面内，有3个根节点标签：</p><ul><li>模板组件区 <code>&lt;template&gt;</code></li><li>脚本区 <code>&lt;script&gt;</code></li><li>样式区 <code>&lt;style&gt;</code></li></ul><h3 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h3><p><code>uni-app</code> 页面除支持<code> Vue 组件生命周期</code>外还支持下方<code>页面生命周期函数</code>(节选)，其实无论组件还是页面，都是vue文件。</p><p>当以组合式 API 使用时，在 Vue2 和 Vue3 中存在一定区别。如果使用的是vue3语法，这些uni-app页面独有的生命周期函数使用前也要按需导入。</p><table><thead><tr><th align="left">函数名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">onInit</td><td align="left">监听<strong>页面初始化</strong>，其参数同 onLoad 参数，为<code>上个页面传递</code>的数据，参数类型为 Object（用于页面传参），触发时机<code>早于</code> onLoad，只存在于百度小程序。</td></tr><tr><td align="left">onLoad</td><td align="left">监听<strong>页面加载</strong>，该钩子被调用时，响应式数据、计算属性、方法、侦听器、props、slots 已设置完成，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考<a href="https://uniapp.dcloud.net.cn/api/router#navigateto">示例</a>。</td></tr><tr><td align="left">onShow</td><td align="left">监听页面显示，页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面</td></tr><tr><td align="left">onReady</td><td align="left">监听页面<strong>初次渲染完成</strong>，此时组件已挂载完成，DOM 树($el)已可用，注意如果渲染速度快，会在页面进入动画完成前触发</td></tr><tr><td align="left">onHide</td><td align="left">监听页面隐藏</td></tr><tr><td align="left">onUnload</td><td align="left">监听页面卸载</td></tr><tr><td align="left">onResize</td><td align="left">监听窗口尺寸变化</td></tr><tr><td align="left">onPullDownRefresh</td><td align="left">监听用户下拉动作，一般用于<code>下拉刷新</code></td></tr><tr><td align="left">onReachBottom</td><td align="left">页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据。具体见下方注意事项</td></tr><tr><td align="left">onTabItemTap</td><td align="left">点击 tab 时触发，参数为Object，具体见下方注意事项</td></tr><tr><td align="left">onShareAppMessage</td><td align="left">用户点击右上角分享</td></tr><tr><td align="left">onPageScroll</td><td align="left">监听页面滚动，参数为Object</td></tr><tr><td align="left">onShareTimeline</td><td align="left">监听用户点击右上角转发到朋友圈</td></tr><tr><td align="left">onAddToFavorites</td><td align="left">监听用户点击右上角收藏</td></tr></tbody></table><p>页面生命周期，说白了就是页面会自动监听某些事件，并执行对应的回调函数，面试的时候问的就是自己如何实现了….</p><p>官方文档还给出了生命周期流程图，下面只给出使用<code>vue2</code>开发的页面声明周期流程图，与vue3对应的流程图区别只在于<code>部分生命周期函数的名称</code>不同（beforeDestory-&gt;beforeUnmount，Destoryed-&gt;Unmounted）</p><img src="..\images\uni-app\uni-app-lifecycle-vue2.jpg" style="zoom: 80%;" /><h4 id="onShow和onHide"><a href="#onShow和onHide" class="headerlink" title="onShow和onHide"></a>onShow和onHide</h4><p>注意页面显示，是一个会重复触发的事件。a页面刚进入时，会触发a页面的onShow。</p><p>当a跳转到b页面时，a会触发onHide，而b会触发onShow。但当b被关闭时，b会触发onUnload，此时a再次显示出现，会再次触发onShow。在tabbar页面（指pages.json里配置的tabbar），不同tab页面互相切换时，会触发各自的onShow和onHide，还是比较好理解的。</p><h4 id="onLoad"><a href="#onLoad" class="headerlink" title="onLoad"></a>onLoad</h4><p>onLoad比较适合的操作是：接受上页的参数，联网取数据，更新data。其参数为上个页面传递的数据，参数类型为 Object</p><h4 id="onReachBottom"><a href="#onReachBottom" class="headerlink" title="onReachBottom"></a>onReachBottom</h4><p>可在pages.json里定义具体页面底部的触发距离，比如设为50（不需要单位），那么滚动页面到距离底部50px时，就会触发onReachBottom事件。</p><p>如使用<code>scroll-view</code>导致页面没有滚动，则触底事件不会被触发。scroll-view滚动到底部的事件请参考scroll-view的文档</p><h2 id="uni-app组成和跨端原理"><a href="#uni-app组成和跨端原理" class="headerlink" title="uni-app组成和跨端原理"></a>uni-app组成和跨端原理</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>uni-app代码编写，基本语言包括js、vue、css。以及ts、scss等css预编译器。</p><p>在app端，还支持原生渲染的<a href="https://uniapp.dcloud.net.cn/tutorial/nvue-outline.html">nvue</a>，以及可以编译为kotlin和swift的<a href="https://doc.dcloud.net.cn/uni-app-x/uts/">uts</a>。</p><p>DCloud还提供了使用js编写服务器代码的uniCloud云引擎。所以只需掌握js，你可以开发web、Android、iOS、各家小程序以及服务器等<code>全栈应用</code>(我嘞个全栈啊)。</p><h3 id="跨端原理"><a href="#跨端原理" class="headerlink" title="跨端原理"></a>跨端原理</h3><p>uni-app分<code>编译器</code>和<code>运行时（runtime）</code>。uni-app能实现<strong>一套代码、多端运行</strong>，是通过这2部分配合完成的。</p><p>编译器将开发者的代码进行编译，编译的<code>输出物（每个平台支持的特有代码）</code>由各个终端的<code>runtime</code>进行解析，每个平台（Web、Android App、iOS App、各家小程序）都有各自的<code>runtime</code>。</p><p><strong>总结的来说</strong>，uni-app能实现跨端，基于uni-app的编译器和提供的运行时环境（runtime）；</p><p>uni-app的编译器基于webpack或者vite，在编译过程中，能把基于uni-app规范编写的代码<strong>转化，打包</strong>成能在特定平台上运行的代码，并这个过程中集成相应的<strong>runtime</strong>；编译打包后的代码<strong>文件</strong>，还会被组织成在<strong>结构</strong>上符合特定平台规范的<strong>项目</strong>。</p><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><img src="..\images\uni-app\编译器.png" style="zoom:67%;" /><ul><li><p>编译器运行在电脑开发环境。一般是<strong>内置在HBuilderX工具中</strong>，也可以使用独立的cli版。</p><p>使用<code>HBuilderX</code>可视化界面创建的项目，编译器在<code>HBuilderX</code>的安装目录下的<code>plugin</code>目录，随着<code>HBuilderX</code>的升级会自动升级编译器。</p><img src="..\images\uni-app\编译器2.png" style="zoom:100%;" /></li><li><p>开发者按<code>uni-app</code>规范编写代码，由编译器将开发者的代码编译生成<code>特定平台支持的代码</code></p><ul><li>在web平台，将<code>.vue</code>文件编译为js，css代码。与普通的vue cli项目类似</li><li>在微信小程序平台，编译器将<code>.vue</code>文件拆分生成wxml、wxss、js等代码。</li><li>在app平台，将<code>.vue</code>文件编译为js代码。进一步，如果涉及uts代码：<ul><li>在Android平台，将.uts文件编译为kotlin代码</li><li>在iOS平台，将.uts文件编译为swift代码</li></ul></li></ul></li></ul><ul><li><p>编译器分vue2版和vue3版</p><ul><li>vue2版：基于<code>webpack</code>实现</li><li>vue3版：基于<code>Vite</code>实现，性能更快</li><li>这些工具本身都是基于<code>Node.js</code>平台开发的，因此在你的本地开发环境中必须安装<code> Node.js</code> 来运行这些构建脚本。</li></ul></li><li><p>编译器支持<code>条件编译</code>，即可以指定某部分代码只编译到特定的终端平台。从而将公用和个性化融合在一个工程中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #ifdef  App</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这段代码只有在App平台才会被编译进去。非App平台编译后没有这段代码&quot;</span>)</span><br><span class="line"><span class="comment">// #endif</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h4><img src="..\images\uni-app\runtime.png" style="zoom:80%;" /><p>uni-app在每个平台都准备了相应的runtime，会在编译的过程中集成到项目中。</p><ul><li>uni-app给小程序端提供的runtime，主要是一个小程序版的vue runtime，页面路由、组件、api等方面基本都是转义。</li><li>uni-app给web端提供的runtime，相比普通的vue项目，多了一套ui库、页面路由框架、和uni对象（即常见API封装）</li><li>uni-app给App端提供的runtime更复杂，可以先简单理解为DCloud也有一套小程序引擎，打包app时将开发者的代码和DCloud的小程序打包成了apk或ipa。当然，事实上DCloud确实有小程序引擎产品，供原生应用实现小程序化。</li></ul><p><strong>uni-app提供的runtime</strong>包括3部分：<strong>基础框架、组件、API</strong>。</p><ol><li>基础框架：<ul><li>包括语法、数据驱动、全局文件、应用管理、页面管理、<strong>js引擎</strong>、<strong>渲染和排版引擎</strong>等</li><li>在<code>web</code>和<code>小程序</code>上，不需要uni-app提供<code>js引擎</code>和<code>排版引擎</code>。因为浏览器有自己的webview，也就是浏览器内核，可以执行渲染和运行js代码的工作；各个小程序平台也有自己的<code>webview</code>和<code>js引擎</code>；但安卓上需要uni-app提供<code>谷歌v8引擎</code>，webview则使用系统自带的；ios上也不需要uni-app提供js引擎和webview，都使用ios系统自带的。</li><li>App的渲染引擎：<strong>同时提供了2套渲染引擎</strong>，<code>.vue</code>页面文件由webview渲染，原理与小程序相同；<code>.nvue</code>页面文件由<code>原生渲染</code>，原理与react native相同。开发者可以根据需要自主选择渲染引擎。</li></ul></li><li>组件<ul><li>在小程序端，uni-app基础组件会直接<code>转义</code>为小程序自己的内置组件。提供给小程序的runtime中基础组件不占体积</li><li>在web和android、iOS端，这几十个组件都在uni-app的runtime中，会占用一定体积，相当于内置了一套ui库。</li></ul></li><li>api<ul><li>uni-app runtime内置了大量常见的、跨端的 <a href="https://uniapp.dcloud.net.cn/api/index.html">API</a>，比如联网(uni.request)、读取存储(uni.getStorage)</li><li>使用uni-app的标准API，可以<code>跨端</code>使用。但对于不跨端的部分(就是某个平台的特色api)，仍可以调用该端的<code>专有API</code>。由于常见的API都已经被封装内置，所以日常开发时，开发者只需关注<code>uni标准API</code>，当需要调用特色端能力时在<strong>条件编译</strong>里编写特色API调用代码。</li><li>小程序平台：<code>uni</code>对象会转为<strong>小程序的自有对象</strong>，比如在微信小程序平台，编写uni.request等同于wx.request。</li><li>web平台：window、dom等浏览器专用API仍可以使用</li></ul></li></ol><h2 id="逻辑层和渲染层分离"><a href="#逻辑层和渲染层分离" class="headerlink" title="逻辑层和渲染层分离"></a>逻辑层和渲染层分离</h2><p>在web平台，逻辑层（js）和渲染层（html、css），都运行在统一的webview（浏览器内核）里，也就是说web平台的逻辑层和渲染层并没有分离。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           但在<code>小程序</code>和<code>app</code>端，逻辑层和渲染层被分离了。</p><p>逻辑层独立成了<code>单独的js引擎(jscore或者v8引擎)</code>，负责执行业务逻辑；</p><p>渲染层仍然是<code>webview</code>，负责页面渲染。简单来说，就是由<code>单线程</code>转换成了<code>双线程</code>。</p><p>要注意的是这里的app端，指的是<strong>混合开发的app</strong>，即混合了前端开发技术和app原生开发技术，而不是原生app；使用uni-app开发的app都混合app，原生app是不涉及前端技术的，比如js的。</p><p>虽然开发者在一个 vue 页面里写 js 和 css，但其实，<code>编译时</code>就已经将它们拆分了。</p><p>分离的核心原因是<strong>性能</strong>。过去很多开发者吐槽<code>基于webview</code>的app性能不佳，很大原因是<code>js运算</code>和<code>界面渲染</code>抢资源导致的卡顿，这一也说明，webview<strong>其实是能执行js代码的</strong>，只不过为了提高性能，现在只被用来渲染。</p><h3 id="逻辑层详解"><a href="#逻辑层详解" class="headerlink" title="逻辑层详解"></a>逻辑层详解</h3><p>逻辑层是运行在一个<code>独立的</code> js引擎里的，它不依赖于本机的 webview，所以一方面它没有浏览器兼容问题，可以在 Android4.4 上跑 es6 代码；另一方面，它无法运行 <code>window</code>、<code>document</code>、<code>navigator</code>、<code>localstorage</code> 等浏览器专用的 js API。</p><p>比如，<code>jscore</code>就是一个<strong>标准 js 引擎</strong>，可以正常运行<code>标准 js（ECMAscript） </code>，比如 if、for、各种字符串、日期处理等。</p><img src="..\images\uni-app\jscore.jpg" style="zoom:50%;" /><ul><li>所谓<code>浏览器 js 引擎</code>，就是 <code>jscore</code> 或 <code>v8</code> 的基础上新增了一批<code>浏览器专用 API</code>，比如 dom；</li><li>node.js 引擎，则是 <code>v8</code> 基础上补充一些<code>电脑专用 API</code>，比如本地 io；</li><li><code>小程序端</code>的 js 引擎，其实是在 <code>jscore</code> 上补充了一批<code>手机端常用的 JS API</code>，比如扫码;</li><li>安卓端的js引擎，则是在<code>谷歌v8引擎</code>的基础上添加了一些手机端常用的 JS API；ios端的js引擎则是基于<code>iOS操作系统</code>提供的<code>jscore</code>。</li></ul><h3 id="视图层详解"><a href="#视图层详解" class="headerlink" title="视图层详解"></a>视图层详解</h3><p>视图层交由webview渲染。</p><ul><li>h5的webview就是浏览器内核</li><li>而小程序平台有自己的<code>webview</code>组件，本质也类似浏览器内核。</li><li>在 iOS 上，只能使用 iOS 提供的 Webview（默认是 <code>WKWebview</code>）。它有一定的<strong>兼容问题</strong>，iOS 版本不同，它的表现有细微差异。</li><li>安卓App 端默认使用了 <code>Android system webview</code>，这个<strong>安卓系统 webview</strong> 跟随<code>手机不同</code>而有<strong>差异</strong>。当然 App 端也支持使用<code>腾讯 X5 引擎</code>，此时可以在 Android 端统一视图层。</li></ul><h3 id="逻辑层和视图层分离的利与弊"><a href="#逻辑层和视图层分离的利与弊" class="headerlink" title="逻辑层和视图层分离的利与弊"></a>逻辑层和视图层分离的利与弊</h3><p>逻辑层和视图层分离，好处是 js 运算不阻塞渲染，最简单直接的感受就是：窗体动画稳。</p><p>缺点是，逻辑层和视图层属于2个不同的线程，不同线程之间的通信是有一定延时的。</p><h2 id="js语法"><a href="#js语法" class="headerlink" title="js语法"></a>js语法</h2><h3 id="浏览器js与标准js"><a href="#浏览器js与标准js" class="headerlink" title="浏览器js与标准js"></a>浏览器js与标准js</h3><p><code>uni-app</code>的js API由标准<code>ECMAScript</code>的js API 和 <code>uni扩展API </code>这两部分组成。</p><p>标准ECMAScript的js仅是<code>最基础</code>的js。浏览器基于它扩展了window、document、navigator等对象。小程序也基于标准js扩展了各种wx.xx、my.xx、swan.xx的API。node也扩展了fs等模块。</p><p>所以说浏览器js不等于标准js。</p><h3 id="ES6-支持"><a href="#ES6-支持" class="headerlink" title="ES6 支持"></a>ES6 支持</h3><p>uni-app 在支持绝大部分 ES6 API 的同时，也支持了 ES7 的 await&#x2F;async（爽）</p><p>具体支持情况参考官方文档。</p><h3 id="App端"><a href="#App端" class="headerlink" title="App端"></a>App端</h3><p>在App端JS脚本运行在<strong>独立的JS引擎</strong>（jscore）中，vue页面使用<code>系统webview</code>渲染，nvue页面使用系统<code>原生View</code>渲染。</p><h4 id="Android平台"><a href="#Android平台" class="headerlink" title="Android平台"></a>Android平台</h4><ul><li>JS脚本运行在<strong>独立Google V8引擎</strong>中，因此支持的语法与Android系统版本无关</li><li>vue页面渲染在<code>系统Webview(android system webview)</code>中，受Android系统版本影响，当然也可以使用x5等三方webview来拉齐实现。</li><li>nvue页面使用系统原生View渲染，css支持情况参考：<a href="https://uniapp.dcloud.net.cn/tutorial/nvue-css.html">nvue页面样式</a></li></ul><h4 id="iOS平台"><a href="#iOS平台" class="headerlink" title="iOS平台"></a>iOS平台</h4><ul><li>JS脚本运行在iOS操作系统提供的<strong>JsCore</strong> 引擎，因此支持的语法与iOS系统有关</li><li>vue页面渲染在系统<code>WKWebview</code>中，受iOS系统版本影响</li><li>nvue页面使用系统原生View渲染，css支持情况参考：<a href="https://uniapp.dcloud.net.cn/tutorial/nvue-css.html">nvue页面样式</a></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>安卓平台的js引擎是独立于安卓的，非常稳定；</p><p>而vue页面的渲染则基于<code>系统webview</code>，受Android系统版本影响，但是使用第三方webview来替代<code>安卓系统webview</code>，从而消除安卓系统不同带来的渲染差异。</p></li><li><p>ios平台的js引擎是ios操作系统提供的，受iOS系统版本影响；</p><p>而vue页面的渲染同样基于系统<code>WKWebview</code>，受iOS系统版本影响；</p></li></ul><h2 id="css语法"><a href="#css语法" class="headerlink" title="css语法"></a>css语法</h2><h3 id="处理器支持"><a href="#处理器支持" class="headerlink" title="处理器支持"></a>处理器支持</h3><p>uni-app 支持less、sass、scss、stylus等预处理器，但是需要安装相应的插件。</p><h3 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h3><p><code>uni-app</code> 支持的<strong>通用 css 单位</strong>包括 px、rpx。</p><ul><li>px 即屏幕像素</li><li>rpx 即响应式 px，一种根据屏幕宽度自适应的动态单位。以 750 宽的屏幕为基准，750rpx 恰好为屏幕宽度。屏幕变宽，rpx 实际显示效果会等比放大，但在 App（vue2 不含 nvue） 端和 H5（vue2） 端屏幕宽度达到 960px 时，默认将按照 375px 的屏幕宽度进行计算，具体配置参考：<a href="https://uniapp.dcloud.net.cn/collocation/pages#globalstyle">rpx 计算配置</a> 。</li></ul><p>vue 页面还支持<code>rem,vw,vh</code></p><p><code>nvue</code>页面还不支持百分比单位。</p><h3 id="样式导入"><a href="#样式导入" class="headerlink" title="样式导入"></a>样式导入</h3><p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用<code>;</code>表示语句结束。</p><p>在模块化开发环境中，还可以使用<code>import  &quot;../../common/uni.css&quot;</code>的方式导入css文件。</p><p><strong>示例代码：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="keyword">@import</span> <span class="string">&quot;../../common/uni.css&quot;</span>;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.uni-card</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">box-shadow</span>: none;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>支持的选择器包括类选择器，id选择器，标签选择器，并集选择器，伪元素选择器。</p><p><strong>注意：</strong></p><ul><li><p>在 <code>uni-app</code> 中不能使用 <code>*</code> 选择器。</p></li><li><p>微信小程序自定义组件中仅支持 class 选择器</p></li><li><p><code>page</code> 相当于 <code>body</code> 节点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 设置页面背景颜色，使用 scoped 会导致失效 -- &gt;</span><br><span class="line">page &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="全局样式与局部样式"><a href="#全局样式与局部样式" class="headerlink" title="全局样式与局部样式"></a>全局样式与局部样式</h3><p>定义在 <code>App.vue </code>中的样式为全局样式，作用于每一个页面。在 pages 目录下 的 vue 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 App.vue 中相同的选择器。</p><p><strong>注意：</strong></p><ul><li>App.vue 中通过 <code>@import</code> 语句可以导入<code>外联样式</code>，一样作用于每一个页面。</li><li>nvue 页面暂不支持全局样式</li></ul><h3 id="css变量"><a href="#css变量" class="headerlink" title="css变量"></a>css变量</h3><p>uni-app 提供内置 CSS 变量</p><table><thead><tr><th align="left">CSS 变量</th><th align="left">描述</th><th align="left">App</th><th align="left">小程序</th><th align="left">H5</th></tr></thead><tbody><tr><td align="left">–status-bar-height</td><td align="left">系统状态栏高度</td><td align="left"><a href="http://www.html5plus.org/doc/zh_cn/navigator.html#plus.navigator.getStatusbarHeight">系统状态栏高度</a>、nvue 注意见下</td><td align="left">25px</td><td align="left">0</td></tr><tr><td align="left">–window-top</td><td align="left">内容区域距离顶部的距离</td><td align="left">0</td><td align="left">0</td><td align="left">NavigationBar 的高度</td></tr><tr><td align="left">–window-bottom</td><td align="left">内容区域距离底部的距离</td><td align="left">0</td><td align="left">0</td><td align="left">TabBar 的高度</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li><code>var(--status-bar-height)</code> 此变量在微信小程序环境为固定 <code>25px</code>，在 App 里为手机实际<strong>状态栏</strong>高度。</li><li>当设置 <code>&quot;navigationStyle&quot;:&quot;custom&quot;</code> 取消<code>原生导航栏</code>后，由于窗体为沉浸式，占据了状态栏位置。此时可以使用一个高度为 <code>var(--status-bar-height)</code> 的 view 放在页面顶部，使用<code>sticky布局</code>，避免页面内容出现在状态栏(避免页面内容压住状态栏)。</li><li>由于在 H5 端，不存在原生导航栏和 tabbar，也是前端 div 模拟。如果设置了一个固定位置的居底 view，在小程序和 App 端是在 tabbar 上方，但在 H5 端会与 tabbar 重叠。此时可使用<code>--window-bottom</code>，不管在哪个端，都是固定在 tabbar 上方。</li><li>目前 nvue 在 App 端，还不支持 <code>--status-bar-height</code>变量，替代方案是在页面 <code>onLoad</code> 时通过 <code>uni.getSystemInfoSync().statusBarHeight</code> 获取状态栏高度，然后通过 style 绑定方式给占位 view 设定高度。</li></ul><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p><code>uni-app</code> 支持使用在 css 里设置背景图片，使用方式与普通 <code>web</code> 项目大体相同，但需要注意以下几点：</p><ul><li><p>支持 base64 格式图片。</p></li><li><p>支持网络路径图片。</p></li><li><p><code>小程序</code>不支持在 css 中使用本地文件，包括本地的<code>背景图</code>和<code>字体文件</code>。需以 <code>base64 </code>方式方可使用。</p></li><li><p>在小程序中使用<code>本地路径</code>背景图片需注意：</p><ol><li>为方便开发者，在背景图片小于 40kb 时，<code>uni-app</code> 编译到不支持本地背景图的平台时，会自动将其转化为 base64 格式；</li><li>图片大于等于 40kb，会有性能问题，不建议使用太大的背景图，如开发者必须使用，则需自己将其转换为 base64 格式使用，或将其挪到服务器上，从网络地址引用。</li><li>本地背景图片的引用路径推荐使用以<code>~@</code>开头的绝对路径，<code>微信小程序</code>不支持相对路径（真机不支持，开发工具支持）</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test2</span> &#123;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;~@/static/logo.png&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>简单的来说就是<strong>对于小程序，在css中使用本地图片是不被支持的</strong>，如果非要使用，当图片大小小于40kb，uni-app则会帮你把它转化成base64格式，否则需要手动转化成base64格式或者网络图片，否则就会出错。</p><p><strong>字体文件</strong>同理。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><p>通过uni-app的<code>easycom</code>， 将组件引入精简为一步。只要<code>自定义组件</code>安装在项目的 <code>components </code>目录下，并符合 <code>components/组件名称/组件名称.vue </code>目录结构。就可以<code>不用引用、不注册</code>，直接在页面中使用，非常方便。</p><p><strong>说明</strong></p><ul><li><p><code>easycom</code>是<code>自动开启</code>的，不需要手动开启，有需求时可以在<code>pages.json</code>的<code>easycom</code>节点进行个性化设置，如关闭自动扫描，或自定义扫描匹配组件的策略。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;easycom&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;autoscan&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span><span class="comment">//默认开启</span></span><br><span class="line">  <span class="comment">//以正则方式自定义组件匹配规则。如果autoscan不能满足需求，可以使用custom自定义匹配规则</span></span><br><span class="line">  <span class="attr">&quot;custom&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;^uni-(.*)&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@/components/uni-$1.vue&quot;</span><span class="punctuation">,</span> <span class="comment">// 匹配components目录内的vue文件</span></span><br><span class="line">    <span class="attr">&quot;^vue-file-(.*)&quot;</span><span class="punctuation">:</span> <span class="string">&quot;packageName/path/to/vue-file-$1.vue&quot;</span> <span class="comment">// 匹配node_modules内的vue文件</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><code>easycom</code>方式引入的组件无需在页面内<code>import</code>，也不需要在<code>components</code>内声明，即无需引入无需注册，可在任意页面使用。</li><li><code>easycom</code>方式引入组件不是全局引入，而是<strong>局部引入</strong>。例如在H5端只有加载相应页面才会加载使用的组件。</li><li>在组件名完全一致的情况下，<code>easycom</code>引入的优先级低于手动引入（区分连字符形式与驼峰形式）。</li><li><code>easycom</code>只处理vue组件，不处理小程序专用组件（如微信的wxml格式组件）</li></ul><p><a href="https://uniapp.dcloud.net.cn/collocation/pages.html#easycom">pages.json 页面路由 | uni-app官网</a></p><h3 id="下载组件"><a href="#下载组件" class="headerlink" title="下载组件"></a>下载组件</h3><p>uni-app有许多内置的组件，比如view，scroll-view。还有许多官方提供的扩展组件。</p><p>如果使用的是<code>uni-ui</code>模板的项目，则这些扩展组件都在创建项目的时候下载好了(都下载到了根目录下的<code>uni_modules</code>文件中)，这样的好处就是<strong>不需要手动下载组件</strong>，直接使用即可；</p><p>而且这些组件并不是会无条件地，全部被打包进最终文件。具体来说，打包工具（如 Webpack 或 Vite）会根据你实际使用的组件来决定哪些内容会被包含在最终的应用程序中(tree-shaking)。</p><p>如果你没有创建<code>uni-ui</code>项目模板，也可以在你的工程里，通过 <code>uni_modules </code>单独安装需要的某个组件。导入指定项目后直接使用即可，这些组件也<strong>无需import和注册，就可以直接使用</strong>，也是得益于<code>eazycom</code>机制。</p><h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><img src="..\images\uni-app\uni-js.png" style="zoom:80%;" /><p><code>uni-app</code>的 js API 由标准 ECMAScript 的 js API 和 uni 扩展 API 这两部分组成。</p><p>标准 ECMAScript 的 js 仅是最基础的 js。浏览器基于它扩展了 window、document、navigator 等对象。小程序也基于标准 js 扩展了各种 wx.xx、my.xx、swan.xx 的 API。node 也扩展了 fs 等模块。</p><p>uni-app 基于 ECMAScript 扩展了 <strong>uni 对象</strong>，uni-app的几乎所有API都包含在这个对象上，并且 API 命名与小程序保持兼容。</p><p>除了 uni-app 框架内置的跨端 API（会被自动编译成特定平台对应的api），各端自己的特色 API 也可通过<a href="https://uniapp.dcloud.io/platform">条件编译</a>自由使用。各端特色 API 规范参考各端的开发文档。</p><h3 id="API-Promise-化"><a href="#API-Promise-化" class="headerlink" title="API Promise 化"></a>API Promise 化</h3><p>异步的方法，如果不传入 success、fail、complete 等 callback 参数，将以 Promise 返回数据。例如：<code>uni.getImageInfo()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常使用</span></span><br><span class="line"><span class="keyword">const</span> task = uni.<span class="title function_">connectSocket</span>(&#123;</span><br><span class="line">  <span class="title function_">success</span>(<span class="params">res</span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> <span class="comment">// Promise 化</span></span><br><span class="line">uni.<span class="title function_">connectSocket</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 此处即为正常使用时 success 回调的 res</span></span><br><span class="line">  <span class="comment">// uni.connectSocket() 正常使用时是会返回 task 对象的，如果想获取 task ，则不要使用 Promise 化</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>原来不用自己<code>new Promise()</code>啊😂</p><h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><h4 id="uni-request-OBJECT"><a href="#uni-request-OBJECT" class="headerlink" title="uni.request(OBJECT)"></a><strong>uni.request(OBJECT)</strong></h4><p>object（传入api的对象）的<strong>常用</strong>属性：</p><table><thead><tr><th align="left">参数名</th><th align="left">类型</th><th align="left">必填</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">String</td><td align="left">是</td><td align="left"></td><td align="left">开发者服务器接口地址</td></tr><tr><td align="left">data</td><td align="left">Object&#x2F;String&#x2F;ArrayBuffer</td><td align="left">否</td><td align="left"></td><td align="left">请求的参数</td></tr><tr><td align="left">header</td><td align="left">Object</td><td align="left">否</td><td align="left"></td><td align="left">设置请求的 header，header 中不能设置 Referer</td></tr><tr><td align="left">method</td><td align="left">String</td><td align="left">否</td><td align="left">GET</td><td align="left">有效值详见下方说明</td></tr><tr><td align="left">dataType</td><td align="left">String</td><td align="left">否</td><td align="left">json</td><td align="left">如果设为 json，会对返回的数据进行一次 JSON.parse，非 json 不会进行 JSON.parse</td></tr><tr><td align="left">responseType</td><td align="left">String</td><td align="left">否</td><td align="left">text</td><td align="left">设置响应的数据类型。合法值：text、arraybuffer</td></tr><tr><td align="left">withCredentials</td><td align="left">Boolean</td><td align="left">否</td><td align="left">false</td><td align="left">跨域请求时是否携带凭证（cookies）</td></tr><tr><td align="left">defer</td><td align="left">Boolean</td><td align="left">否</td><td align="left">false</td><td align="left">控制当前请求是否延时至首屏内容渲染后发送</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left"></td><td align="left">收到开发者服务器成功返回的回调函数，第一个参数是个对象，属性包括：data，statusCode，header，cookies</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left"></td><td align="left">接口调用失败的回调函数，的第一个参数是个对象，属性包括：errCode，errSubject，data，cause，errMsg</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left"></td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><ul><li><p>method有效值<strong>必须大写</strong>，每个平台支持的method有效值不同</p></li><li><p>success 返回参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">data</td><td align="left">Object&#x2F;String&#x2F;ArrayBuffer</td><td align="left">开发者服务器返回的数据</td></tr><tr><td align="left">statusCode</td><td align="left">Number</td><td align="left">开发者服务器返回的 HTTP 状态码</td></tr><tr><td align="left">header</td><td align="left">Object</td><td align="left">开发者服务器返回的 HTTP Response Header</td></tr><tr><td align="left">cookies</td><td align="left"><code>Array&lt;string&gt;</code></td><td align="left">开发者服务器返回的 cookies，格式为字符串数组</td></tr></tbody></table></li></ul><p><strong>requestTask对象</strong></p><p>如果希望返回一个 <code>requestTask</code> 对象，需要至少传入 <code>success / fail / complete </code>参数中的一个。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestTask = uni.<span class="title function_">request</span>(&#123;</span><br><span class="line"><span class="attr">url</span>: <span class="string">&#x27;https://www.example.com/request&#x27;</span>, <span class="comment">//仅为示例，并非真实接口地址。</span></span><br><span class="line"><span class="attr">complete</span>: <span class="function">()=&gt;</span> &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">requestTask.<span class="title function_">abort</span>();<span class="comment">//中断请求</span></span><br></pre></td></tr></table></figure><p>如果没有传入 success &#x2F; fail &#x2F; complete 参数，则会返回封装后的 Promise 对象，通过 <code>requestTask</code>，可中断请求任务。</p><p>对于uni.request这个api无论是否传入回调函数，都会返回一个对象，只不过返回对象的类型不同。</p><h3 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h3><h4 id="uni-navigateTo-OBJECT"><a href="#uni-navigateTo-OBJECT" class="headerlink" title="uni.navigateTo(OBJECT)"></a>uni.navigateTo(OBJECT)</h4><ul><li><strong>保留当前页面</strong>，跳转到应用内的某个页面，使用<code>uni.navigateBack</code>可以返回到原页面。</li><li>只能跳转到<strong>非tabbar页面</strong>。</li><li>路由API的目标页面必须是在<code>pages.json</code>里注册的vue页面，如果想打开web url，参考官方文档。</li></ul><p>OBJECT常用参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">必填</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">String</td><td align="left">是</td><td align="left"></td><td align="left">需要跳转的应用内<code>非 tabBar </code>的页面的路径 , 路径后可以<strong>带参数</strong>。参数与路径之间使用?分隔，参数键与参数值用&#x3D;相连，不同参数用&amp;分隔；如 ‘path?key&#x3D;value&amp;key2&#x3D;value2’，path为下一个页面的路径，下一个页面的onLoad函数可得到传递的参数</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left"></td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left"></td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left"></td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在起始页面跳转到test.vue页面并传递参数</span></span><br><span class="line">uni.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line"><span class="attr">url</span>: <span class="string">&#x27;test?id=1&amp;name=uniapp&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在test.vue页面接受参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="attr">onLoad</span>: <span class="keyword">function</span> (<span class="params">option</span>) &#123; <span class="comment">//option为object类型，会序列化上个页面传递的参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(option.<span class="property">id</span>); <span class="comment">//打印出上个页面传递的参数。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(option.<span class="property">name</span>); <span class="comment">//打印出上个页面传递的参数。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="uni-navigateBack-OBJECT"><a href="#uni-navigateBack-OBJECT" class="headerlink" title="uni.navigateBack(OBJECT)"></a>uni.navigateBack(OBJECT)</h4><p><strong>关闭当前页面</strong>，返回上一页面或多级页面。可通过 <code>getCurrentPages()</code> 获取当前的页面栈，决定需要返回几层。</p><p>OBJECT参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">必填</th><th align="left">默认值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">delta</td><td align="left">Number</td><td align="left">否</td><td align="left">1</td><td align="left">返回的页面数，如果 delta 大于现有页面数，则返回到首页。</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left"></td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left"></td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left"></td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。见下方示例代码</span></span><br><span class="line"><span class="comment">// 此处是A页面</span></span><br><span class="line">uni.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line"><span class="attr">url</span>: <span class="string">&#x27;B?id=1&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 此处是B页面</span></span><br><span class="line">uni.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line"><span class="attr">url</span>: <span class="string">&#x27;C?id=1&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 在C页面内 navigateBack，将返回A页面</span></span><br><span class="line">uni.<span class="title function_">navigateBack</span>(&#123;</span><br><span class="line"><span class="attr">delta</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="uni-redirectTo-OBJECT"><a href="#uni-redirectTo-OBJECT" class="headerlink" title="uni.redirectTo(OBJECT)"></a>uni.redirectTo(OBJECT)</h4><ul><li><strong>关闭当前页面</strong>，跳转到应用内的某个页面，不能跳转到 tabBar 页面。</li><li>和navigateTo的主要区别是这个api会关闭当前页面，而navigateTo不会</li></ul><p>OBJECT参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">String</td><td align="left">是</td><td align="left">需要跳转的应用内<code>非 tabBar </code>的页面的路径，路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用&#x3D;相连，不同参数用&amp;分隔；如 ‘path?key&#x3D;value&amp;key2&#x3D;value2’</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h4 id="uni-reLaunch-OBJECT"><a href="#uni-reLaunch-OBJECT" class="headerlink" title="uni.reLaunch(OBJECT)"></a>uni.reLaunch(OBJECT)</h4><ul><li><strong>关闭所有页面</strong>，打开到应用内的某个页面，包括tabbar页面。</li></ul><p>OBJECT参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">String</td><td align="left">是</td><td align="left">需要跳转的应用内页面路径 , 路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用&#x3D;相连，不同参数用&amp;分隔；如 ‘path?key&#x3D;value&amp;key2&#x3D;value2’，如果跳转的页面路径是<code> tabBar 页面</code>则不能带参数</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h4 id="uni-switchTab-OBJECT"><a href="#uni-switchTab-OBJECT" class="headerlink" title="uni.switchTab(OBJECT)"></a>uni.switchTab(OBJECT)</h4><ul><li>跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。</li><li>在路径中不能携带参数。</li></ul><p>OBJECT参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">url</td><td align="left">String</td><td align="left">是</td><td align="left">需要跳转的 tabBar 页面的路径（需同时在 pages.json 的 tabBar ，pages字段定义的页面），路径后不能带参数</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h3 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h3><h4 id="uni-chooseImage-OBJECT"><a href="#uni-chooseImage-OBJECT" class="headerlink" title="uni.chooseImage(OBJECT)"></a>uni.chooseImage(OBJECT)</h4><p>从本地相册选择图片或使用相机拍照。</p><p>App端如需要更丰富的相机拍照API（如直接调用前置摄像头），参考<a href="https://www.html5plus.org/doc/zh_cn/camera.html">plus.camera</a></p><p>OBJECT 参数说明：</p><table><thead><tr><th align="left">参数名</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">count</td><td align="left">Number</td><td align="left">否</td><td align="left">最多可以选择的图片张数，默认9</td></tr><tr><td align="left">sizeType</td><td align="left"><code>Array&lt;String&gt;</code></td><td align="left">否</td><td align="left">original 原图，compressed 压缩图，默认二者都有</td></tr><tr><td align="left">extension</td><td align="left"><code>Array&lt;String&gt;</code></td><td align="left">否</td><td align="left">根据文件拓展名过滤，每一项都不能是空字符串。默认不过滤。</td></tr><tr><td align="left">sourceType</td><td align="left"><code>Array&lt;String&gt;</code></td><td align="left">否</td><td align="left">album 从相册选图，camera 使用相机，默认二者都有。如需直接开相机或直接选相册，请只使用一个选项</td></tr><tr><td align="left">crop</td><td align="left">Object</td><td align="left">否</td><td align="left">图像裁剪参数，设置后 sizeType 失效</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">是</td><td align="left">成功则返回图片的<code>本地文件路径列表</code>tempFilePaths</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p><strong>success 返回参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">tempFilePaths</td><td align="left"><code>Array&lt;String&gt;</code></td><td align="left">图片的本地文件路径列表</td></tr><tr><td align="left">tempFiles</td><td align="left"><code>Array&lt;Object&gt;、Array&lt;File&gt;</code></td><td align="left">图片的本地文件列表，每一项是一个 File 对象</td></tr></tbody></table><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">chooseImage</span>(&#123;</span><br><span class="line"><span class="attr">count</span>: <span class="number">6</span>, <span class="comment">//默认9</span></span><br><span class="line"><span class="attr">sizeType</span>: [<span class="string">&#x27;original&#x27;</span>, <span class="string">&#x27;compressed&#x27;</span>], <span class="comment">//可以指定是原图还是压缩图，默认二者都有</span></span><br><span class="line"><span class="attr">sourceType</span>: [<span class="string">&#x27;album&#x27;</span>], <span class="comment">//从相册选择</span></span><br><span class="line"><span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res.<span class="property">tempFilePaths</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>File 对象结构如下</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">path</td><td align="left">String</td><td align="left">本地文件路径</td></tr><tr><td align="left">size</td><td align="left">Number</td><td align="left">本地文件大小，单位：B</td></tr><tr><td align="left">name</td><td align="left">String</td><td align="left">包含扩展名的文件名称，仅H5支持</td></tr><tr><td align="left">type</td><td align="left">String</td><td align="left">文件类型，仅H5支持</td></tr></tbody></table><h4 id="uni-previewImage"><a href="#uni-previewImage" class="headerlink" title="uni.previewImage"></a>uni.previewImage</h4><p>预览图片。</p><p>OBJECT 参数说明：</p><table><thead><tr><th align="left">参数名</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">current</td><td align="left">String&#x2F;Number</td><td align="left">详见下方说明</td><td align="left">详见下方说明</td></tr><tr><td align="left">showmenu</td><td align="left">Boolean</td><td align="left">否</td><td align="left">是否显示长按菜单，默认值为 true</td></tr><tr><td align="left">urls</td><td align="left"><code>Array&lt;String&gt;</code></td><td align="left">是</td><td align="left">需要预览的图片链接列表</td></tr><tr><td align="left">indicator</td><td align="left">String</td><td align="left">否</td><td align="left">图片指示器样。可取值：”default” - 底部圆点指示器； “number” - 顶部数字指示器； “none” - 不显示指示器。</td></tr><tr><td align="left">loop</td><td align="left">Boolean</td><td align="left">否</td><td align="left">是否可循环预览，默认值为 false</td></tr><tr><td align="left">longPressActions</td><td align="left">Object</td><td align="left">否</td><td align="left">长按图片显示操作菜单，如不填默认为<strong>保存相册</strong></td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p>关于current详细介绍参考官方文档。</p><h4 id="uni-closePreviewImage-OBJECT"><a href="#uni-closePreviewImage-OBJECT" class="headerlink" title="uni.closePreviewImage(OBJECT)"></a>uni.closePreviewImage(OBJECT)</h4><p>OBJECT 参数说明：</p><table><thead><tr><th align="left">参数名</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h4 id="uni-getImageInfo-OBJECT"><a href="#uni-getImageInfo-OBJECT" class="headerlink" title="uni.getImageInfo(OBJECT)"></a>uni.getImageInfo(OBJECT)</h4><p>获取图片信息。</p><p>小程序下获取网络图片信息需先配置download域名白名单才能生效。</p><p>OBJECT 参数说明：</p><table><thead><tr><th align="left">参数名</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">src</td><td align="left">String</td><td align="left">是</td><td align="left">图片的路径，可以是相对路径，临时文件路径，存储文件路径，网络图片路径</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p><strong>success 返回参数说明</strong></p><table><thead><tr><th align="left">参数名</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">width</td><td align="left">Number</td><td align="left">图片宽度，单位px</td></tr><tr><td align="left">height</td><td align="left">Number</td><td align="left">图片高度，单位px</td></tr><tr><td align="left">path</td><td align="left">String</td><td align="left">返回图片的本地路径</td></tr><tr><td align="left">type</td><td align="left">String</td><td align="left">返回图片的格式</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">chooseImage</span>(&#123;</span><br><span class="line"><span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">sourceType</span>: [<span class="string">&#x27;album&#x27;</span>],</span><br><span class="line"><span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">uni.<span class="title function_">getImageInfo</span>(&#123;</span><br><span class="line"><span class="attr">src</span>: res.<span class="property">tempFilePaths</span>[<span class="number">0</span>],<span class="comment">//传入第一个图片临时路径</span></span><br><span class="line"><span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">image</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(image.<span class="property">width</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(image.<span class="property">height</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="uni-saveImageToPhotosAlbum-OBJECT"><a href="#uni-saveImageToPhotosAlbum-OBJECT" class="headerlink" title="uni.saveImageToPhotosAlbum(OBJECT)"></a>uni.saveImageToPhotosAlbum(OBJECT)</h4><p>保存图片到系统相册。</p><p>OBJECT 参数说明：</p><table><thead><tr><th align="left">参数名</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">filePath</td><td align="left">String</td><td align="left">是</td><td align="left">图片文件路径，可以是临时文件路径也可以是永久文件路径，<strong>不支持网络图片路径</strong></td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p><strong>success 返回参数说明</strong></p><table><thead><tr><th align="left">参数名</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">path</td><td align="left">String</td><td align="left">保存到相册的图片路径，仅 App 3.0.5+ 支持</td></tr><tr><td align="left">errMsg</td><td align="left">String</td><td align="left">调用结果</td></tr></tbody></table><p><strong>注意</strong></p><ul><li>可以通过<strong>用户授权API</strong>来判断用户是否给应用授予相册的<strong>访问权限</strong><a href="https://uniapp.dcloud.io/api/other/authorize">https://uniapp.dcloud.io/api/other/authorize</a></li><li>H5没有API可触发保存到相册行为，下载图片时浏览器会询问图片存放地址。</li><li>微信小程序在2023年10月17日之后，使用API需要配置<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/user-privacy/PrivacyAuthorize.html">隐私协议</a></li></ul><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">chooseImage</span>(&#123;</span><br><span class="line"><span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line"><span class="attr">sourceType</span>: [<span class="string">&#x27;camera&#x27;</span>],</span><br><span class="line"><span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">uni.<span class="title function_">saveImageToPhotosAlbum</span>(&#123;</span><br><span class="line"><span class="attr">filePath</span>: res.<span class="property">tempFilePaths</span>[<span class="number">0</span>],</span><br><span class="line"><span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;save success&#x27;</span>,res.<span class="property">path</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><h4 id="uni-saveFile-OBJECT"><a href="#uni-saveFile-OBJECT" class="headerlink" title="uni.saveFile(OBJECT)"></a>uni.saveFile(OBJECT)</h4><p>OBJECT 参数说明：</p><table><thead><tr><th align="left">参数名</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">tempFilePath</td><td align="left">String</td><td align="left">是</td><td align="left">需要保存的文件的<strong>临时路径</strong>，只能是临时文件路径。</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">返回文件的保存路径，res &#x3D; {savedFilePath: ‘文件的保存路径’}</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p><strong>success 返回参数说明：</strong></p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">savedFilePath</td><td align="left">文件的保存路径</td></tr></tbody></table><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">chooseImage</span>(&#123;</span><br><span class="line">  <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tempFilePaths = res.<span class="property">tempFilePaths</span>;</span><br><span class="line">    uni.<span class="title function_">saveFile</span>(&#123;</span><br><span class="line">      <span class="attr">tempFilePath</span>: tempFilePaths[<span class="number">0</span>],<span class="comment">//选择第一个临时文件路径</span></span><br><span class="line">      <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> savedFilePath = res.<span class="property">savedFilePath</span>;<span class="comment">//保存成功后返回的文件路径</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><h4 id="uni-showToast-OBJECT"><a href="#uni-showToast-OBJECT" class="headerlink" title="uni.showToast(OBJECT)"></a>uni.showToast(OBJECT)</h4><p>显示消息提示框。</p><p>OBJECT参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">String</td><td align="left">是</td><td align="left">提示的内容，长度与 icon 取值有关。</td></tr><tr><td align="left">icon</td><td align="left">String</td><td align="left">否</td><td align="left">图标，有效值详见下方说明，默认：success。</td></tr><tr><td align="left">image</td><td align="left">String</td><td align="left">否</td><td align="left">自定义图标的本地路径（app端暂不支持gif）</td></tr><tr><td align="left">mask</td><td align="left">Boolean</td><td align="left">否</td><td align="left">是否显示透明蒙层，防止触摸穿透，默认：false</td></tr><tr><td align="left">duration</td><td align="left">Number</td><td align="left">否</td><td align="left">提示的延迟时间，单位毫秒，默认：1500</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h4 id="uni-hideToast"><a href="#uni-hideToast" class="headerlink" title="uni.hideToast()"></a>uni.hideToast()</h4><p>隐藏消息提示框。</p><h4 id="uni-showLoading-OBJECT"><a href="#uni-showLoading-OBJECT" class="headerlink" title="uni.showLoading(OBJECT)"></a>uni.showLoading(OBJECT)</h4><p>显示 loading 提示框, 需主动调用 <a href="https://uniapp.dcloud.net.cn/api/ui/prompt.html#hideloading">uni.hideLoading</a> 才能关闭提示框。</p><p>OBJECT参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">String</td><td align="left">是</td><td align="left">提示的文字内容，显示在loading的下方</td></tr><tr><td align="left">mask</td><td align="left">Boolean</td><td align="left">否</td><td align="left">是否显示透明蒙层，防止触摸穿透，默认：false</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><h4 id="uni-hideLoading"><a href="#uni-hideLoading" class="headerlink" title="uni.hideLoading()"></a>uni.hideLoading()</h4><p>隐藏 loading 提示框。</p><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">showLoading</span>(&#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&#x27;加载中&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">uni.<span class="title function_">hideLoading</span>();</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><h4 id="uni-showModal-OBJECT"><a href="#uni-showModal-OBJECT" class="headerlink" title="uni.showModal(OBJECT)"></a>uni.showModal(OBJECT)</h4><p>显示模态弹窗，可以只有一个确定按钮，也可以同时有确定和取消按钮</p><p><strong>OBJECT参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">title</td><td align="left">String</td><td align="left">否</td><td align="left">提示的标题</td></tr><tr><td align="left">content</td><td align="left">String</td><td align="left">否</td><td align="left">提示的内容</td></tr><tr><td align="left">showCancel</td><td align="left">Boolean</td><td align="left">否</td><td align="left">是否显示取消按钮，默认为 true</td></tr><tr><td align="left">cancelText</td><td align="left">String</td><td align="left">否</td><td align="left">取消按钮的文字，默认为”取消”</td></tr><tr><td align="left">cancelColor</td><td align="left">HexColor</td><td align="left">否</td><td align="left">取消按钮的文字颜色，默认为”#000000”</td></tr><tr><td align="left">confirmText</td><td align="left">String</td><td align="left">否</td><td align="left">确定按钮的文字，默认为”确定”</td></tr><tr><td align="left">confirmColor</td><td align="left">HexColor</td><td align="left">否</td><td align="left">确定按钮的文字颜色，H5平台默认为”#007aff”，微信小程序平台默认为”#576B95”，百度小程序平台默认为”#3c76ff”</td></tr><tr><td align="left">editable</td><td align="left">Boolean</td><td align="left">否</td><td align="left">是否显示输入框</td></tr><tr><td align="left">placeholderText</td><td align="left">String</td><td align="left">否</td><td align="left">显示输入框时的提示文本</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用成功的回调函数</td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p><strong>success返回参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">confirm</td><td align="left">Boolean</td><td align="left">为 true 时，表示用户点击了确定按钮</td></tr><tr><td align="left">cancel</td><td align="left">Boolean</td><td align="left">为 true 时，表示用户点击了取消（用于 Android 系统区分点击蒙层关闭还是点击取消按钮关闭）</td></tr><tr><td align="left">content</td><td align="left">String</td><td align="left"><code>editable</code> 为 true 时，值为用户输入的文本</td></tr></tbody></table><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uni.<span class="title function_">showModal</span>(&#123;</span><br><span class="line"><span class="attr">title</span>: <span class="string">&#x27;提示&#x27;</span>,</span><br><span class="line"><span class="attr">content</span>: <span class="string">&#x27;这是一个模态弹窗&#x27;</span>,</span><br><span class="line"><span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (res.<span class="property">confirm</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户点击确定&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">cancel</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户点击取消&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> uniapp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序</title>
      <link href="/posts/4618cb0a.html"/>
      <url>/posts/4618cb0a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>微信小程序有自己开发框架，并且和我们熟悉的vue或者react框架的语法，api区别还是蛮大的，学习成本不低，个人不推荐花太多时间去学习，更推荐uni-app（使用vue的语法开发web应用并多端发布）这类的框架，使用我们熟悉的框架语法开发，还能轻松实现多端发布。当然，wx小程序的知识中也有许多是通用的。</p></blockquote><h2 id="说说你对微信小程序的理解？优缺点？"><a href="#说说你对微信小程序的理解？优缺点？" class="headerlink" title="说说你对微信小程序的理解？优缺点？"></a>说说你对微信小程序的理解？优缺点？</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>2017年，微信正式推出了小程序，允许外部开发者在微信内部运行自己的代码，开展业务</p><p>截至目前，小程序已经成为国内前端的一个重要业务，跟 <code>Web</code> 和手机 <code>App</code> 有着同等的重要性</p><p>小程序是一种不需要下载安装即可使用的应用（但实际上还是存在一个轻量级的下载和安装流程，不过用户感知不到），它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用</p><p>也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载</p><p>注意的是，除了微信小程序，还有百度小程序、微信小程序、支付宝小程序、抖音小程序，都是每个平台自己开发的，都是有针对性平台的应用程序</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>小程序并非凭空冒出来的⼀个概念，当微信中的 <code>WebView</code> 逐渐成为移动 <code>Web</code>的⼀个重要⼊⼝时，微信就有相关的 <code>JS-SDK</code></p><p><code>JS-SDK</code> 解决了移动网页能⼒不⾜的问题，通过暴露微信的接⼝使得 <code>Web</code> 开发者能够拥有更多的能⼒，然而在更多的能⼒之外，<code>JS-SDK</code>的模式并没有解决使⽤移动网页遇到的体验不良的问题</p><p>因此需要设计⼀个比较好的系统，使得所有开发者在微信中都能获得⽐较好的体验：</p><ul><li>快速的加载</li><li>更强⼤的能⼒</li><li>原⽣的体验</li><li>易⽤且安全的微信数据开放</li><li>高效和简单的开发</li></ul><p>这些是<code>JS-SDK</code>做不到的，需要设计一个全新的小程序系统</p><p>其中相比<code>H5</code>，小程序与其的区别有如下：</p><ul><li>运⾏环境：⼩程序基于浏览器内核重构的<code>内置解析器</code></li><li>系统权限：⼩程序能获得更多的系统权限，如⽹络通信状态、数据缓存能⼒等</li><li>渲染机制：⼩程序的<code>逻辑层</code>和<code>渲染层</code>是分开的</li></ul><p>微信小程序可以视为只能用微信打开和浏览的<code>H5</code>，小程序和网页的技术模型是一样的，用到的 <code>JavaScript</code> 语言和 <code>CSS</code> 样式也是一样的，只是网页的 <code>HTML</code> 标签被稍微修改成了 <code>WXML</code> 标签</p><p><strong>因此可以说，小程序页面本质上就是网页</strong></p><p>其中关于微信小程序的实现原理，我们在后面的文章讲到</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>随搜随用，用完即走：使得小程序可以代替许多APP，或是做APP的整体嫁接，或是作为阉割版功能的承载体</li><li>流量大，易接受：小程序借助自身平台更加容易引入更多的流量</li><li>安全</li><li>开发门槛低</li><li>降低兼容性限制</li></ul><p>缺点：</p><ul><li>用户留存：及相关数据显示，小程序的平均次日留存在13%左右，但是双周留存骤降到仅有1%</li><li><code>体积限制</code>：微信小程序只有2M的大小，这样导致无法开发大型一些的小程序</li><li>受控微信：比起APP，尤其是安卓版的高自由度，小程序要面对很多来自微信的<strong>限制</strong>，从功能接口，甚至到类别内容，都要接受微信的管控</li></ul><h2 id="说说微信小程序的实现原理？"><a href="#说说微信小程序的实现原理？" class="headerlink" title="说说微信小程序的实现原理？"></a>说说微信小程序的实现原理？</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>网页开发，渲染线程和脚本是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应的原因，本质就是我们常说的 <code>JS</code> 是单线程的</p><p>而在小程序中，选择了 <code>Hybrid</code> 的渲染方式，将<code>视图层</code>和<code>逻辑层</code>分开的，<strong>双线程</strong>同时运行，视图层的界面使用 <code>WebView</code> 进行渲染，逻辑层运行在 <code>JSCore</code> 中</p><img src="..\images\小程序\微信小程序.png" style="zoom:100%;" /><ul><li><p><strong>渲染层</strong>：</p><p>使用 WXML 和 WXSS 编写，类似于 HTML 和 CSS。</p><p>负责界面展示，包括布局、样式等。 </p><p>实际上是通过<code> WebView</code> 来<code>解析</code>和<code>渲染</code>的，但在微信小程序中进行了优化，以提供接近原生应用的性能。</p><p>界面渲染相关的任务全都在<code>WebView</code>线程里执行。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程</p></li><li><p><strong>逻辑层</strong>：</p><p>主要使用 JavaScript 编写。</p><p>负责处理业务逻辑、数据获取、<code>API 请求</code>等，其中网络请求由<code>微信客户端</code>进行<strong>转发</strong></p><p>运行在一个基于 V8 或者 JSCore 的 JavaScript 引擎之上（视操作系统而定）</p></li><li><p><strong>Native</strong></p><p>Native 层指的是<code>微信客户端</code>本身的<code>原生代码</code>，它负责：</p><ul><li>提供基础库，包含所有可用的 <code>API</code>。</li><li>处理逻辑层和渲染层之间的高效通信。</li><li>实现性能优化，确保小程序能够流畅运行。</li><li>提供安全机制，保护用户数据和隐私。</li></ul></li></ul><h3 id="WebView-是什么"><a href="#WebView-是什么" class="headerlink" title="WebView 是什么"></a>WebView 是什么</h3><p>WebView 是一个允许在应用程序内部<strong>展示网页内容的组件，它依赖于特定平台上的<code>浏览器内核</code>来工作</strong>。</p><p>在不同的平台上有不同实现：</p><ul><li><strong>Android</strong>：使用 <code>android.webkit.WebView</code>。</li><li><strong>iOS</strong>：使用 <code>WKWebView</code>（较新的推荐使用方式）或 <code>UIWebView</code>（已废弃）。</li></ul><p>相当于 Web 开发中的 <strong>浏览器渲染引擎</strong>，也就是浏览器的内核，关于浏览器的介绍可以参考：<a href="https://www.sanye.blog/posts/c0add594.html">前端面试—网络 | 三叶的博客</a></p><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><p>逻辑层和渲染层之间的通信，是通过<code>微信客户端</code>(Native，或者说是宿主环境)提供的 <code>API </code>实现的，比如逻辑层可以通过 <code>setData</code> 方法将数据传递给渲染层，触发页面更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">  <span class="attr">message</span>: <span class="string">&#x27;Hello, World!&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在逻辑层发生数据变更的时候，通过宿主环境（native）提供的<code>setData</code>方法把数据从<code>逻辑层</code>传递到<code>渲染层</code>，再经过对比前后差异，把差异应用在原来的<code>Dom</code>树上(小程序在渲染层，宿主环境会把<code>wxml</code>转化成对应的<code>JS</code>对象，类似web开发中的dom对象），渲染出正确的视图</p><img src="..\images\小程序\微信小程序2.png" style="zoom:90%;" /><p>当视图存在交互的时候，例如用户点击你界面上某个按钮，这类反馈应该通知给开发者的逻辑层，需要将对应的处理状态呈现给用户</p><p>对于事件的分发处理，微信进行了特殊的处理，将所有的事件拦截后，丢到逻辑层交给<code>JavaScript</code>进行处理</p><img src="..\images\小程序\微信小程序3.png" style="zoom:100%;" /><p>由于小程序是基于双线程的，也就是任何在<code>视图层</code>和<code>逻辑层</code>之间的数据传递都是<code>线程间的通信</code>，会有一定的<code>延时</code>，因此在小程序中，页面更新成了异步操作</p><p>异步会使得各部分的运行时序变得复杂一些，比如在<code>渲染首屏</code>的时候，<code>逻辑层</code>与<code>渲染层</code>会同时开始初始化工作，但是渲染层需要有逻辑层的数据才能把界面渲染出来</p><p>如果渲染层初始化工作较快完成，就要等逻辑层的指令才能进行下一步工作</p><p>因此逻辑层与渲染层需要有一定的机制保证<code>时序正确</code>(异步同步化)，在每个小程序页面的生命周期中，存在着若干次页面数据通信。</p><img src="..\images\小程序\微信小程序4.png" style="zoom:100%;" /><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>小程序启动运行两种情况</p><ul><li>冷启动（重新开始）：用户<code>首次打开</code>或者小程序被微信<code>主动销毁</code>后再次打开的情况，此时小程序需要重新加载启动，即为冷启动。</li><li>热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将<code>后台态</code>的小程序切换到前台，这个过程就是热启动。</li></ul><p><strong>初次启动过程</strong></p><p>1.把小程序的代码包下载到本地</p><p>2.解析<code>app.json</code>全局配置文件</p><p>3.执行<code>app.js </code>小程序入口文件，调用<code>App()</code>创建小程序实例</p><p>4.渲染小程序首页（app.json 文件中的 pages 数组的第一个页面路径）</p><p>5.加载解析页面的<code>.json</code>配置文件</p><p>6.加载页面的<code>.wxml</code>模板和<code>.wxss</code>样式</p><p>7.执行页面的<code>.js </code>文件，调用<code>Page()</code>创建页面实例，页面渲染完成</p><p>8.小程序启动完成</p><p><strong>注意：</strong></p><p>1.小程序没有重启的概念<br>2.当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后会被微信<code>主动销毁</code><br>3.短时间内收到系统两次以上内存警告，也会对小程序进行销毁，这也就为什么一旦页面内存溢出，页面会奔溃的本质原因了</p><img src="..\images\小程序\微信小程序5.png" style="zoom:90%;" /><p>每次冷启动时，都会检查是否有<code>更新版本</code>，如果发现有新版本，将会<code>异步下载</code>新版本的代码包，并同时使用<code>客户端本地的包（缓存中的包）</code>进行启动，即新版本的小程序需要等<code>下一次冷启动</code>才会应用上。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p><strong>注册账号</strong></p><p>前往微信公众平台：<a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com/</a></p><p><strong>下载微信开发者工具</strong></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html">https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html</a></p><p><strong>创建第一个项目</strong></p><p>使用js基础模板</p><p><strong>使用技巧</strong></p><ul><li>查看效果<ul><li>编译-&gt;模拟</li><li>打开模拟器后底部可以看到页面路径</li><li>手机预览</li></ul></li><li>帮助-&gt;开发者文档</li><li>详情<ul><li>查看小程序信息</li><li>本地设置</li></ul></li></ul><h2 id="项目结构概述"><a href="#项目结构概述" class="headerlink" title="项目结构概述"></a>项目结构概述</h2><img src="..\images\小程序\6.png" style="zoom:90%;" /><ul><li><p><strong>pages</strong></p><p>用来存放所有小程序的页面，每个页面以单独的<code>文件夹</code>存在<br>其中，每个页面由4个基本文件组成</p><ul><li>.js文件(页面的脚本文件，存放页面的数据、事件处理函数等)</li><li>.json 文件（当前页面的配置文件，配置窗口的外观、表现等)</li><li>.wxml文件（页面的<code>模板结构</code>文件)</li><li>.wxss文件（当前页面的样式表文件)</li></ul></li><li><p><strong>utils</strong></p><p>用来存放工具性质的模块（例如:格式化时间的自定义模块)</p></li><li><p><strong>app.js</strong></p><p>小程序项目的<code>入口文件</code></p></li><li><p><strong>app.json</strong></p><p>小程序项目的<code>全局配置</code>文件</p></li><li><p><strong>app.wxss</strong> </p><p>小程序项目的全局样式文件</p></li><li><p><strong>project.config.json</strong></p><p>项目的配置文件</p></li><li><p><strong>sitemap.json</strong></p><p>站点地图，用来配置小程序及其页面是否允许被微信索引</p></li></ul><h2 id="JSON文件总结"><a href="#JSON文件总结" class="headerlink" title="JSON文件总结"></a>JSON文件总结</h2><h3 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a><strong>app.json</strong></h3><p>是当前小程序的<code>全局配置</code>，包括了小程序的所有<code>页面路径</code>、<code>窗口外观</code>、<code>界面表现</code>、<code>底部 tab</code>等。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">//放页面路径</span></span><br><span class="line">  <span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;window&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tabBar&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//全局注册的组件</span></span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//指定分包</span></span><br><span class="line">  <span class="attr">&quot;subPackages&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>只需要在 <code>app.json-&gt; pages</code>中新增页面的存放路径，小程序开发者工具即可帮我们自动创建对应的<code>页面文件</code></p><p>只需要调整<code>app.json-&gt; pages</code>字符串数组中<code>页面路径</code>的前后顺序，即可修改项目的<strong>首页</strong>。小程序会把排在<code>第一位的页面</code>，当作项目<code>首页</code>进行渲染。</p><h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  ....</span><br><span class="line">  <span class="attr">&quot;window&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;navigationBarTextStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;navigationBarBackgroundColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#fff&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;backgroundColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#F8F8F8&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  ....</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>navigationBar系列(导航栏)</p><ul><li>navigationBarTitleText：修改导航栏的标题</li><li>navigationBarBackgroundColor：修改导航栏的背景色，只支持<code>16进制颜色</code>，不能设置为red，blue等</li><li>navigationBarTextStyle：设置标题颜色，可选值只能是black和white（为什么这里又能直接写颜色了？）</li></ul></li><li><p>background系列（下拉页面才会显示的部分的背景配置）</p><ul><li>backgroundColor：指定16进制的颜色值比如#efefef。</li><li>backgroundTextStyle：只支持<code>dark和light</code>。</li></ul></li><li><p>onReachBottomDistance</p><p>默认为<code>50px</code>，当滚动条距离底部50px的时候触发<code>触底刷新</code></p></li><li><p>enablePullDownRefresh</p><p>设置为true，表示允许下拉刷新</p></li></ul><h4 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//app.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  ....</span><br><span class="line">  <span class="attr">&quot;tabBar&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;selectedColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#28b389&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/home/home&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/home.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/home-h.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;推荐&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/classify/classify&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/classify.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/classify-h.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;分类&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pagePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pages/user/user&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;iconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/user.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;selectedIconPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;static/user-h.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我的&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  ....</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>selectedlconPath：选中时显示的图标路径</li><li>iconPath：未选中时显示的图标路径</li><li>color：tab上文字的默认（未选中）颜色</li><li>selectedColor： tab 上的文字选中时的颜色</li><li>pagePath：tab对应的页面路径，点击tab会跳转到指定页面。</li></ul><p><strong>注意</strong>：</p><p>tabBar中只能配置最少2个、最多5个tab页签（list数组里的元素数目等于tab数目）</p><p>当渲染<strong>顶部</strong> tabBar时，不显示 icon，只显示文本</p><h3 id="页面的json文件"><a href="#页面的json文件" class="headerlink" title="页面的json文件"></a>页面的json文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;navigationBarTitleText&quot;</span><span class="punctuation">:</span> <span class="string">&quot;分类&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;navigationStyle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;custom&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;enablePullDownRefresh&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">//局部组件注册</span></span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;nav-bar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;../../components/nav-bar/nav-bar&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;theme-item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;../../components/theme-item/theme-item&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;uni-load-more&quot;</span><span class="punctuation">:</span> <span class="string">&quot;../../uni_modules/uni-load-more/components/uni-load-more/uni-load-more&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>页面的json文件中的属性，就是全局配置（app.json）中window的配置属性。</p><p>小程序中的每一个页面，可以使用<code>json</code>文件来对本页面的<code>窗口外观</code>进行配置，页面中的配置项会<strong>覆盖</strong>app.json的<code> window</code>属性中相同的配置项。</p><h3 id="project-config-json"><a href="#project-config-json" class="headerlink" title="project.config.json"></a><strong>project.config.json</strong></h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;项目配置文件。&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;packOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ignore&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;setting&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;urlCheck&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;es6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;postcss&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minified&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;newFeature&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;bigPackageSizeSupport&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;babelSetting&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;ignore&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;disablePlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;outputPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compileType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;miniprogram&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;libVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3.5.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;appid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xyz&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;projectname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4meinv&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置,</p><p><code>setting</code>中保存了编译相关的配置</p><p><code>projectname</code>中保存的是项目名称，项目名称不等于小程序名称</p><p><code>appid</code>中保存的是<code>小程序的账号ID</code></p><h3 id="sitemap-json"><a href="#sitemap-json" class="headerlink" title="sitemap.json"></a><strong>sitemap.json</strong></h3><p>站点地图，微信现已开放小程序内搜索，效果类似于PC网页的<code>SEO</code>(搜索引擎优化)。该文件用来配置小程序页面是否允许微信索引。</p><h2 id="js文件总结"><a href="#js文件总结" class="headerlink" title="js文件总结"></a>js文件总结</h2><h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h3><p>是整个小程序项目的<code>入口文件</code>，通过调用<code>App()</code>函数来启动整个小程序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">createApp</span>().<span class="property">app</span>.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="页面的-js-文件"><a href="#页面的-js-文件" class="headerlink" title="页面的.js 文件"></a>页面的.js 文件</h3><p>是页面的入口文件，页面的脚本文件，存放页面的数据、事件处理函数等</p><p>通过调用<code>Page()</code>函数来创建并运行页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">createPage</span>(<span class="title class_">MiniProgramPage</span>);</span><br></pre></td></tr></table></figure><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p><code>wx</code>对象在浏览器中就相当于<code>window</code></p><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>以on开头，用来监听某些事件的触发，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">onWindowResize</span>(<span class="keyword">function</span> callback)<span class="comment">//监听窗口尺寸变化的事件</span></span><br></pre></td></tr></table></figure><h3 id="同步api"><a href="#同步api" class="headerlink" title="同步api"></a>同步api</h3><p>以<code>Sync</code>结尾的API都是同步API</p><p>同步API的执行结果，可以通过<code>函数返回值</code>直接获取，如果执行出错会抛出异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;value&#x27;</span>)<span class="comment">//向本地存储中写入内容</span></span><br></pre></td></tr></table></figure><h3 id="异步api"><a href="#异步api" class="headerlink" title="异步api"></a><strong>异步api</strong></h3><p>类似于jQuery 中的$.ajax(options)函数，需要通过success、fail、complete<code>回调函数</code>接收调用的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">request</span>()<span class="comment">//发起网络数据请求，通过success回调函数接收数据</span></span><br></pre></td></tr></table></figure><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li><p>tap</p><p>手指触摸后马上离开，类似于HTML中的click 事件</p><p>绑定方式：<code>bindtap 或 bind:tap</code>，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;handleTap&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="title function_">handleTap</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;按钮被点击了&#x27;</span>);</span><br><span class="line">    <span class="comment">// 可以在这里执行其他逻辑，如发起网络请求或更新页面状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>input</p><p>文本框输入事件</p><p>绑定方式：<code>bindinput或 bind:input</code></p><p>通过<code>e.detail.value</code>获得最新输入的值，不同于js的<code>e.target.value</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入内容&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;handleInput&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="title function_">handleInput</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> inputValue = e.<span class="property">detail</span>.<span class="property">value</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前输入值:&#x27;</span>, inputValue);</span><br><span class="line">    <span class="comment">// 更新页面状态或其他操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>change</p><p>状态改变时触发，绑定方式同上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">switch</span> <span class="attr">bindchange</span>=<span class="string">&quot;handleChange&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> isChecked = e.<span class="property">detail</span>.<span class="property">value</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开关状态改变为:&#x27;</span>, isChecked ? <span class="string">&#x27;开启&#x27;</span> : <span class="string">&#x27;关闭&#x27;</span>);</span><br><span class="line">    <span class="comment">// 根据开关状态执行相应逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p><strong>事件对象</strong></p><p>和<code>js</code>中的事件对象相同，<code>e.target</code>表示目标对象，即触发该事件的对象；<code>e.currentTarget</code>表示事件流经过的当前对象；<code>e.type</code>表示事件类型。</p><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>页面数据写在js文件中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line"><span class="attr">info</span>: <span class="string">&#x27;init data&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>wxml文件中使用:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;imgSrc&#125;&#125; &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;info&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在wxml文件中使用js中的数据一定要加<code>&#123;&#123;&#125;&#125;</code></p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p><strong>wx:if&#x2F;wx:elif&#x2F;wx:else</strong></p><p><strong>block组件</strong></p><p>类似vue中的template</p><p><strong>hidden</strong></p><p>类似vue中的<code>v-show</code>，不一样的是这里值为true的话是隐藏，v-show是显示</p><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><ul><li><p>wx:for：传入一个数组</p></li><li><p>wx:for-item：可以指定当前项的变量名</p></li><li><p>wx:for-index：可以指定当前循环项的索引的变量名</p></li><li><p>wx:key</p><p>类似vue中的key，如果数组item中有<code>id</code>属性，直接令wx:key&#x3D;’id’即可，不需要写成<code>&#123;&#123;item.id&#125;&#125;</code>，否则会报错（真是奇怪）</p></li></ul><p><strong>示例</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;arr&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line"> 索引是: &#123;&#123;index&#125;&#125;, item项是:&#123;&#123;item&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;arr1&#125;&#125;&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;idx&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;itemName&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;idx&quot;</span>&gt;</span></span><br><span class="line"> 索引是: &#123;&#123;idx&#125;&#125;, item项是: &#123;&#123;itemName&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="wxml与html的区别"><a href="#wxml与html的区别" class="headerlink" title="wxml与html的区别"></a>wxml与html的区别</h3><p><code>标签名称</code>不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTML ( div, span, img, a)</span><br><span class="line">wxml (view, text, image, navigator)</span><br></pre></td></tr></table></figure><p><code>属性节点</code>不同</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">&quot;/pages/home/home&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="wxss与css的区别"><a href="#wxss与css的区别" class="headerlink" title="wxss与css的区别"></a>wxss与css的区别</h3><ul><li><p>新增了<code>rpx</code>尺寸单位</p><p>CSS中需要手动进行像素单位换算，例如rem，wxss在底层支持新的尺寸单位rpx，在不同大小的屏幕上小程序会自动进行换算。</p><p>鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配，rpx把所有设备的屏幕，在<code>宽度</code>上等分为750份（即:当前屏幕的总宽度为750rpx)。小程序在不同设备上运行的时候，会自动把 rpx的样式单位换算成对应的<code>像素单位(px)</code>来渲染，从而实现屏幕适配。</p></li><li><p>wxss仅支持<strong>部分</strong>CSS选择器</p></li><li><p>提供了全局的样式和局部样式</p><p>项目根目录中的<code>app.wxss</code>会作用于所有小程序页面，而页面的wxss样式仅对当前页面生效。</p></li></ul><h3 id="wxs与js的区别"><a href="#wxs与js的区别" class="headerlink" title="wxs与js的区别"></a>wxs与js的区别</h3><ul><li>只支持js的部分语法，不支持es6语法</li><li>声明变量只能用var，没有const，let</li><li>不能写箭头表达式</li><li>对象键值名称相同不能省略</li><li>wxs不能调用js 中定义的函数</li><li>wxs不能调用小程序提供的API</li></ul><p>说白了wx小程序上运行的js代码是阉割版的…</p><p><strong>特点</strong></p><ul><li>wxs 代码可以编写在wxml文件中的<code>&lt;wxs&gt;</code>标签内，就像Javascript 代码可以编写在 html文件中的<code>&lt;script&gt;</code>标签内一样。</li><li>wxml文件中的每个<code>&lt;wxs&gt;&lt;/wxs&gt;</code>标签，必须提供 <code>module</code>属性，用来指定当前wxs 的<code>模块名称</code>，方便在wxml中访问模块中的成员</li><li>wxs代码还可以编写在以<code>.wxs</code>为后缀名的文件内，就像javascript代码可以编写在以.js为后缀名的文件中一样。</li><li>在wxml中引入外联的 wxs脚本时，必须为<code>&lt;wxs&gt;</code>标签添加module和src属性，module用来指定模块的名称src，用来指定要引入的脚本的路径，且必须是<code>相对路径</code>。</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="视图组件"><a href="#视图组件" class="headerlink" title="视图组件"></a>视图组件</h4><ul><li><p>view</p><p>普通视图区域，类似于HTML中的div，是一个块级元素常用来实现页面的布局效果</p></li><li><p>scroll-view</p><p>可滚动的视图区域，常用来实现滚动列表效果；添加<code>scroll-y</code>属性，允许y轴滚动。</p></li><li><p>swiper和swiper-item</p><p>轮播图组件，常用属性：</p><ul><li>indicator-dots：添加导航条，默认值false</li><li>indicator-color：指示点颜色</li><li>indicator-active-color：当前选中的指示点颜色</li><li>autoplay：是否自动切换，默认为false</li><li>interval：自动切换时间间隔（单位ms）</li><li>circular：是否采用衔接滑动，默认为false</li></ul></li><li><p>text</p><p>添加了<code>selectable</code>属性才能实现长按选择复制等操作</p></li><li><p>rich-text</p><p>通过rich-text组件的<code>nodes</code>属性节点，把HTML字符串渲染为对应的结构，就像vue里的<code>v-html</code>。</p><p>这段代码会将 <code>&lt;h1&gt;</code> 元素的内容渲染到 <code>&lt;rich-text&gt;</code> 组件内部，而不是替换整个 <code>&lt;rich-text&gt;</code> 标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rich-text</span> <span class="attr">nodes</span>=<span class="string">&quot;&lt;h1 style=&#x27;color: red; &#x27;&gt;标题&lt;/h1&gt;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rich-text</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h4><ul><li><p>button</p><p>功能比HTML中的button 按钮丰富</p><p>属性：</p><ul><li>type：指定按钮的<code>类型，颜色</code>，有点像前端框架里的语法了</li><li>size：指定按钮的大小</li><li>plain：添加了就具有镂空样式</li><li>open-type：通过这个属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等)</li></ul></li><li><p>image</p><p>组片组件，有默认宽高</p><p>mode属性（前3个修改图片大小，后2个修改image容器大小）</p><ul><li>scaleToFill：(默认值）缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满image元素。没有空隙，没有裁剪，但是会失真）</li><li>aspect<strong>Fit</strong>：缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。（就是contain）。没有裁剪，没有失真，但是可能有空隙。</li><li>aspect<strong>Fill</strong>：缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。（就是cover）。有裁剪，但是没有失真，没有空隙。</li><li>widthFix：缩放模式，<code>容器</code>的宽度不变，高度自动变化，保持原图宽高比不变</li><li>heightFix：缩放模式，<code>容器</code>的高度不变，宽度自动变化，保持原图宽高比不变</li></ul><p><strong>与img区别</strong></p><p>微信中的image更像一个容器，src指定的图片是<code>背景图片</code>，前3个属性值在修改背景图片大小，后2个属性在<code>修改容器</code>的大小。</p><p>而<code>img</code>的大小就是<code>src</code>指定的图片的大小。</p></li></ul><h3 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h3><p><strong>安全限制</strong></p><p>只能请求<code>HTTPS</code>类型的接口</p><p>必须将接口的<code>域名</code>添加到信任列表中</p><p><strong>配置request合法域名</strong></p><p>登录微信小程序管理后台→开发→开发设置→服务器域名→修改request合法域名。</p><p><strong>跳过域名检查</strong></p><p>只能在<code>开发阶段</code>使用，步骤：详情-&gt;本地设置-&gt;不校验…</p><p><strong>发请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27; https://applet-base-api-t.itheima.net/api/get&#x27;</span>,</span><br><span class="line">      <span class="attr">method</span>:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">20</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">success</span>(<span class="params">res</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>)</span><br><span class="line">      &#125;<span class="comment">//请求成功后的回调函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><p>跨域问题<br>跨域问题只存在于基于浏览器的Web开发中。由于小程序的<strong>宿主环境不是浏览器</strong>而是微信客户端，所以小程序中<strong>不存在跨域的问题</strong></p></li><li><p>ajax<br>Ajax技术的核心是依赖于浏览器中的<code>XMLHttpRequest</code>这个对象，由于小程序的宿主环境是<code>微信客户端</code>，所以小程序中不能叫做<code>发起Ajax请求</code>，而是叫做<code>发起网络数据请求</code>。</p></li></ul><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><h4 id="声明式导航"><a href="#声明式导航" class="headerlink" title="声明式导航"></a>声明式导航</h4><ul><li><p>跳转到tabBar页面，需要指定open-type属性为<code>switchTab</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">&quot; /pages/message/message&quot;</span> <span class="attr">open-type</span>=<span class="string">&quot;switchTab&quot;</span>&gt;</span>导航到消息页面<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>跳转到非tabBar页面：open-type必须为<code>navigate</code>，也可以省略不写 </p></li><li><p>后退导航：如果要后退到上一页面或多级页面，则需要指定<code>open-type</code>属性为<code>navigateBack(&#123;delta:1&#125;)</code>，delta表示后退层级</p></li></ul><h4 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h4><ul><li><p>跳转到tabBar页面<br>使用<code>wx.switchTab()</code>方法，传入一个对象，必须包含url属性</p></li><li><p>跳转到非tabBar页面</p><p>使用<code>wx.navigateTo()</code>方法，传入一个对象，必须包含url属性</p></li><li><p>后退导航</p><p>wx.navigateBack()，传入<code>&#123;delta：1&#125;</code>指定后退层级</p></li></ul><h4 id="导航传参"><a href="#导航传参" class="headerlink" title="导航传参"></a>导航传参</h4><p>声明式导航传参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">&quot;/pages/infolinfo?name=zs&amp;age=20&quot;</span>&gt;</span>跳转到info页面<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h4><p>通过声明式导航传参或编程式导航传参所携带的参数，可以直接在<code>onLoad</code>事件中直接获取到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">onUpload</span>(<span class="params">options</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉刷新-触底加载"><a href="#下拉刷新-触底加载" class="headerlink" title="下拉刷新 触底加载"></a>下拉刷新 触底加载</h3><p><strong>下拉刷新</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onPullDownRefresh<span class="comment">//下拉事件触发后执行该函数</span></span><br><span class="line">wx.<span class="title function_">stopPullDownRefresh</span>()可以停止当前页面的下拉刷新 </span><br></pre></td></tr></table></figure><p><strong>触底加载</strong></p><p>通过<code>onReachBottom()</code>函数即可监听当前页面的触底事件</p><p><code>onReachBottomDistance</code>的值默认为50px，当滚动条距离底部50px的时候认为已触底。</p><h3 id="自定义编译模式"><a href="#自定义编译模式" class="headerlink" title="自定义编译模式"></a>自定义编译模式</h3><p>编译-&gt;添加编译模式，现在用热重载就好了，修改代码保存后不会切换到首页。</p><h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><p>创建components文件夹，右键选择创建组件</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><p>局部<br>在<code>页面</code>的json文件的<code>usingComponents</code>属性中声明</p></li><li><p>全局<br>在app.json文件的<code>usingComponents</code>属性中声明，如果没有就自己添加</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span><span class="string">&quot;/components/test/test&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="comment">//count为组件在页面中的名称</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong>：引入组件在json文件中声明，区别于vue</p></li></ul><h3 id="组件和页面的区别"><a href="#组件和页面的区别" class="headerlink" title="组件和页面的区别"></a>组件和页面的区别</h3><ul><li>组件的 <code>.json</code>文件中需要声明<code>&quot;component&quot;: true</code></li><li>组件的.js文件中调用的是<code>Component()</code>函数，而页面调用的是<code>Page()</code>函数</li></ul><h3 id="样式单向隔离"><a href="#样式单向隔离" class="headerlink" title="样式单向隔离"></a>样式单向隔离</h3><p>默认情况下，自定义组件的样式只对当前组件生效，不会影响到<code>组件之外</code>的UI结构，但是可以被组件外的样式影响。<br><code>app.wxss</code>中的部分全局样式对组件无效，只有<code>class选择器</code>会有样式隔离效果，id选择器、属性选择器、标签选择器不受样式隔离的影响。</p><h2 id="自定义tabbar"><a href="#自定义tabbar" class="headerlink" title="自定义tabbar"></a>自定义tabbar</h2><p>在<code>app.json</code>的<code>tabBar</code>字段中新增<code>custom:true</code>属性</p><img src="..\images\小程序\8.png" style="zoom:90%;" /><p>在根目录新建<code>custom-tab-bar</code>文件，然后右键<code>新建组件</code>，开发工具就会把这个组件当作tabbar</p><img src="..\images\小程序\7.png" style="zoom:90%;" /><p><strong>注意</strong></p><ul><li><p>vant组件的样式是很容易被pages页面样式（主包资源）覆盖的，因为vant组件样式本身就不是隔绝的，主包的资源是可以共享的，包括样式</p></li><li><p><strong>每个 tab 页下的自定义 tabBar 组件实例是不同的</strong>，切换到哪个页面，tabbar组件相当于属于哪个页面的组件，会受到这个页面样式的影响</p></li><li><p>也因为这点，在前一个组件页面修改active，通过导航切换到下一个页面后无效了，所以不能把active交给tabbar组件维护，最好交给仓库维护</p></li></ul><h2 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>分包指的是把一个<code>完整的小程序项目</code>，<code>按照需求</code>划分为不同的<code>子包</code>，在构建时打包成不同的分包，用户在使用时<code>按需进行加载</code>，类似webpack中的<strong>代码分割</strong>。可以优化小程序首次启动的下载时间，在多团队共同开发时可以更好的解耦协作。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li><p>一个主包</p><p>一般只包含项目的<code>启动页面</code>或TabBar页面、以及所有分包都需要用到的一些<code>公共资源</code></p></li><li><p>多个分包</p><p>只包含和当前分包有关的<code>页面</code>和<code>私有资源</code></p></li></ul><h3 id="分包的加载规则"><a href="#分包的加载规则" class="headerlink" title="分包的加载规则"></a>分包的加载规则</h3><ul><li>在小程序启动时，默认会下载<code>主包</code>并启动主包内页面，<code>tabBar 页面</code>需要放到主包中</li><li><code>非tabBar页面</code>可以按照功能的不同，划分为不同的<code>分包</code>之后，进行按需下载</li><li>当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示</li></ul><h3 id="体积限制"><a href="#体积限制" class="headerlink" title="体积限制"></a>体积限制</h3><p>整个小程序所有分包大小不超过<code>16M</code>（主包＋所有分包)，单个分包&#x2F;主包大小不能超过<code>2M</code></p><h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><ul><li><p>根目录下的<code>pages</code>一般放的是所有主包页面</p></li><li><p>在根目录下新建<code>subpkg</code>文件(自定义名称)，创建<code>一个</code>分包，内部可以有多个页面，就如同pages文件夹。</p><img src="..\images\小程序\9.png" style="zoom:90%;" /></li><li><p>还要在app.json文件里声明分包结构（类似vue中的路由）</p><p>可以看到subPackages的值是一个数组，说明可以设置多个分包，一个分包对应一个单独的文件夹，内部可以有多个页面。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;subPackages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;subpkg&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span>&#x27;pkgA&#x27;<span class="punctuation">,</span><span class="comment">//分包别名</span></span><br><span class="line">      <span class="comment">//当前分包下所有页面的相对路径</span></span><br><span class="line">      <span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;detail/detail&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;goods_list/goods_list&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;search/search&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="打包原则"><a href="#打包原则" class="headerlink" title="打包原则"></a>打包原则</h3><ul><li>subpackages之外的目录将被打包到主包中</li><li>tabBar 页面必须在主包内</li><li>分包之间不能互相嵌套</li></ul><h3 id="引用原则"><a href="#引用原则" class="headerlink" title="引用原则"></a>引用原则</h3><ul><li>分包内的资源都是<code>私有</code>的，主包内的资源都是<code>共有</code>的</li><li>主包无法引用分包内的私有资源</li><li>分包之间不能相互引用私有资源</li><li>分包可以引用主包内的公共资源</li></ul><h3 id="独立分包"><a href="#独立分包" class="headerlink" title="独立分包"></a>独立分包</h3><p>普通分包打开依赖于主包，独立分包可以<strong>不依赖主包打开</strong>，独立分包在配置的时候需要额外添加<code>independent：true</code>属性</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;subPackages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;subpkg&quot;</span><span class="punctuation">,</span><span class="comment">//指明是项目根目录下的subpkg文件</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span>&#x27;pkgA&#x27;<span class="punctuation">,</span><span class="comment">//分包别名</span></span><br><span class="line">      <span class="comment">//设置独立分包</span></span><br><span class="line">      <span class="attr">&quot;independent&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">,</span></span><br><span class="line">      <span class="comment">//当前分包下所有页面的相对路径</span></span><br><span class="line">      <span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;detail/detail&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;goods_list/goods_list&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;search/search&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>开发者可以按需，将某些具有一定<code>功能独立性</code>的页面配置到独立分包中，<strong>而独立分包不依赖主包即可运行</strong>，可以很大程度上提升分包页面的<code>启动速度</code>。</p><p>独立分包和普通分包以及主包之间，是相互隔绝的，不能相互引用彼此的资源，独立分包中<strong>不能引用主包内的公共资源</strong></p><img src="..\images\小程序\10.png" style="zoom:67%;" /><h3 id="分包预下载"><a href="#分包预下载" class="headerlink" title="分包预下载"></a>分包预下载</h3><p>在进入小程序的某个<code>页面</code>时，由框架自动预下载<code>可能需要的分包</code>，从而提高进入后续分包的<code>启动速度</code></p><p>在app.json中配置:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;preloadRule&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="comment">//分包预下载规则</span></span><br><span class="line"><span class="attr">&quot;pages/contact/contact&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="comment">//触发分包预下载的页面路径</span></span><br><span class="line"><span class="attr">&quot;network&quot;</span><span class="punctuation">:</span><span class="string">&quot;all&quot;</span><span class="punctuation">,</span><span class="comment">//表示在指定的网络模式下下载，默认为wifi</span></span><br><span class="line"><span class="attr">&quot;packages&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;pkgA&quot;</span><span class="punctuation">]</span><span class="comment">//通过root或name指定预下载哪些分包</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>同一个分包中的页面享有共同的预下载大小限额2M</p><h2 id="协同开发"><a href="#协同开发" class="headerlink" title="协同开发"></a>协同开发</h2><h3 id="小程序版本"><a href="#小程序版本" class="headerlink" title="小程序版本"></a>小程序版本</h3><p>上传代码，上传的代码为开发版本</p><p>提交审核，为审核版本</p><p>审核通过可以发布，为线上版本</p><h3 id="小程序推广"><a href="#小程序推广" class="headerlink" title="小程序推广"></a>小程序推广</h3><p>登录小程序管理后台→设置-&gt;基本设置→基本信息小程序码→及线下物料下载</p><h3 id="查看运营数据"><a href="#查看运营数据" class="headerlink" title="查看运营数据"></a>查看运营数据</h3><p>在后台统计查看，或者使用小程序数据助手。</p>]]></content>
      
      
      <categories>
          
          <category> 微信小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试---ES6</title>
      <link href="/posts/d73c0d37.html"/>
      <url>/posts/d73c0d37.html</url>
      
        <content type="html"><![CDATA[<h1 id="var-let-const有哪些区别"><a href="#var-let-const有哪些区别" class="headerlink" title="var,let,const有哪些区别"></a>var,let,const有哪些区别</h1><p>在ES5中，顶层对象（在浏览器中是<code>window</code>）的属性和全局变量是等价的，或者说全局变量会被挂载到<code>window</code>对象中</p><ul><li><p><strong>变量提升</strong></p><p><code>var</code>声明的变量存在<strong>变量提升</strong>，变量提升只提升<strong>变量声明</strong>，不提升<strong>变量赋值</strong>。而<code>let</code>和<code>const</code>不存在变量提升</p></li><li><p><strong>重复声明</strong></p><p>var声明的变量可以被<code>重复声明</code>，后面声明的会<strong>覆盖</strong>前面声明的。而<code>let</code>和<code>const</code>声明的变量无法被<code>重复声明</code>。</p></li><li><p><strong>作用域</strong></p><p>var声明的变量只会产生<code>函数作用域</code>，不会产生<strong>块级作用域</strong></p><p>let用来声明一个<code>变量</code>，会产生一个<strong>块级作用域</strong>，</p><p>const用来声明一个<code>常量</code>，也会产生一个<strong>块级作用域</strong>。</p></li></ul><h2 id="变量提升与函数提升"><a href="#变量提升与函数提升" class="headerlink" title="变量提升与函数提升"></a>变量提升与函数提升</h2><p>只有<code>var声明的变量</code>才存在变量提升，只有<code>具名函数</code>才存在函数提升。</p><p>函数提升优先级比变量提升要高，且不会被变量声明覆盖，但是会被<code>变量赋值</code>覆盖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);<span class="comment">//输出函数ƒ foo()&#123;...&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数声明&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;变量&quot;</span>;<span class="comment">//后声明，后赋值</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数声明&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);<span class="comment">//输出`123`</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数声明&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);<span class="comment">//输出`123`</span></span><br></pre></td></tr></table></figure><p>简单的来说，当输出foo变量会导致输出<code>undefined</code>的时候，那输出的就是foo函数，否则就输出foo变量，<strong>赋值后的变量优先级最高</strong>。</p><h2 id="数组新增了哪些扩展"><a href="#数组新增了哪些扩展" class="headerlink" title="数组新增了哪些扩展"></a>数组新增了哪些扩展</h2><h3 id="扩展运算符-…"><a href="#扩展运算符-…" class="headerlink" title="扩展运算符 …"></a>扩展运算符 …</h3><p>扩展运算符的作用就是把数组变成一个序列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">//等同于console.log(1,2,3)</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>用来展开数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...arr)<span class="comment">//求数组arr的最大值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>用来合并，拷贝数组</strong></p><p>拷贝数组进行的是<code>浅层次</code>的拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [...arr1,...arr2]</span><br></pre></td></tr></table></figure></li><li><p><strong>定义了遍历器（Iterator）接口的对象（可迭代对象），都可以用扩展运算符转为真正的数组</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.<span class="title function_">keys</span>()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>如果对没有<code> Iterator</code> 接口的对象，使用扩展运算符，将会报错，因为这些对象是不可迭代的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure><p>除非写成<code>&#123;...obj&#125;</code>的形式，表示拷贝对象。</p></li></ul><h3 id="构造函数Array的新增方法"><a href="#构造函数Array的新增方法" class="headerlink" title="构造函数Array的新增方法"></a>构造函数Array的新增方法</h3><p>关于构造函数，数组新增的方法有如下：</p><ul><li>Array.from()</li><li>Array.of()</li></ul><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>将两类对象转为真正的数组：类似数组的对象(<code>伪数组</code>)和<code>可迭代对象</code>（包括 <code>ES6</code> 新增的数据结构 <code>Set</code> 和 <code>Map</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>还可以接受<code>第二个参数</code>，用来对每个元素进行处理，将处理后的值放入返回的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)<span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h4><p>用于将一组值，转换为数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br></pre></td></tr></table></figure><p>当参数只有一个的时候，实际上是指定数组的长度</p><p>参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>() <span class="comment">// []</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><h3 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h3><ul><li>find()、findIndex()</li><li>fill()</li><li>entries()，keys()，values()</li><li>includes()</li></ul><h4 id="find-findIndex"><a href="#find-findIndex" class="headerlink" title="find,findIndex"></a>find,findIndex</h4><p><code>find()</code>用于找出，返回第一个符合条件的数组成员</p><p>参数是一个回调函数，接受三个参数依次为当前的值、当前的位置和原数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]</span><br><span class="line">a.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">value, index, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 返回10</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">findIndex`返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回`-1</span><br><span class="line">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;</span><br><span class="line">  return value &gt; 9;</span><br><span class="line">&#125;) // 2</span><br></pre></td></tr></table></figure><h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p>使用给定值，填充一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>).<span class="title function_">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure><p>还可以接受第二个和第三个参数，用于指定填充的<code>起始位置</code>和<code>结束位置</code>，左闭右开</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><blockquote><p> 注意，如果填充的类型为对象，则是浅拷贝，即被填充的数据，使用的都是同一个对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">fill</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">//[&#123;name:&#x27;tom&#x27;&#125;,&#123;name:&#x27;tom&#x27;&#125;] 数组中的这两个对象是同一个对象</span></span><br></pre></td></tr></table></figure><p>除非每次填充都使用新创建的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].<span class="title function_">fill</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><h4 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h4><p>用于判断数组是否包含给定的值，相比<code>indexOf</code>方法，优化了对<code>NaN</code>的判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="title class_">NaN</span>].<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="函数新增了哪些扩展"><a href="#函数新增了哪些扩展" class="headerlink" title="函数新增了哪些扩展"></a>函数新增了哪些扩展</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>ES6</code>允许为函数的参数设置<code>默认值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">//输出 Hello World</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">//输出 Hello China</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>)  <span class="comment">//输出 Hello</span></span><br></pre></td></tr></table></figure><p>函数的形参是<strong>默认声明</strong>的，不能使用<code>let</code>或<code>const</code>再次声明  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = <span class="number">5</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>解构赋值</code>过程中也可以给<code>形参</code>添加<code>默认值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line"><span class="title function_">foo</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line"><span class="title function_">foo</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>函数本质也是个对象，有许多属性</p><ul><li><p><code>func.length</code></p><p>将返回没有指定<code>默认值</code>的参数个数，具体情况还得具体分析，感觉很鸡肋。</p></li><li><p><code>func.name</code></p><p>如果把<code>匿名函数</code>赋值给一个变量，则name属性返回这个变量的名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.<span class="property">name</span> <span class="comment">// &quot;&quot;</span></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.<span class="property">name</span> <span class="comment">// &quot;f&quot;</span></span><br></pre></td></tr></table></figure><p>如果将一个<code>具名函数</code>赋值给一个变量，则 <code>name</code>属性都返回这个<code>具名函数</code>原本的名字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">bar.<span class="property">name</span> <span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure><p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">foo.<span class="title function_">bind</span>(&#123;&#125;).<span class="property">name</span> <span class="comment">// &quot;bound foo&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个<strong>单独的作用域</strong></p><p>等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的</p><p>下面例子中，<code>y=x</code>会形成一个单独作用域，<code>x</code>没有被定义，所以指向全局变量<code>x</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">y = x</span>) &#123; </span><br><span class="line">  <span class="comment">// 等同于 let y = x  </span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><ul><li><p>必须写在<code>当前作用域</code>的<code>作用域顶部</code>才能生效</p></li><li><p>当一个函数被直接调用，无论这个函数在哪儿被直接调用，先看<code>全局作用域</code>中是否开启了严格模式，如果开启了，则this指向<code>undefined</code>，如果未开启，再查看这个被直接调用的函数内部，是否开启了严格模式，如果开启了，则this指向undefined，否则this指向全局对象，在浏览器中指的就是window对象</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">117</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>.<span class="property">num</span>);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">//undefined</span></span><br><span class="line">  <span class="title function_">func1</span>();<span class="comment">//函数func1直接被调用，全局作用域和这个函数内部都未开启严格模式，this指向window输出117</span></span><br><span class="line">&#125;)()<span class="comment">//立即执行函数，属于直接被调用</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">117</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, <span class="variable language_">this</span>.<span class="property">num</span>);</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">//undefined</span></span><br><span class="line">  <span class="title function_">func1</span>();<span class="comment">//函数func1直接被调用，全局作用域开启了严格模式，this指向undefeined</span></span><br><span class="line"><span class="comment">//立即执行函数，属于直接被调用，全局作用域开启了严格模式，所以this=undefined</span></span><br></pre></td></tr></table></figure><p>只要<code>函数形参</code>使用了<code>默认值</code>、<code>解构赋值</code>、或者<code>扩展运算符</code>，那么函数内部就<strong>不能显式设定为严格模式</strong>，否则会报错。所以说函数内部也不能随便开启严格模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">a, b = a</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="keyword">function</span> (<span class="params">&#123;a, b&#125;</span>) &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">doSomething</span> = (<span class="params">...a</span>) =&gt; &#123;</span><br><span class="line">  <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="title function_">doSomething</span>(<span class="params">&#123;a, b&#125;</span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>形如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()=&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>更适用于那些本来 需要<code>匿名函数</code>的地方，类似<code>lambda</code>表达式，它和普通<code>匿名函数</code>一样，它属于<code>表达式函数</code>，不存在<code>函数提升</code></p></li><li><p>只有一个<code>参数</code>的时候可以省略括号；只有一行代码且是<code>return</code>语句，可以省略<code>大括号</code>和<code>return</code>关键字，如果返回的是一个对象，则需要加括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">item =&gt; item.<span class="property">name</span> <span class="comment">//等同于(item)=&gt;&#123; return item.name &#125;</span></span><br><span class="line">item =&gt; (&#123;<span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>没有自己的<strong>环境变量</strong><code>this</code>，内部的this指向被定义的时候<code>外层函数</code>的this，<strong>this指向和如何被调用无关</strong></p></li><li><p>因为没有自己的环境变量<code>this</code>，所以无法使用<code>apply</code>，<code>call</code>，<code>bind</code>等方法改变箭头函数内部的<code>this</code>指向，但是可以<code>调用</code>这些方法。</p></li><li><p>内部也没有<code>arguments</code>对象。<code>arguments</code>在一般函数内部可以直接使用（如同this），即便函数没有形参，也可以给函数传参，传递的所有参数都会被收集到arguments对象</p></li><li><p>没有自己的<code>原型对象</code>，所以不能当作<code>构造函数</code>使用，不能用来创造实例。</p><ul><li>内部不可以使用<code>yield</code>命令，因此箭头函数不能用作 <code>Generator</code> 函数</li></ul></li></ul><h2 id="对象新增了哪些扩展"><a href="#对象新增了哪些扩展" class="headerlink" title="对象新增了哪些扩展"></a>对象新增了哪些扩展</h2><h3 id="属性的简写"><a href="#属性的简写" class="headerlink" title="属性的简写"></a>属性的简写</h3><p>ES6中，当对象键名与对应值名相等的时候，可以进行简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>:foo&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;</span><br></pre></td></tr></table></figure><p>方法也能够进行简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="comment">//这是一种简写方式</span></span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><p>eS6 允许字面量定义对象时，将表达式放在括号内，当作对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastWord = <span class="string">&#x27;last word&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="string">&#x27;first word&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  [lastWord]: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;first word&#x27;</span>] <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">a[lastWord] <span class="comment">// &quot;world&quot;</span></span><br><span class="line">a[<span class="string">&#x27;last word&#x27;</span>] <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>注意，<code>属性名表达式</code>与<code>属性名简写</code>，不能同时使用，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo]: foo&#125;;</span><br></pre></td></tr></table></figure><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的<code>原型对象</code></p><p>即<code>super=this.__proto__</code></p><h2 id="如何理解ES6新增Set、Map两种数据结构"><a href="#如何理解ES6新增Set、Map两种数据结构" class="headerlink" title="如何理解ES6新增Set、Map两种数据结构"></a>如何理解ES6新增Set、Map两种数据结构</h2><p><code>Set</code>是一种叫做<code>集合</code>的数据结构，什么是集合？什么又是字典？</p><ul><li>集合<br>是由一堆无序的、相关联的，且不重复的内存结构【数学中称为元素】组成的组合</li><li>字典<br>是一些元素的集合。每个元素有一个称作key 的域，不同元素的key各不相同</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>Set</code>本身是一个构造函数，用来生成Set数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br></pre></td></tr></table></figure><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p><code>Set</code>的实例关于增删改查的方法：</p><ul><li><p>add()</p><p>向集合中添加元素，返回 <code>Set</code> 结构本身，所以可以<code>链式调用</code></p><p>当添加实例中已经存在的元素，<code>set</code>不会进行处理添加，即会被<code>去重</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">2</span>); <span class="comment">// 2只被添加了一次</span></span><br></pre></td></tr></table></figure></li><li><p>delete()</p><p>删除某个值，返回一个<code>布尔值</code>，表示删除是否成功</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">delete</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>has()</p><p>返回一个<code>布尔值</code>，判断集合中是否存在某个元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">has</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>clear()</p><p>清除所有成员，没有返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure></li></ul><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>关于遍历的方法，有如下：</p><ul><li>keys()：返回<code>键名</code>的迭代器</li><li>values()：返回<code>键值</code>的迭代器</li><li>entries()：返回<code>键值对</code>的迭代器</li><li>forEach()：使用回调函数遍历每个成员</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以看出Set其实就是键和值相等的Map</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="comment">//每个entry的类型是数组，第一个元素是键名，第二个元素是键值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到其实Set的本质就是Map</span></span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure><p><strong>forEach</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27; : &#x27;</span> + value))</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>扩展运算符和<code>Set</code> 结构相结合实现<code>数组</code>或<code>字符串</code>去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 创建一个集合的同时传入一个数组，然后再把这个集合转变成数组，从而起到去重的作用</span></span><br><span class="line"><span class="comment">// 说明Set实例也是可迭代对象，所以能够转化成数组</span></span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]; <span class="comment">// [3, 5, 2]</span></span><br><span class="line"><span class="comment">// 或者let unique = Array.from(new Set(arr)) </span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;352255&quot;</span>;</span><br><span class="line"><span class="comment">//竟然还能传入一个字符串？给字符串去重，因该是把字符串拆分成了字符数组</span></span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> <span class="title class_">Set</span>(str)].<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// &quot;352&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型</p><p><code>Map</code>本身是一个构造函数，用来生成 <code>Map</code> 数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br></pre></td></tr></table></figure><h4 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h4><p><code>Map</code> 结构的实例针对增删改查有以下属性和操作方法：</p><ul><li><p>size 属性</p><p><code>size</code>属性返回键值对的个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>set()</p><p>设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个Map结构</p><p>如果<code>key</code>已经有值，则键值会被<code>更新</code>，否则就新生成该键</p><p>同时返回的是当前<code>Map</code>对象，可采用<code>链式写法</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>)        <span class="comment">// 键是字符串</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>)     <span class="comment">// 键是数值</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>)    <span class="comment">// 键是 undefined</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>).<span class="title function_">set</span>(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>) <span class="comment">// 链式操作</span></span><br></pre></td></tr></table></figure></li><li><p>get()</p><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到key，返回<code>undefined</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line"></span><br><span class="line">const hello = function() &#123;console.log(&#x27;hello&#x27;);&#125;;</span><br><span class="line">m.set(hello, &#x27;Hello ES6!&#x27;) // 键是函数</span><br><span class="line"></span><br><span class="line">m.get(hello)  // Hello ES6!</span><br></pre></td></tr></table></figure></li><li><p>has()</p><p><code>has</code>方法返回一个布尔值，表示某个<code>键</code>是否在当前 Map 对象之中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;edition&#x27;</span>, <span class="number">6</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="number">262</span>, <span class="string">&#x27;standard&#x27;</span>);</span><br><span class="line">m.<span class="title function_">set</span>(<span class="literal">undefined</span>, <span class="string">&#x27;nah&#x27;</span>);</span><br><span class="line"></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;edition&#x27;</span>)     <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="string">&#x27;years&#x27;</span>)       <span class="comment">// false</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="number">262</span>)           <span class="comment">// true</span></span><br><span class="line">m.<span class="title function_">has</span>(<span class="literal">undefined</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>delete()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete`方法删除某个键，返回`true`。如果删除失败，返回`false</span><br><span class="line">const m = new Map();</span><br><span class="line">m.set(undefined, &#x27;nah&#x27;);</span><br><span class="line">m.has(undefined)     // true</span><br><span class="line"></span><br><span class="line">m.delete(undefined)</span><br><span class="line">m.has(undefined)       // false,删除后不再存在</span><br></pre></td></tr></table></figure></li><li><p>clear()</p><p><code>clear</code>方法清除所有成员，没有返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 2</span></span><br><span class="line">map.<span class="title function_">clear</span>()</span><br><span class="line">map.<span class="property">size</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h4><ul><li>keys()：返回<code>键名</code>的迭代器</li><li>values()：返回<code>键值</code>的迭代器</li><li>entries()：返回<code>键值对</code>的迭代器</li><li>forEach()：遍历 Map 的所有成员</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个二维数组说是</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;no&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;T&#x27;</span>,  <span class="string">&#x27;yes&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()，默认调用entries方法得到键值对迭代器</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;F&quot; &quot;no&quot;</span></span><br><span class="line"><span class="comment">// &quot;T&quot; &quot;yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map中的forEach的用法和set中的一样</span></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key, map</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Set对应数据结构中的集合，Map对应数据结构中的字典</li><li>Set本质是键和值相同的Map</li><li>Set和Map都有has，clear，delete这三个方法；</li><li>Set独有的方法的是add，返回Set实例本身，支持链式调用；Map独有的方法是get，set，其中set方法返回的也是Map实例本身，也支持链式调用。</li><li>Set和Map的遍历的方法都包括<code>for...of...</code>和<code>forEach</code>，其中<code>for...of...</code>的对象又包括各种迭代器。</li></ul><h2 id="你是怎么理解ES6中-Promise的"><a href="#你是怎么理解ES6中-Promise的" class="headerlink" title="你是怎么理解ES6中 Promise的"></a>你是怎么理解ES6中 Promise的</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>是<code>异步编程</code>的一种<code>解决方案</code>，比传统的解决方案—<code>回调函数</code>，更加合理和更加强大</p><p>因为使用回调函数来解决异步编程问题，存在<code>回调函数地狱问题</code>，即在回调函数中嵌套回调函数，这样就导致代码的可读性变得很差，代码也变得难以维护。</p><p>而使用<code>promise</code>解决异步编程操作有如下优点：</p><ul><li><code>链式操作</code>减低了编码难度</li><li>代码可读性明显增强</li></ul><p>下面我们来正式介绍promise：</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><code>promise</code>对象仅有三种状态</p><ul><li><code>pending</code>（进行中）</li><li><code>fulfilled</code>（已成功）</li><li><code>rejected</code>（已失败）</li></ul><p>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</p><p>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变</p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">//内部代码从给出的resolve, reject中选一个调用，改变promise对象的状态</span></span><br><span class="line">    <span class="comment">//内部的代码会立即执行，但是resolve/reject可能被异步调用</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code></p><ul><li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”</li><li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败“</li></ul><p><code>Promise</code>构建出来的实例存在以下方法：</p><ul><li>then()</li><li>catch()</li><li>finally()</li></ul><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例，也就是<code>promise</code>能链式书写的原因。</p><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p><code>catch()</code>方法用于指定发生错误时的回调函数，本质就是在内部调用<code>then(undefined,onRejected)</code></p><p>一般来说，使用<code>catch</code>方法代替<code>then()</code>第二个参数</p><h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作，内部其实本质就是在调用<code>then(onFinally,onFinally)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>Promise</code>构造函数存在以下方法：</p><ul><li>all()</li><li>race()</li><li>allSettled()</li><li>resolve()</li><li>reject()</li></ul><h3 id="手写一个Promise"><a href="#手写一个Promise" class="headerlink" title="手写一个Promise"></a>手写一个Promise</h3><p>为了帮助我们更深入的理解Promise，建议尝试自己手写一个Promise</p><p>参考资料：<a href="https://www.bilibili.com/video/BV1mH4y1Q7Z7?spm_id_from=333.788.videopod.episodes&vd_source=00483a04a5a69136669373a8ea522a9b&p=17">Day02-01.手写promise-核心功能-构造函数_哔哩哔哩_bilibili</a></p><p><strong>任务目标</strong></p><ul><li><p><strong>创建一个myPromise类，处理同步修改promise状态的情况</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPromise</span> &#123;</span><br><span class="line">    state = <span class="variable constant_">PENDING</span><span class="comment">//默认值</span></span><br><span class="line">    result</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">func</span>) &#123;</span><br><span class="line">      <span class="comment">//func是创建promise实例的时候，传入的回调函数</span></span><br><span class="line">      <span class="comment">//这个回调函数接受两个参数resolve，reject，我们在构造函数内部准备这两个方法</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">res</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还没有改变</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">          <span class="comment">//那就改变它的状态为&#x27;fulfilled&#x27;</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">          <span class="comment">//res是传入的值</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">result</span> = res</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">err</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还没有改变</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">          <span class="comment">//那就改变它的状态为&#x27;rejected&#x27;</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">result</span> = err</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//因为用户传入的回调函数func本身也可能报错，所以我们用try-catch捕获一下</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//同步调用传入的回调函数，传入2个准备好的能改变promise实例状态的函数</span></span><br><span class="line">        <span class="comment">//由用户决定如何改变promise实例的状态</span></span><br><span class="line">        <span class="title function_">func</span>(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暂时只考虑同步修改promise状态</span></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">onFulFilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">         <span class="title function_">onFulFilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">            <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//同步修改promise状态</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//因为p的状态在刚被创建的时候就改变了，then方法传入的回调函数也会马上执行，拿到p实例的值</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(res)&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(err)&#125;)<span class="comment">//立即输出1</span></span><br></pre></td></tr></table></figure></li><li><p><strong>处理异步修改promise状态的情况</strong></p><p>如果我们promise的状态是异步改变的，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1s后，再调用resolve方法，把promise实例的状态修改为&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="title function_">resolve</span>(<span class="number">1</span>)&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>创建完实例p后我们同步调用<code>then</code>方法（调用then方法本身是同步的，创建promise对象，执行构造函数本身也是同步的）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(res)&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(err)&#125;)</span><br></pre></td></tr></table></figure><p>因为<code>p</code>的状态还没有改变，所以我们还不能执行传入<code>then</code>方法的回调函数，那我们还怎么确保<code>1s</code>后<code>p</code>状态改变，这个回调函数会被调用呢?</p><p>我们先把回调函数存储到一个数组<code>#handler</code>中，当<code>p</code>状态改变的时候再查找这个数组，执行对应的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPromise</span> &#123;</span><br><span class="line">    state = <span class="variable constant_">PENDING</span><span class="comment">//默认值</span></span><br><span class="line">    result</span><br><span class="line">    #handler = []</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">func</span>) &#123;</span><br><span class="line">      <span class="comment">//func是创建promise实例的时候，传入的回调函数</span></span><br><span class="line">      <span class="comment">//这个回调函数接受两个参数resolve，reject，我们在构造函数内部准备这两个方法</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">res</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还没有改变</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">          <span class="comment">//那就改变它的状态为&#x27;fulfilled&#x27;</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">          <span class="comment">//res是传入的值</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">result</span> = res</span><br><span class="line">          <span class="comment">//resolve函数执行之时，就是promise状态改变之时，就是回调函数该被调用的时候</span></span><br><span class="line">          <span class="variable language_">this</span>.#handler.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123; item.<span class="title function_">onFulFilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>) &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">err</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还没有改变</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">          <span class="comment">//那就改变它的状态为&#x27;rejected&#x27;</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">state</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">result</span> = err</span><br><span class="line">          <span class="comment">//reject函数执行之时，就是promise状态改变之时，就是回调函数该被调用的时候</span></span><br><span class="line">          <span class="variable language_">this</span>.#handler.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123; item.<span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>) &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//同步调用传入的回调函数，传入2个准备好的能改变promise实例状态的函数</span></span><br><span class="line">      <span class="comment">//因为用户传入的回调函数func本身也可能报错，所以我们用try-catch捕获一下</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title function_">func</span>(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暂时只考虑同步修改promise状态</span></span><br><span class="line">    <span class="title function_">then</span>(<span class="params">onFulFilled, onRejected</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="comment">//执行传入的回调函数，并把值暴露出去</span></span><br><span class="line">        <span class="title function_">onFulFilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="comment">//执行传入的回调函数，并把值暴露出去</span></span><br><span class="line">        <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还未改变,就先把传入的回调函数存储起来，也可以理解为放入任务队列中</span></span><br><span class="line">        <span class="variable language_">this</span>.#handler.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onFulFilled</span><br><span class="line">          , onRejected</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="number">123</span>) &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(res) &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(err) &#125;)<span class="comment">//1s后输出123</span></span><br></pre></td></tr></table></figure></li><li><p><strong>处理then的返回值</strong></p><p>因为then方法是支持<code>链式调用</code>的，意味着then方法的返回值也是一个promise对象，如何确定返回的promise实例的状态和值呢？</p><p>then方法把传入的<code>回调函数</code>的返回值包装成<code>promise</code>对象后返回</p><p>我们先修改一下then方法，确保能返回一个<code>promise</code>对象，这样书写并不会改变代码原有的功能，<strong>因为构造函数中的代码是立即执行的</strong>，原来的代码也是同步执行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulFilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//原来的代码顶部------------</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="title function_">onFulFilled</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还未改变</span></span><br><span class="line">        <span class="variable language_">this</span>.#handler.<span class="title function_">push</span>(&#123;</span><br><span class="line">          onFulFilled</span><br><span class="line">          , onRejected</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="comment">//原来的代码底部---------------</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再思考返回的<code>promise</code>对象的状态与值如何确定，代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入的resolve,reject，是被用来修改then方法返回的myPromise实例的状态的</span></span><br><span class="line"><span class="comment">//这个wrap方法到底做了什么？</span></span><br><span class="line"><span class="comment">//1.调用传入的回调函数，把promise对象的值（this.result）传入</span></span><br><span class="line"><span class="comment">//2.分析回调函数的返回值，调用传入的，能够改变then方法返回的promise对象状态的函数</span></span><br><span class="line"><span class="comment">//修改then方法返回对象的状态</span></span><br><span class="line"><span class="title function_">wrap</span>(<span class="params">func, resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">//wrap中this的指向等于then的this指向,指向同一个promise对象</span></span><br><span class="line">    <span class="comment">//因为调用传入的onFulFilled/onRejected函数可能会报错，所以使用try-catch捕获</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//需要拿到返回值，来确定then函数返回的promise实例的状态</span></span><br><span class="line">      <span class="keyword">const</span> x = <span class="title function_">func</span>(<span class="variable language_">this</span>.<span class="property">result</span>)</span><br><span class="line">      <span class="comment">//如果返回的是一个myPromise对象，它的状态可能是同步改变或者异步改变</span></span><br><span class="line">      <span class="comment">//因为我们已经解决了异步回调的情况的，所以也能通过then方法拿到它的result，</span></span><br><span class="line">      <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">        <span class="comment">//wow，相当于由一个promise对象的状态来确定另一个promise的状态</span></span><br><span class="line">        x.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="title function_">resolve</span>(res) &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="title function_">reject</span>(err) &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果返回值不是myPromise对象，那就简单了，直接resolve</span></span><br><span class="line">        <span class="title function_">resolve</span>(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">//如果报错直接返回状态为rejeted的promise实例</span></span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="title function_">then</span>(<span class="params">onFulFilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">wrap</span>(onFulFilled, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> == <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">wrap</span>(onRejected, resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果promise实例的状态还未改变</span></span><br><span class="line">        <span class="variable language_">this</span>.#handler.<span class="title function_">push</span>(&#123;</span><br><span class="line">          <span class="attr">onFulFilled</span>:<span class="function">()=&gt;</span>&#123;<span class="variable language_">this</span>.<span class="title function_">wrap</span>(onFulFilled, resolve, reject)&#125;</span><br><span class="line">          , <span class="attr">onRejected</span>:<span class="function">()=&gt;</span>&#123;<span class="variable language_">this</span>.<span class="title function_">wrap</span>(onRejected, resolve, reject)&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个1s后状态改变的promise对象</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="number">1</span>) &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//p调用then方法，因为p状态未确定，回调函数被wrap包装，然后push到#handler</span></span><br><span class="line"><span class="comment">//虽然传入的回调函数没有立马被调用，但是then方法已经返回了一个状态未改变的promise对象</span></span><br><span class="line"><span class="comment">//第一个then方法返回的对象状态未改变，第2次then的调用执行了，但是没动静</span></span><br><span class="line"><span class="comment">//1s后，因为在构造函数内调用resolve(1)方法，p的状态改变，遍历执行#handler中的待执行的回调函数，执行被包装的回调函数</span></span><br><span class="line"><span class="comment">//执行被包装的函数，也就是第一个then传入的第一个回调函数，输出1，等待2s后，调用resolve(2)方法</span></span><br><span class="line"><span class="comment">//此时第一个then方法返回的对象状态被改变，于是第二个then传入的回调函数也被触发，输出2</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(err) &#125;)</span><br><span class="line"><span class="comment">//第一次调用then方法立马返回一个promise对象，但是由于对象的状态还未确定，1s后才会打印出2</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(res) &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(err) &#125;)</span><br></pre></td></tr></table></figure><p>结果就是1s后输出1，3秒后输出2。</p></li><li><p>实现<code>catch</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>finally</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">finally</span>(<span class="params">onFinally</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">then</span>(onFinally, onFinally)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>resolve</code>静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">res</span>) &#123;</span><br><span class="line">   <span class="comment">//如果本来就是myPromise实例，则直接返回</span></span><br><span class="line">   <span class="keyword">if</span> (res <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">     <span class="keyword">return</span> res</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="title function_">resolve</span>(res)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>reject</code>静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>race</code>静态方法</p><p>传入一个数组，返回最先兑现的<code>promise</code>，无论是<code>resolve</code>还是<code>reject</code>，只取一个值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">   <span class="comment">//传入的必须是一个数组</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;arguments is not iterable&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果数组长度为0</span></span><br><span class="line">      <span class="keyword">if</span> (arr.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>([])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//对每个元素都调用then方法（同时），不是myPromise对象则先包裹</span></span><br><span class="line">      <span class="comment">//再等待它们状态的改变，来改变最终返回的promise的状态</span></span><br><span class="line">      arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span> =&gt;</span> &#123; myPromise.<span class="title function_">resolve</span>(i).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123; <span class="title function_">resolve</span>(res) &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="title function_">reject</span>(err) &#125;) &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>all</code>静态方法</p><p>要求传入的数组中的所有 myPromise对象的状态都<code>resolve</code>后，再resolve(&#x2F;&#x2F;包含所有对象值的数组)</p><p>如果任意一个对象reject了，则reject这个对象的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//如果传入的不是数组，报错</span></span><br><span class="line">      <span class="keyword">if</span> (!(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;arguments is not iterable&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arr.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>([])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> result = []</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">      <span class="comment">//要求返回的数组中元素的排列顺序就是传入的顺序</span></span><br><span class="line">      arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">        myPromise.<span class="title function_">resolve</span>(i).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          result[index] = res</span><br><span class="line">          <span class="keyword">if</span> (++count == arr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(result)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="title function_">reject</span>(err) &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>any</code>静态方法</p><p>就是和all相反。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">any</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;arguments is not iterable&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arr.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>([], <span class="string">&#x27;All promises were rejected&#x27;</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> errs = []</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">      arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">        myPromise.<span class="title function_">resolve</span>(i).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(res)</span><br><span class="line">        &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          errs[index] = err</span><br><span class="line">          <span class="keyword">if</span> (++count == arr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>(errs, <span class="string">&#x27;All promises were rejected&#x27;</span>))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>allSettled</code>方法</p><p>传入Promise都变成已敲定,即可获取兑现的结果</p><p>结果数组[{status: ‘fulfilled’, value: 1}, {status: ‘rejected’, value: 3)]</p><p>结果数组的顺序,和传入的Promise数组的顺序一致</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">allSettled</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">myPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>)) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;arguments is not iterable&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>([])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result = []<span class="comment">//一个对象数组</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">      myPromise.<span class="title function_">resolve</span>(i).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        result[index] = &#123; <span class="attr">state</span>: <span class="variable constant_">FULFILLED</span>, <span class="attr">value</span>: res &#125;</span><br><span class="line">        <span class="keyword">if</span> (++count == arr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        result[index] = &#123; <span class="attr">state</span>: <span class="variable constant_">REJECTED</span>, <span class="attr">reason</span>: err &#125;</span><br><span class="line">        <span class="keyword">if</span> (++count == arr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>使用<code>Promise.all()</code>合并多个请求，只需设置一个<code>loading</code>即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initLoad</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// loading.show() //加载loading</span></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getBannerList</span>(),<span class="title function_">getStoreList</span>(),<span class="title function_">getCategoryList</span>()]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        loading.<span class="title function_">hide</span>() <span class="comment">//关闭loading</span></span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        loading.<span class="title function_">hide</span>()<span class="comment">//关闭loading</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据初始化    </span></span><br><span class="line"><span class="title function_">initLoad</span>()</span><br></pre></td></tr></table></figure><p>通过<code>race</code>可以设置<code>图片请求超时时间</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求某个图片资源</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">requestImg</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">        <span class="comment">//也是异步回调确定p的状态</span></span><br><span class="line">        img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="title function_">resolve</span>(img);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//img.src = &quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg&quot;; 正确的</span></span><br><span class="line">        img.<span class="property">src</span> = <span class="string">&quot;https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时函数，用于给请求计时</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timeout</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;图片请求超时&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">5000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span></span><br><span class="line">.<span class="title function_">race</span>([<span class="title function_">requestImg</span>(), <span class="title function_">timeout</span>()])</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">results</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="for-in-和-for-of的区别"><a href="#for-in-和-for-of的区别" class="headerlink" title="for in 和 for of的区别"></a>for in 和 for of的区别</h2><h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><p><code>for in</code>语句以任意顺序迭代一个<code>对象</code>的除<code>Symbol</code>以外的<code>可枚举属性</code>，包括<code>继承的</code>可枚举属性</p><p>一个直接创建的对象是非常常见的，它的原型是<code>Object.prototype</code>，上面的属性都是不可枚举的，所以我们使用<code>for in</code>遍历这种对象时，只会得到它的自己的所有可枚举属性。</p><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h3><p>for of语句可以遍历<code>可迭代对象</code>，包括Array，Map，Set，string，TypedArray，arguments对象等等，遍历的是<code>值</code>，<code>继承</code>而来的无法遍历；保证迭代顺序，而一个直接创建的对象是<code>不可迭代</code>的，无法直接使用<code>for of</code>来遍历。</p><h4 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a><strong>可迭代对象</strong></h4><p>即满足了<code>迭代协议</code>的对象，需要存在一个名为<code>[Symbol.iterator]</code>的方法，这个方法<code>返回</code>一个迭代器对象</p><p>直接创建的对象不是可迭代对象，因为没有这个方法，但是我们也可以手动添加这个方法，让它变成<code>可迭代对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">name</span>:<span class="string">&#x27;1&#x27;</span>,<span class="attr">age</span>:<span class="string">&#x27;21&#x27;</span>,[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]:<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="keyword">return</span> 迭代器对象&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代器对象"><a href="#迭代器对象" class="headerlink" title="迭代器对象"></a><strong>迭代器对象</strong></h4><p>其实迭代器对象就是一个普通对象，包含名为<code> next()</code> 的方法，并没有想象的那么复杂；next方法返回一个包含<code>两个属性</code>的<code>对象</code>：value 和 done。<code>value</code> 是迭代的当前值，<code>done</code> 是一个布尔值，表示是否已经到达了迭代的末尾。</p><p><img src="/../images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-js/%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1.png"></p><p>那么改如何实现一个<code>迭代器对象</code>呢？</p><ul><li><p><strong>手动创建</strong></p><p>根据迭代器对象的定义，我们可以尝试手动创建一个<code>迭代器对象</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">//返回一个迭代器对象</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: arr[index++] &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="string">&#x27;end&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>借助生成器函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">    <span class="comment">//如果生成器函数中有return，return后迭代也就终止了，无论后面还有没有yield</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">      <span class="comment">//直接返回一个迭代器对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">generator</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)<span class="comment">//依次输出1，2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当使用 <code>for...of</code> 遍历一个可迭代对象时，它实际上调用了该对象的 <code>[Symbol.iterator]</code> 方法，<strong>并根据迭代器提供的值进行迭代</strong>。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><p><strong>遍历的东西不同</strong></p><p>for in 遍历的对象的<code>属性</code>，for of遍历的<code>对象的值</code></p></li><li><p><strong>遍历的范围不同</strong></p><p>for in遍历的是<code>对象自己的可枚举属性</code>以及<code>它继承的所有可枚举属性</code></p><p>for of遍历的是<code>对象自己的属性的值</code></p></li><li><p><strong>使用的范围不同</strong></p><p><code>for in</code>可以用于遍历<code>任何对象</code>，而<code>for of</code>只能用来遍历<code>可迭代对象</code></p></li></ul><h2 id="你是怎么理解ES6中-Generator的？使用场景？"><a href="#你是怎么理解ES6中-Generator的？使用场景？" class="headerlink" title="你是怎么理解ES6中 Generator的？使用场景？"></a>你是怎么理解ES6中 Generator的？使用场景？</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>Generator 函数是 ES6 提供的一种<code>异步编程</code>解决方案，语法行为与传统函数完全不同</p><p>回顾下上文提到的解决异步的手段：</p><ul><li>回调函数</li><li>promise</li></ul><p>执行 <code>Generator</code> 函数会返回一个<code>迭代器对象</code>，可以依次遍历 <code>Generator</code> 函数内部的每一个状态</p><p>形式上，<code>Generator</code>函数是一个普通函数，但是有两个特征：</p><ul><li><p><code>function</code>关键字与函数名之间有一个星号</p></li><li><p>函数体内部使用<code>yield(屈服，&#39;叶儿得&#39;)</code>表达式，定义不同的内部状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorldGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><code>Generator</code> 函数会返回一个<code>迭代器对象</code></p><img src="..\images\前端面试-js\迭代器对象.png" style="zoom:80%;" /><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = <span class="title function_">gen</span>();</span><br><span class="line"></span><br><span class="line">g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() === g <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>通过<code>yield</code>关键字可以暂停<code>generator</code>函数返回的<code>迭代器对象</code>的状态</p><img src="../images/前端面试-js/可迭代对象.png" style="zoom:67%;" /><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorldGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> hw = <span class="title function_">helloWorldGenerator</span>();<span class="comment">//并不会输出1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出1 输出&#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出2 输出&#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出3 输出&#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//并不输出4 输出&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><code>done</code>用来判断是否存在下个状态，<code>value</code>对应状态值</p><p>再举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">helloWorldGenerator2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;ending&#x27;</span>;<span class="comment">//这里做了修改</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> hw2 = <span class="title function_">helloWorldGenerator2</span>();<span class="comment">//并不会输出1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出1 输出&#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出2 输出&#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出3 输出&#123; value: &#x27;ending&#x27;, done: false &#125; 这里有区别</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hw.<span class="title function_">next</span>())<span class="comment">//输出4 输出&#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="title function_">yield</span> (x + <span class="number">1</span>));<span class="comment">//y=undefined</span></span><br><span class="line">  <span class="keyword">var</span> z = <span class="title function_">yield</span> (y / <span class="number">3</span>);<span class="comment">//y/3=NaN</span></span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.<span class="title function_">next</span>() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br></pre></td></tr></table></figure><p>通过调用<code>next</code>方法可以带一个参数，该参数就会被当作<code>上一个yield</code>表达式的返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="title function_">foo</span>(<span class="number">5</span>);</span><br><span class="line">b.<span class="title function_">next</span>() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125; y=2*12 y/3=8</span></span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125; y=24 z=13 x=5</span></span><br></pre></td></tr></table></figure><p>正因为<code>Generator</code>函数返回<code>Iterator(迭代器)</code>对象，因此我们还可以通过<code>for...of</code>进行遍历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;、</span><br><span class="line">  <span class="comment">//没有输出6，这是因为 for...of 循环只处理迭代过程中由 yield 产生的值。当迭代器完成（即状态变为 done: true），循环就会终止，并不会检查或处理 return 语句给出的值。</span></span><br><span class="line">  <span class="comment">//不过要注意的是，next是可以取出return的值的，不过for of不行。</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(v);<span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>原生对象</code>没有<code>遍历接口</code>，通过<code>Generator</code>函数为它加上这个接口，就能使用<code>for...of</code>进行遍历了，<code>for...of</code>本质遍历的就是<code>迭代器对象</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据传入的对象，创造一个生成器函数</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">objectEntries</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">//返回一个数组，包含对象自身的所有属性，包括不可枚举属性</span></span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, obj[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Doe&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">//数组解构</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="title function_">objectEntries</span>(jane)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><h3 id="异步解决方案"><a href="#异步解决方案" class="headerlink" title="异步解决方案"></a>异步解决方案</h3><p>回顾之前展开异步解决的方案：</p><ul><li>回调函数</li><li>Promise 对象</li><li>generator 函数</li><li>async&#x2F;await</li></ul><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>)&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p><code>Promise</code>就是为了解决<code>回调地狱</code>而产生的，将回调函数的<code>嵌套</code>，改成<code>链式调用</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;/etc/fstab&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">readFile</span>(<span class="string">&#x27;/etc/shells&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种链式操作形式，使异步任务的两段执行更清楚了，但是也存在了很明显的问题，代码变得冗杂了，语义化并不强，<code>Generator</code>就是用来解决这个问题的。</p><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchUser</span>(<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟异步操作</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(&#123; id, <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;), <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//定义一个生成器（Generator）</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Start fetching user...&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> user = <span class="keyword">yield</span> <span class="title function_">fetchUser</span>(<span class="number">123</span>); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;User fetched:&#x27;</span>, user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用生成器函数，得到一个迭代器对象（iterator）</span></span><br><span class="line"><span class="keyword">const</span> it = <span class="title function_">generatorFunc</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">go</span>(<span class="params">result</span>) &#123;</span><br><span class="line">   <span class="comment">//如果迭代完，直接返回，跳出函数</span></span><br><span class="line">   <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line">   <span class="comment">//否则对拿到的结果调用then方法</span></span><br><span class="line">   result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">     <span class="comment">//等待promise状态改变后再继续执行代码，并把拿到的值当作上一次yield表达式的值，赋值给user</span></span><br><span class="line">     <span class="title function_">go</span>(it.<span class="title function_">next</span>(value));----------</span><br><span class="line">   &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">     <span class="title function_">go</span>(it.<span class="keyword">throw</span>(error));</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="title function_">go</span>(it.<span class="title function_">next</span>());<span class="comment">//先输出 Start fetching user... 1s后输出User fetched: &#123;id: 123, name: &#x27;Alice&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>虽然<code>生成器</code>提供了处理异步代码的一种方式，但它的使用<code>相对复杂</code>，还是不够简洁，于是就有了<code>async</code>和<code>await</code></p><h4 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h4><p><code>async</code> 函数本质上是构建在<code>生成器</code>之上的<code>语法糖</code>，它们内部实际上使用了 Promise，并且允许你以同步的方式编写异步代码，而不需要显式地处理<code>迭代器</code>或手动调用 <code>next()</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function asyncFunc() &#123;</span><br><span class="line">    console.log(&#x27;Start fetching user...&#x27;);</span><br><span class="line">    let user = await fetchUser(123); // 等待 Promise 完成</span><br><span class="line">    console.log(&#x27;User fetched:&#x27;, user);//后面的代码会等待promise状态改变后再执行。</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc();</span><br></pre></td></tr></table></figure><p>值得注意的是，async函数无论是否有return语句，都会返回一个promise对象。如果return一个非promise值，该值会被包装成已解决的Promise对象；如果没有return语句，默认会返回一个已解决的Promise，其值为<code>undefined</code>；如果返回一个promise对象，那么最终返回的也就是这个promise对象。</p><h2 id="你是怎么理解ES6中Proxy的？使用场景"><a href="#你是怎么理解ES6中Proxy的？使用场景" class="headerlink" title="你是怎么理解ES6中Proxy的？使用场景?"></a>你是怎么理解ES6中Proxy的？使用场景?</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p><code>Proxy</code> 是一个构造函数，用于创建一个对象的<code>代理</code>，从而拦截对该对象的基本操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><p><code>target</code>表示所要拦截的<code>目标对象</code>（任何类型的对象，包括原生数组，函数，甚至另一个代理）</p><p><code>handler</code>是一个<code>属性值</code>一般都是<code>函数</code>的对象，各属性中的函数分别定义了在执行各种操作时代理目标对象的行为</p><p>难点就在于分析这个<code>handler</code>，它可以包括多种<code>拦截属性</code>，下面我们只介绍常见的几种:</p><ul><li>get(target,propKey,receiver)：拦截对象属性的读取</li><li>set(target,propKey,value,receiver)：拦截对象属性的设置</li><li>deleteProperty(target,propKey)：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值</li></ul><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p><code>get</code>接受三个参数，依次为目标对象、属性名和 <code>proxy</code> 实例本身，最后一个参数可选</p><p>用来监听对某个<code>属性</code>的取值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target,propKey)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> <span class="comment">// &quot;张三&quot;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果一个属性不可写（<code>writable:false</code>），则 Proxy 不能修改该属性，否则会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">foo</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,<span class="comment">//默认值就是false，表示不可被修改</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">false</span><span class="comment">//默认值就是false，表示不可被删除</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);<span class="comment">//&#123;foo:123&#125;，不过这个属性是不可重写，不可配置的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, propKey</span>) &#123;</span><br><span class="line">    <span class="comment">// return target[propKey] 返回123，不报错</span></span><br><span class="line">    <span class="comment">// return Reflect.get(target, propKey)  返回123，不报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>;<span class="comment">//返回abc，就相当于重写了，报错，</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">foo</span></span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p><code>set</code>方法用来拦截对某个属性的<code>赋值操作</code>，可以接受四个参数，依次为<code>目标对象</code>、<code>属性名</code>、<code>属性值</code>和 <code>Proxy</code> 实例本身。</p><p>如果目标对象自身的某个属性，不可写（<code>writable:false</code>），那么<code>set</code>方法将不起作用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,<span class="comment">//默认值</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value, receiver</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(obj,prop,value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, handler);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>)<span class="comment">//bar</span></span><br><span class="line">proxy.<span class="property">foo</span> = <span class="string">&#x27;baz&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">foo</span>) <span class="comment">// &quot;bar&quot;,属性值并未被修改</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>，<code>严格模式</code>下，<code>set</code>代理如果没有返回<code>true</code>，就会报错</p><h4 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h4><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法<code>抛出错误</code>或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="title function_">deleteProperty</span> (target, key) &#123;</span><br><span class="line">    <span class="title function_">invariant</span>(key);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target,key)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">invariant</span> (<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`无法删除私有属性`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="keyword">delete</span> proxy.<span class="property">_prop</span></span><br><span class="line"><span class="comment">// Error: 无法删除私有属性,抛出了异常就不会执行Reflect.deleteProperty(target,key)</span></span><br></pre></td></tr></table></figure><p>注意，<code>目标对象</code>自身的不可配置（<code>configurable:false</code>）属性，不能被<code>deleteProperty</code>方法删除。</p><h3 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.revocable(target, handler);</span><br></pre></td></tr></table></figure><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>Proxy</code>其功能非常类似于设计模式中的<code>代理模式</code>，常用功能如下：。</p><ul><li><p>拦截和监视外部对对象的操作</p></li><li><p>降低函数或类的复杂度</p></li><li><p>在复杂操作前对操作进行校验或对所需资源进行管理</p></li><li><p>使用<code>Proxy</code>实现观察者模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queuedObservers = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个订阅的方法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observe</span> = fn =&gt; queuedObservers.<span class="title function_">add</span>(fn);</span><br><span class="line"><span class="comment">//返回一个代理对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">observable</span> = obj =&gt; <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key</span>)&#123;</span><br><span class="line">        <span class="title function_">observe</span>(func)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">///当数据改变，就调用所有的订阅方法</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">        queuedObservers.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> <span class="title function_">observer</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="你是怎么理解ES6中Module的？使用场景？"><a href="#你是怎么理解ES6中Module的？使用场景？" class="headerlink" title="你是怎么理解ES6中Module的？使用场景？"></a>你是怎么理解ES6中Module的？使用场景？</h2><h3 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h3><p>如果没有模块化，我们代码会怎样？</p><ul><li>变量和方法不容易维护，容易污染<code>全局作用域</code></li><li>通过手动规定<code>script</code>标签的书写顺序来控制资源的<code>加载顺序</code></li><li>资源的<code>依赖关系</code>模糊，代码难以维护。</li></ul><p>而模块化具有如下特点，能解决原生开发过程中的诸多问题</p><ul><li>代码抽象</li><li>代码封装</li><li>代码复用</li><li>依赖管理</li></ul><p><strong>AMD</strong></p><p><code>Asynchronous ModuleDefinition</code>（AMD），异步模块定义，采用<code>异步方式</code>加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** main.js 入口文件/主模块 **/</span></span><br><span class="line"><span class="comment">// 首先用config()指定各模块路径和引用名</span></span><br><span class="line"><span class="built_in">require</span>.<span class="title function_">config</span>(&#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&quot;js/lib&quot;</span>,</span><br><span class="line">  <span class="attr">paths</span>: &#123;</span><br><span class="line">    <span class="string">&quot;jquery&quot;</span>: <span class="string">&quot;jquery.min&quot;</span>,  <span class="comment">//实际路径为js/lib/jquery.min.js</span></span><br><span class="line">    <span class="string">&quot;underscore&quot;</span>: <span class="string">&quot;underscore.min&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行基本操作</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;jquery&quot;</span>,<span class="string">&quot;underscore&quot;</span>],<span class="keyword">function</span>(<span class="params">$,_</span>)&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>CommonJs</strong></p><p><code>CommonJS</code> 是一套 <code>nodejs</code> 默认支持的模块规范，用于服务端。</p><p>其有如下特点：</p><ul><li>所有代码都运行在<code>模块作用域</code>，不会污染全局作用域</li><li>模块是<code>同步加载</code>的，即只有加载完成，才能执行后面的操作</li><li>模块在首次执行后就会<code>缓存</code>，再次加载只返回缓存结果，如果想要再次执行，可清除缓存</li><li><code>require</code>返回的值是被输出的值的<code>拷贝</code>，模块内部的变化也不会影响这个值</li></ul><p>既然存在了<code>AMD</code>以及<code>CommonJs</code>机制，<code>ES6</code>的<code>Module</code>又有什么不一样？</p><p><code>ES6</code> 在语言标准的层面上，实现了<code>Module</code>，即模块功能，完全可以<strong>取代</strong> <code>CommonJS</code>和 <code>AMD</code>规范，成为<code>浏览器</code>和<code>服务器</code>通用的模块解决方案。</p><p><code>CommonJS</code> 和<code>AMD</code> 模块语法，导入导出的都是<code>整个对象</code>，<code>代码运行时</code>才能确定具体的依赖关系，比如具体使用了模块中的哪些变量。</p><p><code>ES6</code>设计思想是尽量的<code>静态化</code>，使得<code>编译时</code>就能确定模块的依赖关系，以及输入和输出的变量。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>具体使用方式可以参考本博客中<code>nodejs</code>一文。</p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs</title>
      <link href="/posts/3418e521.html"/>
      <url>/posts/3418e521.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>nodejs</code>是前端工程化的基础，是开源的，基于<code>谷歌v8引擎</code>构建的js运行环境，运行开发者使用js编写的服务器。</p><h2 id="三大模块"><a href="#三大模块" class="headerlink" title="三大模块"></a>三大模块</h2><h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><ul><li><p><strong>fs模块</strong></p><p>封装了与本机<code>文件系统</code>进行交互的方法与属性</p><p><strong>fs.readFile()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(path[, options], callback)</span><br></pre></td></tr></table></figure><ul><li><p>参数1：必选参数，字符串，表示<code>文件路径</code>。</p></li><li><p>参数2：可选参数，表示以什么<code>编码格式</code>来读取文件。</p></li><li><p>参数3：必选参数，文件读取完成后，通过<code>回调函数</code>拿到读取的结果，形如<code>(err,dataStr)=&gt;&#123;&#125;</code></p><p>读取成功<code>err</code>为null，否则为错误对象</p></li></ul><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/path/to/file.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);<span class="comment">//data是文件内容的buffer数据流</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>fs.writeFile()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFile</span>(file, data[, options], callback)</span><br></pre></td></tr></table></figure><ul><li>参数1：必选参数，需要指定一个<code>文件路径</code>的字符串，表示文件的<code>存放路径</code></li><li>参数2：必选参数，表示要写入的<code>内容</code>。</li><li>参数3：可选参数，表示以什么<code>格式</code>写入文件内容，默认值是<code>utf-8</code>。</li><li>参数4：必选参数，文件写入完成后的<code>回调函数</code>。</li></ul><blockquote><p> 注意：这个方法只能用来创建文件，不能用来创建路径</p></blockquote></li><li><p><strong>path模块</strong></p><p>path 模块提供了用于<code>处理文件路径</code>的方法，帮助我们在不同操作系统之间<code>处理和标准化</code>路径字符串</p><ul><li><p><strong>__dirname</strong>：返回当<code>前js文件</code>所在目录的<code>绝对路径</code>。</p></li><li><p><strong>path.join()</strong></p><p><code>path.join()</code> 方法则简单地将所有给定的<code>路径片段</code>连接在一起，并<code>规范化</code>生成的路径。它不会尝试将路径转换为绝对路径，也不会考虑当前工作目录。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> filePath = path.<span class="title function_">join</span>(<span class="string">&#x27;/folder&#x27;</span>, <span class="string">&#x27;subfolder&#x27;</span>, <span class="string">&#x27;file.txt&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filePath); <span class="comment">// 输出：&#x27;/folder/subfolder/file.txt&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>path.resolve()</strong></p><p><code>path.resolve()</code> 方法会将传入的<code>路径片段</code>解析为<code>绝对路径</code>。它从右向左处理参数，直到构造出一个<code>绝对路径</code>为止。如果所有给定的<code>路径片段</code>都不是<code>绝对路径</code>，则会使用<code>当前工作目录(process.cwd())</code>作为基础来构建<code>绝对路径</code>。无论输入是什么，<code>path.resolve()</code> 总是返回一个绝对路径。</p></li><li><p><strong>path.parse()</strong></p><p>被用来解析路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pathObj = path.<span class="title function_">parse</span>(<span class="string">&#x27;/folder/subfolder/file.txt&#x27;</span>);</span><br><span class="line"><span class="comment">// 输出：&#123; root: &#x27;/&#x27;, dir: &#x27;/folder/subfolder&#x27;, base: &#x27;file.txt&#x27;, ext: &#x27;.txt&#x27;, name: &#x27;file&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathObj); </span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><p><strong>http模块</strong></p><p>对标浏览器中的<code>XMLHttptRequest</code>模块，<code>http </code>模块用于创建 HTTP 服务器或客户端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="property">statusCode</span> = <span class="number">200</span>;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;Hello World\n&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//开启服务，占用3000端口</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server running on port 3000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p><strong>req</strong></p><p><code>req</code>是请求对象，它包含了与客户端相关的数据和属性，</p><ul><li><code>req.url</code>：是客户端请求的 <code>URL地址</code></li><li><code>req.method</code>：是客户端的<code>请求方法</code></li></ul></li><li><p><strong>res</strong></p><p>res是响应的结果，或者说是<code>响应报文</code></p><ul><li><p><code>res.statusCode</code>：设置响应状态码</p></li><li><p><code>res.setHeader()</code>：设置响应报文的响应头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/plain;charset=utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>res.end()</code>：结束此次请求与响应，并返回数据，当调用<code>res.end()</code>方法，并向客户端发送<code>中文内容</code>的时候，会出现乱码问题，此时，需要<code>手动</code>设置内容的<code>编码格式</code>。即<code>res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=utf-8&#39;)</code></p></li></ul></li></ul><p><strong>客户端&#x2F;服务器</strong></p><p>在网络节点中，负责<code>消费资源</code>的电脑，叫做客户端；负责对外<code>提供网络资源</code>的电脑，叫做服务器。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这三个模块的<code>组合使用</code>非常常见，尤其是在构建需要<code>读写文件</code>并提供<code>网络服务</code>的应用程序中。例如，你可能需要从文件系统读取配置文件，然后使用这些配置来启动一个 HTTP 服务器，或者接收 HTTP 请求并将请求的数据写入文件系统。</p><h2 id="Nodejs与浏览器的区别与联系"><a href="#Nodejs与浏览器的区别与联系" class="headerlink" title="Nodejs与浏览器的区别与联系"></a>Nodejs<strong>与浏览器的区别与联系</strong></h2><ul><li>浏览器依靠内核中的<code>V8引擎</code>执行js代码，node.js基于<code>谷歌V8引擎</code>进行<code>封装</code></li><li>都支持<code>ECMAscript</code>基础语法（ES语法）</li><li>Node.js有独立的<code>api</code>，没有<code>DOM</code>,<code>BOM</code></li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="模块化发展流程"><a href="#模块化发展流程" class="headerlink" title="模块化发展流程"></a>模块化发展流程</h3><ul><li><p>把功能封装为一个一个<code>函数</code>，把函数和相关的变量放到一个<code>js文件</code>中，需要使用某个函数的时候就<code>引入js文件</code>。引入的函数会被挂载到<code>全局对象</code>上，存在<code>全局变量污染</code>的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// math.js</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">function subtract(a, b) &#123;</span><br><span class="line">  return a - b;</span><br><span class="line">&#125;</span><br><span class="line">// 在HTML文件中通过script标签引入math.js后，add和subtract会挂载到全局对象上</span><br></pre></td></tr></table></figure></li><li><p>所以就把<code>相关的函数</code>和<code>变量</code>封装到一个<code>对象</code>中，这样即便存在<code>同名的函数</code>也没关系，但是这样不安全，因为对象的属性可以被<code>随意修改</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// math.js</span><br><span class="line">var MathLib = &#123;</span><br><span class="line">  add: function(a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;,</span><br><span class="line">  subtract: function(a, b) &#123;</span><br><span class="line">    return a - b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 在HTML文件中引入math.js后，MathLib.add 和 MathLib.subtract不会直接挂载到全局对象上</span><br></pre></td></tr></table></figure></li><li><p>使用<code>立即执行函数</code>私有化<code>变量</code>和<code>函数</code>，并使用<code>return</code>暴露函数。这种写法的，被引入的函数和相关变量<strong>不再挂载到全局对象</strong>，必须要求原模块代码先于拓展模块代码被引入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// math.js</span><br><span class="line">var MathLib = (function() &#123;</span><br><span class="line">  // 私有变量和函数</span><br><span class="line">  var privateVar = &#x27;secret&#x27;;</span><br><span class="line">  </span><br><span class="line">  function privateFn() &#123;</span><br><span class="line">    console.log(&#x27;This is private:&#x27;,privateVar);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 返回公开接口</span><br><span class="line">  return &#123;</span><br><span class="line">   privateFn</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li><li><p>为了解决<code>先后顺序</code>问题，再传参的时候判断一下如果传入的是<code>undefined</code>则转为传入{}</p></li><li><p>可以看出模块化实现有多种方式，为了统一，我们必须制定出一个<code>好用统一</code>的<code>模块化标准</code>,比如<code>commonjs</code>和<code>esm</code>，他们被打包后都会转换成<code>立即执行函数</code>风格的模块化代码。</p></li></ul><h3 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h3><ul><li><p><strong>内置模块</strong></p><p>加载的时候直接写包名，比如上述介绍的<code>三大模块</code></p></li><li><p><strong>第三方模块</strong></p><p>加载的时候直接写包名，第三方模块又叫做包，是基于内置模块封装出来的</p></li><li><p><strong>自定义模块</strong></p><p><code>加载</code>的时候需要写路径，可以省略.js后缀名，后缀补全规则</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">按照确切的文件名进行加载</span><br><span class="line">补全.js扩展名进行加载</span><br><span class="line">补全.json扩展名进行加载</span><br><span class="line">补全.node扩展名进行加载</span><br><span class="line">加载失败，终端报错</span><br></pre></td></tr></table></figure></li></ul><h3 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h3><p>模块内定义的<code>变量和函数</code>无法被外部访问</p><h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><p>模块在第一次加载后会被<code>缓存</code>。这也意味着多次调用<code>require()</code>不会导致模块内的代码被<code>执行多次</code></p><ul><li><p>内置模块</p><p>加载优先级最高</p></li><li><p>自定义模块</p><p>加载时<code>必须</code>指定以<code>./</code>或<code>../</code>开头的路径标识符，否则则<code>node</code>会把它当作<code>内置模块</code>或<code>第三方模块</code>进行加载。</p></li><li><p>第三方模块</p><p>如果传递给<code>require()</code>的<code>模块标识符</code>不是一个内置模块，也没有以<code>./</code>或<code>../</code>开头，则<code>Node.js </code>会从<code>当前模块的父目录</code>开始，尝试从<code>/node_modules</code>文件夹中加载<code>第三方模块</code>。如果没有找到对应的第三方模块，则再移动到<code>上一层父目录中</code>，进行加载，直到文件系统的<code>根目录</code>。</p></li><li><p>把<code>目录</code>作为模块(没有指明文件名)</p><p>在被加载的目录下，查找<code>package.json</code>的文件，并寻找 <code>main</code>属性，作为<code>require()</code>加载的入口<br>如果目录里没有<code>package.json</code>文件，或者<code>main</code>入口不存在或无法解析，则Node.js将会式图加载该目录下的<code>index.js</code>文件。<br>如果以上两步都失败了，则Node.js 会在终端打印错误消息，报告模块的缺失: Error: Cannotfind module ‘xxx’</p></li></ul><h2 id="两种模块化标准"><a href="#两种模块化标准" class="headerlink" title="两种模块化标准"></a>两种模块化标准</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>是<code>nodejs</code>默认支持的模块化语法。</p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p>使用 <code>require</code> 函数来导入模块，导入自定义模块写<code>相对路径</code>，导入<code>第三方模块</code>或者<code>内置模块</code>使用<code>模块名</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myModule = <span class="built_in">require</span>(<span class="string">&#x27;./myModule&#x27;</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br></pre></td></tr></table></figure><p>通过<code>require</code>导入模块的方式都是<strong>同步的</strong>，也就是说会阻塞后续的代码的执行，而且第一次加载后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存。</p><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>通常使用<code>module.exports</code>，只能导出一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h4><ul><li><p>在每个<code>.js</code>自定义模块中都有一个<code>module</code>对象，它里面存储了和当前模块有关的信息</p></li><li><p>在自定义模块中，可以使用<code>module.exports</code>对象，将模块内的成员共享出去，默认为<code>&#123;&#125;</code></p></li><li><p><code>module.exports</code>可以直接写成<code>exports</code>，它们<code>起初</code>指向同一个<code>空对象</code></p><img src="..\images\nodejs\commonjs.png" style="zoom:67%;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x,y</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//module.exports.add = add 如果使用这种导出方式，module.exports和exports指向的对象都包含add方法</span></span><br><span class="line"><span class="comment">//module.exports = &#123;add&#125;  如果使用这种导出方式，module.exports指向的对象包含add方法，但是exports指向的还是空对象</span></span><br><span class="line"><span class="comment">//exports = &#123;add&#125;  如果使用这种导出方式，module.exports指向的对象还是空对象，exports指向的是包含add方法的对象</span></span><br></pre></td></tr></table></figure></li><li><p><code>require()</code>模块时，得到的永远是<code>module.exports</code>指向的对象</p></li><li><p>在js文件中使用了<code>module</code>，就可以认为这个js文件是<code>commonjs</code>模块</p></li></ul><h3 id="esm"><a href="#esm" class="headerlink" title="esm"></a>esm</h3><p>ES模块功能主要由两个命令构成：</p><ul><li><code>export</code>：用于规定模块的<code>对外接口</code></li><li><code>import</code>：用于<code>输入</code>其他模块提供的功能</li></ul><h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>在编译阶段，<code>import</code>会<code>提升</code>到整个模块的头部，首先执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure><p>多次重复执行同样的导入，只会执行一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br></pre></td></tr></table></figure><p>要注意的是import语句只能书写在模块顶级作用域，不能写在局部作用域，除非使用import()动态导入。</p><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>一个模块就是一个独立的文件，该文件内部的所有变量，外部<code>无法获取</code>。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字<code>输出</code>该变量。简单的来说，<code>export</code>就是用来暴露模块内部私有的变量的。</p><h4 id="命名导出-导入"><a href="#命名导出-导入" class="headerlink" title="命名导出&#x2F;导入"></a><strong>命名导出&#x2F;导入</strong></h4><ul><li><p>命名导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a+b&#125;<span class="comment">//math.js</span></span><br></pre></td></tr></table></figure><p>或者写成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> add = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a+b&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;<span class="variable constant_">PI</span>,add&#125;</span><br></pre></td></tr></table></figure><p>但是不能写成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> add = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a+b&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">PI</span> <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">export</span> add <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>也就是说只能在声名一个变量的时候导出变量或者导出一个对象，不能声明后再单独导出一个变量。</p></li><li><p>命名导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import后面接着from关键字，from指定模块文件的位置，可以是相对路径，也可以是绝对路径</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">PI</span>, add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>); <span class="comment">// 输出: 3.14159</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure><p>如果想要给<code>输入变量</code>起别名，通过<code>as</code>关键字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">&#x27;./profile.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输入的变量都是<code>只读</code>的，不允许修改，但是如果是<code>对象</code>，允许修改<code>属性</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">&#x27;./xxx.js&#x27;</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">foo</span> = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 合法操作</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// Syntax Error : &#x27;a&#x27; is read-only;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="默认导出-导入"><a href="#默认导出-导入" class="headerlink" title="默认导出&#x2F;导入"></a>默认导出&#x2F;导入</h4><p>如果不需要知道<code>变量名</code>或<code>函数</code>就完成导入，就要用到<code>export default</code>命令，为模块指定<code>默认输出</code></p><ul><li><p>默认导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">&#x27;模块名/路径&#x27;</span> <span class="comment">//obj这个名字是自定义的，可以随便取名</span></span><br></pre></td></tr></table></figure></li><li><p>默认导出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baseURL = <span class="string">&#x27;http://hmajax.itheima. net &#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getArraySum</span> = arr =&gt; arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum，val</span>) =&gt;</span> sum += val，<span class="number">0</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">baseURL,getArraysum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接导出一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a><strong>动态加载</strong></h4><p>允许您仅在<code>需要时</code>动态加载模块，而不必预先加载所有模块，这存在明显的<code>性能优势</code></p><p>这个新功能允许您将<code>import()</code>作为<code>函数</code>调用，将<code>模块的路径</code>作为参数，这个函数返回一个 <code>promise</code>对象，可以在<code>then</code>方法中拿到该模块的导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;/modules/myModule.mjs&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params"><span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Do something with the module.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>根据模块是使用<code>默认导出</code>还是<code>命名导出</code>，<code>module</code> 对象的内容会有所不同。</p><p>如果模块使用了默认导出（<code>export default</code>），那么动态导入的结果<code>module</code>将是一个带有 <code>default</code> 属性的对象。这个属性的值就是模块中<code>默认导出的内容</code>。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// myModule.mjs</span><br><span class="line">export default function() &#123;</span><br><span class="line">  console.log(&#x27;This is a default export.&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，动态导入后拿到的 <code>module</code> 对象看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  default: [Function: anonymous（就是匿名的意思）]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以通过 <code>module.default</code> 来访问默认导出的内容。</p><p>如果模块使用了<code>命名导出</code>（<code>export</code>），那么动态导入的结果将<code>直接包含</code>这些命名的属性。例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myModule.mjs</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，动态导入后的 <code>module</code> 对象看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  PI: 3.14159,</span><br><span class="line">  add: [Function: add]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接通过 <code>module.PI</code> 和 <code>module.add</code> 来访问这些<code>命名导出</code>的内容。</p><p>如果你的模块<code>同时</code>使用了<code>默认导出</code>和<code>命名导出</code>，那么动态导入的结果将会同时包含这两类内容。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myModule.mjs</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is a default export.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，动态导入后的 <code>module</code> 对象将包括 <code>default</code> 属性以及其他命名导出的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">default</span>: [<span class="title class_">Function</span>: anonymous（就是匿名的意思）],</span><br><span class="line">  <span class="attr">PI</span>: <span class="number">3.14159</span>,</span><br><span class="line">  <span class="attr">add</span>: [<span class="title class_">Function</span>: add]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>一个模块内可以<code>同时</code>使用<code>命名导出</code>和<code>默认导出</code>，但是如果没有<code>默认导出</code>，也不能使用<code>默认导入</code></li><li>不能尝试对<code>默认导入</code>使用<code>对象解构</code>，会被当成<code>按需（命名）导入</code></li></ul><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><ul><li><code>require</code> 是同步加载模块的。当执行到 <code>require</code> 语句时，JavaScript 引擎会暂停执行后续代码，直到模块完全加载并返回。</li><li><code>import</code> 是基于 Promise 的，并且是<strong>异步</strong>的。这意味着它可以避免阻塞主线程，特别是在浏览器环境中对于网络请求尤为重要。然而，在 Node.js 环境下，如果模块已经被加载进内存，则可以立即访问而无需等待。</li><li>你可以在<strong>任何作用域中</strong>使用 <code>require</code> 来加载模块，包括函数内部、条件语句内等。这意味着你可以根据运行时条件动态地加载模块，<strong>这就导致使用commonjs模块化语法的项目必须在运行的时候才能确定具体的模块的依赖关系</strong>。</li><li>与 <code>require</code> 不同，<code>import</code> 语句通常需要位于<strong>文件的顶层作用域</strong>。这是因为 ES 模块系统设计为支持<strong>静态分析</strong>，这有助于优化和提前解析依赖关系，<code>tree-shaking</code>得以实现。</li><li>虽然import语句不能写在局部作用域，但是esm语法还提供了动态导入<code>import()</code>，<strong>它允许你在代码的任意位置进行模块的异步加载</strong>。</li><li><code>import()</code>引入的模块通常会被单独打包成<code>chunk</code>（异步<code>chunk</code>），不参与任何模块的静态依赖分析（因为是动态导入的所以不支持静态分析），这一点在webpack中也有介绍。</li></ul><h3 id="切换方法"><a href="#切换方法" class="headerlink" title="切换方法"></a>切换方法</h3><p><code>nodejs</code>默认支持<code>commonjs</code>模块化语法，但是也可以切换为<code>ESM</code>语法，在运行模块所在文件夹新建<code>package.json</code>文件，并设置<code>&#123; &quot;type&quot; : &quot;module&quot; &#125;</code>这样就能使用<code>ESM</code>语法 </p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>将<code>模块</code>和<code>其他资料</code>聚合成一个<code>文件夹</code>（通常是<code>js文件</code>和<code>package.json</code>文件，用来记录包的清单信息），本质就是个文件夹，一个第三方模块。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p><code>package.json</code> 文件是每个 npm 包的<code>核心配置文件</code>，它包含了关于包的元数据信息，如名称、版本、作者等，以及定义了项目的<code>依赖关系</code>、开发依赖关系、脚本命令等。它列出项目的<code>直接依赖项</code>，并指定这些依赖项的<code>版本范围</code>（例如 <code>^1.2.3</code> 或 <code>~1.2.3</code>）。这意味着安装时(<code>npm i</code>)，npm 可以根据这些范围，从注册表中获取满足条件的<code>最新版本</code>。由于它只指定了<code>版本范围</code>而不是具体的版本号，<strong>因此允许在一定范围内自动更新依赖项</strong>，这可以确保你总是用上<code>最新的修复和改进</code>，但也可能引入<code>不兼容</code>的变化。</p><h3 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h3><p><code>package-lock.json</code> 文件是在 npm 5 引入的一个锁定文件，它记录了所有安装过的依赖及其子依赖的<code>确切版本</code>。不同于 <code>package.json</code> 中的版本范围，<code>package-lock.json</code> <strong>锁定了依赖树中每一个包的具体版本号</strong>。这样可以确保无论何时何地<code>重新安装依赖</code>，都能得到<code>完全相同</code>的依赖环境，避免因为不同时间点安装不同版本的依赖而引起的潜在问题，从而<strong>提供更为稳定的开发环境</strong>。</p><h3 id="规范的包结构"><a href="#规范的包结构" class="headerlink" title="规范的包结构"></a>规范的包结构</h3><ul><li>包必须以<code>单独的目录</code>而存在</li><li>包的<code>顶级目录</code>下要必须包含<code>package.json</code>这个包管理配置文件</li><li><code>package.json</code>中必须包含<code>name</code>，<code>version</code>，<code>main</code>这三个属性，分别代表包的<code>名字</code>、<code>版本号</code>，<code>包的入口</code>。</li></ul><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>npm(node packages manager)是<code>node.js</code>的标准<code>软件包管理器</code>，下载好<code>node</code>这个就能用了，通常用来在项目中下载，引入其他已发布的包，类似<code>java</code>中的<code>maven</code>。</p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ul><li><p><strong>npm init  -y</strong></p><p>给一个包初始化<code>package.json</code>文件，配置清单信息（记录这个包引入的其他包的信息）</p><p>只能在<code>英文</code>目录下运行，不能包含空格，不能包含中文</p></li><li><p><strong>npm i</strong></p><p>安装所有依赖，包括开发依赖dependencies 和 生产依赖devDependencies</p></li><li><p><strong>npm i 软件包名 -D</strong></p><p>下载软件包到本地开发环境（devDependencies），软件包名和<code>-D</code>的顺序不重要，下方同理</p></li><li><p><strong>npm i 软件包名 -s</strong></p><p>下载安装包到本地的生产环境(dependencies)，不添加任何符号，比如<code>npm i 软件包名</code>将默认下载到开发依赖中。</p></li><li><p><strong>npm i 软件包名 -g</strong></p><p>下载软件包到全局。全局安装的软件包不会被添加到任何<code>package.json</code>文件中，因为它们不属于特定的项目，全局安装的软件包会被放置在系统的<code>全局 Node.js 安装目录</code>下（C:\Users\35194\AppData\Roaming\npm\node_modules）</p></li><li><p><strong>npm i 包1 包2….</strong></p><p>一次性安装多个包（用空格隔开）</p></li><li><p><strong>npm uninstall 包名</strong></p><p>卸载包，package.json文件中内容也会改变</p></li></ul><h3 id="推荐的包"><a href="#推荐的包" class="headerlink" title="推荐的包"></a>推荐的包</h3><h4 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h4><p>一个方便切换<code>下载源</code>的工具包，选择合适的下载源，能显著提高我们下载包的速度。</p><p>安装指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g nrm</span><br></pre></td></tr></table></figure><p>不借助<code>nrm</code>切换下载源:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry //获取下包的服务器地址</span><br><span class="line">npm config <span class="built_in">set</span> registry = https://registry.npm.taobao.org //修改包的下载地址</span><br></pre></td></tr></table></figure><p>明显比较麻烦，需要记住<code>指令</code>和<code>下载源的网址</code>。</p><p>使用<code>nrm</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nrm <span class="built_in">ls</span> //获取所有可用镜像源</span><br><span class="line">nrm use 镜像源名 //切换下载源</span><br></pre></td></tr></table></figure><h4 id="i5ting-toc"><a href="#i5ting-toc" class="headerlink" title="i5ting_toc"></a>i5ting_toc</h4><p>一个可以把<code>md文档</code>转换成<code>html</code>的包</p><p>安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g i5ting toc</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i5ting_toc -f 要转换的md文件路径 -o</span><br></pre></td></tr></table></figure><h4 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h4><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nodemon //安装到全局</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev nodemon //安装到本地开发环境</span><br></pre></td></tr></table></figure><p>安装完成后，你可以直接用 <code>nodemon</code> 来代替 <code>node</code> 命令来启动你的应用程序。例如，如果你的应用入口文件是 <code>app.js</code>，你可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure><p>当你修改<code>app.js</code>文件并保存时，<code>nodemon</code>会检测到这个文件变化，并自动重新运行这个文件。</p><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><p>mysql模块是托管于<code>npm </code>上的第三方模块。它提供了在 Node.js项目中<code>连接和操作 </code>MySQL数据库的能力。</p><h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><code>express</code> 是一个极简且灵活的基于Node.js 的<code>Web 应用框架</code>，它为构建 Web 应用和 API 提供了一组强大的功能。Express 通过提供路由、中间件、模板引擎等功能<code>简化了</code> HTTP 服务器的创建过程，并支持快速开发<code>可扩展</code>的应用程序。</p><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express</span><br></pre></td></tr></table></figure><p><strong>导入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 express 模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建 express 应用实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br></pre></td></tr></table></figure><h3 id="根据语法写业务函数"><a href="#根据语法写业务函数" class="headerlink" title="根据语法写业务函数"></a><strong>根据语法写业务函数</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/api/complex&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 一个字母都不能写错</span></span><br><span class="line">  <span class="comment">// 解决复杂跨域问题</span></span><br><span class="line">  <span class="comment">// res.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;http://127.0.0.1:5500&quot;)</span></span><br><span class="line">  res.<span class="title function_">send</span>(data)<span class="comment">//不需要转化成json</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>req</p><ul><li><p>req.query：获取<code>url</code>中的查询参数，默认是个空对象</p></li><li><p>req.body：获取请求的请求体</p></li><li><p>req.params：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>( <span class="string">&#x27;/user/:id&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span>&#123; </span><br><span class="line"><span class="comment">//req.params 默认是一个空对象</span></span><br><span class="line"><span class="comment">//里面存放着通过︰动态匹配到的参数值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">params</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以传入多个动态参数，比如<code>/user/:id/:name</code></p></li></ul></li><li><p>res</p><ul><li><p>res.send(‘数据’)：在<code>响应体</code>中携带数据，并返回响应</p></li><li><p>res.sendFile(‘’文件路径’’)</p><p><code>res.sendFile </code>方法自动处理文件的<code>读取</code>和<code>发送</code>，减少了<code>手动读取文件</code>和<code>设置响应头</code>的工作,它会根据文件扩展名<code>自动设置</code>响应头中的 Content-Type 字段。</p></li></ul></li></ul><h3 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a><strong>开启服务</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">listen</span>(<span class="number">8081</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务器启动&quot;</span>)</span><br><span class="line">&#125;)<span class="comment">//服务器对应的域名是http://127.0.0.1:8081</span></span><br></pre></td></tr></table></figure><p>然后执行，<code>node express.js</code>启动服务器（上述代码都写在express.js文件中），每次修改服务器内容后都需要<code>重新启动</code>，所以建议使用<code>nodemon express.js</code></p><h3 id="配置静态资源"><a href="#配置静态资源" class="headerlink" title="配置静态资源"></a>配置静态资源</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;./public&#x27;</span>))</span><br></pre></td></tr></table></figure><p>上述代码指定了，服务器的<code>静态资源</code>根目录，为与<code>express.js</code>文件同一级别的<code>public</code>文件</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/your-project</span><br><span class="line">  /public</span><br><span class="line">    /images</span><br><span class="line">      logo.png</span><br><span class="line">    /stylesheets</span><br><span class="line">      style.css</span><br><span class="line">    /javascripts</span><br><span class="line">      script.js</span><br><span class="line">  app.js</span><br></pre></td></tr></table></figure><p>这意味着如果客户端请求 <code>http://127.0.0.1:8081/images/logo.png</code>，<code>Express</code> 会尝试从 <code>public/images/logo.png</code> 提供该文件。</p><p><strong>指定虚拟路径前缀</strong></p><p>果你想为静态资源设置一个虚拟路径前缀（例如 <code>/static</code>），可以这样做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/static&#x27;</span>, express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>));</span><br></pre></td></tr></table></figure><p>这行代码意味着所有的<code>静态资源</code>都将通过 <code>/static</code> 开头的 URL 路径访问。比如，要获取 <code>public/images/logo.png</code> 文件，客户端应该请求 <code>http://127.0.0.1:8081/static/images/logo.png</code>。</p><p><strong>配置多个静态资源</strong></p><p>如果你有多个静态资源目录，可以多次调用 <code>express.static</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>));</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;assets&#x27;</span>));</span><br></pre></td></tr></table></figure><p>这样，Express 会按照<code>定义的顺序</code>查找静态文件。首先会在 <code>public</code> 目录下查找，如果没有找到，再尝试在 <code>assets</code> 目录中查找。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>在Express 中，<code>路由</code>指的是<code>客户端的请求</code>与<code>服务器处理函数</code>之间的<code>映射</code>关系，也可以说是<code>后端路由</code>。和匹配静态资源类似，在匹配时，会按照路由的<code>声明/书写顺序</code>进行匹配。</p><p><strong>路由模块化</strong></p><ul><li><p><strong>创建路由文件</strong></p><p>首先，在你的项目中创建一个 <code>routes</code> 目录，并为每个资源创建单独的<code>路由文件</code>。例如，如果你有一个用户资源和一个产品资源，可以创建如下结构：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/your-project</span><br><span class="line">  /routes</span><br><span class="line">    user.js</span><br><span class="line">    product.js</span><br><span class="line">  app.js</span><br></pre></td></tr></table></figure></li><li><p><strong>定义路由</strong></p><p>在每个路由文件中，使用 <code>express.Router()</code> 来创建一个新的<code>路由器对象</code>，并定义与该资源相关的路由。然后<code>导出</code>这个路由器对象。以用户资源为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes/user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户的 GET 路由</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/info&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;GET request to the user route&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户的 POST 路由</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/info&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;POST request to the user route&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出路由器</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure></li><li><p><strong>加载路由模块</strong></p><p>接下来，在主应用文件（通常是 <code>app.js</code>）中引入这些路由模块，并使用 <code>app.use()</code> 方法挂载它们。你还可以为每个路由模块指定一个<code>基础路径</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> userRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/user&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> productRouter = <span class="built_in">require</span>(<span class="string">&#x27;./routes/product&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载用户路由，基础路径为 /users</span></span><br><span class="line"><span class="comment">// 这样就能通过 /users/info访问到users对应的资源</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/users&#x27;</span>, userRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载产品路由，基础路径为 /products</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/products&#x27;</span>, productRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PORT</span> = process.<span class="property">env</span>.<span class="property">PORT</span> || <span class="number">3000</span>;</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="variable constant_">PORT</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Server is running on http://localhost:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>当一个请求到达<code>Express</code>的服务器之后，可以连续调用多个<code>中间件</code>，从而对这次请求进行<code>预处理</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes/user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义中间件，用于所有用户路由</span></span><br><span class="line">router.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Time: &#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户的 GET 路由</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;GET request to the user route&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出路由器</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><ul><li><p><strong>和路由的区别</strong></p><p><code>中间件函数</code>的形参列表中，必须包含<code>next </code>参数。而<code>路由处理函数</code>中只包含<code>req</code>和<code>res</code>。</p></li><li><p><strong>next()</strong></p><p><code>next()</code>是实现多个中间件<code>连续调用</code>的关键，它表示把<code>控制权</code>转交给<code>下一个中间件或路由</code></p></li><li><p><strong>共享</strong></p><p>多个中间件之间，<code>共享</code>同一份<code>req</code>和<code>res</code>。基于这样的特性，我们可以在上游的中间件中，统一为 <code>req</code>或<code>res</code>对象添加自定义的属性或方法，供下游的<code>中间件</code>或<code>路由</code>进行使用。</p></li><li><p><strong>执行顺序</strong></p><p>可以使用<code>app.use()</code>连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件<code>定义的先后顺序</code>依次进行</p></li></ul><h4 id="按作用范围分类"><a href="#按作用范围分类" class="headerlink" title="按作用范围分类"></a>按作用范围分类</h4><ul><li><p><strong>全局中间件</strong></p><p>所有请求到达都会经过的中间件，通过调用<code>app.use(中间件函数)</code>，即可定义一个<code>全局生效</code>的中间件</p></li><li><p><strong>局部中间件</strong></p><p>在定义路由的时候传入中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/ &#x27;</span>, mw1,<span class="function">(<span class="params">req,res</span>) =&gt;</span>&#123;res.<span class="title function_">send</span>(<span class="string">&#x27; Home page. &#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure><p>定义<code>多个</code>局部中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/ &#x27;</span>， mw1, mw2, <span class="function">(<span class="params">req,res</span>) =&gt;</span>&#123;res.<span class="title function_">send</span>(<span class="string">&#x27; Home page. &#x27;</span>)&#125;)</span><br></pre></td></tr></table></figure><p>或者在一个<code>单独的模块</code>中定义，通过<code>router.use(中间件函数)</code>实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes/user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义中间件，用于所有用户路由</span></span><br><span class="line">router.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Time: &#x27;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="其他分类"><a href="#其他分类" class="headerlink" title="其他分类"></a>其他分类</h4><ul><li><p><strong>应用级别</strong>：绑定到app上的</p></li><li><p><strong>路由级别</strong>：绑定路由上的</p></li><li><p><strong>误差级别中间件</strong>：专门用来<code>捕获</code>整个项目中发生的<code>异常错误</code>，从而防止项目异常崩溃的问题。区别于其他中间件，必须放在<code>所有路由之后</code>，可以观察到，错误级别的中间件有四个参数，<code>(err, req, res, next)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err,req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err.<span class="property">inner</span>.<span class="property">message</span> = <span class="string">&quot;No authorization token was found&quot;</span>)&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(&#123;</span><br><span class="line">      <span class="attr">code</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">msg</span>:<span class="string">&quot;token未携带&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>(<span class="string">&#x27;token未携带&#x27;</span>)<span class="comment">//它最终会被传递到最后一个中间件，通常是日志记录中间件，然后打印到控制台</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>内置中间件</strong></p><ul><li><p><strong>express.static()</strong></p><p>快速托管<code>静态资源</code>的内置中间件，所以说，<code>express.static()</code>返回一个<code>新的中间件函数</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>express.json()</strong></p><p>这个中间件用于解析<code>JSON</code>格式的<code>请求体</code>。它会将接收到的 JSON 数据解析成 <code>JavaScript 对象</code>，并将其存储在 <code>req.body</code> 中，以便后续的路由处理器可以访问。</p></li><li><p><strong>express.urlencoded()</strong></p><p>此中间件用于解析<code> URL 编码</code>格式的<code>请求体</code>，通常出现在 HTML 表单提交时。与 <code>express.json()</code> 类似，它也会将解析后的数据附加到 <code>req.body</code>。</p></li></ul></li><li><p><strong>自定义中间件</strong></p><p>定义一个模块，编写中间件函数，然后导出，使用的时候导入，再挂载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myMiddleware</span>(<span class="params">req, res, next</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行一些操作...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用 next() 将控制权传递给下一个中间件或路由处理程序</span></span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并使用自定义中间件</span></span><br><span class="line">app.<span class="title function_">use</span>(myMiddleware);</span><br></pre></td></tr></table></figure></li><li><p><strong>第三方中间件</strong></p><p>下载然后使用，比如<code>cors</code></p></li></ul><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><ul><li><p>一定要在<code>注册路由</code>前<code>注册中间价</code>，特别是<code>全局中间价</code>，局部中间件也要先<code>声明</code>在使用。</p></li><li><p>中间件类别的区分在于<code>参数的个数</code>。</p></li><li><p>如果在中间件中发生错误，应该传递给 <code>next(err)</code>，这样可以让<code>错误处理中间件</code>有机会处理该错误</p></li><li><p>不要忘记调用 <code>next()</code>：如果你不调用 <code>next()</code>，请求-响应周期将会停止，导致客户端永远等待响应。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nodejs </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试---webpack</title>
      <link href="/posts/762e27cc.html"/>
      <url>/posts/762e27cc.html</url>
      
        <content type="html"><![CDATA[<h2 id="谈谈你对webpack的理解"><a href="#谈谈你对webpack的理解" class="headerlink" title="谈谈你对webpack的理解"></a>谈谈你对webpack的理解</h2><p>webpack主要是用来解决<code>模块化</code>打包问题的。</p><h3 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h3><p>将某一个复杂的项目按照某种规则或者规范划分为多个文件，<strong>每个文件就是一个模块</strong>。模块内部是数据是私有的。</p><h3 id="模块化实现历程"><a href="#模块化实现历程" class="headerlink" title="模块化实现历程"></a>模块化实现历程</h3><ul><li>通过<code>script</code>标签引入js文件</li><li>在前者的基础上，使用<code>命名空间</code>的方式，每个模块只暴露一个对象。</li><li>在前者的基础上，使用立即执行函数</li></ul><p>早期模块化的方式中，每个能实现某些功能js文件被设计为一个单独的模块，然后通过<code>script标签</code>引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;module-a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;module-b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式的缺点很明显，被引入后，模块中的变量都成为<code>全局变量</code>，存在<code>变量污染</code>问题，而且模块之间没有<code>依赖关系</code>。</p><p>随后，就出现了<code>命名空间</code>方式，规定每个模块<code>只</code>暴露一个全局对象，然后模块的内容都挂载到这个对象中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//moduleA.js</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">moduleA</span> = &#123;</span><br><span class="line">  <span class="attr">data</span>:<span class="number">20</span></span><br><span class="line">  <span class="attr">method1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;moduleA#method1&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在很大程度上解决了<code>全局变量污染</code>的问题，但是没有解决<code>依赖混乱</code>的问题，而且<strong>不安全</strong>，模块内部的数据可以被<code>随意修改</code>。</p><p>后来又选择用<code>立即执行函数</code>为模块添加<code>私有空间</code>, 解决了内部数据可以被随意修改的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//moduleA.js</span><br><span class="line">(function ($) &#123;</span><br><span class="line">  //私有变量，不会挂载到window上，所以不能直接修改</span><br><span class="line">  var name = &#x27;module-a&#x27;</span><br><span class="line"></span><br><span class="line">  function method1 () &#123;</span><br><span class="line">    console.log(name + &#x27;#method1&#x27;)</span><br><span class="line">    $(&#x27;body&#x27;).animate(&#123; margin: &#x27;200px&#x27; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  //挂载到window对象上只向外暴露方法，而且暴露的方法也使用了命名空间的思想，避免了全局冲突</span><br><span class="line">  window.moduleA = &#123;</span><br><span class="line">    method1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(jQuery)</span><br></pre></td></tr></table></figure><p>支持传入参数，能在一定程度上解决模块依赖问题，但是必须注意引入<code>模块的先后顺序</code>，否则就会出现<code>undefined</code>的问题。</p><p>理想的解决方式是，在页面中通过script标签引入<code>一个JS入口文件</code>，其余用到的模块可以通过<code>代码控制</code>，按需加载进来。</p><p>除了模块加载的问题以外，还需要规定模块化的规范，如今流行的则是<code>CommonJS</code>、<code>ES Modules</code>，关于二者的详细介绍参考本博客内的</p><p><a href="https://www.sanye.blog/posts/3418e521.html">nodejs | 三叶的博客</a>一文</p><p>我们上述讨论的模块化的范围只限于<code>js</code>文件，后来html,css等文件也可以被模块化，这就需要借助<code>webpack</code>。</p><h3 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h3><ul><li><p>解决了<strong>全局变量污染</strong>的问题</p></li><li><p>提高了代码的可维护性与复用性</p></li><li><p>使得项目中文件的<strong>依赖关系明确</strong>，支持按需加载。</p></li></ul><h3 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h3><p>用于现代<code>JavaScript</code>应用程序的静态模块打包工具。</p><h2 id="webpack的构建流程"><a href="#webpack的构建流程" class="headerlink" title="webpack的构建流程"></a>webpack的构建流程</h2><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a><strong>初始化阶段</strong></h3><p>合并<code>配置文件</code>和<code>shell语句</code>中的配置参数，得到最终的配置对象<code>options</code>，并加载用户配置的 <code>plugins</code></p><p>完成上述步骤之后，则开始初始化<code>Compiler</code>编译对象，该对象掌控者<code>webpack</code>生命周期，不执行具体的任务，只是进行一些<code>调度工作</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Compiler</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Tapable</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">context</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">hooks</span> = &#123;</span><br><span class="line">            <span class="attr">beforeCompile</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;params&quot;</span>]),</span><br><span class="line">            <span class="attr">compile</span>: <span class="keyword">new</span> <span class="title class_">SyncHook</span>([<span class="string">&quot;params&quot;</span>]),</span><br><span class="line">            <span class="attr">afterCompile</span>: <span class="keyword">new</span> <span class="title class_">AsyncSeriesHook</span>([<span class="string">&quot;compilation&quot;</span>]),</span><br><span class="line">            <span class="attr">make</span>: <span class="keyword">new</span> <span class="title class_">AsyncParallelHook</span>([<span class="string">&quot;compilation&quot;</span>]),</span><br><span class="line">            <span class="attr">entryOption</span>: <span class="keyword">new</span> <span class="title class_">SyncBailHook</span>([<span class="string">&quot;context&quot;</span>, <span class="string">&quot;entry&quot;</span>])</span><br><span class="line">            <span class="comment">// 定义了很多不同类型的钩子</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">webpack</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> compiler = <span class="keyword">new</span> <span class="title class_">Compiler</span>();</span><br><span class="line">  ...<span class="comment">// 检查options,若watch字段为true,则开启watch线程</span></span><br><span class="line">  <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>简单来说就做了这些事</p><ul><li>得到options配置对象</li><li>初始化插件（plugins）</li><li>初始化compiler对象</li></ul><h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><p><code>Compiler</code>初始化完成后会调用<code>Compiler</code>的<code>run</code>方法来真正启动<code>webpack</code>编译构建流程，主要流程如下：</p><ul><li><code>compile</code> 开始编译</li><li>从入口文件开始，使用配置的loader转换文件，构建模块，并分析模块的依赖关系，创建这些模块对象。</li><li><code>build-module</code> 构建模块</li><li><code>seal</code> 封装构建结果</li><li><code>emit</code> 把各个chunk输出到结果文件</li></ul><h4 id="compile-编译"><a href="#compile-编译" class="headerlink" title="compile 编译"></a>compile 编译</h4><p>执行了<code>run</code>方法后，首先会触发<code>compile</code>，主要是构建一个<code>Compilation</code>对象</p><p>该对象是编译阶段的主要执行者，主要会依次执行下述流程：执行<code>模块创建</code>、<code>依赖收集</code>、分块、打包等主要任务。</p><h4 id="make-编译模块"><a href="#make-编译模块" class="headerlink" title="make 编译模块"></a>make 编译模块</h4><p>当创建了上述的<code>compilation</code>对象后，就开始从<code>Entry</code>入口文件开始读取，主要执行<code>_addModuleChain()</code>函数，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">_addModuleChain</span>(<span class="params">context, dependency, onModule, callback</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据依赖查找对应的工厂函数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Dep</span> = <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">DepConstructor</span>&#125; */</span> (dependency.<span class="property">constructor</span>);</span><br><span class="line">  <span class="keyword">const</span> moduleFactory = <span class="variable language_">this</span>.<span class="property">dependencyFactories</span>.<span class="title function_">get</span>(<span class="title class_">Dep</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用工厂函数 NormalModuleFactory 的 create 方法来生成一个空的 NormalModule 对象</span></span><br><span class="line">  moduleFactory.<span class="title function_">create</span>(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">dependencies</span>: [dependency],</span><br><span class="line">      <span class="comment">// 其他配置项...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">err, <span class="variable language_">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 定义每个模块构建完成后的回调函数</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">afterBuild</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//一旦模块(比如入口文件)构建完成，Webpack 需要知道该模块是否引入了其他模块，并且需要解析这些依赖项。 </span></span><br><span class="line">        <span class="comment">//这一步骤确保所有依赖都被正确识别，并且如果有必要，也会触发这些依赖模块的构建(buildModule)过程。</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">processModuleDependencies</span>(<span class="variable language_">module</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line">          <span class="title function_">callback</span>(<span class="literal">null</span>, <span class="variable language_">module</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 构建模块的过程中，Webpack 会读取模块内容并应用指定的 loaders。</span></span><br><span class="line">      <span class="comment">// loaders 在这里对模块的源代码进行转换（例如编译、转换语言特性、添加 polyfills 等）。</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">buildModule</span>(<span class="variable language_">module</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">callback</span>(err);</span><br><span class="line">        <span class="comment">//就是上面定义的箭头函数</span></span><br><span class="line">        <span class="title function_">afterBuild</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="build-module-完成模块编译"><a href="#build-module-完成模块编译" class="headerlink" title="build module 完成模块编译"></a>build module 完成模块编译</h4><p>对应上述代码中的<code>this.buildModule()</code></p><p>这里主要调用配置的<code>loaders</code>，将我们的模块转成标准的<code>JS</code>模块</p><p>在用<code>Loader</code> 转换完一个模块后，使用 <code>acorn</code> 解析转换后的内容，输出对应的抽象语法树（<code>AST</code>），以方便后面 <code>Webpack</code>对代码的分析。</p><p>转换完成后，开始分析模块的依赖关系，对应上述代码中的 <code>this.processModuleDependencies</code>。从配置的入口模块开始，分析其 <code>AST</code>，当遇到<code>require</code>等导入其它模块语句时，便将其加入到依赖的模块列表，同时，对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系。</p><p>webpack是先使用<code>loader</code>处理<code>入口文件</code>，再在<code>分析依赖</code>的过程中发现其他模块，然后才对其他模块递归使用loader，重复上述过程，就能解析完所有模块并构建好模块依赖图。</p><h3 id="打包并输出"><a href="#打包并输出" class="headerlink" title="打包并输出"></a>打包并输出</h3><h4 id="seal-输出资源"><a href="#seal-输出资源" class="headerlink" title="seal 输出资源"></a>seal 输出资源</h4><p><code>seal</code>方法主要任务是生成<code>chunks</code>，对<code>chunks</code>进行一系列的<code>优化操作</code>，并生成要输出的代码</p><p>根据入口文件和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>（如果只有一个入口文件，一般只有一个chunk），再把每个 <code>Chunk</code> 转换成一个单独的文件。</p><p><strong>chunk</strong></p><p><code>webpack</code> 中的 <code>chunk</code> ，可以理解为配置在 <code>entry</code>（入口文件） 中的模块，或者是动态引入的模块。</p><p>每个 chunk 可以包含<code>一个或多个模块</code>，并且可以被<code>单独加载</code>。</p><ol><li><p><strong>入口点</strong>（Entry Points）：每个入口点都会创建一个初始 chunk。</p></li><li><p><strong>动态导入</strong>（Dynamic Imports）： <code>import()</code> 动态加载模块时，会创建<strong>异步 chunks</strong>，它们是<code>按需加载</code>的。</p></li><li><p><strong>代码分割</strong>（Code Splitting）：开发者可以通过配置让 Webpack 根据某些规则<code>自动分割代码</code>到不同的 chunks 中。</p></li></ol><h4 id="emit-输出完成"><a href="#emit-输出完成" class="headerlink" title="emit 输出完成"></a>emit 输出完成</h4><p>在确定好输出内容后，根据配置确定<code>输出的路径</code>和<code>文件名</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Compiler</code> 开始生成文件前，钩子 <code>emit</code> 会被执行，这是我们修改最终文件的最后一个机会</p><p>从而<code>webpack</code>整个打包过程则结束了</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><img src="..\images\前端面试-webpack\webpack编译流程.png" style="zoom:67%;" /><h2 id="说说webpack中常见的Loader？解决了什么问题？"><a href="#说说webpack中常见的Loader？解决了什么问题？" class="headerlink" title="说说webpack中常见的Loader？解决了什么问题？"></a>说说webpack中常见的Loader？解决了什么问题？</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><code>loader</code> 本质是一个函数，用于对<code>文件</code>的<code>源代码</code>进行转换，使之变为webpack可用的<code>模块</code>，在 <code>import</code> 或<code>加载</code>模块时预处理文件</p><p><code>webpack</code>做的事情，仅仅是分析出各种模块的<code>依赖关系</code>，然后形成资源列表，最终打包生成到指定的文件中。如下图所示：</p><img src="..\images\前端面试-webpack\webpack.png" style="zoom: 60%;" /><p>在<code>webpack</code>内部中，任何<code>文件</code>都是<code>模块</code>，不仅仅只是<code>js</code>文件，这得益于loader扩大了模块化的范围</p><p>默认情况下，在遇到<code>import</code>或者<code>require</code>加载模块的时候，<code>webpack</code>只支持对<code>js</code> 和 <code>json</code> 文件打包</p><p>像<code>css</code>、<code>sass</code>、<code>png</code>等这些类型的文件的时候，<code>webpack</code>则无能为力，这时候就需要配置对应的<code>loader</code>进行文件内容的解析</p><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a><strong>配置方式</strong></h3><p>推荐在配置文件中配置，<code>rules</code>是一个数组，意味着我们可以给多种文件配置<code>loader</code>，每一类文件对应一个对象。</p><p><code>use</code>也是一个数组，这意味着我们可以对任意一种文件使用多个<code>loader</code>，每个<code>loader</code>是一个对象的格式，<code>loader</code>是支持<code>链式调用</code>的，调用的顺序是从<code>右至左</code>的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">&#x27;style-loader&#x27;</span> &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">              <span class="attr">modules</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; <span class="attr">loader</span>: <span class="string">&#x27;sass-loader&#x27;</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="常见的loader"><a href="#常见的loader" class="headerlink" title="常见的loader"></a>常见的loader</h3><p><strong>css-loader</strong></p><p>分析 <code>css</code> 模块之间的关系，并合成⼀个 <code>css</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br></pre></td></tr></table></figure><p>如果只通过<code>css-loader</code>加载文件，这时候页面代码设置的样式并没有生效</p><p>原因在于，<code>css-loader</code>只是负责将<code>.css</code>文件进行一个解析，而并不会将解析后的<code>css</code>插入到页面中</p><p>如果我们希望再完成插入<code>style</code>的操作，那么我们还需要另外一个<code>loader</code>，就是<code>style-loader</code></p><p><strong>style-loader</strong></p><p>把 <code>css-loader</code> 生成的内容，用 <code>style</code> 标签挂载到页面的 <code>head</code> 中，简单来说就是把css-loader生成的css代码内联到html文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">  ...,</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>]</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>less-loader</strong></p><p>开发中，我们也常常会使用<code>less</code>、<code>sass</code>、<code>stylus</code>预处理器编写<code>css</code>样式，使开发效率提高，这里需要使用<code>less-loader</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less-loader -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rules</span>: [</span><br><span class="line">  ...,</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">   <span class="attr">use</span>: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>,<span class="string">&quot;less-loader&quot;</span>]</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="编写loader"><a href="#编写loader" class="headerlink" title="编写loader"></a>编写loader</h3><p>在编写 <code>loader</code> 前，我们首先需要了解 <code>loader</code> 的本质</p><p>其本质为<strong>函数</strong>，函数中的 <code>this</code> 作为上下文会被 <code>webpack</code> 填充，指向 <code>webpack</code> 提供的对象，能够获取当前 <code>loader</code> 所需要的各种信息，因此我们不能将 <code>loader</code>设为一个<code>箭头函数</code></p><p>函数接受一个参数source，为 <code>webpack</code> 传递给 <code>loader</code> 的文件源内容</p><p>函数中有异步操作或同步操作，异步操作通过 <code>this.callback</code> 返回，返回值要求为 <code>string</code> 或者 <code>Buffer</code></p><p>代码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出一个函数，source为webpack传递给loader的文件源内容</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">source</span>) &#123;</span><br><span class="line">    <span class="comment">// content：String | Buffer，经过 loader 编译后需要导出的内容</span></span><br><span class="line">    <span class="keyword">const</span> content = <span class="title function_">doSomeThing2JsString</span>(source);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 loader 配置了 options 对象，那么this.query将指向 options</span></span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">query</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可以用作解析其他模块路径的上下文</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">context</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * this.callback 参数：</span></span><br><span class="line"><span class="comment">     * error：Error | null，当 loader 出错时向外抛出一个 error</span></span><br><span class="line"><span class="comment">     * content:处理后的模块内容</span></span><br><span class="line"><span class="comment">     * sourceMap：供一个 sourcemap，方便调试原始代码和编译后的代码之间的映射关系。</span></span><br><span class="line"><span class="comment">     * 这对于开发者工具来说非常有用，因为它们可以利用这些信息来显示原始代码而非编译后的代码。</span></span><br><span class="line"><span class="comment">     * ast：本次编译生成的AST抽象语法树，常用的解析器如 Babel可以将代码转换为 AST</span></span><br><span class="line"><span class="comment">     * 之后执行的loader可以直接使用这个AST，进而省去重复生成 AST 的过程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="literal">null</span>, content); <span class="comment">// 异步</span></span><br><span class="line">    <span class="comment">//返回经过loader编译后的内容</span></span><br><span class="line">    <span class="keyword">return</span> content; <span class="comment">// 同步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">source, inputSourceMap</span>) &#123;</span><br><span class="line">  <span class="comment">// 模拟异步操作，如读取文件或进行复杂的代码转换</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 假设我们进行了某些操作并产生了新的 source 和 sourceMap</span></span><br><span class="line">      <span class="keyword">const</span> newSource = source.<span class="title function_">replace</span>(<span class="regexp">/foo/g</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> newSourceMap = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(inputSourceMap); <span class="comment">// 示例中简单地序列化 source map</span></span><br><span class="line">      <span class="comment">// 成功完成任务，调用 callback 并传入结果</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">callback</span>(<span class="literal">null</span>, newSource, newSourceMap);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 发生错误，通过 error 参数返回错误信息</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">callback</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般在编写<code>loader</code>的过程中，保持功能单一，避免做多种功能</p><p>如<code>less</code>文件转换成 <code>css</code>文件也不是一步到位，而是 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code>几个 <code>loader</code>的链式调用才能完成转换</p><h2 id="说说webpack中常见的Plugin？解决了什么问题？"><a href="#说说webpack中常见的Plugin？解决了什么问题？" class="headerlink" title="说说webpack中常见的Plugin？解决了什么问题？"></a>说说webpack中常见的Plugin？解决了什么问题？</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p><code>Plugin</code>（Plug-in）是一种计算机应用程序，它和<code>主应用程序</code>互相交互，以提供特定的功能</p><p>是一种遵循一定规范的应用程序接口编写出来的程序，只能运行在程序规定的系统下，因为其需要调用<code>原纯净系统</code>提供的<code>函数库</code>或者<code>数据</code></p><p><code>webpack</code>中的<code>plugin</code>也是如此，<code>plugin</code>赋予其各种灵活的功能，例如打包优化、资源管理、环境变量注入等，它们会运行在 <code>webpack</code> 的不同阶段（钩子 &#x2F; 生命周期），贯穿了<code>webpack</code>整个编译周期</p><p>主要用来解决<code>loader</code>无法解决的其他事情，本质是一个具有<code>apply</code>方法的<code>js对象</code>（区别于vue的插件本质是一个具有<code>install</code>方法的对象），这个方法会被<code>compiler</code>对象调用。webpack构建过程中会<code>广播</code>很多事件，plugin可以<code>监听</code>自己感兴趣的事件，<strong>从而改变最后的打包结果。</strong></p><h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h3><p>这里讲述文件的配置方式，一般情况，通过配置文件导出对象中<code>plugins</code>属性传入<code>new</code>实例对象。如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>); <span class="comment">// 访问内置的插件</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">ProgressPlugin</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123; <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>插件本质是一个<strong>类</strong>，插件实例其本质是一个具有<code>apply</code>方法<code>javascript</code>对象</p><p>apply方法被调用的时候会传入<code>compiler</code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pluginName = <span class="string">&#x27;ConsoleLogOnBuildWebpackPlugin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConsoleLogOnBuildWebpackPlugin</span> &#123;</span><br><span class="line">  <span class="title function_">apply</span>(<span class="params">compiler</span>) &#123;</span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">run</span>.<span class="title function_">tap</span>(pluginName, <span class="function">(<span class="params">compilation</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;webpack 构建过程开始！&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">ConsoleLogOnBuildWebpackPlugin</span>;</span><br></pre></td></tr></table></figure><p><code>tap</code> 方法是用来<strong>注册</strong>一个函数，当某个特定的钩子被触发时，这个函数就会被执行。你可以把它看作是一种订阅模式，你的插件“订阅”了特定事件，并提供了一个回调函数，在该事件发生时执行。</p><p><code>compiler hook</code> 的 <code>tap</code>方法的第一个参数，应是驼峰式命名的插件名称</p><p>关于整个<code>编译生命周期钩子</code>（hooks），有如下：</p><ul><li>entry-option ：初始化 option</li><li>run：会在 Webpack 开始编译之前触发</li><li>compile： 真正开始的编译，在创建 compilation 对象之前</li><li>compilation ：生成好了 compilation 对象</li><li>make：从 entry 开始递归分析依赖，准备对每个模块进行 build</li><li>after-compile： 编译 build 过程结束</li><li>emit ：在将内存中 assets 内容写到磁盘文件夹之前</li><li>after-emit ：在将内存中 assets 内容写到磁盘文件夹之后</li><li>done： 完成所有的编译过程</li><li>failed： 编译失败的时候</li></ul><h3 id="常见的plugin"><a href="#常见的plugin" class="headerlink" title="常见的plugin"></a>常见的plugin</h3><ul><li><p>html-webpack-plugin：</p><p>在打包结束后，自动生成⼀个 <code>html</code> 文件，并<code>自动引入</code>打包后的js，css文件（自动注入到head标签中）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">       <span class="attr">title</span>: <span class="string">&quot;My App&quot;</span>,</span><br><span class="line">       <span class="attr">filename</span>: <span class="string">&quot;app.html&quot;</span>,</span><br><span class="line">       <span class="attr">template</span>: <span class="string">&quot;./src/html/index.html&quot;</span></span><br><span class="line">     &#125;) </span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>mini-css-extract-plugin：</p><p>提取 <code>CSS</code> 代码到一个单独的文件中，通常用来代替<code>style-loader</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">   <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">     <span class="attr">use</span>: [<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">     <span class="attr">filename</span>: <span class="string">&#x27;[name].css&#x27;</span><span class="comment">//放置提取出的css代码的css文件的文件名</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>更多的常见plugin可参考：<a href="https://www.sanye.blog/posts/8b27fb24.html">webpack基础 | 三叶的博客</a></p><h3 id="编写plugin"><a href="#编写plugin" class="headerlink" title="编写plugin"></a>编写plugin</h3><p>由于<code>webpack</code>基于发布订阅模式，在整个<code>编译周期</code>中会<code>广播</code>出许多事件，插件通过监听感兴趣的事件，并调用webpack提供的<code>api</code>，就可以在特定的阶段执行自己的插件任务。</p><p>在之前也了解过，<code>webpack</code>编译会创建两个核心对象：</p><ul><li><code>compiler</code>：包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin，和 webpack 整个生命周期相关的钩子</li><li><code>compilation</code>：作为 plugin内置事件回调函数的参数，包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当检测到一个文件变化，一次新的 Compilation 将被创建</li></ul><p>如果自己要实现<code>plugin</code>，也需要遵循一定的规范：</p><ul><li>插件必须是一个<code>函数</code>或者是一个包含 <code>apply</code> 方法的对象，这样才能访问<code>compiler</code>实例</li><li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用，因此不建议修改</li><li>异步的事件需要在插件处理完任务时，调用回调函数通知 <code>Webpack</code> 进入下一个流程，不然会卡住</li></ul><p>实现<code>plugin</code>的模板如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPlugin</span> &#123;</span><br><span class="line">    <span class="comment">// Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span></span><br><span class="line">  <span class="title function_">apply</span> (compiler) &#123;</span><br><span class="line">    <span class="comment">// 找到合适的事件钩子，实现自己的插件功能</span></span><br><span class="line">    compiler.<span class="property">hooks</span>.<span class="property">emit</span>.<span class="title function_">tap</span>(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function"><span class="params">compilation</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// compilation: 当前打包构建流程的上下文</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(compilation);</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，可以读取到<code>最终将输出的资源</code>、代码块、模块及其依赖，并且可以<code>修改</code>输出资源的内容。</p><h2 id="说说Loader和Plugin的区别？"><a href="#说说Loader和Plugin的区别？" class="headerlink" title="说说Loader和Plugin的区别？"></a>说说Loader和Plugin的区别？</h2><p>前面两节我们有提到<code>Loader</code>与<code>Plugin</code>对应的概念，先来回顾下</p><ul><li><p>loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</p></li><li><p>plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事，</p><p>比如提取css代码到一个单独的文件。</p></li></ul><p>从整个<strong>运行时机</strong>上来看，如下图所示：</p><img src="..\images\前端面试-webpack\time.png" style="zoom: 50%;" /><p>可以看到，两者在<code>运行时机</code>上的区别：</p><ul><li>loader 运行在打包文件之前</li><li>plugins 在<code>整个编译周期</code>都起作用</li></ul><p>在<code>Webpack</code> 运行的生命周期中会广播出许多事件，<code>Plugin</code> 可以监听这些事件，在合适的时机通过<code>Webpack</code>提供的 <code>API</code>改变输出结果</p><p>对于<code>loader</code>，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将<code>A.scss</code>或<code>A.less</code>转变为<code>B.css</code>，单纯的文件转换过程。</p><h2 id="webpack类似的工具还有哪些？区别？"><a href="#webpack类似的工具还有哪些？区别？" class="headerlink" title="webpack类似的工具还有哪些？区别？"></a>webpack类似的工具还有哪些？区别？</h2><p>模块化是一种处理复杂系统分解为更好的可管理模块的方式</p><p>每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体(<code>bundle</code>)</p><p>在前端领域中，并非只有<code>webpack</code>这一款优秀的<strong>模块打包工具</strong>，还有其他类似的工具，例如<code>Rollup</code>、<code>Parcel</code>、<code>snowpack</code>，以及最近风头无两的<code>Vite</code></p><p>这里没有提及<code>gulp</code>、<code>grunt</code>是因为它们只是定义为<code>构建工具</code>，不能类比，关于<code>gulp</code>的介绍可参考<a href="https://www.sanye.blog/posts/72ebd24d.html">hexo博客搭建的一些思考 | 三叶的博客</a></p><h3 id="Rollup"><a href="#Rollup" class="headerlink" title="Rollup"></a>Rollup</h3><img src="..\images\前端面试-webpack\rollup.png" style="zoom: 80%;" /><p><code>Rollup</code> 是一款 <code>ES Modules</code> 打包器，从作用上来看，<code>Rollup</code> 与 <code>Webpack</code> 非常类似。不过相比于 <code>Webpack</code>，<code>Rollup</code>要<strong>小巧</strong>的多</p><p>现在很多我们熟知的库都都使用它进行打包，比如：<code>Vue</code>、<code>React</code>和<code>three.js</code>等</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/messages.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">hi</span>: <span class="string">&#x27;Hey Guys, I am zce~&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/logger.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">log</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- INFO ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------------------------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">error</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;---------- ERROR ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(msg)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;---------------------------&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">&#x27;./logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> messages <span class="keyword">from</span> <span class="string">&#x27;./messages&#x27;</span></span><br><span class="line"><span class="title function_">log</span>(messages.<span class="property">hi</span>)</span><br></pre></td></tr></table></figure><p>然后通过<code>rollup</code>进行打包，把index.js文件和它依赖的模块打包成一个<code>chunk</code>，结果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">log</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- INFO ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;--------------------------&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> messages = &#123;</span><br><span class="line">  <span class="attr">hi</span>:<span class="string">&#x27;Hey Guys,I am zce~&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//导入模块成员</span></span><br><span class="line"><span class="comment">//使用模块成员</span></span><br><span class="line"><span class="title function_">log</span>(messages.<span class="property">hi</span>);</span><br></pre></td></tr></table></figure><p>可以看到，代码非常简洁，完成不像<code>webpack</code>那样存在大量引导代码和模块函数</p><p>并且<code>error</code>方法由于没有被使用，输出的结果中并无<code>error</code>方法，可以看到，<code>rollup</code>默认使用<code>Tree-shaking</code> 优化输出结果</p><p>因此，可以看到<code>Rollup</code>的<strong>优点</strong>：</p><ul><li>打包后的代码更简洁、打包效率更高</li><li>默认支持 Tree-shaking</li></ul><p>但<strong>缺点</strong>也十分明显，不能处理<code>其他类型的资源文件</code>和 <code>CommonJS</code> 模块，又或是编译 <code>ES</code> 新特性，这些额外的需求 ，<code>Rollup</code>需要使用插件去完成。</p><p>综合来看，<code>rollup</code>并不适合开发应用，因为需要使用<strong>第三方模块</strong>，而目前第三方模块大多数使用<code>CommonJs</code>方式导出成员，并且<code>rollup</code>不支持<code>HMR</code>，使开发效率降低</p><p>但是在用于打包<code>JavaScript</code> 库时，<code>rollup</code>比 <code>webpack</code> 更有优势，因为其打包出来的代码更小、速度更快，其存在的缺点可以忽略。</p><h3 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h3><img src="..\images\前端面试-webpack\parcel.png" style="zoom:80%;" /><p>Parcel ，是一款完全<code>零配置</code>的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序。</p><p><code>Parcel</code> 跟 <code>Webpack</code> 一样都支持以<code>任意类型文件</code>作为打包入口，但建议使用<code>HTML</code>文件作为入口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ./src/index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Parcel Tutorials<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main.js文件通过<code>ES Moudle</code>方法导入其他模块成员</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/logger.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">log</span> = msg =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---------- INFO ----------&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">&#x27;./logger&#x27;</span></span><br><span class="line"><span class="title function_">log</span>(<span class="string">&#x27;hello parcel&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行之后，使用命令打包</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx parcel src/index.html</span><br></pre></td></tr></table></figure><p>执行命令后，<code>Parcel</code>不仅打包了应用，同时也启动了一个<code>开发服务器</code>，跟<code>webpack Dev Server</code>一样</p><p>跟<code>webpack</code>类似，也支持<code>模块热替换(HMR)</code>，但用法更简单</p><p>同时，<code>Parcel</code>有个十分好用的功能：支持<code>自动安装依赖</code>，像<code>webpack</code>开发阶段突然需要安装某个第三方依赖，必然会终止<code>dev server</code>然后安装再启动。而<code>Parcel</code>则免了这繁琐的工作流程。</p><p>同时，<code>Parcel</code>能够零配置加载其他类型的资源文件，无须像<code>webpack</code>那样配置对应的<code>loader</code></p><p>由于打包过程是<code>多进程</code>同时工作，构建速度会比<code>Webpack</code> 快，输出文件也会被<code>压缩</code>，并且样式代码也会被单独提取到<code>单个文件</code>中</p><p>可以感受到，<code>Parcel</code>给开发者一种很大的自由度，只管去实现业务代码，其他事情用<code>Parcel</code>解决</p><h3 id="Snowpack"><a href="#Snowpack" class="headerlink" title="Snowpack"></a>Snowpack</h3><img src="..\images\前端面试-webpack\snowpack.png" style="zoom: 67%;" /><p>Snowpack，是一种<code>闪电般快速</code>的前端构建工具，专为现代<code>Web</code>设计，较复杂的打包工具（如<code>Webpack</code>或<code>Parcel</code>）的替代方案，利用<code>JavaScript</code>的本机模块系统，避免不必要的工作并保持流畅的开发体验。</p><p><strong>开发阶段</strong>，每次保存<code>单个文件</code>时，<code>Webpack</code>和<code>Parcel</code>都需要<code>重新构建</code>和<code>重新打包</code>应用程序的<strong>整个</strong><code>bundle</code>，这个过程包括：重新解析依赖关系，重新优化和压缩，重新生成资源文件。而<code>Snowpack</code>为你的应用程序<code>每个文件</code>构建一次，就可以永久缓存，文件更改时，<code>Snowpack</code>只会重新构建该<code>单个文件</code>。</p><h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><img src="..\images\前端面试-webpack\vite2.png" style="zoom:67%;" /><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p><p>它主要由两部分组成：</p><ul><li>一个开发服务器，它基于原生ES 模块提供了丰富的内建功能，如速度快到惊人的模块热更新HMR</li><li>一套<code>构建指令</code>，它使用 <code>Rollup</code>打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li></ul><p>其作用类似<code>webpack</code>+ <code>webpack-dev-server</code>，其特点如下：</p><ul><li>快速的冷启动</li><li>即时的模块热更新</li><li>真正的<code>按需编译</code></li></ul><p><code>vite</code>会直接启动开发服务器，不需要进行打包操作，因此启动速度非常快</p><p>利用现代浏览器支持<code>ES Module</code>的特性，当浏览器请求<code>某个模块</code>的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间。</p><p>原理图如下所示：</p><img src="..\images\前端面试-webpack\vite.png" style="zoom: 67%;" /><p>在热模块<code>HMR</code>方面，当修改一个模块的时候，<strong>仅需让浏览器重新请求该模块即可</strong>，无须像<code>webpack</code>那样需要把该模块的相关依赖模块全部编译一次，效率更高。</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>相比上述的模块化工具，<code>webpack</code>大而全，很多常用的功能做到开箱即用。有两大最核心的特点：<strong>一切皆模块</strong>和<strong>按需加载</strong></p><p>与其他构建工具相比，有如下优势：</p><ul><li>智能解析：对 CommonJS 、 AMD 、ES6 的语法做了兼容</li><li>万物模块：对 js、css、图片等资源文件都支持打包，不过需要通过配置loader来实现</li><li>开箱即用：HMR、Tree-shaking等功能</li><li>代码分割：可以将<code>代码切割</code>成不同的 chunk，实现按需加载，降低了初始化时间</li><li>插件系统，具有强大的 Plugin 接口，具有更好的灵活性和扩展性</li><li>易于调试：支持 SourceUrls 和 SourceMaps</li><li>快速运行：webpack 使用异步 IO 并具有多级缓存，这使得 webpack 很快且在增量编译上更加快</li><li>生态环境好：社区更丰富，出现的问题更容易解决</li></ul><h2 id="说说如何借助webpack来优化前端性能？"><a href="#说说如何借助webpack来优化前端性能？" class="headerlink" title="说说如何借助webpack来优化前端性能？"></a>说说如何借助webpack来优化前端性能？</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>随着前端的项目逐渐扩大，必然会带来的一个问题就是性能</p><p>尤其在大型复杂的项目中，前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至奔溃</p><p>一般项目在完成后，会通过<code>webpack</code>进行打包，利用<code>webpack</code>对前端项目性能优化是一个十分重要的环节</p><h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3><p>通过<code>webpack</code>优化前端的手段有：</p><ul><li>JS，CSS，Html代码压缩</li><li>文件大小压缩</li><li>图片压缩</li><li>Tree Shaking</li><li>代码分离</li><li>内联 chunk</li></ul><h4 id="js代码压缩"><a href="#js代码压缩" class="headerlink" title="js代码压缩"></a><strong>js代码压缩</strong></h4><p><code>terser</code>是一个<code>JavaScript</code>的解释、绞肉机、压缩机的工具集，可以帮助我们压缩、丑化我们的代码，让<code>bundle</code>更小</p><p>在<code>production</code>模式下，<code>webpack</code> 默认就是使用 <code>TerserPlugin</code> 来处理我们的代码的。如果想要自定义配置它，配置方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">TerserPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">                <span class="attr">parallel</span>: <span class="literal">true</span> <span class="comment">// 电脑cpu核数-1</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性介绍如下：</p><ul><li>extractComments：默认值为true，表示会将注释抽取到一个单独的文件中，开发阶段，我们可设置为 false ，不保留注释</li><li>parallel：使用多进程并发运行提高构建的速度，默认值是true，并发运行的默认数量： os.cpus().length - 1</li><li>terserOptions：设置我们的terser相关的配置：</li><li>compress：设置压缩相关的选项，mangle：设置丑化相关的选项，可以直接设置为true</li><li>mangle：设置丑化相关的选项，可以直接设置为true</li><li>toplevel：底层变量是否进行转换</li><li>keep_classnames：保留类的名称</li><li>keep_fnames：保留函数的名称</li></ul><h4 id="压缩css代码"><a href="#压缩css代码" class="headerlink" title="压缩css代码"></a><strong>压缩css代码</strong></h4><p><code>CSS</code>压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等</p><p>CSS的压缩我们可以使用另外一个插件：<code>css-minimizer-webpack-plugin</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-minimizer-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizerPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">        <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">minimizer</span>: [</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>(&#123;</span><br><span class="line">                <span class="attr">parallel</span>: <span class="literal">true</span></span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HTML代码压缩"><a href="#HTML代码压缩" class="headerlink" title="HTML代码压缩"></a><strong>HTML代码压缩</strong></h4><p>使用<code>HtmlWebpackPlugin</code>插件来生成<code>HTML</code>的模板时候，通过配置属性<code>minify</code>进行<code>html</code>优化</p><p>关于<code>HtmlWebpackPlugin</code>插件的详细使用方法，可参考<a href="https://www.sanye.blog/posts/8b27fb24.html">webpack基础 | 三叶的博客</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">plugin</span>:[</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HtmlwebpackPlugin</span>(&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="attr">minify</span>:&#123;</span><br><span class="line">                <span class="attr">minifyCSS</span>:<span class="literal">false</span>, <span class="comment">// 是否压缩css</span></span><br><span class="line">                <span class="attr">collapseWhitespace</span>:<span class="literal">false</span>, <span class="comment">// 是否折叠空格</span></span><br><span class="line">                <span class="attr">removeComments</span>:<span class="literal">true</span> <span class="comment">// 是否移除注释</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置了<code>minify</code>，实际会使用另一个插件<code>html-minifier-terser</code></p><h4 id="文件大小压缩"><a href="#文件大小压缩" class="headerlink" title="文件大小压缩"></a><strong>文件大小压缩</strong></h4><p>前面介绍的都是<code>代码压缩</code>，是指对<code>源代码</code>进行处理，以减小其体积而不改变其功能。</p><p>代码压缩通常涉及以下几种操作：</p><ul><li><strong>移除空白字符</strong>：包括空格、制表符、换行符等。</li><li><strong>缩短变量名和函数名</strong>：将长的<code>标识符</code>替换为短的名字，比如从<code>myVariableName</code>变成<code>a</code>。</li><li><strong>移除注释</strong>：在生产环境中，注释是没有必要的，所以会被删除。</li><li><strong>简化语句</strong>：例如，合并多个<code>var</code>声明或者将一些表达式简化。</li></ul><p><code>文件大小压缩</code>则是指使用<code>算法</code>对文件内容进行<code>编码</code>，从而生成一个更小的表示形式，有时可能会导致文件类型的改变（如压缩成.zip或.rar档案）</p><p>常见的文件压缩方法有：</p><ul><li><strong>无损压缩</strong>：如ZIP、Gzip、Brotli等，可以完全还原原始文件的内容。这些压缩方法适用于所有类型的文件，并且特别适合于文本文件，因为文本文件中往往存在很多重复模式，容易被压缩算法利用。</li><li><strong>有损压缩</strong>：如JPEG图片压缩，视频编码等，通过去除一些人类视觉或听觉不易察觉的信息来减小文件大小，但不能完全恢复原始文件。</li></ul><p>在网络传输中，服务器常常会在发送响应之前使用<code>Gzip</code>或<code>Brotli</code>等压缩算法对整个响应体（包含HTML、JS、CSS等）进行压缩，以减少传输的数据量。当客户端接收到这个压缩后的数据后，会<code>自动解压并处理</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install compression-webpack-plugin -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ComepressionPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">test</span>:<span class="regexp">/\.(css|js)$/</span>,  <span class="comment">// 哪些文件需要压缩</span></span><br><span class="line">    <span class="attr">threshold</span>:<span class="number">500</span>, <span class="comment">// 设置文件多大开始压缩</span></span><br><span class="line">    <span class="attr">minRatio</span>:<span class="number">0.7</span>, <span class="comment">// 至少压缩的比例</span></span><br><span class="line">    <span class="attr">algorithm</span>:<span class="string">&quot;gzip&quot;</span>, <span class="comment">// 采用的压缩算法</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a><strong>图片压缩</strong></h4><p>一般来说在打包之后，一些图片文件的大小是远远要比 <code>js</code> 或者 <code>css</code> 文件要来的大，所以图片压缩较为重要</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;[name]_[hash].[ext]&#x27;</span>,</span><br><span class="line">            <span class="attr">outputPath</span>: <span class="string">&#x27;..\images/&#x27;</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;image-webpack-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="comment">// 压缩 jpeg 的配置</span></span><br><span class="line">            <span class="attr">mozjpeg</span>: &#123;</span><br><span class="line">              <span class="attr">progressive</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">quality</span>: <span class="number">65</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 使用 imagemin**-optipng 压缩 png，enable: false 为关闭</span></span><br><span class="line">            <span class="attr">optipng</span>: &#123;</span><br><span class="line">              <span class="attr">enabled</span>: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 使用 imagemin-pngquant 压缩 png</span></span><br><span class="line">            <span class="attr">pngquant</span>: &#123;</span><br><span class="line">              <span class="attr">quality</span>: <span class="string">&#x27;65-90&#x27;</span>,</span><br><span class="line">              <span class="attr">speed</span>: <span class="number">4</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 压缩 gif 的配置</span></span><br><span class="line">            <span class="attr">gifsicle</span>: &#123;</span><br><span class="line">              <span class="attr">interlaced</span>: <span class="literal">false</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class="line">            <span class="attr">webp</span>: &#123;</span><br><span class="line">              <span class="attr">quality</span>: <span class="number">75</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><code>image-webpack-loader</code>，这是一个专门用来压缩图片的加载器。它不会影响文件的存储位置或名称，而是专注于减少图像文件的大小。</p><h4 id="TreeShaking"><a href="#TreeShaking" class="headerlink" title="TreeShaking"></a><strong>TreeShaking</strong></h4><p><code>Tree Shaking</code> 是一个术语，在计算机中表示消除死代码（一般指的是js代码），依赖于<code>ES Module</code>的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）</p><p>在 Webpack5 中，Tree Shaking 在生产环境下<code>默认启动</code>，这就意味着不需要配置<code>usedExports</code>，同时还会自动启用<code>代码压缩</code>。</p><p>如果想在<code>开发环境</code>启动 Tree Shaking，需要配置 <code>optimization.usedExports</code> 为 true，启动<strong>标记</strong>功能；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">optimization</span>:&#123;</span><br><span class="line">        <span class="attr">usedExports</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>usedExports</code> 用于在 Webpack 编译过程中启动<code>标记功能</code>，使用之后，没被用上的变量&#x2F;函数（包括未导入的函数&#x2F;变量和导入后未使用的函数&#x2F;变量），在<code>webpack</code>打包中会被加上<code>unused harmony export</code>注释，当生成产物时，被标记的变量&#x2F;函数对应的<code>导出语句</code>会被删除。</p><p>当然，仅仅删除未被使用的变量&#x2F;函数的<code>导出语句</code>是不够的，若 Webpack 配置启用了代码压缩工具，如<code> Terser</code> 插件，那么在打包的最后它<strong>还会删除</strong>所有<code>引用被标记内容</code>的代码语句，这些语句一般称作<code> Dead Code</code>。可以说，真正执行 Tree Shaking 操作的是 Terser 插件。</p><p>如下面<code>sum</code>函数没被用到，<code>webpack</code>打包会添加注释，<code>terser</code>在优化时，则将该函数连同引用该函数的代码删除掉。</p><p>要注意的是，上述注释只有在开发打包下，开启usedExports，不开启代码压缩，才能看到。</p><img src="..\images\前端面试-webpack\usedExports.png" style="zoom:90%;" /><p><strong>但是，并不是所有 Dead Code 都会被 Terser 删除</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">cube</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">square</span>(<span class="number">10</span>));</span><br><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; cube &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cube</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><p>我们添加一条<code>console.log</code>语句，它打印了调用 <code>squre</code> 函数的返回结果，<code>index.js</code> 保留原样。按照我们之前的设想，打包后会删除与 <code>square</code> 函数相关的代码语句，即 <code>square</code> 函数的<code>声明语句</code>、打印语句都会被删除。</p><p>然而实际上，打包后的<code>math.js</code> 模块中，<code>square</code> 函数的痕迹被完全清除，但是打印语句仍然被保留。这是因为，这条语句存在<strong>副作用</strong>。</p><p><strong>副作用（side effect）</strong> 的定义是，在<code>导入时</code>会执行特殊行为的代码（不是export，而是比如调用函数之类的代码）。例如 polyfill，它影响全局作用域，因而存在副作用。</p><p>显然，以上示例的 <code>console.log()</code> 语句存在副作用。Terser 在执行 Tree Shaking 时，会<strong>保留</strong>它认为存在<code>副作用</code>的代码，而不是将其删除，即便这个代码是Dead code。</p><p>作为开发者，如果你非常清楚某条语句会被<code>判别为有副作用</code>，但其实是无害的(删除后无影响)，应该被删除，可以使用 <code>/*#__PURE__*/</code> 注释，来向 terser 传递信息，表明这条语句是纯的，没有副作用，terser 可以放心将它删除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">cube</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*#__PURE__*/</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">square</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>然后在打包结果中就不会有<code>console.log</code>语句</p><p><strong>sideEffects</strong></p><p><code>sideEffects</code>用于告知<code>webpack compiler</code>哪些<strong>模块</strong>是有副作用（区别于<code>pure注释</code>的代码层面），</p><p><code>&quot;sideEffects&quot;</code> 是 <code>package.json</code> 的一个字段，默认值为 <code>true</code>，即认为所有模块都可能是有副作用的。如果你非常清楚你的 package 是纯粹的，不包含副作用，那么可以简单地将该属性标记为 <code>false</code>，来告知 webpack 整个包都是没有副作用的，可以安全地删除所有<code>未被使用的代码</code>（Dead Code），执行比较激进的tree-shaking；如果你的 package 中有些模块确实有一些副作用，可以改为提供一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;sideEffects&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;./src/util/format.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.css&quot;</span> <span class="comment">// 所有的css文件</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>更多内容参考：<a href="https://juejin.cn/post/7105022295474700295">Webpack 5 实践：你不知道的 Tree Shaking本篇文章从 什么是 Tree Shaking、如何使用 T - 掘金</a></p><h4 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h4><p>将代码分离到不同的<code>bundle</code>中，之后我们可以<code>按需加载</code>，或者并行加载这些文件</p><p>默认情况下，所有的<code>JavaScript</code>代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度</p><p>代码分离可以分出更小的<code>bundle</code>，以及控制资源加载优先级，提供代码的加载性能</p><p>这里通过<code>splitChunksPlugin</code>来实现，该插件<code>webpack</code>已经默认安装和集成，只需要配置即可</p><p>默认配置中，chunks仅仅针对于异步（async）请求，我们可以设置为<code>initial</code>或者<code>all</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">optimization</span>:&#123;</span><br><span class="line">        <span class="attr">splitChunks</span>:&#123;</span><br><span class="line">            <span class="attr">chunks</span>:<span class="string">&quot;all&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>splitChunks</code>主要属性有如下：</p><ul><li>Chunks，对同步代码还是异步代码进行处理</li><li>minSize： 拆分包的大小, 至少为minSize，如何包的大小不超过minSize，这个包不会拆分</li><li>maxSize： 将大于maxSize的包，拆分为不小于minSize的包</li><li>minChunks：被引入的次数，默认是1</li></ul><h4 id="内联chunk"><a href="#内联chunk" class="headerlink" title="内联chunk"></a><strong>内联chunk</strong></h4><p>可以通过<code>InlineChunkHtmlPlugin</code>插件将一些<code>chunk</code>的模块内联到<code>html</code>，如<code>runtime</code>的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">InlineChunkHtmlPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;react-dev-utils/InlineChunkHtmlPlugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">plugin</span>:[</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InlineChunkHtmlPlugin</span>(<span class="title class_">HtmlWebpackPlugin</span>,[<span class="regexp">/runtime.+\.js/</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="说说webpack的热更新是如何做到的？原理是什么？"><a href="#说说webpack的热更新是如何做到的？原理是什么？" class="headerlink" title="说说webpack的热更新是如何做到的？原理是什么？"></a>说说webpack的热更新是如何做到的？原理是什么？</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p><code>HMR</code>全称 <code>Hot Module Replacement</code>，可以理解为<code>模块热替换</code>，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用。</p><p>例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失</p><p>如果使用的是 <code>HMR</code>，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用。</p><p>在<code>webpack</code>中配置开启热模块也非常的简单，如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 开启 HMR 特性</span></span><br><span class="line">    <span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// hotOnly: true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述这种配置，如果我们修改并保存<code>css</code>文件，确实能够以不刷新的形式更新到页面中</p><p>但是，当我们修改并保存<code>js</code>文件之后，页面依旧自动刷新了，这里并没有触发热模块</p><p>所以，<code>HMR</code>并不像 <code>Webpack</code> 的其他特性一样可以开箱即用，需要有一些额外的操作</p><p>我们需要去指定哪些模块发生更新时进行<code>HRM</code>，如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable language_">module</span>.<span class="property">hot</span>)&#123;</span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>(<span class="string">&#x27;./util.js&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;util.js更新了&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><img src="..\images\前端面试-webpack\HMR.png" style="zoom:100%;" /><ul><li>Webpack Compile：将 JS 源代码编译成 bundle.js</li><li>HMR Server：用来将热更新的文件输出给 HMR Runtime</li><li>Bundle Server：静态资源文件服务器，提供文件访问路径</li><li>HMR Runtime：<code>socket服务器</code>，会被注入到浏览器，更新文件的变化</li><li>bundle.js：构建输出的文件</li><li>在HMR Runtime 和 HMR Server之间建立 websocket，即图上4号线，用于实时更新文件变化</li></ul><p>上面图中，可以分成两个阶段：</p><ul><li>启动阶段为上图 1 - 2 - A - B</li></ul><p>在编写未经过<code>webpack</code>打包的源代码后，<code>Webpack Compile</code> 将源代码和 <code>HMR Runtime</code> 一起编译成 <code>bundle</code>文件，传输给<code>Bundle Server</code> 静态资源服务器</p><ul><li>更新阶段为上图 1 - 2 - 3 - 4</li></ul><p>当某一个文件或者模块发生变化时，<code>webpack</code>监听到文件变化对文件重新编译打包，编译生成唯一的<code>hash</code>值，这个<code>hash</code>值用来作为下一次热更新的<code>标识</code></p><p>根据变化的内容生成两个补丁文件：<code>manifest</code>（包含了 <code>hash</code> 和 <code>chundId</code>，用来说明变化的内容）和<code>chunk.js</code> 模块</p><p>由于<code>socket</code>服务器在<code>HMR Runtime</code> 和 <code>HMR Server</code>之间建立 <code>websocket</code>链接，当文件发生改动的时候，服务端会向浏览器推送一条消息，消息包含文件改动后生成的<code>hash</code>值，如下图的<code>h</code>属性，作为下一次热更细的标识</p><p>在浏览器接受到这条消息之前，浏览器已经在上一次<code>socket</code> 消息中已经记住了此时的<code>hash</code> 标识，这时候我们会创建一个 <code>ajax</code> 去服务端请求获取到变化内容的 <code>manifest</code> 文件</p><p><code>mainfest</code>文件包含重新<code>build</code>生成的<code>hash</code>值，以及变化的模块，对应上图的<code>c</code>属性</p><p>浏览器根据 <code>manifest</code> 文件获取模块变化的内容，从而触发<code>render</code>流程，实现局部模块更新</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于<code>webpack</code>热模块更新的总结如下：</p><ul><li>通过<code>webpack-dev-server</code>创建两个服务器：提供静态资源的服务（express）和Socket服务</li><li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li><li>socket server 是一个 websocket 的长连接，双方可以通信</li><li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li><li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li><li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新。</li></ul><h2 id="如何提高webpack的构建速度？"><a href="#如何提高webpack的构建速度？" class="headerlink" title="如何提高webpack的构建速度？"></a>如何提高webpack的构建速度？</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>随着我们的项目涉及到页面越来越多，功能和业务代码也会随着越多，相应的 <code>webpack</code> 的构建时间也会越来越久</p><p>构建时间与我们日常开发效率密切相关，当我们本地开发启动 <code>devServer</code> 或者 <code>build</code> 的时候，如果时间过长，会大大降低我们的工作效率</p><p>所以，优化<code>webpack</code> 构建速度是十分重要的环节</p><h3 id="如何优化-1"><a href="#如何优化-1" class="headerlink" title="如何优化"></a>如何优化</h3><p>常见的提升构建速度的手段有如下：</p><ul><li>优化 loader 配置</li><li>合理使用 resolve.extensions</li><li>优化 resolve.modules</li><li>优化 resolve.alias</li><li>使用 DLLPlugin 插件</li><li>使用 cache-loader</li><li>terser 启动多线程</li><li>合理使用 sourceMap</li></ul><h4 id="优化loader配置"><a href="#优化loader配置" class="headerlink" title="优化loader配置"></a>优化loader配置</h4><p>在使用<code>loader</code>时，可以通过配置<code>include</code>、<code>exclude</code>、<code>test</code>属性来匹配文件</p><p>如采用 ES6 的项目为例，在配置 <code>babel-loader</code>时，可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 只对项目根目录下的 src文件夹中的文件采用 babel-loader</span></span><br><span class="line">        <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">        <span class="comment">// babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span></span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&#x27;babel-loader?cacheDirectory&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说白了就是使用loader的时候，尽可能精确的匹配文件。</p><h4 id="合理使用-resolve-extensions"><a href="#合理使用-resolve-extensions" class="headerlink" title="合理使用 resolve.extensions"></a>合理使用 resolve.extensions</h4><p>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库， <code>resolve</code>可以帮助<code>webpack</code>从每个 <code>require/import</code> 语句中，找到需要引入的，合适的模块代码</p><p>解析到未加扩展名的文件时，通过<code>resolve.extensions</code>，自动给文件添加拓展名，默认情况如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">       <span class="attr">extensions</span>: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们引入文件的时候，若<code>没有文件后缀名</code>，则会根据数组内的值依次查找</p><p>当我们配置的时候，则不要随便把所有后缀都写在里面，这会调用多次文件的查找，这样就会减慢打包速度</p><p>简单的来说就是，后缀自动填充数组的长度不要太长了。</p><h4 id="优化-resolve-modules"><a href="#优化-resolve-modules" class="headerlink" title="优化 resolve.modules"></a>优化 resolve.modules</h4><p><code>resolve.modules</code> 用于配置 <code>webpack</code> 去哪些目录下寻找<code>第三方模块</code>。默认值为<code>[&#39;node_modules&#39;]</code>，所以默认会从<code>node_modules</code>中查找文件 当安装的第三方模块都放在项目根目录下的 <code>./node_modules</code>目录下时，所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span><br><span class="line">    // 其中 __dirname 表示当前工作目录，也就是项目根目录</span><br><span class="line">    modules: [path.resolve(__dirname, &#x27;node_modules&#x27;)]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="优化-resolve-alias"><a href="#优化-resolve-alias" class="headerlink" title="优化 resolve.alias"></a>优化 resolve.alias</h4><p><code>alias</code>给一些<code>常用路径</code>起一个<code>别名</code>，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是<code>./../../</code>的形式</p><p>通过配置<code>alias</code>以减少查找过程，再vue的脚手架中，这是自动配置好的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">resolve</span>:&#123;</span><br><span class="line">        <span class="attr">alias</span>:&#123;</span><br><span class="line">            <span class="string">&quot;@&quot;</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;./src&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-cache-loader"><a href="#使用-cache-loader" class="headerlink" title="使用 cache-loader"></a>使用 cache-loader</h4><p>在一些性能开销较大的 <code>loader</code>之前添加 <code>cache-loader</code>，以将结果<strong>缓存</strong>到磁盘里，显著提升<code>二次构建</code>速度</p><p>保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 <code>loader</code> 使用此<code>loader</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ext$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [<span class="string">&#x27;cache-loader&#x27;</span>, ...loaders],</span><br><span class="line">                <span class="attr">include</span>: path.<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="terser-启动多线程"><a href="#terser-启动多线程" class="headerlink" title="terser 启动多线程"></a>terser 启动多线程</h4><p>使用多进程并行运行来提高构建速度，其实默认就是使用多线程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">parallel</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更多优化方式参考：<a href="https://vue3js.cn/interview/webpack/improve_build.html#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96">面试官：如何提高webpack的构建速度？</a></p><h2 id="说说webpack-proxy工作原理？为什么能解决跨域"><a href="#说说webpack-proxy工作原理？为什么能解决跨域" class="headerlink" title="说说webpack proxy工作原理？为什么能解决跨域?"></a>说说webpack proxy工作原理？为什么能解决跨域?</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p><code>webpack proxy</code>，即<code>webpack</code>提供的代理服务</p><p>基本行为就是接收客户端发送的请求后转发给其他服务器</p><p>其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）</p><p>想要实现代理首先需要一个中间服务器（代理服务区），<code>webpack</code>中提供服务器的工具为<code>webpack-dev-server</code></p><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><p><code>webpack-dev-server</code>是 <code>webpack</code> 官方推出的一款开发工具，将<code>自动编译</code>和<code>自动刷新浏览器</code>等一系列对开发友好的功能全部集成在了一起，目的是为了提高开发者日常的开发效率，<strong>只适用在开发阶段</strong></p><p>关于配置方面，在<code>webpack</code>配置对象属性中，通过<code>devServer</code>属性提供，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">contentBase</span>: path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">9000</span>,</span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;https://api.github.com&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxy属性的名称是需要被代理的<code>请求路径前缀</code>，一般为了辨别都会设置前缀为<code>/api</code>，值为对应的代理匹配规则，对应如下：</p><ul><li>target：表示的是代理到的目标地址</li><li>pathRewrite：默认情况下，我们的<code> /api</code>也会被写入到URL中，如果希望删除，可以使用pathRewrite</li><li>secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false</li><li>changeOrigin：它表示是否更新<code>代理请求</code>的 <code>headers</code> 中<code>host</code>地址</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>参考<a href="https://www.sanye.blog/posts/f33bd2b9.html">前端面试—vue部分</a>一文中的跨域解决部分。</p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试---css</title>
      <link href="/posts/4b58a1f5.html"/>
      <url>/posts/4b58a1f5.html</url>
      
        <content type="html"><![CDATA[<p>全文主要参考如下github项目，在此基础上补充了一些自己的东西：</p><p><a href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a></p><p>项目网站：<a href="https://vue3js.cn/interview/">web前端面试 - 面试官系列</a></p><p>一个非常全面，细致的前端面试题库,十分的推荐，深刻体会到github的强大之处了。</p><h2 id="说说css盒模型"><a href="#说说css盒模型" class="headerlink" title="说说css盒模型"></a>说说css盒模型</h2><p>浏览器在渲染html元素的时候，会把所有元素表示为一个一个矩形的盒子。</p><h3 id="盒模型组成"><a href="#盒模型组成" class="headerlink" title="盒模型组成"></a>盒模型组成</h3><ul><li><p><strong>content</strong></p><p>即实际内容，显示文本和图像</p></li><li><p><strong>padding</strong></p><p>即内边距，内边距是透明的，取值<strong>不能为负</strong>，背景图片可以扩展到padding。</p></li><li><p><strong>border</strong></p><p>即边框，由粗细、样式、颜色三部分组成。例如<code>border:1px solid black</code></p></li><li><p><strong>margin</strong></p><p>即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域。</p></li></ul><h3 id="盒模型分类"><a href="#盒模型分类" class="headerlink" title="盒模型分类"></a>盒模型分类</h3><ul><li><p><strong>w3c标准盒模型</strong>（content-box）</p><p><code>width/height</code>的范围只包括<code>content</code>，虽说是<code>标准盒模型</code>，怎么感觉没有ie盒模型好用捏。</p></li><li><p><strong>ie盒模型</strong>(border-box)</p><p><code>width/height</code>的范围包括<code>content</code>,<code>border</code>,<code>padding</code>。</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: content-box|border-box|inherit;//指定元素使用哪种盒模型来渲染,inherit表示继承父元素盒模型</span><br></pre></td></tr></table></figure><h2 id="说说em-px-rem-vh-vw区别"><a href="#说说em-px-rem-vh-vw区别" class="headerlink" title="说说em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别"></a>说说em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw区别</h2><ul><li><p><strong>em</strong></p><p>是一个相对单位，和<code>rem</code>不同的是，相对的是<code>父元素</code>的字体大小</p></li><li><p><strong>px</strong></p><p>1px即1个<code>css像素</code>，是绝对单位。</p></li><li><p><strong>rem</strong></p><p>是一个相对单位，相对的是根元素<code>html</code>的字体大小。</p><p>如果想要简化<code>font-size</code>的转化，我们可以修改html的字体大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">10px</span>  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>vw&#x2F;vh</strong></p><p>把<code>视口</code>的宽高划分为100等份，1vw表示视口宽度的1&#x2F;100，1vh表示视口高度的1&#x2F;100，是一个相对单位，相对的是视口的宽&#x2F;高，而百分比布局相对的是<code>父元素的宽/高</code>。</p><p>这里的<code>视口</code>，在<code>PC端</code>指的就是<code>浏览器窗口</code>，在<code>移动端</code>指的就是<code>布局视口</code>，一般就是<code>设备屏幕</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span> #指定布局视口宽度为设备宽度</span><br></pre></td></tr></table></figure></li></ul><h2 id="设备像素、css像素、设备独立像素、dpr、ppi-之间的区别"><a href="#设备像素、css像素、设备独立像素、dpr、ppi-之间的区别" class="headerlink" title="设备像素、css像素、设备独立像素、dpr、ppi 之间的区别"></a>设备像素、css像素、设备独立像素、dpr、ppi 之间的区别</h2><ul><li><p><strong>css像素</strong></p><p>在web编程中，<strong>css代码中的像素</strong>，一般<code>1px</code>就是一个<code>css像素</code>。</p></li><li><p><strong>设备像素</strong></p><p>设备像素（device pixels），又称为<code>物理像素</code>，指设备能控制显示的<code>最小物理单位</code>，就是显示屏上的一个一个像素点。</p><p>从屏幕在工厂生产出的那天起，它上面的<code>物理像素点</code>就固定不变了。</p><p><strong>屏幕的分辨率</strong>通常为<code>a×b</code>的格式，分别指的是宽，高上的<code>物理像素点</code>的个数。</p></li><li><p><strong>设备独立像素</strong></p><p>设备独立像素指的是<code>与设备无关的</code>逻辑像素，以通过<code>程序控制</code>使用的<code>虚拟像素</code>，一个<code>设备独立像素</code>可能会对应多个<code>设备像素</code>。</p><p>我们在游戏中可以调节游戏的分辨率，实际就是在调节<code>设备独立像素</code>。</p><p>在屏幕<code>未缩放</code>情况下（100%），<code>1css像素=1设备独立像素</code>，我们也可以推断出缩放屏幕，其实就是在改变<code>css像素</code>与<code>设备独立像素的</code><strong>比例关系</strong></p></li><li><p><strong>dpr</strong></p><p><code>dpr = 设备像素/设备独立像素</code>，在PC端，<code>dpr = 1</code>，在移动端，<code>dpr&gt;=1</code></p><p>我们通常讨论的是<code>不缩放</code>的情况下，也就是<code>1css像素就是1设备独立像素</code>,因此<code>dpr</code>又可以被认等于<code>设备像素/css像素</code>。</p><p>当设备像素比为1:1时，使用1（1×1）个<code>设备像素</code>显示<code>1个CSS像素</code></p><p>当设备像素比为2:1时，使用4（2×2）个<code>设备像素</code>显示<code>1个CSS像素</code></p><p>当设备像素比为3:1时，使用9（3×3）个<code>设备像素</code>显示<code>1个CSS像素</code></p></li><li><p><strong>PPI</strong></p><p>即<code>pixel per inch</code>每英寸像素点的个数，这个<code>PPI</code>越大，说明物理像素点的密度更大，<code>像素点一般也更多，像素点大小也越小</code>，能更<code>细致</code>的展现图像。</p><img src="..\images\前端面试-css\ppi.png" style="zoom:80%;" /><p>比如，iPhone 3GS 和 iPhone 4&#x2F;4s 的尺寸都是 3.5 寸，但 iPhone 3GS 的分辨率是<code> 320x480</code>，iPhone 4&#x2F;4s 的分辨率是<code> 640x960</code></p><p>这意味着，iPhone 3GS 在<code>宽</code>上有<code>320</code>个物理像素，iPhone 4&#x2F;4s 在<code>宽</code>上有<code> 640</code> 个物理像素<strong>，也就是说iPhone 4&#x2F;4s的PPI更大</strong>。</p><p>如果我们按照真实的物理像素进行布局，比如说我们按照<code> 320 物理像素</code>进行布局，到了<code> 640 物理像素</code>的手机上就会有一半的空白，为了避免这种问题，就出现了<code>虚拟像素单位</code></p><p>我们统一 iPhone 3GS 和 iPhone 4&#x2F;4s 都是 320 个虚拟像素，只是在 iPhone 3GS 上，最终 1 个虚拟像素换算成 1 个物理像素，在 iphone 4s 中，<strong>1 个虚拟像素最终换算成 2 个物理像素(DPR&#x3D;2)</strong></p><p>可以看到光提高<code>PPI</code>还是不够的，为了解决空白问题吗，还要修改<code>DPR</code>。</p><p>我们思考一下，为什么原本能用1个物理像素表示的，为了解决空白问题就硬要用2个物理像素表示呢，就非得让屏幕中的所有像素点参与展示吗，这样不就等同于<code>放大图片</code>吗，放大图片不是会变模糊吗，因为图片本身没有这么多细节（分辨率&lt;实际用来渲染的像素数目），所以对于<code>PPI</code>更高的设备，我们要准备分辨率更高的图片（分辨率越高的图片，文件大小越大，占用的物理像素点越多，和屏幕分辨率是一个概念），才能完美的解决空白问题。</p><p>举个例子，我们有50x50分辨率（在PC端，DPR为1的设备，就是50x50px）的图片，放到iPhone 3GS上（DPR&#x3D;1）会占用50x50像素（物理像素），放到iPhone4&#x2F;4s上(DPR&#x3D;2)，会占用100*100像素（物理像素），因为<code>图片分辨率 &lt; 实际参与渲染的物理像素</code>，所以会变模糊。</p><p>如果我们放一个 100x100 分辨率(在PC端，DPR为1的设备，就是100x100px)图片，然后手动的把这个图片<strong>缩小</strong>为 50x50(css像素，即px)，放到iPhone4&#x2F;4s上，会占用100*100像素（物理像素），因为<code>图片分辨率 = 实际参与渲染的物理像素</code>，所以会被清晰的展示。</p><p>所以一般情况下，我们认为<code>PPI</code>越大，图像越清晰，因为我们能用更多更小的像素来渲染图片。</p></li></ul><h2 id="如何实现元素隐藏"><a href="#如何实现元素隐藏" class="headerlink" title="如何实现元素隐藏"></a><strong>如何实现元素隐藏</strong></h2><ul><li><strong>display:none</strong><ul><li>能实现元素隐藏，而且元素<code>不再占有原来的位置</code></li><li>会触发页面的<code>重排</code>与<code>重绘</code></li><li>元素对应的<code>dom</code>对象仍然存在，无法再响应<code>点击事件</code></li></ul></li><li><strong>visibility:hidden</strong><ul><li>能实现元素隐藏，而且元素<code>占有原来的位置</code></li><li>只会触发页面的<code>重绘</code></li><li>元素对应的<code>dom</code>对象仍然存在，无法再响应<code>点击事件</code></li></ul></li><li><strong>opacity:0</strong><ul><li>能实现元素隐藏，而且元素<code>占有原来的位置</code></li><li>元素对应的<code>dom</code>对象仍然存在，且能响应<code>点击事件</code></li><li>一般情况下也会引发重绘</li></ul></li></ul><p><strong>总结</strong></p><p>这三种方法都能实现元素隐藏，<code>display:none</code>会让元素不再占有原来的位置，而其他两种则会保留原来的位置。</p><p>添加了<code>display:none</code>与<code>visibility:hidden</code>的元素都<strong>无法再响应点击事件</strong>，而添加了<code>opacity:0</code>的元素可以。</p><h2 id="谈谈你对BFC的理解"><a href="#谈谈你对BFC的理解" class="headerlink" title="谈谈你对BFC的理解"></a><strong>谈谈你对BFC的理解</strong></h2><h3 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h3><p>也叫<code>块级格式化上下文</code>，可以理解为css中的一种属性，开启了<code>bfc</code>的盒子被视为一块<code>独立的渲染区域</code>，内部元素不会影响外部元素的布局。</p><h3 id="如何开启BFC"><a href="#如何开启BFC" class="headerlink" title="如何开启BFC"></a>如何开启BFC</h3><ul><li><code>html</code>标签默认开启了<code>BFC</code></li><li><code>overflow</code>的值不为<code>visible</code>的元素</li><li>添加了<code>绝对定位</code>，<code>固定定位</code>的元素</li><li>开启了<code>浮动</code>的元素</li><li>开启了<code>flex布局</code>或者<code>grid布局</code>的元素(这2种布局的内部元素布局方式确实独特)</li></ul><h3 id="开启了BFC有什么作用"><a href="#开启了BFC有什么作用" class="headerlink" title="开启了BFC有什么作用"></a><strong>开启了BFC有什么作用</strong></h3><ul><li><p><strong>可以用来清除浮动</strong></p><p>BFC盒子内部的<code>浮动元素</code>也参与BFC盒子高度的计算。</p><p>所以浮动元素，绝对定位元素，固定定位元素，不需要担心浮动元素不参与自身高度的计算 。</p></li><li><p><strong>开启了BFC的元素不会与浮动元素重叠</strong></p><p>所以<code>浮动元素</code>不会被<code>浮动元素</code>压住。</p></li><li><p><strong>可以用来解决边距塌陷问题</strong></p><p>如果两个相邻的盒子存在边距塌陷问题，只要让其中一个盒子<code>包裹</code>一个开启了<code>BFC</code>的盒子就能解决边距塌陷问题。</p></li></ul><h2 id="介绍一下flex弹性布局"><a href="#介绍一下flex弹性布局" class="headerlink" title="介绍一下flex弹性布局"></a>介绍一下flex弹性布局</h2><p>开启Flex布局的元素（display:flex），称为<code>flex</code>容器<code>container</code>，它的<code>所有子元素</code>自动成为容器成员，称为<code>flex</code>项目<code>item</code></p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a><strong>容器属性</strong></h3><p>包括<code>flex-direction</code>，<code>flex-wrap</code>，<code>flex-flow</code>，<code>justify-content</code>，<code>align-items</code>，<code>align-content</code>。</p><ul><li><p><strong>flex-direction</strong></p><p>决定<strong>主轴</strong>的方向(即项目的排列方向)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;   </span><br><span class="line">    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>row（默认值）：主轴为水平方向，起点在左端，从左到右摆放</li><li>row-reverse：主轴为水平方向，起点在右端，从右到左摆放</li><li>column：主轴为垂直方向，起点在上沿。从上到下摆放</li><li>column-reverse：主轴为垂直方向，起点在下沿，从下到上摆放</li></ul></li><li><p><strong>flex-wrap</strong></p><p>用来决定子元素一行放不下了<strong>是否换行</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;  </span><br><span class="line">    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><strong>nowrap</strong>（默认值）：不换行</li><li><strong>wrap</strong>：换行，第一行在下方</li><li>wrap-reverse：换行，第一行在上方</li></ul></li><li><p><strong>flex-flow</strong></p><p>是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>justify-content</strong></p><p>定义了项目（子元素）在主轴上的<strong>对齐</strong>方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>flex-start（默认值）：开始处（start）开始对齐</p></li><li><p>flex-end：结束处（end）开始对齐</p></li><li><p>center：居中对齐</p></li><li><p>space-between：两端对齐，项目之间的间隔都相等</p></li><li><p>space-around：两个项目两侧间隔相等</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\flex.png" style="zoom: 67%;" /><img src="..\images\前端面试-css\flex2.png" style="zoom: 67%;" /><img src="..\images\前端面试-css\flex3.png" style="zoom:67%;" /><img src="..\images\前端面试-css\flex4.png" style="zoom:67%;" /><img src="..\images\前端面试-css\flex5.png" style="zoom:67%;" /><img src="..\images\前端面试-css\flex6.png" style="zoom:67%;" /></li><li><p><strong>align-items</strong></p><p>定义子元素如何在<code>侧轴</code>上对齐（垂直于主轴），只适用于只有<code>一根主轴线</code>的时候（如果主轴为row，就是只有一行）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start：交叉轴的<code>起点</code>对齐</li><li>flex-end：交叉轴的<code>终点</code>对齐</li><li>center：交叉轴的中点对齐, 就是居中对齐</li><li>baseline: 项目的第一行文字的基线对齐</li><li><strong>stretch</strong>（默认值，拉伸）：如果项目<strong>未设置高度</strong>或设为auto，将占满整个容器的高度。</li></ul></li><li><p><strong>align-content</strong></p><p>定义<strong>多根主轴</strong>的对齐方式。如果项目只有一根主轴线（比如主轴是<code>row</code>的时候，只有<code>一行</code>子元素），该属性不起作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start：与交叉轴的起点对齐</li><li>flex-end：与交叉轴的终点对齐</li><li>center：与交叉轴的中点对齐</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍</li><li>stretch（默认值）：轴线占满整个侧轴</li></ul><p>可以看到，这些属性值和<code>justify-content</code>的属性值是几乎一样的，如果<code>主轴有多根</code>，可以把<code>每根主轴</code>当作侧轴上的<code>一个元素</code>。</p></li></ul><h3 id="容器成员属性"><a href="#容器成员属性" class="headerlink" title="容器成员属性"></a><strong>容器成员属性</strong></h3><ul><li><p><code>order</code></p><p>定义项目的排列顺序。数值越小，排列越靠前，默认为<code>0</code>，不指定<code>order</code>属性，那就是<code>order：0</code></p><p>默认情况，子元素的排列顺序是在<code>html文档中的书写顺序</code>，而指定order能改变这个顺序。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>flex-grow</code></p><p>定义了子元素的<code>放大</code>比例，默认为<code>0</code>，当容器设为<code>flex-wrap: nowrap(默认值);</code>即不换行的时候，如果一行没有占满：</p><ul><li><p><code>flow-grow</code>的值为0，如果一行没有占满，也不放大。</p></li><li><p>如果子元素<code>flow-grow</code>的值不为0，无论是否<code>指定宽度</code>，都会根据<code>flex-grow</code>的值来分割剩余空间</p></li><li><p>子元素<code>flex-grow</code>属性都为1，则它们将<code>等分</code>剩余空间。</p></li></ul></li><li><p><code>flex-shrink</code></p><p>定义了子元素的<code>缩小比例</code>（容器宽度&lt;子元素总宽度时如何收缩），默认为<code>1</code></p><p>如果所有子元素的<code>flex-shrink</code>属性都为<code>1</code>，当空间不足时，都将<code>等比例缩小</code></p><p>如果一个子元素的<code>flex-shrink</code>属性为<code>0</code>，其他项目都为<code>1</code>，则空间不足时，前者<code>不缩小</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">250px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">   <span class="attribute">display</span>: flex;</span><br><span class="line">   <span class="attribute">background-color</span>: antiquewhite;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: aqua;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="selector-class">.b</span> &#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: red;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="selector-class">.c</span> &#123;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">   <span class="attribute">background-color</span>: gold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\flex-shrink.png" style="zoom:80%;" /><p>可以看到即便子元素<code>指定了宽度</code>，如果一行放不下，也会等比例缩小。我们可以通过修改<code>flex-shrink</code>属性来修改具体的缩小规则。</p></li><li><p><code>flex-basis</code></p><p>设置的是元素在主轴上的<code>初始尺寸</code>，所谓的<code>初始尺寸</code>就是元素在<code>flex-grow</code>和<code>flex-shrink</code>生效前的尺寸。</p><ul><li><strong>auto</strong>: 默认值，这意味着项目将根据其内容确定其<code>初始大小</code>，如设置了<code>width/height</code>则元素尺寸由<code>width/height</code>决定</li><li>固定值：你可以指定一个<code>具体的长度单位</code>，如像素 (<code>px</code>)、百分比 (<code>%</code>) 等。这会设置项目的<code>初始大小</code>，不考虑内容的自然尺寸。</li><li>0：<strong>完全依赖</strong>于 <code>flex-grow</code> 来分配多余的空间。这种方式常用于创建等分布局，如果令一个元素的<code>flex-basis:0</code>，由于<code>flex-grow</code>默认为<code>0</code>，此时无论是否指定宽度，在主轴上的宽度都为<code>0</code>。</li></ul></li><li><p><code>flex</code></p><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>，也是比较难懂的一个复合属性。</p><p>我们通常的书写方式<code>flex:1</code>修改的是<code>flex-grow</code>的值，即规定了分割剩余空间时的权重或者份数。</p></li><li><p><code>align-self</code></p><p>允许侧轴上的单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性，但是不能覆盖<code>align-content</code>的，</p><p>默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\align-self.png" style="zoom:80%;" /></li></ul><h2 id="介绍一下grid网格布局"><a href="#介绍一下grid网格布局" class="headerlink" title="介绍一下grid网格布局"></a>介绍一下grid网格布局</h2><p>通过<code>display:grid/inline-grid</code>就能开启网格布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;sub-item&quot;</span>&gt;</span>&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item item-3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>上述代码实例中，<code>.container</code>元素就是网格布局容器，<code>.item</code>元素就是网格的项目，由于网格元素只能是容器的<code>顶层子元素</code>，所以<code>p</code>元素并不是网格元素</p><p>同样，<code>Grid</code> 布局属性可以分为两大类：</p><ul><li>容器属性</li><li>项目属性</li></ul><h3 id="容器属性-1"><a href="#容器属性-1" class="headerlink" title="容器属性"></a>容器属性</h3><ul><li><p><strong>display</strong></p><ul><li>display：grid 则该容器是一个<code>块级元素</code></li><li>display: inline-grid 则容器元素为<code>行内元素</code></li></ul></li><li><p><strong>grid-template-columns</strong>&#x2F;<strong>grid-template-rows</strong></p><p><code>grid-template-columns</code> 属性设置<code>列宽</code>，<code>grid-template-rows</code> 属性设置<code>行高</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="comment">/*  声明了三列，宽度分别为 200px 200px 200px */</span></span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">200px</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="comment">/*  声明了两行，行高分别为 50px 50px  */</span></span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上表示固定列宽为 200px，行高为 50px</p><p>上述代码可以看到重复写单元格宽高，通过使用<code>repeat()</code>函数，可以简写重复的值</p><ul><li>第一个参数是重复的<code>次数</code></li><li>第二个参数是重复的<code>值</code></li></ul><p>所以上述代码可以简写成</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>,<span class="number">200px</span>);</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>:<span class="built_in">repeat</span>(<span class="number">2</span>,<span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上述的<code>repeact</code>关键字，还有：</p><ul><li><p><strong>auto-fill</strong>：示<code>自动填充</code>，让一行（或者一列）中<strong>尽可能的容纳更多</strong>的单元格，只能在<code>repeat</code>函数中使用，用来替代具体的重复次数。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//表示列宽是 <span class="number">200</span> px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置更多的列</span><br><span class="line"><span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">200px</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>fr</strong>：片段，为了方便表示比例关系，非常类似<code>flex</code>布局中的份数，用<code>份数</code>来替代具体的宽高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//表示第一个列宽设置为 <span class="number">200px</span>，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 <span class="number">1</span>/<span class="number">3</span> 和 <span class="number">2</span>/<span class="number">3</span></span><br><span class="line"><span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">1</span>fr <span class="number">2</span>fr </span><br></pre></td></tr></table></figure></li><li><p><strong>minmax</strong>：产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。第一个参数就是最小值，第二个参数就是最大值，用一个<code>范围</code>来替代具体的宽高。</p><p>minmax(100px, 1fr)<code>表示列宽不小于(&gt;=)</code>100px<code>，不大于(&lt;=)</code>1fr</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">grid-template-columns</span>:<span class="built_in">repeat</span>(auto-fill,<span class="built_in">minmax</span>(<span class="number">260px</span>,<span class="number">1</span>fr))</span><br></pre></td></tr></table></figure></li><li><p><strong>auto</strong>：由浏览器自己决定长度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//表示第一第三列为 <span class="number">100px</span>，中间由浏览器决定长度</span><br><span class="line"><span class="attribute">grid-template-columns</span>: <span class="number">100px</span> auto <span class="number">100px</span> </span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>gap</strong></p><p>定义宫格之间的<code>间隔</code></p></li></ul><h3 id="容器成员属性-1"><a href="#容器成员属性-1" class="headerlink" title="容器成员属性"></a>容器成员属性</h3><p>….</p><h2 id="CSS如何画一个三角形"><a href="#CSS如何画一个三角形" class="headerlink" title="CSS如何画一个三角形"></a>CSS如何画一个三角形</h2><p>可以通过指定<code>边框（border）</code>样式实现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:  <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">50px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#96ceb4</span> <span class="number">#ffeead</span> <span class="number">#d9534f</span> <span class="number">#ffad60</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个盒子的样式如下：</p><img src="..\images\前端面试-css\三角.png" style="zoom:80%;" /><p>当盒子的<code>宽高</code>不断减小，那每个边框是不是就会变成一个三角形呢？</p><img src="..\images\前端面试-css\三角2.png" style="zoom:80%;" /><p>这样会得到四个三角形，但是我们只要一个，我们可以把其他边框的颜色<code>变透明</code>,但是这样隐藏的部分仍然<code>占据部分高度</code>，</p><p>比如我们只要下面的三角形，那我们就可以让上边框的的宽度变为<code>0</code>，效果就是这样。</p><img src="..\images\前端面试-css\三角3.png" style="zoom:80%;" /><p>然后再让左右边框变为透明的就好了。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: transparent transparent <span class="number">#d9534f</span> transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\三角4.png" style="zoom:80%;" /><h2 id="如何实现元素水平居中，垂直居中"><a href="#如何实现元素水平居中，垂直居中" class="headerlink" title="如何实现元素水平居中，垂直居中"></a><strong>如何实现元素水平居中，垂直居中</strong></h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ul><li><p><strong>行内元素&#x2F;行内块元素</strong></p><ul><li><p>给父元素添加<code>text-align:center</code></p></li><li><p>给父元素添加<code>flex</code>布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex; </span><br><span class="line"><span class="attribute">justify-content</span>: center;</span><br></pre></td></tr></table></figure></li><li><p>给自身添加<code>绝对定位</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>块级元素</strong></p><ul><li><p>添加<code>margin: 0 auto</code>，要求块级元素的宽度<code>确定</code></p></li><li><p>给父元素添加<code>flex</code>布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex; </span><br><span class="line"><span class="attribute">justify-content</span>: center;</span><br></pre></td></tr></table></figure></li><li><p>给自身添加绝对定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ul><li><p><strong>行内元素</strong></p><ul><li><p>指定行内元素的行高<code>line-height</code>为父元素高度。</p></li><li><p>给父元素添加<code>flex</code>布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex; </span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br></pre></td></tr></table></figure></li><li><p>给自身添加绝对定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>行内块元素&#x2F;块级元素</strong></p><ul><li><p>给父元素添加<code>flex</code>布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: flex; </span><br><span class="line"><span class="attribute">align-items</span>: center;</span><br></pre></td></tr></table></figure></li><li><p>给自身添加绝对定位</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>总结</strong></p><p><code>绝对定位</code>和<code>flex布局</code>是万能的。<code>margin:0 auto</code>，<code>text-align:center</code>，<code>line-height:父元素高度</code>，是一些特殊情况。</p><h2 id="说说对CSS预处理语言的理解？有哪些区别"><a href="#说说对CSS预处理语言的理解？有哪些区别" class="headerlink" title="说说对CSS预处理语言的理解？有哪些区别?"></a>说说对CSS预处理语言的理解？有哪些区别?</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li><p>CSS代码看起来是<code>没有逻辑性</code>的，<code>不方便维护及扩展</code>，不利于<code>复用</code>。<code>css预处理语言</code>在css的基础上，添加了<code>变量</code>，<code>混入</code>，<code>嵌套</code>等功能，让css代码看起来更有<code>逻辑性</code>，更容易维护和复用。</p></li><li><p>css预处理语言包括一套<code>自定义的语法</code>和一个<code>解析器</code>，解析器会把用自定义语法编写的代码转化成<code>css代码</code>。</p></li></ul><h3 id="常见的css预编译语言"><a href="#常见的css预编译语言" class="headerlink" title="常见的css预编译语言"></a>常见的css预编译语言</h3><ul><li><p><strong>sass</strong></p><p>2007 年诞生，最早也是最成熟的 <code>Css</code>预处理器，拥有 Ruby 社区的支持和 <code>Compass</code> 这一最强大的 <code>Css</code>框架，目前受 <code>LESS</code> 影响，已经进化到了全面兼容 <code>Css</code> 的 <code>Scss</code></p><p><strong>sass和scss的区别与联系</strong></p><ul><li>是同一种css预处理语言(sass)的两种<code>不同语法形式</code>，它们都扩展了标准的 CSS，虽然有<code>不同的自定义语法</code>，但是使用<code>同一个解析器</code>（编译器）来处理</li><li>sass使用<code>缩进</code>来表示代码块，不使用大括号 <code>&#123;&#125;</code> 和分号 <code>;</code>更接近 Python 的风格，强调简洁性和可读性。文件使用 <code>.sass</code> 扩展名</li><li>scss与 CSS 的语法几乎完全相同，所以更容易被现有开发者接受和使用。文件使用 <code>.scss</code> 扩展名</li></ul></li><li><p><strong>less</strong></p><p>2009年出现，受<code>SASS</code>的影响较大，但又使用 <code>Css</code> 的语法，让大部分开发者和设计师更容易上手，在 <code>Ruby</code>社区之外支持者远超过 <code>SASS</code></p><p>其缺点是比起 <code>SASS</code>来，可编程功能不够，不过优点是<code>简单</code>和兼容 <code>Css</code>，反过来也影响了 <code>SASS</code>演变到了<code>Scss</code> 的时代</p></li></ul><h3 id="常用特性"><a href="#常用特性" class="headerlink" title="常用特性"></a>常用特性</h3><ul><li><p><strong>嵌套</strong></p><p>二者的嵌套语法都是一致的，甚至连<code>引用父级选择器</code>的标记 <code>&amp; </code>也相同</p><p>区别只是 Sass可以用没有大括号的方式书写(用<strong>缩进</strong>)</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="selector-tag">&amp;</span><span class="selector-class">.b</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>变量</strong></p><p>变量的出现有效的提高了css代码复用性，减少了不必要的<code>硬编码</code>。</p><p><code>less</code>声明的变量必须以<code>@</code>开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号<code>:</code>分隔开</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@red</span>: #c00;</span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: @red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sass</code>声明的变量跟<code>less</code>十分的相似，只是变量名前面使用<code>$</code>开头</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$red: <span class="number">#c00</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">strong</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: $red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>作用域</strong></p><p>在css预处理语言中，变量是具有<code>作用域</code>的。</p><p><code>sass</code>中所有定义的变量都在全局作用域中，没有局部作用域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$color: black;</span><br><span class="line">.scoped &#123;</span><br><span class="line">  $bg: blue;</span><br><span class="line">  $color: white;</span><br><span class="line">  color: $color;</span><br><span class="line">  background-color:$bg;</span><br><span class="line">&#125;</span><br><span class="line">.unscoped &#123;</span><br><span class="line">  color:$color;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scoped</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:white;<span class="comment">/*是白色*/</span></span><br><span class="line">  <span class="attribute">background-color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.unscoped</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:white;<span class="comment">/*白色（无全局变量概念）*/</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>所以，在<code>sass</code>中最好不要定义相同的变量名，后面定义的会覆盖前面定义的。</p><p><code>less</code>的变量作用域跟<code>javascript</code>十分的相似，有<code>局部变量</code>和<code>全局变量</code>之分。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@color:</span> black;</span><br><span class="line"><span class="selector-class">.scoped</span> &#123;</span><br><span class="line">  <span class="variable">@bg:</span> blue;</span><br><span class="line">  <span class="variable">@color:</span> white;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="variable">@bg</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.unscoped</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:<span class="variable">@color</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scoped</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:white;<span class="comment">/*白色（调用了局部变量）*/</span></span><br><span class="line">  <span class="attribute">background-color</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.unscoped</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>:black;<span class="comment">/*黑色（调用了全局变量）*/</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p><strong>混入</strong></p><p><code>Mixins</code>可以将一部分样式抽出，作为单独定义的<code>模块</code>，被很多<strong>选择器</strong><code>重复使用</code>，可以说是css预处理语言的<strong>精髓</strong>所在。</p><p>在<code>less</code>中的用法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.alert</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这不是在定义函数吗</span></span><br><span class="line"><span class="selector-class">.highlight</span>(<span class="variable">@color</span>: red) &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">@color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.heads-up</span> &#123;</span><br><span class="line">  <span class="selector-class">.alert</span>;</span><br><span class="line">    <span class="comment">//函数调用？</span></span><br><span class="line">  <span class="selector-class">.highlight</span>(red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.alert</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heads-up</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Sass</code>声明<code>mixins</code>时需要使用<code>@mixin</code>，后面紧跟<code>mixin</code>的名，也可以设置参数，参数名为变量<code>$</code>声明的形式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> large-text &#123;</span><br><span class="line">  <span class="attribute">font</span>: &#123;</span><br><span class="line">    family: Arial;</span><br><span class="line">    size: <span class="number">20px</span>;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.page-title</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> large-text;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>代码模块化</strong></p><p>模块化就是将复杂的Css代码按某种规则划分为一个个文件，每个文件就是一个模块，模块可以通过<code>@import</code>引入</p><p><code>scss</code>、<code>less</code>二者的使用方法都如下所示。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./common&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./github-markdown&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./mixin&#x27;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;./variables&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在原生css代码中，也能使用<code>@import</code>关键字导入其他css文件(无论是在css文件中还是在style标签中)；<code>url()</code>是可加可不加的，要注意的是，结尾都要加上<code>分号</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&#x27;./common&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何实现单行／多行文本溢出的省略样式？"><a href="#如何实现单行／多行文本溢出的省略样式？" class="headerlink" title="如何实现单行／多行文本溢出的省略样式？"></a>如何实现单行／多行文本溢出的省略样式？</h2><p>对于文本的溢出，我们可以分成两种形式：</p><ul><li>单行文本溢出</li><li>多行文本溢出</li></ul><h3 id="单行文本溢出显示"><a href="#单行文本溢出显示" class="headerlink" title="单行文本溢出显示"></a>单行文本溢出显示</h3><p>涉及的<code>css</code>属性有：</p><ul><li>text-overflow</li><li>white-space</li><li>overflow</li></ul><p><code>overflow</code>设为<code>hidden</code>，普通情况用在<code>块级元素</code>的外层隐藏<code>内部溢出元素</code>，或者配合下面<code>两个属性</code>实现文本溢出省略</p><p><code>white-space:nowrap</code>，作用是设置文本<code>不换行</code>，是<code>overflow:hidden</code>和<code>text-overflow：ellipsis</code>生效的基础</p><p><code>text-overflow</code>属性值有如下：</p><ul><li><code>clip</code>：当对象内文本溢出部分<code>裁切</code>掉</li><li><code>ellipsis</code>：当对象内文本溢出时显示<code>省略</code>标记（…）</li></ul><p><code>text-overflow</code>只有在设置了<code>overflow:hidden</code>和<code>white-space:nowrap</code>才能够生效。</p><img src="..\images\前端面试-css\文本省略.png" style="zoom:90%;" /><h3 id="多行文本溢出显示"><a href="#多行文本溢出显示" class="headerlink" title="多行文本溢出显示"></a>多行文本溢出显示</h3><p>多行文本溢出的时候，我们可以分为两种情况：</p><ul><li><p><strong>基于高度截断</strong></p><p>就是把省略号作为<code>伪元素</code>，添加到容器，并使用<code>绝对定位</code>定位到行尾并遮住文字，再通过 <code>overflow: hidden</code> 隐藏多余文字。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.demo &#123;</span><br><span class="line">   position: relative;</span><br><span class="line">   line-height: 20px;</span><br><span class="line">   height: 40px;</span><br><span class="line">   overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.demo::after &#123;</span><br><span class="line">   content: &quot;...&quot;;</span><br><span class="line">   position: absolute;</span><br><span class="line">   bottom: 0;</span><br><span class="line">   right: 0;</span><br><span class="line">   padding: 0 20px 0 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\文本省略2.png" style="zoom:80%;" /></li></ul><h2 id="CSS提高性能的方法有哪些？"><a href="#CSS提高性能的方法有哪些？" class="headerlink" title="CSS提高性能的方法有哪些？"></a>CSS提高性能的方法有哪些？</h2><h3 id="浏览器渲染的流程"><a href="#浏览器渲染的流程" class="headerlink" title="浏览器渲染的流程"></a>浏览器渲染的流程</h3><p>浏览器有一个固定的渲染流程——只有在布局（layout）完成后才能绘制（paint）页面，而<code>布局</code>的前提是要生成<code>渲染树</code>（render tree），而<code>渲染树</code>的生成则需要 <code>DOM树</code> 和 <code>CSSOM 树</code>的配合。</p><p>如果先让用户看到一个没有样式的页面，等 CSS 样式解析完后再重绘（repaint），这样的体验会<strong>很差</strong>。所以，浏览器会等到<code>确定需要 CSS</code> 时才开始渲染。只有在<strong>下载完 CSS 并生成 CSS 对象模型 (CSSOM)<strong>之后，浏览器</strong>才</strong>会绘制页面。</p><h3 id="如何提高性能"><a href="#如何提高性能" class="headerlink" title="如何提高性能"></a>如何提高性能</h3><ul><li>内联首屏关键CSS</li><li>异步加载CSS</li><li>资源压缩</li><li>合理使用选择器</li><li>不要使用@import</li></ul><p><strong>内联首屏关键css</strong></p><ul><li><p><strong>如何找出关键css代码</strong></p><p>有许多工具可以帮助自动生成和内联关键 CSS，例如：</p><ul><li><strong>Penthouse</strong>：一个 Node.js 库，用于生成关键路径 CSS。</li><li><strong>Webpack 插件</strong>：如 <code>critical-css-webpack-plugin</code>，可以在构建过程中自动处理关键 CSS。</li></ul><p>在vue开发中，首屏组件对应的css，js代码一定是会被html文件引入的，使用路由懒加载，虽然不能实现内联css代码，但是也能实现<code>代码分割</code>，确保渲染首屏的时候只加载首屏关键css代码。</p></li><li><p><strong>如何内联</strong></p><p>将提取出的<code>关键 CSS </code>直接嵌入到 HTML 文件的 <code>&lt;head&gt;</code> 部分，使用 <code>&lt;style&gt;</code> 标签包裹。</p></li><li><p><strong>为什么内联关键css能提高首屏渲染速度</strong></p><p>内联css代码将成为html文件的一部分，会随着html文件的下载而被下载，能够使浏览器在下载完<code>html</code>后就能<strong>立刻渲染</strong>，</p><p>说简单点就是<strong>节省了下载的时间</strong></p><p>而如果<code>外部引用css</code>代码，在解析<code>html</code>结构过程中遇到外部<code>css</code>文件，才会开始<code>下载css</code>代码，再解析，再渲染。</p><p>所以，<code>CSS</code>内联使用使渲染时间<code>提前</code>。</p></li><li><p><strong>那为什么不把全部css代码内联到html文件</strong></p><p>虽然内联关键 CSS 可以<strong>加速首屏渲染</strong>，但过大的内联样式可能会<code>增加 HTML 文件的大小</code>，反而影响<code>加载速度</code>。因此，应该尽量保持内联 CSS 的精简。</p></li></ul><p><strong>异步加载（就是下载）css</strong></p><p>对于<code>首屏关键css</code>我们内联到<code>html</code>文件，其他非关键css代码放到外部文件中，再通过<code>link</code>标签引入，但浏览器在解析 HTML 时遇到 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 标签时，<code>默认</code>会<strong>等待</strong>这些样式表<code>下载并解析完成之后</code>才继续渲染页面，也就是说会<strong>阻塞页面的渲染</strong>。</p><p>然而，<code>非首屏关键css</code>不应该阻塞页面的加载，因为这些样式<strong>没有必要</strong>立即加载出来，可以采用<code>异步加载</code>的方式来加载这些外部css文件。</p><ul><li><p>利用<strong>媒体查询</strong></p><p>在link标签上添加<code>media</code>属性即可实现媒体查询，使得网页能够在不同的设备条件下加载不同的css代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 加载和解析 styles.css 会阻塞渲染，因为这个样式表在浏览器渲染过程中是要用到的，浏览器会等待它解析完再渲染 --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 加载和解析 print.css 不会阻塞渲染，因为这个样式表在浏览器渲染过程中不会用到 --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;print.css&quot; media=&quot;print&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在大屏幕上，加载和解析 mobile.css 不会阻塞渲染，因为这个样式表在浏览器渲染过程中不会用到  --&gt;</span><br><span class="line">&lt;link</span><br><span class="line">  rel=&quot;stylesheet&quot;</span><br><span class="line">  href=&quot;mobile.css&quot;</span><br><span class="line">  media=&quot;screen and (max-width: 480px)&quot; /&gt;</span><br></pre></td></tr></table></figure><p>可以看出，<strong>css文件的下载和解析本身不会阻塞浏览器渲染</strong>，阻塞的原因是在<strong>等待</strong>需要用到的css文件解析完毕罢了</p><p>设置一个当前浏览器不支持的值：</p><p><code>this</code>只的是link标签本身</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;./index<span class="selector-class">.css</span>&quot; media=&quot;print&quot; onload=&quot;this<span class="selector-class">.media</span>=&#x27;<span class="attribute">all</span>&#x27;&quot;&gt;</span><br></pre></td></tr></table></figure><p>在加载完毕之后，使用<code>onload</code>属性将<code>link</code>的媒体类型设置为<code>all</code>，然后便开始渲染。</p><p>这样这个css文件的<code>加载</code>不会阻塞浏览器渲染，加载结束之后变为浏览器渲染需要用到的css文件，于是开始解析（此时会阻塞渲染），解析完毕浏览器开始渲染。</p></li><li><p>利用js插入<code>link</code>标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadCSS</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">  link.<span class="property">rel</span> = <span class="string">&quot;stylesheet&quot;</span>;</span><br><span class="line">  link.<span class="property">href</span> = url;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(link);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等待dom树构建完毕再加载非关键css代码</span></span><br><span class="line"><span class="comment">//因为是在dom树构建完毕后再添加的link标签，能再一定程度上延迟css文件的加载和解析</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">loadCSS</span>(<span class="string">&quot;styles.css&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用预加载<code>preload</code></p><p>预加载最适合通常由浏览器<strong>较晚发现</strong>的资源，通过预加载某个资源，是在告知浏览器希望在浏览器<code>发现该资源之前</code>提前提取该资源，因为确定该资源对当前网页<strong>很重要</strong>。</p><p>现代浏览器在<code>确定资源优先级</code>方面已经非常出色，因此请务必谨慎使用 <code>preload</code>，并仅预加载最重要的资源。</p><p>可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Attributes/rel/preload"><code>rel=&quot;preload&quot;</code></a> 将<code>link</code>元素转换为预加载器，用于关键资源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>用 <code>preload</code>，浏览器<strong>会尽快获取引用的资源</strong>，并将其存储在浏览器缓存中（它不会执行脚本或应用样式表，单纯只是下载），以便在后续代码中引用时可以更快地使用它们。为了让用户体验尽可能流畅，我们应提前加载页面加载初期用户会遇到的高优先级资源。</p></li></ul><p><strong>资源压缩</strong></p><p>利用<code>webpack</code>、<code>gulp/grunt</code>、<code>rollup</code>等模块化工具，将<code>css</code>代码进行压缩，使文件变小，<strong>大大降低了浏览器的加载时间</strong></p><p><strong>合理使用css选择器</strong></p><p><code>css</code>匹配的规则是<code>从右往左</code>开始匹配，例如<code>#markdown .content h3</code>匹配规则如下：</p><ul><li>先找到h3标签元素</li><li>然后去除祖先不是.content的元素</li><li>最后去除祖先不是#markdown的元素</li></ul><p>如果嵌套的层级更多，页面中的元素更多，那么<code>匹配</code>所要花费的时间代价自然更高。</p><p>所以最好不要嵌套使用过多复杂选择器。</p><p><strong>不使用@import</strong></p><p>css样式文件有两种引入方式，一种是<code>link</code>元素，另一种是<code>@import</code></p><p>使用 <code>@import</code> 规则引入的 CSS 文件是<code>串行</code>加载的，打开<code>开发者工具-&gt;网络</code>，即可观察到这一现象。</p><img src="..\images\前端面试-css\import.png" style="zoom:80%;" /><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* styles.css */</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">&#x27;reset.css&#x27;</span>);</span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">&#x27;layout.css&#x27;</span>);</span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">&#x27;theme.css&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>reset.css</code>、<code>layout.css</code> 和 <code>theme.css</code> 是按顺序加载的，只有当前一个文件加载完成后才会开始加载下一个。如果这些文件都是<code>渲染首屏</code>需要的，那么这样导入css文件将会减缓首屏渲染速度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;reset.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;layout.css&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;theme.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>尽管 <code>&lt;link&gt;</code> 标签默认会<code>阻塞页面渲染</code>，但它允许浏览器<code>并行加载</code>多个 CSS 文件。这意味着虽然整个页面的渲染仍然会被延迟，但单个文件的加载不会影响其他文件的下载<strong>直到所有这些文件都解析完毕</strong>。</p><h2 id="import和link标签引入css文件的区别"><a href="#import和link标签引入css文件的区别" class="headerlink" title="@import和link标签引入css文件的区别"></a><strong>@import和link标签引入css文件的区别</strong></h2><ul><li><p><strong>范畴不同</strong></p><p><code>link</code>是一个html标签，除了css文件<code>（rel=&quot;stylesheet&quot;）</code>还能引入其他类型的文件。而<code>@import</code>属于css语法范畴，只能引入css文件</p></li><li><p><strong>加载方式不同</strong></p><p><code>link</code>标签引入的css文件是<code>并行加载</code>的，而使用 <code>@import</code> 规则引入的 CSS 文件是<code>串行</code>加载的</p></li><li><p><strong>是否支持动态插入</strong></p><p>正因为<code>link</code>是html标签，所以支持js控制<code>link</code>标签动态插入css样式表，而<code>@import</code>无法做到动态插入css文件。</p></li><li><p><strong>兼容性</strong></p><p><code>link</code>标签是html标签，没有兼容性问题，而<code>@import</code>是css2.1之后推出的，所以对于部分浏览器不支持，兼容性较差。</p></li></ul><h2 id="说说css的层叠顺序"><a href="#说说css的层叠顺序" class="headerlink" title="说说css的层叠顺序"></a>说说css的层叠顺序</h2><h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a><strong>层叠上下文</strong></h3><p>有层叠上下文的元素一般比<code>普通元素(未开启定位的元素)</code>层级高</p><p><strong>如何产生层叠上下文</strong></p><ul><li>html元素默认有层叠上下文，称为“根层叠上下文”</li><li>普通元素设置<code>position</code>属性为<code>非static</code>值，并设置<code>z-index</code>属性为<code>具体数值不为auto</code>，产生层叠上下文。</li></ul><p><strong>如何查找</strong></p><p>从父元素开始向上查找，直至查找到一个<code>有层叠上下文</code>的元素。</p><h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a><strong>z-index</strong></h3><p>静态布局元素（postion:static）的z-index属性不会生效，只对定位元素有效。</p><p>默认值为<code>auto</code>，不会产生层叠上下文。</p><p>父元素的<code>z-index</code>权重可以理解为比子元素高（老爸比不过对面的，自己也就比不过），我们一般只在<code>同一个层叠上下文中</code>比较层叠优先级。</p><h3 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h3><p>层叠上下文 &lt; 开启了层叠上下文，但是指定<code>z-index:-1</code> &lt;<code> 未开启定位元素</code>（块级水平盒子 &lt; 浮动盒子 &lt; 行内&#x2F;行内块元素 ） &lt;<code> z-index:auto</code>(开启定位，但是未指定<code>z-index</code>的元素，即未开启层叠上下文)  &#x3D; 开启定位并指定<code>z-index=0</code>的定位元素&lt; 开启定位并指定<code>z-index&gt;0</code>的定位元素</p><p>由此可知，<code>浮动盒子</code>的层叠优先级低于<code>行内/行内块元素</code>，但高于<code>块级元素</code>，所以<code>浮动盒子</code>不会压住后面的<code>行内/行内块元素</code>，会压住<code>后面的</code>块级元素。</p><p>开启了定位的元素（相对定位，绝对定位，固定定位）的，即便不指定<code>z-index</code>，层叠优先级也比<code>行内/行内块</code>元素高，当然也就比<code>浮动元素高</code>。如果指定了<code>z-index</code>为负值，优先级反而变的比它们低了。</p><h2 id="怎么理解回流跟重绘？什么场景下会触发？"><a href="#怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="怎么理解回流跟重绘？什么场景下会触发？"></a>怎么理解回流跟重绘？什么场景下会触发？</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>在<code>HTML</code>中，每个元素都会被表示成一个盒子，在浏览器解析过程中，会涉及到<code>回流</code>与<code>重绘</code>：</p><ul><li>回流：布局引擎会根据各种样式计算每个盒子在页面上的<code>大小</code>与<code>位置</code>，<strong>简单的来说，回流的作用就是布局元素，即确定元素的位置和大小</strong></li><li>重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行<code>绘制</code>，<strong>简单的来说，就是更为细致的渲染盒子</strong>。</li></ul><p>具体的浏览器解析渲染机制如下所示：</p><img src="..\images\前端面试-css\回流与重绘.png" style="zoom:85%;" /><ul><li>解析<code>HTML</code>，生成<code>DOM树</code>，解析<code>CSS</code>，生成<code>CSSOM树</code></li><li>将<code>DOM树</code>和<code>CSSOM树</code>结合，生成<code>渲染树</code>(Render Tree)，生成了<code>渲染树</code>才能确定每个元素的大小和布局方式，才能进行布局（layout）</li><li>Layout(回流)：根据生成的<code>渲染树</code>，进行<code>回流(Layout)</code>，得到节点的几何信息（位置，大小）</li><li>Painting(重绘)：根据<code>渲染树</code>以及回流得到的<code>几何信息</code>，得到节点的<code>绝对像素</code></li><li>Display：将像素发送给GPU，展示在页面上</li></ul><p>在页面初始渲染阶段，<code>回流</code>不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使<code>页面布局</code>发生改变</p><p>当我们对 <code>DOM</code> 的修改引发了 <code>DOM几何尺寸</code>的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来</p><p>当我们对 <code>DOM</code>的修改导致了样式的变化（<code>color</code>或<code>background-color</code>），却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘。</p><h3 id="如何触发回流"><a href="#如何触发回流" class="headerlink" title="如何触发回流"></a>如何触发回流</h3><p>那么当<code>页面布局</code>或者<code>几何信息</code>发生变化的时候，就需要<code>回流</code>，如下面情况：</p><ul><li>添加或删除<code>可见的</code>DOM元素</li><li>元素的<code>位置</code>发生变化</li><li>元素的<code>大小</code>发生变化（包括margin、padding、border、width，height等，即<code>盒模型</code>的四部分）</li><li><code>内容</code>发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</li><li>页面一开始渲染的时候（这避免不了）</li><li>浏览器的<code>窗口尺寸</code>变化（因为回流是根据视口的大小来计算元素的位置和大小的，这个依据变了，就难免要重新计算）</li><li>获取元素<code>特定的属性</code>，比如<code>client，scroll，offset</code>开头的<code>布局属性</code>，这些属性有一个共性，就是需要通过<code>即时计算</code>得到。因此浏览器为了获取这些值，也会进行回流。</li></ul><h3 id="如何触发重绘"><a href="#如何触发重绘" class="headerlink" title="如何触发重绘"></a>如何触发重绘</h3><p>触发回流一定会触发重绘</p><p>除此之外还有一些其他引起重绘行为：</p><ul><li>颜色的修改</li><li>文本方向的修改</li><li>阴影的修改</li></ul><h3 id="浏览器的优化机制"><a href="#浏览器的优化机制" class="headerlink" title="浏览器的优化机制"></a><strong>浏览器的优化机制</strong></h3><p>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过<code>队列化</code>修改并<code>批量执行</code>来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列</p><p>当你获取布局信息的操作的时候，会<code>强制队列刷新</code>，包括前面讲到的<code>offsetTop</code>等方法都会返回最新的数据</p><p>因此浏览器不得不立即<code>清空队列，触发回流重绘</code>来返回正确的值。</p><h2 id="css选择器有哪些？优先级？哪些属性可以继承？"><a href="#css选择器有哪些？优先级？哪些属性可以继承？" class="headerlink" title="css选择器有哪些？优先级？哪些属性可以继承？"></a>css选择器有哪些？优先级？哪些属性可以继承？</h2><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>CSS选择器是CSS规则的第一部分。就是选择<code>符合匹配规则的元素</code>，给它们应用相应的样式规则。</p><p>关于<code>css</code>属性选择器常用的有：</p><ul><li><p>id选择器（#box），选择id为box的元素，id选择器选择唯一的元素，每个元素的id应该是唯一的。</p></li><li><p>类选择器（.one），选择类名为one的所有元素</p></li><li><p>标签选择器（div），选择标签为div的所有元素</p></li><li><p>后代选择器（#box div），选择id为box元素内部所有的div元素，只要是box后代div元素就行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.className</span> <span class="selector-tag">a</span> </span><br></pre></td></tr></table></figure><p> 这是一个有效的选择器。它会选择<code>带有类名className的a标签</code>之下的另一个<code>a</code>标签。但是从html角度考虑，<code>a标签</code>不能套接<code>a标签</code>。</p><p>而且它的权重比<code>.className a</code>要高。</p></li><li><p>子选择器（.one&gt;one_1），选择父元素为.one的所有.one_1的元素</p></li><li><p>相邻同胞选择器（.one+.two），选择紧接在.one之后的所有.two元素</p></li><li><p>群组选择器（div,p），选择div、p的所有元素，这两类元素使用相同的css规则。</p></li></ul><p>还有一些使用频率相对没那么多的选择器：</p><ul><li><p>伪类选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:link</span> ：选择未被访问的链接，常见的使用场景是和<span class="selector-tag">a</span>标签绑定的，即<span class="selector-tag">a</span><span class="selector-pseudo">:link</span></span><br><span class="line"><span class="selector-pseudo">:visited</span>：选取已被访问的链接，常见的使用场景是和<span class="selector-tag">a</span>标签绑定的，即<span class="selector-tag">a</span><span class="selector-pseudo">:visited</span></span><br><span class="line"><span class="selector-pseudo">:active</span>：选择活动链接，就是点击<span class="selector-tag">a</span>标签不松手时的样式。常见的使用场景是和<span class="selector-tag">a</span>标签绑定的，即<span class="selector-tag">a</span><span class="selector-pseudo">:active</span></span><br><span class="line"><span class="selector-pseudo">:hover</span> ：鼠标指针浮动在上面的元素</span><br><span class="line"><span class="selector-pseudo">:focus</span> ：选择具有焦点的</span><br><span class="line"><span class="selector-pseudo">:nth-child</span>(n)、<span class="selector-pseudo">:first-child</span>、<span class="selector-pseudo">:last-child</span> 等：基于元素在其父级中的位置选择元素。</span><br></pre></td></tr></table></figure><blockquote><p> 注意：上述与a标签有关的书写顺序应该是，a:link-&gt;a:hover-&gt;a:visited-&gt;a:active，书写顺序越靠后，优先级越高，这样书写才能保证相应的样式会如期生效。</p></blockquote><p><strong>:nth-child(n)和:nth-of-type(n)的区别</strong></p><p><code>:nth-child(n)</code>是先根据顺序查找元素，再匹配类型，<code>:nth-of-type(n)</code>是先根据元素类型<code>筛选元素</code>，再根据顺序查找元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落一。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落二。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>另一个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落三。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;选中的是 &lt;<span class="selector-tag">p</span>&gt;段落二。&lt;/<span class="selector-tag">p</span>&gt;这个元素</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">p</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;选中的是第四个元素，且要求它的类型是<span class="selector-tag">p</span>，但是第四个元素类型是<span class="selector-tag">h2</span>，所以这个css规则不会生效</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">p</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">3</span>) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;//选中的是内部所有的<span class="selector-tag">p</span>元素中的第三个，也就是第五个元素&lt;<span class="selector-tag">p</span>&gt;段落三。&lt;/<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>伪元素选择器</p><p>伪元素通常以双冒号 <code>::</code> 开头，这是为了区分<code>伪类选择器</code>，但在一些较老的浏览器中，单冒号 <code>:</code> 也被支持。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::first-letter</span> ：用于选取指定选择器的首字母</span><br><span class="line"><span class="selector-pseudo">::first-line</span> ：选取指定选择器的首行</span><br><span class="line"><span class="selector-pseudo">::before</span> : 选择器在被选元素的内容前面插入内容</span><br><span class="line">::after : 选择器在被选元素的内容后面插入内容</span><br></pre></td></tr></table></figure><p>伪元素的好处就是可以在不改变<code>页面结构</code>的前提下，往页面中<code>插入内容</code>。</p><p>伪元素选择器还可以用来<code>清除浮动</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;//让伪元素独占一行</span><br><span class="line">  <span class="attribute">clear</span>: both;//确保左右两边没有浮动元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>clear属性的解释</strong></p><p>指明某个元素周围不能出现<code>浮动元素</code>，通常借助<code>伪元素</code>来清除浮动，属性值为<code> none | left | right | both</code>所以说，<code>周围</code>最多是指的左右两边（both）。</p></li><li><p>属性选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute]</span> 选择带有attribute属性的元素</span><br><span class="line"><span class="selector-attr">[attribute=value]</span> 选择所有使用attribute=value的元素</span><br><span class="line"><span class="comment">/*选择attribute属性包含value的元素，匹配的是整个单词，它不能匹配部分字符串，比如不能匹配valueof 但是能匹配value of*/</span></span><br><span class="line"><span class="selector-attr">[attribute~=value]</span> </span><br><span class="line"><span class="selector-attr">[attribute|=value]</span>：选择attribute属性以value开头的元素</span><br></pre></td></tr></table></figure></li></ul><p>在<code>CSS3</code>中新增的选择器有如下：</p><ul><li><p>层次选择器（p~ul），选择前面有p元素的每个ul元素</p></li><li><p>伪类选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:first-of-type</span> 表示一组同级元素中其类型的第一个元素</span><br><span class="line"><span class="selector-pseudo">:last-of-type</span> 表示一组同级元素中其类型的最后一个元素</span><br><span class="line"><span class="selector-pseudo">:only-of-type</span> 表示没有同类型兄弟元素的元素</span><br><span class="line"><span class="selector-pseudo">:only-child</span> 表示没有任何兄弟的元素</span><br><span class="line"><span class="selector-pseudo">:nth-child</span>(n) 根据元素在一组同级中的位置匹配元素</span><br><span class="line"><span class="selector-pseudo">:nth-last-of-type</span>(n) 匹配给定类型的元素，基于它们在一组兄弟元素中的位置，从末尾开始计数</span><br><span class="line"><span class="selector-pseudo">:last-child</span> 表示一组兄弟元素中的最后一个元素</span><br><span class="line"><span class="selector-pseudo">:root</span> 设置<span class="selector-tag">HTML</span>文档</span><br><span class="line"><span class="selector-pseudo">:empty</span> 指定空的元素</span><br><span class="line"><span class="selector-pseudo">:enabled</span> 选择可用元素</span><br><span class="line"><span class="selector-pseudo">:disabled</span> 选择被禁用元素</span><br><span class="line"><span class="selector-pseudo">:checked</span> 选择选中的元素</span><br><span class="line"><span class="selector-pseudo">:not</span>(selector) 选择与 &lt;selector&gt; 不匹配的所有元素</span><br></pre></td></tr></table></figure></li><li><p>属性选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[attribute*=value]</span>：选择attribute属性值包含value的所有元素</span><br><span class="line"><span class="selector-attr">[attribute^=value]</span>：选择attribute属性开头为value的所有元素</span><br><span class="line"><span class="selector-attr">[attribute$=value]</span>：选择attribute属性结尾为value的所有元素</span><br></pre></td></tr></table></figure></li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>相信大家对<code>CSS</code>选择器的优先级都不陌生：</p><blockquote><p>内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</p></blockquote><p>到具体的计算层⾯，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p><ul><li>如果存在内联样式，那么 A &#x3D; 1, 否则 A &#x3D; 0</li><li>B的值等于 ID选择器出现的次数</li><li>C的值等于<code>类选择器</code> 和 <code>属性选择器</code> 和 <code>伪类</code> 出现的总次数，也就是说，<code>属性选择器</code>，<code>类选择器</code>，<code>伪类选择器</code>的优先级是相同的。</li><li>D 的值等于 <code>标签选择器</code> 和 <code>伪元素 </code>出现的总次数，也就是说<code>标签选择器</code>和<code>伪元素选择器</code>的优先级是相同的。</li></ul><p>这里举个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#nav-global</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span> &gt; <span class="selector-tag">a</span><span class="selector-class">.nav-link</span></span><br></pre></td></tr></table></figure><p>套用上面的算法，依次求出 <code>A</code> <code>B</code> <code>C</code> <code>D</code> 的值：</p><ul><li>因为没有内联样式 ，所以 A &#x3D; 0</li><li>ID选择器总共出现了1次， B &#x3D; 1</li><li>类选择器出现了1次， 属性选择器出现了0次，伪类选择器出现0次，所以 C &#x3D; (1 + 0 + 0) &#x3D; 1</li><li>标签选择器出现了3次， 伪元素出现了0次，所以 D &#x3D; (3 + 0) &#x3D; 3</li></ul><p>上面算出的<code>A</code> 、 <code>B</code>、<code>C</code>、<code>D</code> 可以简记作：<code>(0, 1, 1, 3)</code></p><p>知道了优先级是如何计算之后，就来看看<code>比较规则</code>：</p><ul><li>从<code>左往右</code>依次进行比较 ，较大者优先级更高</li><li>如果相等，则继续往右移动一位进行比较</li><li>如果4位全部相等，则后面的会<code>覆盖</code>前面的，也就是说，<code>书写顺序</code>能决定<code>同优先级的选择器</code>的优先级。</li></ul><p>经过上面的优先级计算规则，我们知道<code>内联样式</code>的优先级最高，如果外部样式需要覆盖内联样式，就需要使用<code>!important</code>，示例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">12px</span> <span class="meta">!important</span> <span class="comment">/*这个样式的优先级最高*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p>在<code>css</code>中，继承是指的是给父元素设置一些属性，后代元素会自动拥有这些属性</p><p>关于继承属性，可以分成：</p><ul><li><p><strong>字体系列属性</strong></p><p>简单来说，就是font开头的属性，所有字体属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font</span>:组合字体</span><br><span class="line">font-family:规定元素的字体系列</span><br><span class="line">font-weight:设置字体的粗细</span><br><span class="line">font-size:设置字体的尺寸</span><br><span class="line">font-style:定义字体的风格</span><br><span class="line">font-variant:偏大或偏小的字体</span><br></pre></td></tr></table></figure></li><li><p><strong>文本系列属性</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-indent</span>：文本缩进</span><br><span class="line"><span class="attribute">text-align</span>：文本水平对齐</span><br><span class="line"><span class="attribute">line-height</span>：行高</span><br><span class="line"><span class="attribute">word-spacing</span>：增加或减少单词间的空白</span><br><span class="line"><span class="attribute">letter-spacing</span>：增加或减少字符间的空白</span><br><span class="line"><span class="attribute">text-transform</span>：控制文本大小写</span><br><span class="line"><span class="attribute">direction</span>：规定文本的书写方向</span><br><span class="line"><span class="attribute">color</span>：文本颜色</span><br></pre></td></tr></table></figure></li><li><p><strong>元素可见性visibility</strong></p><p>这就意味着，给一个父元素添加<code>visibility：hidden</code>，他的子元素也都会被隐藏。</p></li><li><p>表格布局属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">caption-side</span>：定位表格标题位置</span><br><span class="line"><span class="attribute">border-collapse</span>：合并表格边框</span><br><span class="line"><span class="attribute">border-spacing</span>：设置相邻单元格的边框间的距离</span><br><span class="line"><span class="attribute">empty-cells</span>：单元格的边框的出现与消失</span><br><span class="line"><span class="attribute">table-layout</span>：表格的宽度由什么决定</span><br></pre></td></tr></table></figure></li><li><p>列表属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">list-style-type</span>：文字前面的小点点样式</span><br><span class="line"><span class="attribute">list-style-position</span>：小点点位置</span><br><span class="line"><span class="attribute">list-style</span>：以上的属性可通过这属性集合</span><br></pre></td></tr></table></figure></li><li><p>引用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">quotes</span>：设置嵌套引用的引号类型</span><br></pre></td></tr></table></figure></li><li><p>光标属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cursor</span>：箭头可以变成需要的形状</span><br><span class="line"><span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&quot;/img/ania_link.cur&quot;</span>),default;<span class="comment">/*如果第一个资源不可用，就使用默认样式*/</span></span><br></pre></td></tr></table></figure></li></ul><p>继承中比较<code>特殊</code>的几点：</p><ul><li><code>a</code> 标签的<code>字体颜色</code>不会继承父元素的字体颜色</li><li><code>h1-h6</code>标签字体的大小也不会继承父元素的字体大小</li></ul><h3 id="无继承的属性"><a href="#无继承的属性" class="headerlink" title="无继承的属性"></a>无继承的属性</h3><ul><li>display</li><li>文本属性：vertical-align、text-decoration</li><li>盒子模型的属性：宽度、高度、内外边距、边框等</li><li>背景属性：背景图片、颜色、位置等</li><li>定位属性：浮动、清除浮动、定位position等</li><li>生成内容属性：content、counter-reset、counter-increment</li><li>轮廓样式属性：outline-style、outline-width、outline-color、outline</li><li>页面样式属性：size、page-break-before、page-break-after</li></ul><h2 id="CSS3新增了那些特性"><a href="#CSS3新增了那些特性" class="headerlink" title="CSS3新增了那些特性"></a>CSS3新增了那些特性</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p><code>css</code>，即层叠样式表（Cascading Style Sheets）的简称，是一种<strong>标记语言</strong>，由浏览器解释执行用来使页面变得<strong>更美观</strong></p><p><code>css3</code>是<code>css</code>这种标记语言的<strong>最新标准</strong>，是向后兼容的，<code>CSS1/2</code>的特性在<code>CSS3</code> 里都是可以使用的</p><p>而<code>CSS3</code> 也增加了很多新特性，为开发带来了更佳的开发体验，让页面变得更为<strong>美观</strong>。</p><h3 id="新增选择器"><a href="#新增选择器" class="headerlink" title="新增选择器"></a>新增选择器</h3><h3 id="新增样式"><a href="#新增样式" class="headerlink" title="新增样式"></a>新增样式</h3><ul><li><p><strong>边框</strong></p><ul><li><p><strong>border-radius</strong>：创建圆角边框</p><p>值可以是绝对单位<code>px</code>也可以是<code>百分比</code>单位。</p><p>如果是绝对单位，比如为<code>10px</code>，则从盒模型每个角的顶点开始，往两条边的方向分别延伸<code>10px</code>，然后在这两个点的位置做一条垂直的边，确定交点，然后再以这个焦点为圆心做一个圆，然后在舍去这个圆截取的部分 ，就得到了圆角模型。</p><p>如果单位是百分比，则先转化为绝对单位，相对的是每个角对应的两条边。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\圆角.png" style="zoom:80%;" /><p>图中圆的半径为<code>10px</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">      <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\圆角2.png" style="zoom:80%;" /><p>图中的红线只是辅助线，可以看到当令 <code>border-radius: 50%</code>时就能得到一个椭圆，如果盒子的宽高相等就是一个圆形。</p><p><code>50%</code>是<code>border-radius</code>能取得的最大值，再增加也不会有效果。</p></li><li><p><strong>box-shadow</strong>：为元素添加<strong>阴影</strong></p><p>设置属性如下：</p><ul><li>水平阴影（x轴）</li><li>垂直阴影（y轴）</li><li>模糊距离（z轴）</li><li>阴影尺寸(影子大小)</li><li>阴影颜色</li><li>内&#x2F;外阴影</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">4px</span>;</span><br></pre></td></tr></table></figure>   <img src="..\images\前端面试-css\box-shadow.png" style="zoom:80%;" /><p>如果第一个属性值（x）为<code>正数</code>，则阴影就会出现在盒模型的<code>右边</code> ,值越大右边阴影越<code>宽</code>，反之则出现在盒模型的<code>左边</code></p><p>如果第二个属性值（y）为<code>正数</code>，则阴影就会出现在盒模型的<code>下边</code> ,值越大下边阴影越<code>宽</code>，反之则出现在盒模型的<code>上边</code></p><p>如果第三个属性值（z）表示盒模型距离视口的距离，一般为正值，这个值增大可以看到盒模型仿佛在贴近屏幕，阴影就变越来越<code>模糊</code>了。</p><p>第四个值为阴影的尺寸，其实修改第一，二个属性的值就能控制阴影的大小了，这个值存在的意义就是在原有的大小上再添加。</p></li><li><p><strong>border-image</strong>：使用图片来绘制边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//添加<span class="attribute">border-image</span>前</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">40px</span> solid black;</span><br><span class="line">      <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\border-image2.png" style="zoom:80%;" /><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//添加<span class="attribute">border-image</span>后</span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">40px</span> solid black;</span><br><span class="line">      <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">&quot;C:/Users/35194/Desktop/hexo/myblog/source/images/cover/江南.png&quot;</span>);</span><br><span class="line">      <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\border-image.png" style="zoom:80%;" /><p>看起来好像很鸡肋啊。</p></li></ul></li><li><p><strong>背景</strong></p></li><li><p><strong>颜色</strong></p></li><li><p><strong>transition过渡</strong></p><p><code>transition</code>属性可以为指定的一个或多个<code>CSS</code>属性添加<code>过渡效果</code>，让样式改变看起来更自然，多个属性之间用逗号进行分隔，必须规定两项内容:<code>css属性</code>和<code>持续时间</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition</span>: CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认<span class="number">0</span>)</span><br><span class="line">transition: all <span class="number">0.4s</span> #给所有样式添加过渡 花费<span class="number">0.4s</span></span><br></pre></td></tr></table></figure><p>详细介绍见下文《css新增动画》</p></li><li><p><strong>transform转换</strong></p><p>transform属性允许你<code>平移</code>，<code>缩放</code>，<code>旋转</code>指定元素</p><p>详细介绍见下文《css新增动画》</p></li><li><p><strong>animation 动画</strong></p><p>详细介绍见下文《css新增动画》</p></li><li><p><strong>渐变</strong></p><ul><li><p><strong>linear-gradient</strong>：线性渐变</p><p>线性渐变创建了一条沿直线前进的颜色带，这条直线的<code>方向</code>，<code>角度</code>是可以自定义的。</p><p><strong>基础线性渐变</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.simple-linear</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(blue, pink);//注意是<span class="attribute">background</span>属性，不能是<span class="attribute">background-color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\渐变色.png" style="zoom:80%;" /><p><strong>改变渐变方向</strong></p><p>默认情况下，线性渐变的方向是从上到下，你可以指定一个值来改变渐变的方向，我们把这个值放到第一个参数的位置，值的类型可以是关键字，也可以是具体的角度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.horizontal-gradient</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, blue, pink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\渐变色2.png" style="zoom:80%;" /><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.diagonal-gradient</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom right, blue, pink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\渐变色3.png" style="zoom:80%;" /><p><strong>设置渐变角度</strong></p><p>在使用角度的时候，<code>0deg</code> 代表渐变方向为从下到上，<code>90deg</code> 代表渐变方向为从左到右，诸如此类正角度都属于顺时针方向。而负角度意味着逆时针方向。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.angled-gradient</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, blue, pink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\渐变色4.png" style="zoom:80%;" /><p><strong>控制渐变的进程</strong></p><p>默认情况下，渐变在两个相邻的色标之间都是均匀推进的，两个色标之间的中点是颜色值的中点，也可以控制在哪个位置才开始均匀推进。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(blue <span class="number">50px</span>, pink);//可以是px，也可以是相对单位。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\渐变色5.png" style="zoom:80%;" /><p>如图所示，前<code>50px</code>的部分的颜色都是<code>blue</code>。</p><p><strong>堆叠渐变</strong></p><p>你可以将渐变与其他的渐变堆叠起来。只要<strong>顶部的渐变</strong>不是完全不透明的，那么下面的渐变就会依然可见。</p><p><strong>顶部的渐变就是最先声明的渐变，就是书写位置最靠前的渐变。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.a</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">      //渐变的声明顺序不能乱。</span><br><span class="line">      <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, transparent <span class="number">10px</span>, <span class="number">#fff</span>), </span><br><span class="line">                  <span class="built_in">linear-gradient</span>(to right, blue, pink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-css\渐变色6.png" style="zoom:80%;" /><p>其实多个背景图片也是按照这种规则来堆叠的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">      <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;../images/w3logo.png&#x27;</span>) center/contain no-repeat, <span class="built_in">url</span>(<span class="string">&#x27;../images/0.png&#x27;</span>) center/contain no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如图：</p><img src="..\images\前端面试-css\bk.png" style="zoom:33%;" /></li><li><p><strong>radial-gradient</strong>：径向渐变</p><p>径向渐变类似于线性渐变，除了是从一个<code>中心点</code>向外辐射的。你可以指定中心点的<code>位置</code>。你还可以使其为<code>圆形</code>或者是<code>椭圆形</code>。</p><p>更多内容参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_images/Using_CSS_gradients">使用 CSS 渐变 - CSS：层叠样式表 | MDN</a></p></li></ul></li><li><p><strong>flex布局与grid布局</strong></p><p>有文章介绍，不赘述。</p></li></ul><h2 id="CSS3新增动画"><a href="#CSS3新增动画" class="headerlink" title="CSS3新增动画"></a>CSS3新增动画</h2><p><code>css</code>实现动画的方式，有如下几种，都是css3新增的</p><ul><li>transition 实现渐变动画</li><li>transform 转变动画</li><li>animation 实现自定义动画</li></ul><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p><code>transition</code>的属性如下：</p><ul><li>property:填写需要变化的css属性</li><li>duration:完成过渡效果需要的时间单位(s或者ms)</li><li>timing-function:完成效果的速度曲线</li><li>delay: 动画效果的延迟触发时间</li></ul><p><code>time-function</code>的所有值如下</p><img src="..\images\前端面试-css\transition.png" style="zoom:90%;" /><p><strong>注意</strong>：并不是所有的属性都能使用过渡的，如<code>display:none&lt;-&gt;display:block</code>，而<code>visibility:hidden&lt;-&gt;visibility:visible</code>却可以，所以不是显示与隐藏的问题，就是<code>display:none&lt;-&gt;display:block</code>不能。</p><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>一般配合<code>transition</code>过渡使用</p><p><strong>不影响其他盒子的位置</strong>。元素会在<code>视觉</code>上发生位置变化，但<code>实际位置</code>没变，这一点和<code>相对定位</code>相同。</p><p>注意的是，<code>transform</code>不支持<code>inline</code>元素（因为无法指定<code>宽高</code>（也无法指定垂直外边距）），使用前把它变成<code>block</code></p><p>包含四个常用的功能：</p><ul><li><p><strong>translate</strong>：位移</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">translate</span>(<span class="number">15px</span>,<span class="number">15px</span>) //向右向下平移<span class="number">15px</span></span><br></pre></td></tr></table></figure><p>传入的单位也可以是<code>百分比</code>，相对的是元素自身的<code>宽/高</code>。</p></li><li><p><strong>rotate</strong>：旋转</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>:rotate（<span class="number">45deg</span>）</span><br></pre></td></tr></table></figure><p>正值表示为<em>顺时针</em>旋转45度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>: x y</span><br></pre></td></tr></table></figure><p>设置平面转换中心点，默认是<strong>元素中心</strong>，x y可以是像素（px），也可以是<code>百分比</code>，相对的也是元素自身的<code>宽高</code>，比如<code>transform-origin: 50% 50%;</code>指定的转换中心点就是盒子中点。也可以是<code>方位名词</code>，所有组合方式只能表示<code>9</code>个点。</p></li><li><p><strong>scale</strong>：缩放</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>:<span class="built_in">scale</span>(x,y) </span><br></pre></td></tr></table></figure><p>里面的数字不跟单位，就是<code>倍数</code>的意思，分别表示<code>宽高</code>缩放为原来的多少倍。</p></li><li><p><strong>skew</strong>：倾斜</p></li></ul><h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a><strong>transform-origin</strong></h3><p><code>transform-origin</code> 是 CSS 中的一个属性，用于定义应用变换（如旋转、缩放、倾斜等）的原点位置。默认情况下，变换的中心点是元素的中心（即 <code>50% 50%</code>）</p><h4 id="值的数量"><a href="#值的数量" class="headerlink" title="值的数量"></a>值的数量</h4><p><code>transform-origin</code> 可以接受一到三个值。</p><p>如果指定一个值，就是在指定x轴的位置，Y 轴默认为 <code>50%</code>。</p><p>如果指定两个值，分别指定 X 轴和 Y 轴的位置。在支持 3D 转换的情况下，可以指定 X 轴、Y 轴和 Z 轴的位置。</p><h4 id="可能的值"><a href="#可能的值" class="headerlink" title="可能的值"></a>可能的值</h4><ul><li><strong>百分比</strong>：例如 <code>0%</code>, <code>50%</code>, <code>100%</code> 等。<code>0% 0%</code> 表示左上角，<code>100% 100%</code> 表示右下角。</li><li>关键字<ul><li>水平方向：<code>left</code>, <code>center</code>, <code>right</code></li><li>垂直方向：<code>top</code>, <code>center</code>, <code>bottom</code></li></ul></li><li><strong>长度单位</strong>：如 <code>px</code>, <code>em</code>, <code>cm</code> 等具体数值。</li></ul><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>先通过<code>@keyframes</code>定义动画，再通过<code>animation</code>属性使用动画</p><h4 id="定义动画"><a href="#定义动画" class="headerlink" title="定义动画"></a>定义动画</h4><p><code>CSS</code> 动画只需要定义一些<code>关键的帧</code>，而其余的帧，浏览器会根据计时函数插值计算出来</p><p>通过 <code>@keyframes</code> 来定义关键帧</p><p>比如，如果我们想要让元素旋转一圈，只需要定义<code>开始</code>和<code>结束</code>两帧即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rotate&#123;</span><br><span class="line">    //开始样式</span><br><span class="line">    <span class="selector-tag">from</span>&#123;</span><br><span class="line">        //在大括号内具体描述每个时刻对应的样式</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    //结束样式</span><br><span class="line">    <span class="selector-tag">to</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>from</code> 表示最开始的那一帧，<code>to</code> 表示结束时的那一帧。<code>rotate</code>表示自定义的动画名。</p><p>也可以使用<code>百分比</code>刻画生命周期:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rotate&#123;</span><br><span class="line">    <span class="number">0%</span>&#123;</span><br><span class="line">        //在大括号内具体描述每个时刻对应的样式</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">50%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">180deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">100%</span>&#123;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h4><p>定义好动画，我们就可以直接使用了，使用动画涉及到了许多属性，记忆起来较为困难。</p><p><code>animation</code>是其他8个属性的简写，当使用 <code>animation</code> 简写属性时，<code>按顺序来书写值</code>是很重要的。如果你省略了某些中间的属性，必须确保后续属性<code>仍然</code>按照正确的顺序给出。参考下面书写的顺序。</p><table><thead><tr><th>属性</th><th>描述</th><th>属性值</th></tr></thead><tbody><tr><td>animation-name</td><td>指定 @keyframes 动画的名称</td><td></td></tr><tr><td>animation-duration</td><td>指定动画完成一个周期所需要时间，单位秒（s）或毫秒（ms），默认是 0</td><td></td></tr><tr><td>animation-timing-function</td><td>指定动画计时函数，即动画的速度曲线，默认是 “ease”</td><td>linear、ease、ease-in、ease-out、ease-in-out</td></tr><tr><td>animation-delay</td><td>指定动画延迟时间，即动画何时开始，默认是 0</td><td></td></tr><tr><td>animation-iteration-count</td><td>指定动画播放的次数，默认是 1</td><td>具体次数，infinite（无限多次）</td></tr><tr><td>animation-direction 指定动画播放的方向</td><td>默认是 normal</td><td>normal、reverse、alternate、alternate-reverse</td></tr><tr><td>animation-fill-mode</td><td>定义动画在播放之前或之后如何影响元素的样式。默认是 none</td><td>forwards、backwards、both</td></tr><tr><td>animation-play-state</td><td>指定动画播放状态，正在运行或暂停。默认是 running</td><td>running、pauser</td></tr></tbody></table><h2 id="什么是响应式设计？响应式设计的基本原理是什么？"><a href="#什么是响应式设计？响应式设计的基本原理是什么？" class="headerlink" title="什么是响应式设计？响应式设计的基本原理是什么？"></a>什么是响应式设计？响应式设计的基本原理是什么？</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>响应式设计的目标是确保一个网站在<code>不同类型的设备</code>上都能<code>良好地工作</code>，能够根据<code>视口尺寸和大小</code>来布局元素</p><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>响应式设计的基本原理是通过<code>媒体查询</code>检测不同的设备<code>屏幕尺寸</code>从而做对应处理，为了处理移动端，页面头部必须有<code>meta</code>声明<code>viewport</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>width&#x3D;device-width: 布局视口的宽度等于设备宽度。</li><li>maximum-scale:是缩放比例的<code>最大值</code></li><li>inital-scale:是缩放的<code>初始化</code></li><li>user-scalable:值为布尔值，决定用户是否可以进行缩放操作。</li></ul><p>实现<code>响应式布局</code>的方式有如下：</p><ul><li><p><strong>像素单位使用相对单位：</strong></p><ul><li><p>百分比</p><p><code>height</code>、<code>width</code>属性的百分比依托于<code>父元素</code>的<code>宽高</code>，但是其他属性则<code>不完全依赖父元素</code></p><p>子元素的<code>top/left</code>和<code>bottom/right</code>如果设置百分比，则相对于<code>最近的定位元素</code>(position非static)的<code>宽高</code></p><p>子元素的<code>内外边距(padding和margin)</code>如果设置百分比，不论是<code>垂直方向</code>或者是<code>水平方向</code>，都相对于直接<code>父元素</code>的<code>width</code>，而与父元素的<code>height</code>无关。</p></li><li><p>vw&#x2F;vh</p><p>有文章介绍，不赘述</p></li><li><p>rem</p><p>有文章介绍，不赘述</p></li></ul></li><li><p><strong>媒体查询</strong></p><p>媒体查询是<code>css3</code>中引入的功能，作用类似<code>js</code>中的<code>if-else语句</code>，通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局。即便我们使用了<code>相对单位</code>，也只能解决<code>同一类型设备</code>的响应式问题，比如在PC端设计的网页，即便使用了<code>相对单位</code>，在移动端展示的效果也是<code>宽大于高的矩形</code>，展示效果不佳，此时就需要借助媒体查询来解决这个问题。</p><p><strong>基本语法</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> [<span class="keyword">not</span>|<span class="keyword">only</span>] media-type <span class="keyword">and</span> (media-feature) &#123;</span><br><span class="line">  <span class="comment">/* CSS样式规则 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@media</code>：用于定义一个媒体查询。</li><li><code>[not|only]</code>：可选关键字，<code>not</code>排除特定条件，<code>only</code>用来指定仅在满足条件时应用样式（主要用于避免旧浏览器解析媒体查询）。</li><li><code>media-type</code>：指定媒体类型，例如<code>screen</code>（屏幕）、<code>print</code>（打印机）等。如果省略，则默认为<code>all</code>，即适用于所有类型的媒体。</li><li><code>and</code>：逻辑运算符，用来连接多个媒体特性条件。</li><li><code>(media-feature)</code>：媒体特性条件表达式，例如<code>(max-width: 600px)</code>。</li></ul><p><strong>示例</strong></p><p>根据<code>屏幕大小</code>确定<code>字体大小</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当屏幕宽度小于等于600px时 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  //后续还可以写更多选择器</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 当屏幕宽度大于等于768px且小于1200px时 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1199px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 当屏幕宽度大于等于1200px时 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>屏幕方向</code>调整<code>布局</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 适用于竖屏设备 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: portrait) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 适用于横屏设备 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试---js部分</title>
      <link href="/posts/aef189c3.html"/>
      <url>/posts/aef189c3.html</url>
      
        <content type="html"><![CDATA[<h2 id="说说js的数据类型"><a href="#说说js的数据类型" class="headerlink" title="说说js的数据类型"></a>说说js的数据类型</h2><p>js的数据类型可以分为两类，<strong>基本数据类型</strong>和<strong>引用数据类型</strong></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>基本数据类型主要有6种：<code>Number,String,Boolean,Symbol,Null,Undefined</code>，后来又添加了一种叫做<code>BigInt</code></p><ul><li><p>number</p><p>最常见的<code>整数</code>类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intNum = <span class="number">55</span> <span class="comment">// 10进制的55</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">070</span> <span class="comment">// 8进制的56</span></span><br><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span> <span class="comment">//16进制的10</span></span><br></pre></td></tr></table></figure><p><code>浮点类型</code>则在数值中必须包含<code>小数点</code>，还可通过<strong>科学计数法</strong>表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum3 = <span class="number">.1</span>; <span class="comment">// 有效，但不推荐</span></span><br><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 等于 31250000</span></span><br></pre></td></tr></table></figure><p>在数值类型中，存在一个特殊数值<code>NaN</code>，意为“不是数值”，用于表示数值运算操作失败了（<strong>而不是抛出错误</strong>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>/<span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span>/+<span class="number">0</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li><li><p>string</p><p>字符串使用双引号（”）、单引号（’）或反引号（&#96;）表示都可以。</p><p>在js中，字符串是<code>不可变</code>的，意思是一旦创建，它们的值就<strong>不能变了</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>;<span class="comment">//这行代码会在内存中创建一个包含 &quot;Java&quot; 的字符串对象，并将引用赋值给变量 lang。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从内存中读取 lang 当前所指向的字符串 &quot;Java&quot;。</span></span><br><span class="line"><span class="comment">//将 &quot;Java&quot; 和 &quot;Script&quot; 拼接成新的字符串 &quot;JavaScript&quot;，并在内存中创建一个新的字符串对象。</span></span><br><span class="line"><span class="comment">//将 lang 变量存储的引用更新为新创建的字符串 &quot;JavaScript&quot;的引用</span></span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lang)</span><br></pre></td></tr></table></figure></li><li><p>Boolean</p><p>Boolean（布尔值）类型有两个字面值： <code>true</code>和<code>false</code></p><p>通过<code>Boolean</code>可以将其他类型的数据转化成布尔值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型                    转换为 <span class="literal">true</span> 的值                    转换为 <span class="literal">false</span> 的值</span><br><span class="line"> <span class="title class_">String</span>                      非空字符串                              <span class="string">&quot;&quot;</span> </span><br><span class="line"> <span class="title class_">Number</span>                   非零数值（包括无穷值）                     <span class="number">0</span> 、 <span class="title class_">NaN</span> </span><br><span class="line"> <span class="title class_">Object</span>                      任意对象                               <span class="literal">null</span></span><br><span class="line"><span class="title class_">Undefined</span>                   N/A （不存在）                         <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>注意：在js中<code>负数</code>转化成布尔值也是<code>true</code></p></li><li><p>Symbol</p><p><code>Symbol</code>关键字的主要用途是用来创造一个<code>唯一</code>的标识符，用作对象属性，确保不会产生<code>属性冲突</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> otherGenericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(genericSymbol == otherGenericSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>传入符号主要为了标识，符号相同并不代表值也相同 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooSymbol == otherFooSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Symbol 类型的键，并且不会出现在<code>for...in</code> 循环中，也不会被<code>Object.keys()</code>方法返回，因为这种类型的键是<strong>不可枚举</strong>的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Symbol</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 Symbol 作为对象的键</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">normalKey</span>: <span class="string">&#x27;value for normal key&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[sym] = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="comment">// 遍历对象属性，Symbol 键不会出现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// 输出: normalKey</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj));<span class="comment">//输出[&#x27;normalKey&#x27;]</span></span><br></pre></td></tr></table></figure><p><code>Object.assign</code>会把Symbol 类型的键也拷贝进去：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Symbol</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 Symbol 作为对象的键</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">normalKey</span>: <span class="string">&#x27;value for normal key&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[sym] = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj2, obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2)<span class="comment">//&#123;normalKey: &#x27;value for normal key&#x27;, Symbol(description): &#x27;123&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>Symbol 类型的<strong>键和值</strong>，都不会包含在<code>序列化</code>的结果中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Symbol</span></span><br><span class="line"><span class="keyword">const</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 Symbol 作为对象的键</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">normalKey</span>: sym</span><br><span class="line">&#125;;</span><br><span class="line">obj[sym] = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))<span class="comment">//&#123;&quot;name&quot;:&quot;tom&quot;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Null</p><p>Null类型同样只有一个值，即特殊值 <code>null</code></p><p>逻辑上讲， null 值表示一个空对象，这也是给<code>typeof</code>传一个 <code>null</code> 会返回 <code>&quot;object&quot;</code> 的原因。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> car); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>Undefined</p><p><code>Undefined</code> 类型只有一个值，就是特殊值 <code>undefined</code>，如果一个变量声明了但是未被赋值，那么这个变量的值就是undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message; <span class="comment">// 这个变量被声明了，只是值为 undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 没有声明过这个变量，报错</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>引用数据类型统称为<code>Object</code></p><p>主要包括以下三种：</p><ul><li><p>Object</p><p>通常使用字面量表示法来创建对象，这样创建的对象是<code>Object</code>构造函数的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Array</p><p>js数组是一组<code>有序</code>的数据，但跟其他语言不同的是，数组中每个槽位可以存储<code>任意类型</code>的数据。并且，数组也是<code>动态大小</code>的，会随着数据添加而自动增长。通常通过<code>字面量表示法</code>创建数组。</p><p>给数组分配一个固定大小，就是分配几个连续的空间，内部元素默认值是<code>undefined</code>；可以调用数组的<code>fill</code>方法修改初始值，比如<code>arr.fill(0)</code>；虽然说数组大小是<code>固定的</code>，但是还是可以往数组中加入元素，改变数组的大小，不过新加入的元素放在<code>已分配空间之后</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="number">2</span>, &#123;<span class="attr">age</span>: <span class="number">20</span> &#125;]</span><br><span class="line">colors.<span class="title function_">push</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>或者通过<code>Array</code>来创建数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>)<span class="comment">//创建一个长度为4的数组，虽然创建的时候指定了长度，但是长度还是可以变化的</span></span><br><span class="line">arr.<span class="title function_">fill</span>(<span class="number">0</span>) <span class="comment">//数组中的每个元素初始值为undefined,我们把它初始化为1</span></span><br><span class="line">arr.<span class="title function_">map</span>(<span class="function"><span class="params">i</span>=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>).<span class="title function_">fill</span>(<span class="number">0</span>))<span class="comment">//把数组中的每个元素替换为数组，实现二维数组的创建。</span></span><br></pre></td></tr></table></figure></li><li><p>Function</p><p>函数实际上是<code>对象</code>，每个函数都是 <code>Function</code>类型的实例，而 <code>Function</code>也有属性和方法，跟其他引用类型一样。</p></li><li><p>其他类型</p><p>除了上述说的三种之外，还包括<code>Date</code>、<code>RegExp</code>、<code>Map</code>、<code>Set</code>等，他们都是<code>Object</code>类型的<code>子类</code>。</p></li></ul><h2 id="typeof和instanceof"><a href="#typeof和instanceof" class="headerlink" title="typeof和instanceof"></a>typeof和instanceof</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 操作符返回一个字符串，表示值的数据类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> operand</span><br><span class="line"><span class="title function_">typeof</span>(operand)</span><br></pre></td></tr></table></figure><p>这两种使用方法都是可以的。下面是一些例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="property">log</span> <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>主要用来判断某个<code>构造函数</code>是否在某个<code>实例对象</code>的原型链上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> constructor</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><p>typeof返回的是<code>字符串</code>，instanceof返回的是<code>布尔值</code></p></li><li><p>typeof只能能准确判断<code>基本数据</code>的类型，不能<code>准确</code>判断<code>引用数据</code>的类型。</p></li><li><p>intanceof只能准确判断<code>引用数据</code>的类型，不能判断<code>基本数据</code>的类型</p></li></ul><p>可以看到，上述两种方法都有弊端，并不能满足所有场景的需求。</p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h3><p>还有一种通用的判断方式<code>Object.prototype.toString()</code>，简单来说就是<code>Object</code>原型对象上挂载的<code>toString</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>(&#123;&#125;)       <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)  <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>)    <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>)  <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)  <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)  <span class="comment">// &quot;[object Function]&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到返回的结果是一个字符串，第一位都是<code>object</code>，这与js中<strong>万物皆对象</strong>的思想符合。所有类型的数据都能调用<code>toString()</code>方法，如果是基本数据类型，会先进行数据<code>装箱</code>，转化成<code>对象</code>，再调用这个方法。Object是所有对象的父类（Object在所有对象的原型链上），所以所有对象都能访问到这个方法，那为什么不直接让数据调用这个方法呢？因为对象的原型链上可能还存在<code>同名方法</code>。使用<code>函数.call(对象)</code>的方式，能确保对象调用的就是指定的函数&#x2F;方法。</p><h2 id="谈谈-JavaScript-中的类型转换机制"><a href="#谈谈-JavaScript-中的类型转换机制" class="headerlink" title="谈谈 JavaScript 中的类型转换机制"></a>谈谈 JavaScript 中的类型转换机制</h2><p>前面我们讲到，<code>JS</code>中有六种简单数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>string</code>、<code>number</code>、<code>symbol</code>，以及引用类型：<code>object</code></p><p>常见的类型转换有：</p><ul><li>强制转换（显示转换）</li><li>自动转换（隐式转换）</li></ul><h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><p>显示转换，即我们很清楚可以看到这里发生了类型的转变，常见的方法有：</p><ul><li>Number()</li><li>parseInt()</li><li>String()</li><li>Boolean()</li></ul><h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><p>将任意类型的值转化为<code>数值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"><span class="comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324&#x27;</span>) <span class="comment">// 324</span></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;324abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 空字符串转为0，空数组也转换成0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">//对象：通常转换成NaN,除了只包含单个数值的数组和空数组</span></span><br><span class="line"><span class="title class_">Number</span>(&#123;&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>([<span class="number">5</span>]) <span class="comment">// 5</span></span><br><span class="line"><span class="title class_">Number</span>([]) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>从上面可以看到，<code>Number</code>转换的时候是很严格的，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code></p><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p><code>parseInt</code>相比<code>Number</code>，就没那么严格了，<code>parseInt</code>函数逐个解析字符，遇到不能转换的字符就停下来。这个方法是可以直接被调用的，不许要显式借助其他对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;32a3&#x27;</span>) <span class="comment">//32</span></span><br></pre></td></tr></table></figure><h4 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h4><p>可以将任意类型的值转化成<code>字符串</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值：转为相应的字符串</span></span><br><span class="line"><span class="title class_">String</span>(<span class="number">1</span>) <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="comment">//字符串：转换后还是原来的值</span></span><br><span class="line"><span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">//布尔值：true转为字符串&quot;true&quot;，false转为字符串&quot;false&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>) <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="comment">//undefined：转为字符串&quot;undefined&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>) <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="comment">//null：转为字符串&quot;null&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>) <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="comment">//对象</span></span><br><span class="line"><span class="title class_">String</span>(&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;) <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">String</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure><p>可以看到，对于<code>基本数据类型</code>，强制转化成字符串，就是加个<code>双引号</code>就好了，而引用数据类型就不一样了，需要调用<code>toString</code>方法</p><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h4><p>可以将任意类型的值转为<code>布尔值</code>，转换规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Boolean</span>(<span class="literal">undefined</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="title class_">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Boolean</span>(&#123;&#125;) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>([]) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>)) <span class="comment">// 因为返回的是一个对象Boolean &#123;false&#125;，所以转化成布尔值是true</span></span><br></pre></td></tr></table></figure><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>在隐式转换中，我们可能最大的疑惑是 ：何时发生<code>隐式转换</code>？</p><p>我们这里可以归纳为两种情况发生隐式转换的场景：</p><ul><li>比较运算（<code>==</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>）</li><li>算术运算（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>）</li><li><code>if</code>、<code>while</code>需要布尔值地方</li></ul><p>除了上面的场景，还要求运算符两边的操作数不是同一类型</p><ul><li><p><strong>自动转化成布尔值</strong></p><p>在需要<code>布尔值</code>的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用<code>Boolean</code>函数</p></li><li><p><strong>自动转换成字符串</strong></p><p>遇到预期为<code>字符串</code>的地方，就会将非字符串的值自动转为字符串</p><p>常发生在<code>+</code>运算中，一旦存在字符串，则会进行字符串拼接操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="number">1</span> <span class="comment">// &#x27;51&#x27;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">true</span> <span class="comment">// &quot;5true&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">false</span> <span class="comment">// &quot;5false&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + &#123;&#125; <span class="comment">// &quot;5[object Object]&quot; </span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + [] <span class="comment">// &quot;5&quot; 因为[]转换成字符串是空串</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="keyword">function</span> (<span class="params"></span>)&#123;&#125; <span class="comment">// &quot;5function ()&#123;&#125;&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">undefined</span> <span class="comment">// &quot;5undefined&quot;</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> + <span class="literal">null</span> <span class="comment">// &quot;5null&quot;</span></span><br></pre></td></tr></table></figure><p>对于基本数据类型和函数，字符串拼接的时候直接参与拼接，对于其他引用数据类型，需要先调用<code>toString</code>方法。</p></li><li><p><strong>自动转换成数值</strong></p><p>除了左右两边包含字符串的<code>+</code>号，<code>其他运算符</code>都会把参与运算的数据自动转成<code>数值</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;2&#x27;</span> <span class="comment">// 3</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * <span class="string">&#x27;2&#x27;</span> <span class="comment">// 10</span></span><br><span class="line"><span class="literal">true</span> - <span class="number">1</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="literal">false</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="string">&#x27;1&#x27;</span> - <span class="number">1</span>   <span class="comment">// 0</span></span><br><span class="line"><span class="string">&#x27;5&#x27;</span> * []    <span class="comment">// 等价于5*0</span></span><br><span class="line"><span class="literal">false</span> / <span class="string">&#x27;5&#x27;</span> <span class="comment">// 等价于0/5</span></span><br><span class="line"><span class="string">&#x27;abc&#x27;</span> - <span class="number">1</span>   <span class="comment">// 等价于NaN-1</span></span><br><span class="line"><span class="literal">null</span> + <span class="number">1</span> <span class="comment">// 等价于0+1</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="number">1</span> <span class="comment">// 等价于NaN+1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别"></a><strong>&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</strong></h2><p>一个是<code>宽松比较</code>，一个是<code>严格比较</code>；<code>==</code>比较<code>值</code>是否相等，不比较<code>类型</code>是否相同，允许隐式转换。<code>===</code>比较的是<code>值</code>和<code>类型</code>是否相同，都相同才会返回true。</p><p>难点在于<code>==</code>非严格比较，比较规则如下</p><ul><li><p>undefined &#x3D;&#x3D; null 返回true</p><p>在非严格比较中，<code>undefined</code>和<code>null</code>，只与<code>undefined</code>或者<code>null</code>相等。</p></li><li><p>NaN &#x3D;&#x3D; NaN 返回false</p><p><code>NaN</code>和任何数比较，包括本身，都返回false。</p></li><li><p>两个都为<code>简单类型</code>，<strong>字符串</strong>和<strong>布尔值</strong>都会转换成<strong>数值</strong>，再比较。</p></li><li><p>如果一个操作数是<code>对象</code>，另一个操作数不是，则调用对象的 <code>valueOf()</code>方法取得其<strong>原始值</strong>，再根据前面的规则进行比较。</p></li><li><p>两个都为引用类型，则比较它们是否指向同一个对象，也就是比较<strong>地址</strong>是否相同。</p></li></ul><h2 id="Javascript-数字精度丢失的问题"><a href="#Javascript-数字精度丢失的问题" class="headerlink" title="Javascript 数字精度丢失的问题"></a>Javascript 数字精度丢失的问题</h2><h3 id="为什么会出现精度丢失"><a href="#为什么会出现精度丢失" class="headerlink" title="为什么会出现精度丢失"></a>为什么会出现精度丢失</h3><p>对于某些小数，计算机无法用<strong>有限的二进制位精确的表示</strong>，比如0.1用二进制表示思路如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span>*<span class="number">2</span>=<span class="number">0.2</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.2</span>*<span class="number">2</span>=<span class="number">0</span>*<span class="number">4</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.4</span>*<span class="number">2</span>=<span class="number">0.8</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.8</span>*<span class="number">2</span>=<span class="number">1.6</span>&gt;<span class="number">1</span>  --<span class="number">1</span></span><br></pre></td></tr></table></figure><p>假设<code>0.1</code>的二进制表示是<code>0.xxxx</code>，每次对<code>0.1×2</code>，都会让二进制表示中的小数点<code>右移</code>一位(就像我们给十进制小数<code>×10</code>会让小数点右移一样，每个数的权值都变大了)，即<code>x.xxxx</code>，如果<code>0.1×2&lt;1</code>，说明<strong>第一个x为0</strong>，依此类推，<code>0.1</code>的二进制表示为<code>0.0001xxxx</code>，然后我们继续计算后续的x的值。<code>0.1×16 = 1.6</code>,对应的二进制表示为<code>1.xxxx</code>，显然<code>0.xxxx</code>应该表示的是<code>0.6</code>，所以我们就把问题转化为求<code>0.6</code>的二进制表示了。简单的来说，我们只需要对小数不断的<code>×2</code>，如果结果<code>小于1</code>，填入<code>0</code>，反之填入<code>1</code>，然后对乘法的结果<code>-1</code>，然后继续计算，填入的位置是从小数点的高位到地位。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.6</span>*<span class="number">2</span>=<span class="number">1.2</span>&gt;<span class="number">1</span>  --<span class="number">1</span></span><br><span class="line"><span class="number">0.2</span>*<span class="number">2</span>=<span class="number">0.4</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.4</span>*<span class="number">2</span>=<span class="number">0.8</span>&lt;<span class="number">1</span>  --<span class="number">0</span></span><br><span class="line"><span class="number">0.8</span>*<span class="number">2</span>=<span class="number">1.6</span>&gt;<span class="number">1</span>  --<span class="number">1</span></span><br><span class="line"><span class="number">0.6</span>*<span class="number">2</span>=<span class="number">1.2</span>&gt;<span class="number">1</span>  --<span class="number">1</span></span><br></pre></td></tr></table></figure><p>因此我们可以得出<code>0.1</code>的二进制表示是<code>0.000110011....</code>很明显这是一个<code>无限循环小数</code>，我们<strong>无法用有限的二进制位来精确的存储</strong>这个小数，因为存储的时候，数据就没有被准确的存储，所以下次再取出使用的时候就会有<strong>精度损失</strong>。</p><p>在<code>JavaScript</code>中，现在主流的数值类型是<code>Number</code>，而<code>Number</code>采用的是<code>IEEE754</code>规范中<strong>64位双精度浮点数编码</strong>。</p><p>如何理解这个<code>双</code>字呢，这个<code>双</code>表示使用2个<code>机器字</code>（word）来表示浮点数，通常现代计算机的一个<code>机器字</code>是 32 位，双精度意思就是用<code>64位</code>来表示浮点数。这样的存储结构优点是可以<strong>统一处理整数和小数</strong>，节省存储空间。</p><p>我们先来看看如何将一个浮点数用<code>IEEE754单精度浮点数编码</code>表示，单精度浮点数编码用<code>32位</code>来表示浮点数，第一位是符号位，0表示正数，1表示负数；后8位表示指数位，后23位表示尾数。</p><p>拿<code>0.75</code>这个浮点数举例子，将它转换成二进制是<code>0.11</code>，然后将二进制转换成<code>1.xxx*2^n</code>的形式，就是<code>1.1*2^-1</code>，由于这个数是正数，所以第一位是0，<strong>指数位</strong>是<code>-1</code>，我们将它与127（二进制表示是8个1<code>11111111</code>）相加得到126（<code>11111110</code>），我们把这个操作叫做<strong>偏移</strong>，然后尾数是1，这样我们就可以得到<code>单精度浮点数编码</code>表示：0111111101，然后要凑齐32位，后面补零就好。</p><p>对于双精度浮点数编码，道理其实也是一样的，不同的是，使用1位表示<code>符号位</code>，11位表示<code>指数位</code>，52位表示<code>尾数</code>  。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </p><p>具体如何处理可以自行搜索或者参考：<a href="https://vue3js.cn/interview/JavaScript/loss_accuracy.html#%E4%B8%80%E3%80%81%E5%9C%BA%E6%99%AF%E5%A4%8D%E7%8E%B0">面试官：说说 Javascript 数字精度丢失的问题，如何解决？ | web前端面试 - 面试官系列</a></p><h3 id="如何解决精度缺失问题"><a href="#如何解决精度缺失问题" class="headerlink" title="如何解决精度缺失问题"></a>如何解决精度缺失问题</h3><ul><li><p>先把<code>小数</code>转换成<code>整数</code>再参与运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0.2</span></span><br><span class="line"><span class="keyword">let</span> c = a + b</span><br><span class="line"><span class="keyword">let</span> d = (a * <span class="number">10</span> + b * <span class="number">10</span>) / <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c == <span class="number">0.3</span>, d == <span class="number">0.3</span>)<span class="comment">//输出false true</span></span><br></pre></td></tr></table></figure></li><li><p>借助第三方工具库，比如<code>Math.js</code>、<code>BigDecimal.js</code>，通过<code>调用相关方法</code>来模拟加减乘除运算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;mathjs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> a = math.<span class="title function_">bignumber</span>(<span class="string">&#x27;0.1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b = math.<span class="title function_">bignumber</span>(<span class="string">&#x27;0.2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> result = math.<span class="title function_">add</span>(a, b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">format</span>(result, &#123;<span class="attr">notation</span>: <span class="string">&#x27;fixed&#x27;</span>&#125;)); <span class="comment">// 输出 &quot;0.3&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/bigdecimal.js/0.6.2/bigdecimal.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">bigDecimal</span>(<span class="string">&#x27;0.1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title function_">bigDecimal</span>(<span class="string">&#x27;0.2&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> result = a.<span class="title function_">add</span>(b);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="title function_">toString</span>()); <span class="comment">// 输出 &quot;0.3&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="说说-JavaScript-中内存泄漏的几种情况"><a href="#说说-JavaScript-中内存泄漏的几种情况" class="headerlink" title="说说 JavaScript 中内存泄漏的几种情况"></a>说说 JavaScript 中内存泄漏的几种情况</h2><h3 id="内存泄漏是什么"><a href="#内存泄漏是什么" class="headerlink" title="内存泄漏是什么"></a>内存泄漏是什么</h3><p>内存泄漏（Memory leak）指的是在计算机科学中，由于疏忽或错误造成程序<strong>未能释放已经不再使用的内存</strong>。</p><p>对于<code>持续运行的进程</code>，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><p>可以拿电脑游戏来举例，3a大作的体积动辄几十上百GB，但是我们的电脑并没有这么多的内存（外存一般都有几百GB，但是内存一般只有几十GB），我们玩游戏的时候，并不会将游戏的全部资源都放入内存中，而是只将需要用到的资源放入，并释放不再需要的内存。</p><h3 id="垃圾自动回收机制"><a href="#垃圾自动回收机制" class="headerlink" title="垃圾自动回收机制"></a><strong>垃圾自动回收机制</strong></h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>在<code>C</code>语言中，因为是手动管理内存，内存泄露是经常出现的事情。</p><p>这很麻烦，所以大多数语言提供<code>自动内存管理</code>，减轻程序员的负担，这被称为<code>垃圾自动回收机制</code></p><p>js也有垃圾自动回收机制。</p><p><strong>原理</strong>：<code>垃圾收集器</code>会定期（周期性）找出那些不再继续使用的变量，然后释放其内存。</p><h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p>通常情况下有两种实现方式，用来判断哪些变量不再使用：</p><ul><li>标记清除</li><li>引用计数</li></ul><p><strong>标记清除</strong></p><p><code>清除</code>那些被<code>标记</code>的变量，释放它们的内存，是<code>JavaScript</code>最常用的垃圾收回机制，</p><p>当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“</p><p>垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉</p><p>在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了</p><p>随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="number">0</span>,n = <span class="number">19</span> <span class="comment">// 把 m,n,add() 标记为进入环境。</span></span><br><span class="line"><span class="title function_">add</span>(m, n) <span class="comment">// 把 a, b, c标记为进入环境。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n) <span class="comment">// a,b,c标记为离开环境，等待垃圾回收。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  a++</span><br><span class="line">  <span class="keyword">var</span> c = a + b</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用计数</strong></p><p>语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是<code>0</code>，就表示这个值不再用到了，因此可以将这块内存释放。</p><p>如果一个值不再需要了，引用数却不为<code>0</code>，垃圾回收机制无法释放这块内存，从而导致内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，数组<code>[1, 2, 3, 4]</code>是一个值，会占用内存。变量<code>arr</code>是仅有的对这个值的引用，因此引用次数为<code>1</code>。尽管后面的代码没有用到<code>arr</code>，它还是会持续占用内存</p><p>如果需要这块内存被垃圾回收机制释放，只需要设置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>通过设置<code>arr</code>为<code>null</code>，就解除了对数组<code>[1,2,3,4]</code>的引用，引用次数变为 0，就被垃圾回收了。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>有了垃圾自动回收机制，并不代表不用担心内存泄漏问题，对于那些占用内存很大的变量，确保它们不再被使用的时候，不存在对它们的引用。</p><h3 id="常见内存泄漏情况"><a href="#常见内存泄漏情况" class="headerlink" title="常见内存泄漏情况"></a>常见内存泄漏情况</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a><strong>意外的全局变量</strong></h4><ul><li><p><strong>给一个未声明的标识符赋值</strong>，javaScript 引擎会认为你在引用一个已经存在的全局变量；如果找不到这个变量，则会自动在全局对象（浏览器环境中为 <code>window</code>，Node.js 环境中为 <code>global</code>）上创建它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>直接调用构造函数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">variable</span> = <span class="string">&quot;potential accidental global&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 调用自己，this 指向了全局对象（window）</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>使用严格模式，可以避免意外的全局变量。</p></li></ul><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a><strong>定时器</strong></h4><p>定时器开启后，除非显式的清除，否则将一直存在，如果定时器中引用了不再使用的变量，又未及时清除定时器，就会造成内存泄漏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = <span class="title function_">getData</span>();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;Node&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">        node.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>如果<code>id</code>为Node的元素从<code>DOM</code>中移除，该定时器仍会存在，同时，因为回调函数中包含对<code>someResource</code>的引用，定时器外面的<code>someResource</code>也不会被释放。</p><p>除了定时器之外，延时器(setTimeout)和事件监听器(addEventListener)如果不使用，都要记得清除或者解绑，否则会持续引用不再需要的回调函数，从而造成内存泄漏，因为函数也是一种类型的数据，也会占用内存。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;XXX&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj, <span class="string">&#x27;闭包内引用obj obj不会被释放&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> unused</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> func = <span class="title function_">bindEvent</span>()</span><br><span class="line"><span class="comment">//解决方法，清除引用</span></span><br><span class="line">func = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>即便函数调用结束了，由于func持续引用unused函数，这个函数的空间不会被释放，又因为unused函数引用obj，obj这个变量的空间也不会被释放。</p><h2 id="说说你对闭包的理解？闭包使用场景"><a href="#说说你对闭包的理解？闭包使用场景" class="headerlink" title="说说你对闭包的理解？闭包使用场景"></a>说说你对闭包的理解？闭包使用场景</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>闭包由一个<code>内部函数</code>和它引用的<code>外部函数</code>的作用域组成。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>创建私有变量</li><li>延长变量的生命周期</li></ul><p><strong>示例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//立即执行函数，充当外部函数</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let a = 1;</span><br><span class="line">  function b()&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">  &#125;//因为没有外部函数，所以没有构成闭包</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="说说你对防抖和节流的理解"><a href="#说说你对防抖和节流的理解" class="headerlink" title="说说你对防抖和节流的理解"></a>说说你对防抖和节流的理解</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>本质上是<code>优化高频率执行代码造成的性能损耗</code>的一种手段。</p><p>如：浏览器的 <code>resize</code>、<code>scroll</code>、<code>keypress</code>、<code>mousemove</code> 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。</p><p>为了优化体验，我们需要限制这类事件的调用次数，对此我们就可以采用 <strong>防抖（debounce）</strong> 和 <strong>节流（throttle）</strong> 的方式来减少调用频率</p><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p><strong>定义</strong></p><p>事件被触发后，且在n秒内不再触发该事件，则执行对应的回调函数，如果在n秒内再次触发该事件，则重新开始计时；可以用操作系统中的资源被剥夺来理解，这里的资源就是<code>延时器</code>。</p><p>简单的来说，就是对于频繁触发的事件，只执行最后一次触发对应的事件回调。</p><p><strong>手写防抖函数</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个函数，返回一个实现了防抖的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myDebounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//形成了一个闭包，内部函数引用了外部函数的变量timer,func,wait</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">         <span class="comment">//抢夺资源,清除定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//开启新的定时器</span></span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//修改this指向，传入e</span></span><br><span class="line">        func.<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">        timer = <span class="literal">null</span><span class="comment">//运行完后释放资源</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[type=text]&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, <span class="title function_">myDebounce</span>(func, <span class="number">500</span>))</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p><strong>定义</strong></p><p>在n秒内无论触发多少次事件，只执行<code>第一次触</code>发对应的<code>回调函数</code></p><p>可以用操作系统中的<code>资源不可被剥夺来理解</code>，这里的资源就是<code>延时器</code>。</p><p>简单的来说就是，对于频繁触发的事件，每间隔一定时间才执行一次事件回调。</p><p><strong>手写节流</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="title function_">myThrottle</span>(func, <span class="number">1000</span>))</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入一个函数，返回一个实现了节流的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myThrottle</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">    <span class="comment">//声明一个定时器</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">//返回一个新的函数,这个函数引用了func,wait和timer，构成闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="comment">//如果定时器已经开启直接返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//虽然实际调用的是返回的新函数，但是在函数内部还是调用了传入的func函数，而且我们使用apply模拟了直接调用</span></span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        timer = <span class="literal">null</span><span class="comment">//释放资源</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><p>相同点：</p><ul><li>都可以通过使用 <code>setTimeout</code> 实现</li><li>目的都是，降低回调执行频率。节省计算资源</li></ul><p>不同点：</p><ul><li>函数防抖，在一段连续操作结束后，只执行最后一次触发对应的回调。函数节流，在一段连续操作中，每一段时间只执行一次，在频率较高的事件中被使用来提高性能。</li><li>函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>防抖在连续的事件，只需触发一次回调的场景有：</p><ul><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li><li>手机号、邮箱验证输入检测</li><li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li></ul><p>节流在间隔一段时间执行一次回调的场景有：</p><ul><li>滚动加载，加载更多或滚到底部监听</li><li>搜索框，搜索联想功能</li></ul><h2 id="数组的常用方法"><a href="#数组的常用方法" class="headerlink" title="数组的常用方法"></a>数组的常用方法</h2><p>我们可以从<strong>增删查改</strong>，是否会修改原数组这几个角度来给数组的常用方法归类</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a><strong>增</strong></h3><ul><li><p>push()：可以传入任意个数的元素，这些元素会被添加到数组的末尾，返回<code>新数组的长度</code>,会修改原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = []; <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 推入两项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>unshift():也是可以传入任意个数的元素，这些元素会被添加到数组的首部，返回<code>新数组的长度</code>,会修改原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>); <span class="comment">// 从数组开头推入两项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>splice():第一个参数传入开始位置，第二个参数传入0，表示不删除元素，后续参数传入插入的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors) <span class="comment">// red,yellow,orange,green,blue(插入的元素从开始下标开始排序)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed) <span class="comment">// []，返回包含被删除元素的数组，因为没有元素被删除所以是空数组</span></span><br></pre></td></tr></table></figure></li><li><p>concat():首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="删"><a href="#删" class="headerlink" title="删"></a><strong>删</strong></h3><ul><li><p>pop()：方法用于删除数组的最后一项，同时减少数组的<code>length</code> 值，返回<code>被删除的项</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>(); <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// green</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>shift()：法用于删除数组的第一项，同时减少数组的<code>length</code> 值，返回<code>被删除的项</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>]</span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">shift</span>(); <span class="comment">// 取得第一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(item) <span class="comment">// red</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="property">length</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>splice()：第一个参数传入开始位置，第二个参数传入要删除元素的个数，返回包含被删除元素的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// green,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed); <span class="comment">// [&quot;red&quot;]，只有一个元素的数组</span></span><br></pre></td></tr></table></figure></li><li><p>slice()：本质是返回一个数组切片，并不会修改原数组，截取区间遵循<code>左闭右开</code>原则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors)   <span class="comment">// red,green,blue,yellow,purple</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2); <span class="comment">// green,blue,yellow,purple</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors3); <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>一般通过下标修改数组元素的值，也可以使用splice先删除元素再添加元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;purple&quot;</span>); <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// red,red,purple,blue</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed); <span class="comment">// green，只有一个元素的数组</span></span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>一般也是通过下标来查找数组元素。</p><ul><li><p>indexOf()：传入一个元素，返回数组中<code>第一个</code>与该元素相等的元素的<code>下标</code>，使用的是<code>严格比较</code>，如果数组中没有该元素，则返回<code>-1</code>，因为<code>NaN</code>不与任何数相等，所以indexOf(NaN)返回值必定为<code>-1</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>,<span class="title class_">NaN</span>];</span><br><span class="line">numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>)) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></li><li><p>includes()：判断某个元素是否在数组中存在，也是严格比较，存在返回<code>true</code>，否则返回<code>false</code>。对<code>NaN</code>做了特殊处理，能判断是它否存在于数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>,<span class="title class_">NaN</span>];</span><br><span class="line">numbers.<span class="title function_">includes</span>(<span class="number">4</span>) <span class="comment">//true</span></span><br><span class="line">numbers.<span class="title function_">includes</span>(<span class="title class_">NaN</span>) <span class="comment">//返回true</span></span><br></pre></td></tr></table></figure></li><li><p>find()：传入一个返回值是 <code>布尔类型</code>的回调函数，用于判断满足某个条件的元素是否存在，存在则返回第一个符合条件的元素，不存在则返回<code>undefined</code>，通常用于判断<code>对象数组</code>中是否存在某个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">27</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>)<span class="comment">// &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>findIndex()：语法和用途和find相同，不过返回的是元素的<code>下标</code>，未找到返回<code>-1</code>。</li></ul><h3 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h3><ul><li><p>reverse()：反转数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="title function_">alert</span>(values); <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure></li><li><p>sort()：给数组排序，sort()方法接受一个比较函数，用于判断哪个值应该排在前面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line">    <span class="comment">//return value1-value2 升序排序</span></span><br><span class="line">    <span class="comment">//return value2-value1 降序排序</span></span><br><span class="line">    <span class="comment">//value1[key]-value2[key] 根据某个属性升序排序，反之降序排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>(compare);</span><br><span class="line"><span class="title function_">alert</span>(values); </span><br></pre></td></tr></table></figure></li></ul><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>join()：把数组中的元素拼<code>接成</code>一个字符串，用传入的符号连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>)); <span class="comment">// red,green,blue</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;||&quot;</span>)); <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><ul><li><p>some()：传入一个返回值为布尔值的回调函数，如果数组中<code>存在</code>满足条件的元素，则该方法返回true，否则返回false。</p></li><li><p>every()：传入一个返回值为布尔值的回调函数，如果数组中<code>每个</code>元素都满足条件，则该方法返回true，否则返回false。</p></li><li><p>forEach()：遍历数组中的每个元素，并执行一定操作，可以<code>修改</code>原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>filter()：传入一个返回值为布尔值的回调函数，返回一个包含所有能让这个回调函数返回值为true的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filterResult); <span class="comment">// 3,4,5,4,3</span></span><br></pre></td></tr></table></figure></li><li><p>map()：根据传入的回调函数和数组中的每一个元素，并返回一个新的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapResult) <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h2><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a><strong>concat</strong></h4><p>用于将一个或多个字符串拼接成一个新字符串，返回一个新的字符串，不会修改原来的字符串，js中的字符串是不可变的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">&quot;world&quot;</span>);<span class="comment">//创建一个新的字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h4 id="slice-substr-substring"><a href="#slice-substr-substring" class="headerlink" title="slice() substr() substring()"></a><strong>slice() substr() substring()</strong></h4><p>作用是返回字符串的切片</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>)); <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// &quot;lo worl&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>数组中也有<code>slice()</code>方法</p></li><li><p>可以看出<code>slice()</code>和<code>substring()</code>的用法是一致的，当传入两个参数的时候，分别表示的是截取的左右区间（左闭右开）</p></li><li><p>而<code>substr()</code>传入两个参数时，第一个表示参数起始位置，第二个参数表示的是要截取的元素的<code>个数</code>。</p></li><li><p>当只传入一个参数，三者的效果是相同的。</p></li></ul><h4 id="indexOf-startWith-includes"><a href="#indexOf-startWith-includes" class="headerlink" title="indexOf() startWith() includes()"></a><strong>indexOf() startWith() includes()</strong></h4><p>indexOf：从字符串<code>开头</code>去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ），数组中也有这个方法，也许因为字符串本来就可以看成字符数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">indexOf</span>(<span class="string">&quot;o&quot;</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>startWith()：判断字符串是否以某个字符串开头，返回值为布尔类型。</p><p>includes()：判断字符串中是否包含某个字符串，返回值是布尔类型，数组中也有这个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;foo&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>由此可见，无论是数组还是字符串中，都有indexOf，includes，slice方法</p></blockquote><h3 id="字符串拆分"><a href="#字符串拆分" class="headerlink" title="字符串拆分"></a>字符串拆分</h3><p>把字符串按照指定的分割符，拆分成数组中的每一项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;12+23+34&quot;</span></span><br><span class="line"><span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&quot;+&quot;</span>) <span class="comment">// [12,23,34]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = str.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>) <span class="comment">//[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;+&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;+&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h3><p>提及字符串，就不得不提到模板匹配，提起模板匹配就不得不提起<code>正则表达式</code>。</p><h4 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h4><p>接收一个参数，可以是一个正则表达式字符串，也可以是一个<code>RegExp</code>对象（正则表达式），如果你传递一个非正则表达式对象，它会被隐式转换为正则表达式；返回值是数组</p><p><strong>非全局匹配</strong>（传入的正则表达未加修饰符<code>g</code>）</p><p>只会匹配第一个符合条件的字符串片段，下面给出一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches); </span><br></pre></td></tr></table></figure><p><strong>匹配成功的返回结果，包含<code>第一个匹配的字符串片段</code>和<code>更多信息</code></strong></p><img src="..\images\前端面试-js\match.png" style="zoom:80%;" /><ul><li><code>index</code> 属性：匹配结果在字符串中的开始位置</li><li><code>input</code> 属性：原始字符串</li></ul><p>如果匹配失败则返回<code>null</code></p><p><strong>全局匹配</strong></p><p>匹配所有符合条件的字符串片段，并以数组的形式给出，例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = text.<span class="title function_">match</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches); </span><br></pre></td></tr></table></figure><p><strong>匹配成功的返回结果，只包含<code>符合条件的字符串片段</code>。</strong></p><img src="..\images\前端面试-js\match2.png" style="zoom:80%;" /><p>如果匹配失败则返回<code>null</code></p><h4 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">search</span>(regexp)</span><br></pre></td></tr></table></figure><ul><li><code>str</code> 是要进行搜索操作的字符串。</li><li><code>regexp</code> 是一个正则表达式对象。如果你传递一个非正则表达式对象（例如，一个字符串），它将被隐式转换为一个正则表达式对象。</li><li><strong>如果找到匹配项，<code>search()</code> 方法返回<code>第一个匹配项</code>的<code>首字符</code>的下标。</strong></li><li>如果没有找到匹配项，<code>search()</code> 方法返回 <code>-1</code>。</li><li>是否给传入的正则表达式添加修饰符<code>g</code>，对结果没有影响。</li></ul><p>下面举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cas, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">let</span> index = text.<span class="title function_">search</span>(pattern);</span><br><span class="line"><span class="keyword">let</span> index2 = text.<span class="title function_">search</span>(pattern);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(index,index2); <span class="comment">//输出5,5</span></span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p><code>replace()</code> 方法用于在字符串中查找匹配的子字符串，并用新的子字符串替换它，这个方法不会改变原始字符串，因为JavaScript中的字符串是不可变的，它会返回一个新的字符串作为结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="title function_">replace</span>(regexp|substr, newSubstr|<span class="keyword">function</span>)</span><br></pre></td></tr></table></figure><ul><li><code>regexp</code> (正则表达式)：一个<code>RegExp</code>对象或者其字面量。标识要查找的子字符串。请注意全局搜索需要使用<code>g</code>标志。</li><li><code>substr</code> (字符串)：将被替换的子字符串。</li><li><code>newSubstr</code> (字符串)：新子字符串，用于替换匹配项的字符串。</li><li><code>function</code> (函数)：用于<code>创建新子字符串的函数</code>，该函数将被每一个匹配项调用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.<span class="title function_">replace</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: &quot;Hello JavaScript!&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello world! Welcome to the world of programming.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.<span class="title function_">replace</span>(<span class="regexp">/world/g</span>, <span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: &quot;Hello JavaScript! Welcome to the JavaScript of programming.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World! Welcome to the world of Programming.&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.<span class="title function_">replace</span>(<span class="regexp">/world/gi</span>, <span class="string">&quot;JavaScript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: &quot;Hello JavaScript! Welcome to the JavaScript of Programming.&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;20 apples, 15 bananas, and 3 cherries&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.<span class="title function_">replace</span>(<span class="regexp">/\d+/g</span>, <span class="keyword">function</span>(<span class="params">number</span>) &#123;<span class="comment">// \d+ 是匹配一个或多个数字的正则表达式</span></span><br><span class="line">    <span class="keyword">return</span> number * <span class="number">2</span>; <span class="comment">// 将每个数字乘以2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newStr); <span class="comment">// 输出: &quot;40 apples, 30 bananas, and 6 cherries&quot;</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝浅拷贝"><a href="#深拷贝浅拷贝" class="headerlink" title="深拷贝浅拷贝"></a>深拷贝浅拷贝</h2><p>当我们拷贝一个基本类型的数据，拷贝的就是它的<code>值</code>，此时没有深浅拷贝一说，只有当我们拷贝一个对象的时候，才有深浅拷贝的说法。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝顾名思义，就是浅层次的拷贝，只拷贝<code>一层</code>。当我们要拷贝一个对象的时候，对于这个对象的所有属性，如果属性的值是<code>基本数据类型</code>，那我们直接拷贝<code>值</code>，如果属性值为<code>引用数据类型</code>，则拷贝<code>地址</code>。示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">//只拷贝obj自身的属性</span></span><br><span class="line">        <span class="keyword">if</span>(obj.<span class="title function_">hasOwnProperty</span>(prop))&#123;</span><br><span class="line">            newObj[prop] = obj[prop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出浅拷贝的手动实现也是非常简单的。</p><p><strong>浅拷贝常见方法</strong></p><ul><li><p><code>Object.assign</code></p><p>只会拷贝对象中<strong>可枚举的自有属性</strong>，不会拷贝其继承自原型链上的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">nature</span>: [<span class="string">&#x27;smart&#x27;</span>, <span class="string">&#x27;good&#x27;</span>],</span><br><span class="line">  <span class="attr">names</span>: &#123;</span><br><span class="line">    <span class="attr">name1</span>: <span class="string">&#x27;fx&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj[f] = <span class="string">&#x27;cindy&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(obj2, obj);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj)<span class="comment">//&#123;age: 18, nature: Array(2), names: &#123;…&#125;, Symbol(): &#x27;cindy&#x27;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2 == newObj) <span class="comment">//返回true，说明返回的就是原对象（传入的第一个对象）</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用<code>扩展运算符</code>实现的拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fxArr = [<span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>]</span><br><span class="line"><span class="keyword">const</span> fxArrs = [...fxArr]</span><br><span class="line">fxArrs[<span class="number">1</span>] = <span class="string">&quot;love&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArr) <span class="comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fxArrs) <span class="comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>对一个对象进行深拷贝，拷贝多层。当我们要深拷贝一个对象的时候，对于这个对象的所有属性，如果属性的值是<code>基本数据类型</code>，那我们直接拷贝<code>值</code>，如果属性值为<code>引用数据类型</code>，则我们递归拷贝这个引用类型。特点是深拷贝得到的对象与原对象没有任何<strong>公共的内存空间</strong>。</p><p><strong>深拷贝常见方法</strong></p><ul><li><p>_.cloneDeep()</p><p>借助第三方库<code>lodash</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    <span class="attr">c</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = _.<span class="title function_">cloneDeep</span>(obj1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">b</span>.<span class="property">f</span> === obj2.<span class="property">b</span>.<span class="property">f</span>);<span class="comment">// false,验证是深度拷贝</span></span><br></pre></td></tr></table></figure></li><li><p>手写简单深拷贝</p><p>核心在于把值为基本类型的属性当作<strong>递归出口</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是null或者不是object类型(基础数据类型)，则直接返回，这是一个递归出口</span></span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理Array</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneArr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; obj.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            cloneArr[i] = <span class="title function_">deepClone</span>(obj[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneArr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理Object</span></span><br><span class="line">    <span class="keyword">let</span> cloneObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            cloneObj[key] = <span class="title function_">deepClone</span>(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>JSON.stringify()</code></p><p>但是这种方式存在<strong>弊端</strong>，会忽略值为<code>undefined</code>，<code>symbol</code>，<code>函数</code>的属性，因为这些值都是<code>不可被序列化</code>的，不会出现在序列化的字符串中。除此之外，使用Symbol作为键的属性也不会包含在序列化的结果中，<strong>因为JSON标准不支持Symbol类型的键</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title class_">Symbol</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name1</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">name3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;,</span><br><span class="line">  <span class="attr">name4</span>: <span class="title class_">Symbol</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">  <span class="attr">name5</span>: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj[name] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// &#123;name5: &quot;b&quot;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>浅拷贝和深拷贝都创建出一个新的对象，这个新的对象与原对象内容完全相同，浅拷贝新旧对象可能存在公共的空间，修改新对象属性可能会影响原对象，而深拷贝新旧对象则不存在公共的空间，修改数据不会相互影响。</p><h2 id="说说js中的事件模型"><a href="#说说js中的事件模型" class="headerlink" title="说说js中的事件模型"></a>说说js中的事件模型</h2><h3 id="事件与事件流"><a href="#事件与事件流" class="headerlink" title="事件与事件流"></a>事件与事件流</h3><p>事件就是用户与页面或者浏览器进行的<strong>交互操作</strong>；</p><p>事件流都会经历三个阶段：</p><ul><li>事件<code>捕获阶段</code>(capture phase)</li><li>处于<code>目标阶段</code>(target phase)</li><li>事件<code>冒泡阶段</code>(bubbling phase)</li></ul><p>当我们在某个元素上触发某个事件的时候（这个与我们直接交互的元素叫做<code>目标元素</code>）,然后事件流就会从顶级元素开始，通常是<code>DOM</code>元素，流向目标元素，这个向下流动的过程叫做<code>事件捕获</code>，再流回顶级元素，这个向上流动的过程叫做<code>事件冒泡</code>。事件监听通常是在冒泡阶段触发的。</p><h3 id="事件模型分类"><a href="#事件模型分类" class="headerlink" title="事件模型分类"></a>事件模型分类</h3><p>有三大类：<code>原始事件模型</code>，<code>标准事件模型</code>，ie事件模型（很少用了）</p><ul><li><p><strong>原始事件模型（DOM0级）</strong></p><p><strong>绑定方式</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> onclick=<span class="string">&quot;fun()&quot;</span>&gt; <span class="comment">//里面的js代码会被执行，所以不要写成函数名，而是可执行的js代码</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[type=button]&#x27;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = fun;<span class="comment">//相当于给dom元素添加属性，传入一个函数，注意不要写成onClick</span></span><br></pre></td></tr></table></figure><p>link标签也可以添加onload属性，link标签加载后再执行相关逻辑，比如修改media类型。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./txt.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;setTimeout(()=&gt;&#123;this.media=&#x27;all&#x27;&#125;,2000)&quot;</span>&gt;</span></span><br><span class="line">//this指向link标签，是linnk标签对应的dom对象</span><br></pre></td></tr></table></figure><p>link标签加载完毕后再参与渲染，这也会存在样式闪烁问题。</p><p><strong>解绑方式：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>绑定速度快</li><li>只支持冒泡触发，不支持捕获触发</li><li><code>同一个类型</code>的事件(比如click事件)只能绑定一次，<strong>后面绑定的会覆盖前面绑定的</strong>。</li></ul></li><li><p><strong>标准事件模型（DOM2级）</strong></p><p><strong>绑定方式：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.addEventListener(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure><p>参数如下：</p><ul><li><code>eventType</code>指定事件类型(不要加on)</li><li><code>handler</code>是事件处理函数</li><li><code>useCapture</code>是一个<code>boolean</code>用于指定是否在<code>捕获阶段</code>进行处理，默认值为<code>false</code>，与IE浏览器保持一致</li></ul><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&#x27;p&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&#x27;span&#x27;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &lt;/p &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onClickFn</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tagName = event.<span class="property">currentTarget</span>.<span class="property">tagName</span>;</span><br><span class="line">    <span class="keyword">var</span> phase = event.<span class="property">eventPhase</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(tagName, phase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">false</span>);</span><br><span class="line">p.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, onClickFn, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击后输出</span></span><br><span class="line">P <span class="number">3</span></span><br><span class="line"><span class="variable constant_">DIV</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>几个常见事件属性</strong></p><ul><li><code>event.currentTarget </code>，当前事件流所在的元素，是一个<code>dom</code>对象。</li><li><code>event.eventPhase</code>，代表当前执行阶段的整数值。1为捕获阶段、2为事件对象触发阶段、3为冒泡阶段。</li><li><code>event.target</code>，代表目标元素，即触发事件的元素。</li><li><code>event.stopPropagation</code>，阻止事件冒泡。 </li><li><code>event.stopImmediatePropagation()</code>，这个方法不仅做了<code>stopPropagation()</code>所做的所有事情——即阻止事件冒泡到父元素，而且还会<strong>完全停止同一个事件的所有后续处理</strong>。这意味着，在当前元素上为该事件类型注册的<strong>所有其它监听器都不会被调用</strong>。</li></ul><p><strong>解绑方式</strong>：</p><p>传入的回调函数必须是<code>具名函数</code>，<strong>内容相同的两个匿名函数不会被认为相等</strong>。</p><p>解绑事件监听器的作用是<strong>释放内存空间</strong>，否则事件监听器将会一直存在，持续引用对应的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.<span class="title function_">removeEventListener</span>(eventType, handler, useCapture)</span><br></pre></td></tr></table></figure><p><strong>特性：</strong></p><ul><li><p>可以在一个<code>DOM</code>元素上绑定多个事件处理器，各自并不会冲突</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage1, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage2, <span class="literal">false</span>);</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(‘click’, showMessage3, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>如果在<code>目标元素</code>上绑定了多个对<code>同一事件</code>的监听，则<code>捕获触发</code>对应的事件回调会先于<code>冒泡触发</code>对应的事件回调被执行</p><p>如果是都是在<code>同一阶段触发</code>，比如都是冒泡触发，则按声明顺序执行回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是第一个添加的监听&#x27;</span>)</span><br><span class="line">&#125;,)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是第二个添加的监听&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>点击box，控制台输出的顺序是：</p><p><code>&#39;我是第二个添加的监听&#39;</code></p><p><code>&#39;我是第一个添加的监听&#39;</code></p></li></ul></li><li><p>IE事件模型（基本不用，现在再vscode中都无法使用）</p><p>IE事件模型只有2个过程，没有事件捕获阶段:</p><ul><li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。</li><li>事件冒泡阶段：事件从目标元素冒泡到<code>document</code>, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li></ul><p><strong>绑定方式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.attachEvent(eventType, handler)</span><br></pre></td></tr></table></figure><p><strong>解绑方式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dom.<span class="title function_">detachEvent</span>(eventType, handler)</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;.btn&#x27;</span>);</span><br><span class="line">btn.<span class="title function_">attachEvent</span>(‘onclick’, showMessage);</span><br><span class="line">btn.<span class="title function_">detachEvent</span>(‘onclick’, showMessage);</span><br></pre></td></tr></table></figure></li></ul><h2 id="资源加载事件"><a href="#资源加载事件" class="headerlink" title="资源加载事件"></a>资源加载事件</h2><p><strong>DOMContentLoaded</strong></p><p>这个是<code>Document</code>对象的事件，在DOM内容完全加载和解析完毕后触发，不等待样式表、图像等<code>外部资源</code>的加载。</p><p><strong>window的load事件</strong></p><p>则是在所有资源（包括图片、样式表等）都<strong>加载完毕</strong>后才触发，要注意的是，<code>load</code> 事件并<strong>不等待所有的异步请求完成</strong>，比如通过 JavaScript 发起的 AJAX 请求或 Fetch API 请求，甚至不等待动态加载的内容（如通过 JavaScript 动态插入的图片或其他资源）。</p><h2 id="讲讲事件代理"><a href="#讲讲事件代理" class="headerlink" title="讲讲事件代理"></a>讲讲事件代理</h2><p>事件代理也叫<code>事件委托</code>，当我们要监听某个元素某个事件的时候，我们可以选择不给这个元素添加事件监听，而是给这个元素的<code>父元素或者祖先元素</code>添加对该事件的监听。然后在<code>事件冒泡</code>阶段触发该事件监听对应的回调函数。<strong>我们可以说，事件委托是基于事件冒泡的</strong></p><p>当你给DOM元素绑定事件处理器时，JavaScript引擎必须保留对该函数的引用，以便在事件触发时可以调用它。这意味着只要事件处理器存在，其对应的函数就不会被垃圾回收机制回收，从而一直占用着内存。</p><p>如果事件处理器使用了闭包（例如，在定义事件处理器的函数内部访问外部变量），那么这些外部变量也不能被垃圾回收，因为闭包会持有对外部作用域的引用。这进一步增加了内存占用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">textContent</span>);</span><br><span class="line">&#125;);<span class="comment">//比如这个事件监听器中的回调函数就会一直被引用</span></span><br></pre></td></tr></table></figure><p>事件代理的优点：</p><ul><li><p>不必为每个<code>目标元素</code>绑定事件监听，<strong>减少了页面所需内存</strong>。</p></li><li><p>自动绑定，解绑事件监听，减少了重复的工作。</p></li></ul><p>事件代理的局限性:</p><ul><li><code>focus</code>、<code>blur</code>这些事件<code>[输入框的事件]</code><strong>没有事件冒泡机制</strong>，所以无法进行委托绑定事件。</li><li><code>mousemove</code>、<code>mouseout</code>这样的事件，虽然有事件冒泡，但触发频率很高，而且只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的</li></ul><h2 id="在script标签中添加async和defer有什么作用和区别"><a href="#在script标签中添加async和defer有什么作用和区别" class="headerlink" title="在script标签中添加async和defer有什么作用和区别"></a>在script标签中添加async和defer有什么作用和区别</h2><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async 属性用于告诉浏览器脚本是异步的，可以并行下载，而不会阻塞页面的解析，即异步下载，不阻塞页面解析。</p><p>脚本下载完成后<code>立即执行</code>，不保证脚本的执行顺序，如果页面未加载完成，<code>可能阻塞页面加载</code>。</p><p>适用于独立的脚本，如第三方分析脚本，这些脚本不需要等待其他脚本执行完毕。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>defer 属性用于告诉浏览器脚本应该<code>延迟</code>到整个页面解析完成后执行，也是异步下载，不阻塞页面解析，所有脚本在页面解析完成，即DOM树构建完毕，后按引入顺序执行。适用于依赖于 DOM 的脚本，如需要操作 DOM 的脚本，这些脚本需要确保 DOM 已经完全加载。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>都能让浏览器<strong>异步下载脚本</strong>；async类型的脚本在下载完后<strong>立即执行</strong>，可能会阻塞页面渲染；defer类型的脚本下载完后会等到页面解析完成后，即 DOM 树构建完毕后，再按顺序执行。</p><h2 id="说说你对事件循环的理解"><a href="#说说你对事件循环的理解" class="headerlink" title="说说你对事件循环的理解"></a>说说你对事件循环的理解</h2><h3 id="同步与异步任务"><a href="#同步与异步任务" class="headerlink" title="同步与异步任务"></a>同步与异步任务</h3><p>首先，<code>JavaScript</code>是一门<strong>单线程的语言</strong>，意味着同一时间内只能做一件事，这样就存在<strong>线程阻塞</strong>的问题，而解决阻塞的方法就是将任务划分为<code>同步任务</code>和<code>异步任务</code></p><ul><li>同步任务：立即执行的任务，同步任务一般会直接进入到<code>主线程</code>中执行</li><li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等，交给<code>宿主环境</code>去执行，时机成熟后放入<code>任务队列</code>中</li></ul><h3 id="微任务与宏任务"><a href="#微任务与宏任务" class="headerlink" title="微任务与宏任务"></a>微任务与宏任务</h3><p><code>异步任务</code>又可以<strong>细分</strong>为<code>微任务</code>和<code>宏任务</code>，任务队列也被划分为微任务队列和宏任务队列。</p><p>什么是微任务，什么是宏任务？</p><p><strong>宏任务</strong>是指<code>时间粒度</code>比较大的任务（就是js操作比较多，需要更多的时间来执行，无法迅速完成的任务），<strong>微任务</strong>则反之。常见的宏任务有<code>setTimeout()</code>，常见的微任务有<code>Promise.then()</code></p><p>在执行下一个宏任务之前，会先查看<code>微任务队列中</code>是否有需要执行的<code>微任务</code>，如果有则先把微任务执行完，再开启新的宏任务。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p><code>宏任务</code>是事件循环的基本单位，一个宏任务中可以同时包含<code>同步任务</code>，<code>宏任务</code>，<code>微任务</code>；</p><p><code>事件循环</code>指的是，js引擎先执行<code>宏任务</code>中包含的<code>同步任务</code>，再查找并执行微任务队列中的所有微任务，再查找宏任务队列，开启新的宏任务，如此循环往复的过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li>宏任务：执行整体代码（相当于<code>&lt;script&gt;</code>中的代码，整体是一个宏任务）：<ol><li>输出: <code>script start</code></li><li>遇到 setTimeout，加入宏任务队列，当前宏任务队列(setTimeout)</li><li>遇到 promise，加入微任务，当前微任务队列(promise1)</li><li>输出：<code>script end</code></li></ol></li><li>微任务：执行微任务队列（promise1）<ol><li>输出：<code>promise1</code>，then 之后产生一个微任务，加入微任务队列，当前微任务队列（promise2）</li><li>执行 then，输出<code>promise2</code></li></ol></li><li><strong>执行渲染操作，更新界面（敲黑板划重点）。</strong></li><li>宏任务：执行 setTimeout<ol><li>输出：<code>setTimeout</code></li></ol></li></ol><p>参考文章：<a href="https://segmentfault.com/a/1190000044769124">程序员 - 一次搞懂-JS事件循环之宏任务和微任务 - 个人文章 - SegmentFault 思否</a></p><h3 id="async与await"><a href="#async与await" class="headerlink" title="async与await"></a>async与await</h3><p><code>async</code> 是异步的意思，<code>await </code>则可以理解为等待</p><p>放到一起可以理解<code>async</code>就是用来声明一个异步方法，而 <code>await </code>是用来等待异步方法执行</p><p><strong>async</strong></p><p>无论如何，<code>async</code>函数返回的总是一个<code>promise</code>对象，下面两种方法是等效的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;TEST&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会自动包装成resolved类型的promise对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncF</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;TEST&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>await</strong></p><p>正常情况下，<code>await</code>命令后面是一个 <code>Promise </code>对象，返回该对象的结果。如果不是 <code>Promise </code>对象，就<code>直接返回</code>对应的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//等同于return 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// 直接输出123</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//等同于return 123</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="number">123</span>) &#125;, <span class="number">3000</span>) &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">let</span> res = <span class="title function_">f</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)<span class="comment">//输出状态为pending的promise对象</span></span><br><span class="line">res.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v)) <span class="comment">// 3s后输出123</span></span><br></pre></td></tr></table></figure><p>不管<code>await</code>后面跟着的是什么，<code>await</code>都会阻塞后面的代码，后面的代码成为异步任务(如果阻塞的是是同步代码就成为<code>微任务</code>)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn1</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">fn2</span>() <span class="comment">// fn2函数的执行不会被阻塞</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>) <span class="comment">// 被阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn2</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>上述输出结果为：<code>1</code>，<code>fn2</code>，<code>3</code>，<code>2</code></p><h2 id="说说你对BOM的理解"><a href="#说说你对BOM的理解" class="headerlink" title="说说你对BOM的理解"></a>说说你对BOM的理解</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p><code>BOM</code> (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象</p><p>其作用就是跟<code>浏览器</code>做一些交互效果,比如如何进行页面的<code>后退</code>，<code>前进</code>，<code>刷新</code>，浏览器的窗口发生变化，滚动条的滚动，以及获取客户的一些信息如：浏览器品牌版本，屏幕分辨率</p><img src="..\images\前端面试-js\bom.png" style="zoom:85%;" /><img src="..\images\前端面试-js\BOM2.png" style="zoom:67%;" /><h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p><code>Bom</code>的核心对象是<code>window</code>，它表示浏览器的一个实例，<code>location</code>，<code>navigator</code>等后续介绍的对象都是<code>window</code>的属性。</p><p>在浏览器中，<code>window</code>对象有双重角色，即是浏览器窗口的一个接口，又是全局对象</p><p>因此所有在<code>全局作用域</code>中声明的<code>变量</code>、<code>函数</code>都会变成<code>window</code>对象的<code>属性</code>和<code>方法</code></p><ul><li><p><code>window.scrollTo(x,y)</code>：如果有滚动条，将横向滚动条移动到相对于窗体宽度为x个像素的位置，将纵向滚动条移动到相对于窗体高度为y个像素的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">500</span>);<span class="comment">//将页面垂直滚动到距离页面顶部500像素的位置，而水平滚动条不会发生变化。</span></span><br></pre></td></tr></table></figure></li><li><p><code>window.scrollBy(x,y)</code>： 如果有滚动条，将<code>横向滚动条</code>向左移动x个像素，将<code>纵向滚动条</code>向下移动y个像素</p></li></ul><ul><li><p><code>window.open()</code> ：</p><p><code>window.open()</code>既可以导航到一个特定的<code>url</code>，也可以打开一个新的浏览器窗口。</p><p><code>window.open()</code> 会返回<code>新窗口的引用</code>，也就是新窗口的 <code>window</code> 对象，当使用 <code>window.open()</code> 方法打开新窗口时，如果返回值是 <code>null</code>，<strong>这通常意味着浏览器阻止了该弹窗的创建</strong>。现代浏览器为了防止恶意网站滥用弹窗，通常会限制<code>非用户交互</code>触发的弹窗。如果你在页面加载时或没有明确的用户动作（如点击事件）的情况下调用 <code>window.open()</code>，浏览器可能会认为这是未经请求的弹窗，并阻止它。</p><p>比如直接在script标签中书写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;sanye.blog&#x27;</span>)<span class="comment">//被浏览器阻止</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    myWin = <span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&#x27;http://www.vue3js.cn&#x27;</span>, <span class="string">&#x27;_blank&#x27;</span>)</span><br><span class="line">&#125;)<span class="comment">//可行</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newWindow = <span class="variable language_">window</span>.<span class="title function_">open</span>(url, target, features[, replace]);</span><br></pre></td></tr></table></figure><p><strong>url</strong> (可选)</p><ul><li>类型: <code>String</code></li><li>描述: 新窗口要加载的 <code>URL</code> 地址。如果省略或设置为 <code>null</code>，则会打开一个空白窗口。</li></ul><p><strong>target</strong> (可选)</p><ul><li>类型: <code>String</code></li><li>描述: 指定新窗口的<code>目标位置</code>。它可以是以下预定义值之一：<ul><li><code>_self</code>: 在<code>当前框架</code>中加载页面（默认行为）。</li><li><code>_blank</code>: 在<code>新的窗口</code>或标签页中加载页面。</li><li><code>_parent</code>: 在父框架中加载页面。如果当前页面不在框架(iframe)内，则与 <code>_self</code> 的行为相同，在当前标签页中加载新页面。</li><li><code>_top</code>: 在整个窗口中加载页面，取消所有框架。</li><li>或者是一个由开发者定义的名称，用来标识<code>特定的窗口</code>或 <code>&lt;iframe&gt;</code>。</li></ul></li></ul><p><strong>features</strong> (可选)</p><ul><li>类型: <code>String</code></li><li>描述: 一系列用<code>逗号分隔</code>的<code>字符串</code>，用于指定新窗口的各种<code>属性</code>和<code>行为</code>。每个特征可以带有或不带参数<ul><li><code>width=600</code>: 设置窗口宽度为 600 像素。</li><li><code>height=400</code>: 设置窗口高度为 400 像素</li></ul></li></ul><p><strong>replace</strong> (可选)</p><ul><li>类型: <code>Boolean</code></li><li>描述: 如果设置为 <code>true</code>，则新加载的页面将<code>替换历史记录中的当前条目</code>；如果为 <code>false</code> 或<code>未提供</code>，则会在历史记录中添加一个<code>新条目</code>。这对于防止用户多次点击<code>后退</code>按钮返回到同一个页面非常有用。</li></ul></li><li><p><code>window.close()</code> ：仅用于关闭通过 <code>window.open()</code> 打开的窗口</p><p>如果尝试关闭一个<code>不同域名</code>下的窗口，可能会遇到<code>跨域限制</code>。在这种情况下，<code>window.close()</code> 可能不会工作，因为浏览器的安全模型会阻止你操作不属于同一源的窗口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myWin.<span class="title function_">close</span>()<span class="comment">//关闭myWin窗口</span></span><br></pre></td></tr></table></figure></li><li><p>新创建的 <code>window</code> 对象有一个 <code>opener</code> 属性，该属性指向打开他的<code>原始窗口对象</code></p></li></ul><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><p>是一个<code>对象</code>，包含了许多属性，一个<code>url</code>地址例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//www.wrox.com:80/WileyCDA/?q=javascript#contents</span></span><br></pre></td></tr></table></figure><p><code>location</code>属性描述如下：</p><table><thead><tr><th>属性名</th><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>hash</td><td>“#contents”</td><td>url中，#后面的字符，没有则返回空串</td></tr><tr><td>host</td><td><a href="http://www.wrox.com/">www.wrox.com:80</a></td><td>服务器名称和端口号</td></tr><tr><td>hostname</td><td><a href="http://www.wrox.com/">www.wrox.com</a></td><td>域名，不带端口号</td></tr><tr><td>href</td><td><a href="http://www.wrox.com/WileyCDA/?q=javascript#contents">http://www.wrox.com:80/WileyCDA/?q=javascript#contents</a></td><td>完整url</td></tr><tr><td>pathname</td><td>“&#x2F;WileyCDA&#x2F;“</td><td>服务器下面的文件路径</td></tr><tr><td>port</td><td>80</td><td>url的端口号，没有则为空</td></tr><tr><td>protocol</td><td>http:</td><td>使用的协议</td></tr><tr><td>search</td><td>?q&#x3D;javascript</td><td>url的查询字符串，通常为？后面的内容</td></tr></tbody></table><ul><li>除了 <code>hash</code>之外，只要修改<code>location</code>的一个属性，就会导致页面重新加载新<code>URL</code></li><li><code>location.reload()</code>，此方法可以重新刷新当前页面。这个方法会根据<code>最有效的方式</code>刷新页面，如果页面自上一次请求以来没有改变过，页面就会从<code>浏览器缓存</code>中重新加载，这一点和浏览器的<code>缓存策略</code>相关。如果要<code>强制</code>从服务器中重新加载，传递一个参数<code>true</code>即可。</li></ul><h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p><code>navigator</code> 对象主要用来获取<code>浏览器的属性</code>，区分浏览器类型。属性较多，且兼容性比较复杂。</p><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p>保存的纯粹是<code>客户端能力</code>信息，也就是浏览器窗口外面的<code>客户端显示器</code>的信息，比如像素宽度和像素高度。</p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history是window对象的一个属性，它本身也是个对象，提供了许多api，主要用来操作浏览器<code>URL</code>的历史记录，允许我们<strong>编程式</strong>控制页面被在历史记录之间跳转，也允许我们<strong>修改</strong>历史记录。</p><p>检查一个页面并在控制台输入history，即可查看当前页面的<code>state</code>，<code>scrollRestoraion</code>等信息。</p><img src="..\images\前端面试-js\a.png" style="zoom:80%;" /><table><thead><tr><th>API</th><th>作用</th></tr></thead><tbody><tr><td>history.back()</td><td>跳转到前一个页面，如果没有前一个页面，则不做响应，不会改变history.length</td></tr><tr><td>history.forward()</td><td>跳转到后一个页面，如果当前就最新页面，则不做响应，不会改变history.length</td></tr><tr><td>history.go()</td><td>传入数字，<code>正数</code>表示前进几个页面，<code>负数</code>表示后退几个页面，<code>0</code>表示刷新页面，不会改变history.length</td></tr><tr><td>history.length</td><td>获取当前窗口页面历史记录跳数，它是一个只读属性，无法直接修改。</td></tr><tr><td>history.pushState()</td><td>往<strong>历史记录栈顶</strong>添加一条记录，历史记录条数加1，但是<strong>不会跳转页面</strong>。在当前页面调用这个api，你能明显的看到<strong>url改变了</strong>，但是页面没有跳转。接收三个参数，历史记录对象（state），页面标题，URL路径。</td></tr><tr><td>history.replaceState()</td><td>不会增加历史记录数目，<strong>会修改当前历史记录</strong></td></tr><tr><td>history.state</td><td>访问<strong>当前页面</strong>的状态对象。</td></tr><tr><td>history.scrollRestoraion</td><td>如果值为<strong>auto</strong>，则在前进或者后退的时候，<strong>滚动条</strong>会回到原来的位置。如果值为<strong>manual</strong>，则不会恢复。默认值是auto即后退到历史页面的时候，滚动条会回到原来的位置。可以通过在页面（html文件）内部的js代码中使用history.scrollRestoraion来修改这个页面滚动条的恢复方式。</td></tr></tbody></table><h2 id="DOM常见的操作有哪些"><a href="#DOM常见的操作有哪些" class="headerlink" title="DOM常见的操作有哪些"></a>DOM常见的操作有哪些</h2><h3 id="DOM是什么"><a href="#DOM是什么" class="headerlink" title="DOM是什么"></a>DOM是什么</h3><p><code>浏览器</code>根据<code>html</code>标签生成的<code>js对象</code>，所有的<code>标签属性</code>都可以在上面找到（所以说node中没有dom），修改这个对象属性会<code>自动映射</code>到标签上。关键词：浏览器，html标签，js对象，属性映射。</p><h3 id="DOM常见的操作"><a href="#DOM常见的操作" class="headerlink" title="DOM常见的操作"></a>DOM常见的操作</h3><ul><li>创建节点</li><li>获取结点</li><li>更新节点</li><li>添加节点</li><li>删除节点</li></ul><h4 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h4><p><strong>createElement</strong></p><p>创建<code>元素结点</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divEl = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>createTextNode</strong></p><p>创建文本结点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textEl = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;content&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>createAttribute</strong></p><p>创建属性节点，可以是自定义属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个元素结点</span></span><br><span class="line"><span class="keyword">var</span> elem = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建一个属性结点</span></span><br><span class="line"><span class="keyword">var</span> attr = <span class="variable language_">document</span>.<span class="title function_">createAttribute</span>(<span class="string">&#x27;href&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置属性结点的值</span></span><br><span class="line">attr.<span class="property">value</span> = <span class="string">&#x27;http://example.com&#x27;</span>;</span><br><span class="line"><span class="comment">// 将属性结点添加到元素结点</span></span><br><span class="line">elem.<span class="title function_">setAttributeNode</span>(attr);</span><br><span class="line"><span class="comment">// 添加一些文本到元素</span></span><br><span class="line">elem.<span class="property">textContent</span> = <span class="string">&#x27;链接&#x27;</span>;</span><br></pre></td></tr></table></figure><p>虽然可以直接使用<code>elem.href = &#39;http://example.com&#39;;</code>或<code>elem.setAttribute(&#39;href&#39;, &#39;http://example.com&#39;);</code>来达到相同的效果，但是了解<code>如何创建和操作属性结点</code>可以帮助更好地理解DOM的操作机制。</p><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><p>可以通过<code>捕获</code>的方式获取dom结点，也可以通过一个<code>dom结点的属性</code>来获取另一个dom结点</p><p><strong>querySelector</strong></p><p>传入任何有效的<code>css</code> 选择器，即获得<code>首个</code>符合条件的Dom元素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.element&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#element&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;[name=username]&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div + p &gt; span&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果页面上没有指定的元素时，返回 <code>null</code></p><p><strong>querySelectorAll</strong></p><p>传入任何有效的<code>css</code> 选择器，返回一个<code>伪数组</code>，包含全部符合匹配条件的DOM元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> notLive = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>其他方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id属性值&#x27;</span>);返回拥有指定id的对象的引用</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;class属性值&#x27;</span>);返回拥有指定<span class="keyword">class</span>的对象集合</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;标签名&#x27;</span>);返回拥有指定标签名的对象集合</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&#x27;name属性值&#x27;</span>); 返回拥有指定名称的对象结合</span><br><span class="line"><span class="variable language_">document</span>/element.<span class="title function_">querySelector</span>(<span class="string">&#x27;CSS选择器&#x27;</span>);  仅返回第一个匹配的元素</span><br><span class="line"><span class="variable language_">document</span>/element.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;CSS选择器&#x27;</span>);   返回所有匹配的元素</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>;  获取页面中的<span class="variable constant_">HTML</span>标签</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>; 获取页面中的<span class="variable constant_">BODY</span>标签</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">all</span>; 获取页面中的所有元素节点的对象集合型,不是标准<span class="variable constant_">DOM</span>的一部分，它的行为可能在不同的浏览器中表现不同</span><br></pre></td></tr></table></figure><p>我们仅通过观察是<code>...Element...</code>还是，<code>...Elements...</code>就能判断出返回的结果是集合还是单独的元素</p><p>除此之外，每个<code>DOM</code>元素还有<code>parentNode</code>、<code>childNodes</code>、<code>firstChild</code>、<code>lastChild</code>、<code>nextSibling</code>、<code>previousSibling</code>属性，关系图如下图所示。</p><img src="..\images\前端面试-js\dom.png" style="zoom:80%;" /><p><strong>parentNode和parentElement</strong></p><p><code>parentNode</code> 返回指定节点的父节点，这个父节点可以是<strong>任何类型的节点</strong>，包括文档类型节点、元素节点、文本节点等。但是，在实际应用中，除了元素节点外，其他类型的节点很少作为父节点存在。</p><p><code>parentElement</code> 仅返回指定节点的父元素节点（即类型为<code>HTMLElement</code>的节点）。如果指定节点的父节点<strong>不是一个元素节点</strong>（例如，它可能是一个文本节点或文档片段），则 <code>parentElement</code> 返回 <code>null</code>，即<code>先捕获再判断类型</code>。</p><p>简单的来说，就是一个对父节点的类型有要求，一个没有。</p><p><strong>childNodes和children</strong></p><p><code>childNodes</code> 返回一个实时的<code>NodeList</code>对象，包含了指定节点的所有直接子节点(一级子节点)，包括元素节点、文本节点、注释节点等所有类型的节点。</p><p><code>children</code> 返回一个实时的 <code>HTMLCollection </code>对象，只包含指定节点的<code>直接元素子节点（一级元素结点）</code>（即标签）。不包括文本节点、注释节点等其他类型的节点。</p><p><strong>获取页面上的所有结点</strong></p><p>一个简单的方法是从文档的根节点（<code>document</code> 或 <code>document.documentElement</code>，后者指的是 <code>&lt;html&gt;</code> 元素）开始，然后递归地访问每个节点的 <code>childNodes</code>。</p><p><strong>获取页面上的所有元素结点</strong></p><ul><li><p>使用 <code>document.getElementsByTagName(&#39;*&#39;)</code>：这将返回一个包含文档中所有元素的实时 <code>HTMLCollection</code></p></li><li><p>使用 <code>document.querySelectorAll()</code>：通过传递 <code>&#39;*&#39;</code> 选择器，你可以获得一个静态的 <code>NodeList</code>，它包含了文档中的所有元素结点。</p></li></ul><h4 id="更新结点"><a href="#更新结点" class="headerlink" title="更新结点"></a>更新结点</h4><p><strong>innerHTML</strong></p><p>不但可以修改一个<code>DOM</code>节点的<code>文本内容</code>，如果传入的是html片段，还会被解析成dom结点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p&quot;&gt;...&lt;/p &gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// &lt;p id=&quot;p&quot;&gt;ABC&lt;/p &gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.<span class="property">innerHTML</span> = <span class="string">&#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>innerText、textContent</strong></p><p>自动对字符串进行<code>HTML</code>编码，就是把小于号转化成<code>&amp;lt;</code>大于号转化成<code>&amp;gt;</code>保证无法设置任何<code>HTML</code>标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p &gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本:</span></span><br><span class="line">p.<span class="property">innerText</span> = <span class="string">&#x27;&lt;script&gt;alert(&quot;Hi&quot;)&lt;/script&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">// HTML被自动编码，无法设置一个&lt;script&gt;节点:</span></span><br><span class="line"><span class="comment">// &lt;p id=&quot;p-id&quot;&gt;&amp;lt;script&amp;gt;alert(&quot;Hi&quot;)&amp;lt;/script&amp;gt;&lt;/p &gt;</span></span><br></pre></td></tr></table></figure><p>两者的区别在于读取属性时，<code>innerText</code>不返回<code>隐藏元素</code>的文本(即 <code>display: none</code> 或者 <code>visibility: hidden</code>)，而<code>textContent</code>返回所有文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;example&quot;&gt;</span><br><span class="line">  &lt;p&gt;可见文本&lt;/p&gt;</span><br><span class="line">  &lt;p style=&quot;display: none;&quot;&gt;隐藏文本&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const element = document.getElementById(&#x27;example&#x27;);</span><br><span class="line">  console.log(element.innerText);     // 输出: &quot;可见文本&quot;</span><br><span class="line">  console.log(element.textContent);  // 输出: &quot;可见文本\n隐藏文本&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="添加结点"><a href="#添加结点" class="headerlink" title="添加结点"></a>添加结点</h4><p><strong>appendChild</strong></p><p>把一个节点添加到父节点的最后一个子节点之后，<strong>如果这个添加的结点已经在页面中存在，那么这个结点会先从原位置删除</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript&lt;/p &gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme&lt;/p &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加一个<code>p</code>元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> js = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;js&#x27;</span>)</span><br><span class="line">js.<span class="property">innerHTML</span> = <span class="string">&quot;JavaScript&quot;</span></span><br><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">list.<span class="title function_">appendChild</span>(js);</span><br></pre></td></tr></table></figure><p>在<code>HTML</code>结构变成了下面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;java&quot;</span>&gt;</span>Java&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;python&quot;</span>&gt;</span>Python&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme&lt;/p &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript&lt;/p &gt;  <span class="comment">&lt;!-- 添加元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>insertBefore</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentElement.<span class="title function_">insertBefore</span>(newElement, referenceElement)</span><br></pre></td></tr></table></figure><p>子节点会插入到<code>referenceElement</code>之前</p><ul><li><code>parentElement</code>: 这是要操作的目标元素，新的子节点将被添加到这个元素的<code>子节点列表</code>中。</li><li><code>newElement</code>: 这是你想要插入的<code>新元素节点</code>。</li><li><code>referenceElement</code>: 这是在新元素插入之前所依据的<code>参考元素</code>。新元素会被放置在这个<code>参考元素</code>之前。如果这个参数为 <code>null</code>，则新元素会被插入到父元素的最后，就像使用 <code>appendChild()</code> 一样。</li></ul><p><strong>setAttribute</strong></p><p>在指定元素中<code>添加一个属性</code>节点，如果元素中已有该属性改变属性值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">div.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;white&#x27;</span>);<span class="comment">//第一个参数属性名，第二个参数属性值。</span></span><br></pre></td></tr></table></figure><h4 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h4><p><strong>removeChild</strong></p><p>删除一个节点，首先要获得<code>该节点本身</code>以及它的<code>父节点</code>，然后，调用父节点的<code>removeChild</code>把自己删掉，也就是说，一个结点是不能删除自身的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">const</span> self = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;to-be-removed&#x27;</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">const</span> parent = self.<span class="property">parentNode</span>;</span><br><span class="line"><span class="comment">// 删除并返回被删除的dom元素</span></span><br><span class="line"><span class="keyword">const</span> removed = parent.<span class="title function_">removeChild</span>(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>删除后的节点虽然不在<code>文档树</code>中了，但其实它还在<code>内存中</code>，可以随时再次被添加到别的位置。</p><h2 id="如何实现触底加载，下拉刷新？"><a href="#如何实现触底加载，下拉刷新？" class="headerlink" title="如何实现触底加载，下拉刷新？"></a>如何实现触底加载，下拉刷新？</h2><p>要明白如何实现功能，我们首先要搞清楚dom元素的一些<strong>定位，宽高属性</strong></p><ul><li><p>client</p><p><code>clientWidth/clientHeight</code>：可视区域的宽&#x2F;高+内边距，不包含<code>border</code></p></li><li><p>scroll</p><p><code>scrollWidth/scrollHeight</code>：有滚动条元素的元素整体的宽高。</p></li></ul><p>举个例子，我们在一个高度为<code>600px</code>的盒子<code>box</code>里放两个背景颜色不同，高度都是<code>400px</code>的盒子<code>box1</code>,<code>box2</code>，并给<code>box</code>添加css属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>:auto </span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">补充一下overflow属性的值</span><br><span class="line">visible（默认值）:内容不会被裁剪，而是会呈现在元素框之外。</span><br><span class="line">hidden:内容会被裁剪，并且超出的部分不会显示。浏览器不会为溢出内容提供任何滚动机制。</span><br><span class="line">scroll:即使内容并未溢出,也提供滚动条</span><br><span class="line">auto:如果内容溢出了元素框，则浏览器会根据需要提供滚动条。如果内容没有溢出，则不显示滚动条</span><br><span class="line"></span><br><span class="line">单个方向上的溢出控制</span><br><span class="line">overflow-x：控制水平方向上的溢出。</span><br><span class="line">overflow-y: 控制垂直方向上的溢出。</span><br></pre></td></tr></table></figure><p>这样<code>box</code>盒子就出现了滚条，可以实现内容的滚动，内部盒子也不会影响外部盒子的布局（开启了<code>BFC</code>，可以观察添加该条属性前后，body高度的变化，从800px变为600px）。然后我们访问box盒子（有滚动条的盒子）的<code>clientHeight</code>属性和<code>scrollHeight</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box.<span class="property">clientHeight</span> <span class="comment">//600px</span></span><br><span class="line">box.<span class="property">scrollHeight</span> <span class="comment">//800px</span></span><br></pre></td></tr></table></figure><p>这样是不是就很容易理解client和scroll之间的区别呢。对于没有滚动条的元素，clientWidth&#x2F;clientHeight与scrollWidth&#x2F;scrollHeight的值是一一相等的。</p><p>当我们不断地给<code>body</code>添加元素，<code>body</code>的高度总有超过浏览器窗口高度的时候，此时<code>body</code>标签的父元素，<code>html</code>标签会自动开启滚动条，<code>html.clientHeight</code>就是<strong>浏览器窗口</strong>的高度。</p><ul><li><p>scroll</p><p>scroll开头的属性中，还有两个重要的属性。</p><p>scrollLeft&#x2F;scrollTop：表示<strong>具有滚动条的元素</strong>，顶部滚动出<code>可视区域</code>的高度，或者左部滚动出<code>可视区域</code>的宽度，对于不具有滚动条的元素，这两个属性的值都是<code>0</code>。这两个属性是可读写的，将元素的 <code>scrollLeft</code> 和 <code>scrollTop</code> 设置为 0，可以重置元素的滚动位置。</p></li></ul><p>常见的属性中除了以client，scroll开头的属性，还有以<code>offset</code>开头的属性</p><ul><li><p>offset</p><p><code>offsetWidth/offsetHeight</code>：可视区域的宽&#x2F;高+内边距+border+滚动条，这两个属性通常被拿来与<code>clientWidth/clientHeight</code>属性比较,都是可视区域的宽高，不过范围有所不同。</p><p><code>offsetLeft/offsetHeight</code>：元素左部&#x2F;顶部距离<strong>最近的定位元素</strong>的距离，相对的<strong>不是视口</strong>，通常是固定的，不会随滚动条改变而改变。</p></li></ul><img src="..\images\前端面试-js\offset.png" style="zoom:80%;" /><h3 id="如何实现触底加载"><a href="#如何实现触底加载" class="headerlink" title="如何实现触底加载"></a>如何实现触底加载</h3><p><strong>方法1</strong></p><p>如果<code>html</code>元素<strong>顶部滚出可视区域的高度</strong>+html元素的<strong>可视区域高度</strong>，大于html标签的<strong>整体高度</strong>，则判定为触底，其实这个时候就是页面已经滑到底部了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (html.<span class="property">scrollTop</span> + html.<span class="property">clientHeight</span> &gt;= html.<span class="property">scrollHeight</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触底&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：实现起来非常简单。</p><p>缺点：只能判断最后一个元素是否触底，不能判断<strong>非底部元素</strong>是否触底（如果body很长，那么非底部元素也是有触底事件的）</p><p><strong>方法2</strong></p><p>使用<code>IntersectionObserver API</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">func</span> = (<span class="params">entries, observer</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//每观察一个元素，entries的大小就会+1</span></span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">isIntersecting</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;元素进入视口&#x27;</span>);</span><br><span class="line">      <span class="comment">//entry.target：表示被观察的元素。</span></span><br><span class="line">      observer.<span class="title function_">unobserve</span>(entry.<span class="property">target</span>); <span class="comment">// 一旦进入视口，停止观察</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二个参数指明元素完全出现在视口再触发回调函数，符合触底的思想</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(func,&#123;<span class="attr">threshold</span>:<span class="number">1</span>&#125;);</span><br><span class="line">observer.<span class="title function_">observe</span>(target) <span class="comment">//观察某个元素</span></span><br></pre></td></tr></table></figure><p>关于<code>IntersectionObserver</code>更详细的介绍参考下文。</p><p>优点：不仅能精确控制某个元素是否触底，令<code>threshold</code>的值为0，还能实现<strong>图片懒加载</strong>的效果，即图片一出现在视口，就发送请求获取图片。</p><p>缺点：需要调用api实现起来麻烦。</p><h3 id="如何实现下拉刷新"><a href="#如何实现下拉刷新" class="headerlink" title="如何实现下拉刷新"></a>如何实现下拉刷新</h3><p>监听<code>window</code>的<code>touchstart</code>,<code>touchmove</code>,<code>touchend</code>,通过<code>e.touches[0].pageY</code>获得触碰位置。<code>touchend</code>事件触发后，计算移动的距离，判断是否需要刷新数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> start</span><br><span class="line"><span class="keyword">let</span> distance = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> load</span><br><span class="line"><span class="keyword">let</span> tip</span><br><span class="line"><span class="comment">//在一次下拉操作中，这个回调函数只会执行一次</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">//存储第一次触摸屏幕距离视口顶部的距离</span></span><br><span class="line">  start = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientY</span></span><br><span class="line">  <span class="comment">//还未开始加载</span></span><br><span class="line">  load = <span class="literal">false</span></span><br><span class="line">  <span class="comment">//还未提示正在下拉</span></span><br><span class="line">  tip = <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//在一次下拉操作中，这个回调函数会被执行多次</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">//记录下拉的距离</span></span><br><span class="line">  distance = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientY</span> - start</span><br><span class="line">  <span class="comment">//如果下拉的距离大于0且未提示过正在下拉刷新，则提示</span></span><br><span class="line">  <span class="keyword">if</span> (distance &gt; <span class="number">0</span> &amp;&amp; !tip) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正在进行下拉刷新操作&#x27;</span>)</span><br><span class="line">    <span class="comment">//本次下拉操作不再提示正在下拉刷新</span></span><br><span class="line">    tip = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果下拉的距离超过设定的距离且未提示过松手释放，则提示</span></span><br><span class="line">  <span class="keyword">if</span> (distance &gt; <span class="number">50</span> &amp;&amp; !load) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;松手释放&#x27;</span>)</span><br><span class="line">    <span class="comment">////本次下拉操作不再提示松手释放</span></span><br><span class="line">    load = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//在一次下拉操作中，这个回调函数只会执行一次</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">//如果下拉的距离超过了指定距离，则松手后开始更新</span></span><br><span class="line">  <span class="keyword">if</span> (load) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正在进行更新操作&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="如何判断一个元素是否在可视区域中？"><a href="#如何判断一个元素是否在可视区域中？" class="headerlink" title="如何判断一个元素是否在可视区域中？"></a>如何判断一个元素是否在可视区域中？</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如：</p><ul><li>图片的懒加载</li><li><strong>列表的无限滚动</strong></li><li>计算广告元素的曝光情况</li><li>可点击链接的预加载</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="借助dom的布局属性"><a href="#借助dom的布局属性" class="headerlink" title="借助dom的布局属性"></a><strong>借助dom的布局属性</strong></h4><p>当一个元素的<code>html</code>标签的<code>scrollTop</code>属性，加上<code>视口的高度</code>，大于等于一个元素的<code>offsetTop</code>属性，那么这个元素就出现在视口中。如何获取视口的高度呢？有三种方式：</p><ul><li><code>window.innerHeight </code></li><li><code>document.documentElement.clientHeight</code>：<code>html标签</code>的高度就可以认为是<strong>视口的高度</strong></li><li><code>document.body.clientHeight</code> ：<code>body</code>标签的高度通常等于<code>html标签</code>的<code>高度</code>，所以也可以被认为是视口的高度。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="property">offsetTop</span> - <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> &lt;= <span class="title function_">viewPortHeight</span>(视口高度)</span><br></pre></td></tr></table></figure><p><strong>然而这么做有一个前提，那就是el的最近的定位元素是<code>html</code>标签。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPortOfOne</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// viewPortHeight 兼容所有浏览器写法</span></span><br><span class="line">    <span class="keyword">const</span> viewPortHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span> </span><br><span class="line">    <span class="keyword">const</span> offsetTop = el.<span class="property">offsetTop</span><span class="comment">//元素距离html标签顶部的距离，前提html确实是最近的定位元素</span></span><br><span class="line">    <span class="keyword">const</span> html = <span class="variable language_">document</span>.<span class="property">documentElement</span></span><br><span class="line">    <span class="keyword">const</span> scrollTop = html.<span class="property">scrollTop</span></span><br><span class="line">    <span class="keyword">return</span> offsetTop - scrollTop &lt;= viewPortHeight</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h4><p><code>Intersection(交叉，交集) Observer</code> 即，重叠观察者，从这个命名就可以看出它用于<code>判断两个元素是否重叠</code>，因为不用进行<code>scroll</code>事件的监听，性能方面相比<code>getBoundingClientRect</code>会好很多。</p><p>使用步骤主要分为两步：<code>创建观察者</code>和<code>传入被观察者</code></p><p><strong>创建观察者</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="comment">// 表示重叠面积占被观察者的比例，从 0 - 1 取值，</span></span><br><span class="line">  <span class="comment">// 1 表示完全被包含</span></span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">1.0</span>, </span><br><span class="line">  <span class="attr">root</span>:<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#scrollArea&#x27;</span>) <span class="comment">// 必须是目标元素的父级元素，如果省略，浏览器的视口（viewport）作为根容器</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params">entries, observer</span>) =&gt; &#123; ....&#125;</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, options);</span><br></pre></td></tr></table></figure><p>通过<code>new IntersectionObserver</code>创建了观察者 <code>observer</code>，传入的回调函数 <code>callback</code> <strong>在重叠比例超过 <code>threshold</code> 时会被执行</strong></p><p>关于<code>callback</code>回调函数常用属性如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上段代码中被省略的 callback</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="keyword">function</span>(<span class="params">entries, observer</span>) &#123; </span><br><span class="line">    <span class="comment">//entries是一个数组，包含了所有被观察的对象</span></span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        entry.<span class="property">isIntersecting</span>      <span class="comment">// 布尔值，表示两元素是否重叠</span></span><br><span class="line">        entry.<span class="property">time</span>;               <span class="comment">// 触发的时间</span></span><br><span class="line">        entry.<span class="property">intersectionRatio</span>;  <span class="comment">// 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）</span></span><br><span class="line">        entry.<span class="property">target</span>;             <span class="comment">// 被观察者</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>传入被观察者</strong></p><p>通过 <code>observer.observe(target)</code> 这一行代码即可<strong>简单的注册被观察者</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.target&#x27;</span>);</span><br><span class="line">observer.<span class="title function_">observe</span>(target);</span><br></pre></td></tr></table></figure><h4 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h4><p>调用dom的getBoundingClientRect方法，返回值是一个 <code>DOMRect</code>对象，拥有<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>x</code>, <code>y</code>, <code>width</code>, 和 <code>height</code>属性。</p><ul><li><code>x</code>: 元素左边缘相对于<code>视口左边界</code>的距离，通常情况下等于left</li><li><code>y</code>: 元素上边缘相对于<code>视口顶部</code>的距离，通常情况下等于top</li><li><code>top</code>: 元素上边缘相对于<code>视口顶部</code>的距离。</li><li><code>right</code>: 元素右边缘相对于<code>视口左边界</code>的距离。</li><li><code>bottom</code>: 元素下边缘相对于<code>视口顶部</code>的距离。</li><li><code>left</code>: 元素左边缘相对于视口左边界的距离。</li><li><code>width</code>: 元素的宽度，包括填充和边框，但不包括外边距。</li><li><code>height</code>: 元素的高度，包括填充和边框，但不包括外边距。</li></ul><p>如果一个元素在视窗之内的话，那么它一定满足下面四个条件：</p><ul><li>top 大于等于 0</li><li>left 大于等于 0</li><li><strong>bottom 小于等于视窗高度，就是元素底部距离视口顶部的距离，小于等于视口高度，这个是最常用的判断条件</strong></li><li>right 小于等于视窗宽度</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个布尔值，判断元素是否在视口中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPort</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> viewWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">  <span class="keyword">const</span> viewHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    top,</span><br><span class="line">    right,</span><br><span class="line">    bottom,</span><br><span class="line">    left,</span><br><span class="line">  &#125; = element.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    top &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    left &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    right &lt;= viewWidth &amp;&amp;</span><br><span class="line">    bottom &lt;= viewHeight</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获得元素的即时位置，<strong>每次页面滚动</strong>都要重新调用这个方法来获得最新的位置信息。</p><h3 id="实现图片的懒加载"><a href="#实现图片的懒加载" class="headerlink" title="实现图片的懒加载"></a>实现图片的懒加载</h3><p>下面使用<code>IntersectionObserver</code>实现了一个图片懒加载指令。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> lazy = &#123;</span><br><span class="line">    <span class="title function_">bind</span>(<span class="params">el,binding</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries,observer</span>)=&gt;</span>&#123;</span><br><span class="line">            entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>)=&gt;</span>&#123;</span><br><span class="line">                entry.<span class="property">target</span>.<span class="property">src</span> = binding.<span class="property">value</span></span><br><span class="line">                observer.<span class="title function_">unobserve</span>(entry.<span class="property">target</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,&#123;<span class="attr">threshold</span>:<span class="number">0</span>&#125;)</span><br><span class="line">        observer.<span class="title function_">observe</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现列表的无限滚动"><a href="#实现列表的无限滚动" class="headerlink" title="实现列表的无限滚动"></a>实现列表的无限滚动</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> infinite = &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        el.<span class="title function_">getBoundingClientRect</span>().<span class="property">bottom</span> &lt;=</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        binding.<span class="title function_">value</span>()<span class="comment">//调用传入的回调函数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new操作符到底做了什么"><a href="#new操作符到底做了什么" class="headerlink" title="new操作符到底做了什么"></a>new操作符到底做了什么</h2><ul><li>创建一个新的对象</li><li>让这个对象的<code>[[prototype]]</code>属性等于构造函数的<code>prototype</code>，即让新创建的对象的原型等于构造函数的原型对象。</li><li>调用这个对象的<code>constructor</code>方法</li></ul><p>如果构造函数的<code>返回值</code>是<strong>基本类型</strong>，那么这个返回值不起任何效果，但是如果构造函数的返回值是<strong>引用类型</strong>，new操作返回的对象就是构造函数返回的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Parent</span>()) <span class="comment">//Parent &#123;name: &#x27;parent&#x27;, play: Array(3)&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line"> this.name = &#x27;parent&#x27;;</span><br><span class="line">    this.play = [1, 2, 3];</span><br><span class="line">    return [1,2,3]</span><br><span class="line">&#125;</span><br><span class="line">console.log(new Parent()) //输出[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>手写<code>new</code></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name,age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">constructor, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">//方法1</span></span><br><span class="line">  <span class="comment">// const obj = Object.create(constructor.prototype)</span></span><br><span class="line">  <span class="comment">//方法2</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="comment">//新对象原型指向构造函数原型对象</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = constructor.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="comment">//让这个对象调用constructor方法，并传入参数</span></span><br><span class="line">  <span class="keyword">const</span> res = obj.<span class="title function_">constructor</span>(<span class="params">...args</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> res == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myNew</span>(<span class="title class_">Parent</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="number">30</span>)) <span class="comment">//Parent &#123;name: &#x27;tom&#x27;, age: 30&#125;</span></span><br></pre></td></tr></table></figure><h2 id="在js中如何实现继承"><a href="#在js中如何实现继承" class="headerlink" title="在js中如何实现继承"></a>在js中如何实现继承</h2><p>继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码</p><p>在子类别继承父类别的同时，可以<code>重新定义</code>某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。</p><p>如果大家学过<code>java</code>，想必对继承的概念都非常熟悉了。</p><p>那在js这门语言中是如何实现继承呢?</p><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>让父类的一个<code>实例</code>作为子类的<code>原型对象</code>，这样子类的原型对象的原型确实是父类的原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent1&#x27;</span>;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br></pre></td></tr></table></figure><p>这样就满足<code>Child.prototype._proto_ = Parent.prototype</code>，在原型链上确实是符合继承关系，但是这也<strong>只是</strong>在原型链上实现了继承，<code>Child.prototype.constructor</code>也不指向<code>Child</code>的构造函数，而是指向Parent的构造函数，而且这个构造函数还不是原型对象（prototype）自己的属性</p><img src="..\images\前端面试-js\继承.png" style="zoom:80%;" /><p>正确的情况，<code>Child.prototype</code>的<code>constructor</code>应该是<code>Child.prototype</code><strong>自己的属性</strong>（ownProperty）</p><p>正确的状态，比如Parent构造函数</p><img src="..\images\前端面试-js\继承2.png" style="zoom:80%;" /><p>总的来说，原型链继承的问题包括， 子类的原型对象<strong>没有自己的构造函数，还存在多余的属性</strong>。</p><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Parent()&#123;</span><br><span class="line">    this.name = &#x27;parent1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = function () &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">function Child()&#123;</span><br><span class="line">    Parent1.call(this);</span><br><span class="line">    this.type = &#x27;child&#x27;</span><br><span class="line">&#125;</span><br><span class="line">let child = new Child();</span><br></pre></td></tr></table></figure><p>构造函数继承也只是实现了构造函数上的继承，比原型链继承还低智，就纯粹在<code>Child</code>的构造函数中调用了<code>Parent</code>的构造函数，并让<code>this</code>指向Child构造函数内部的this，在这个例子中，<code>Parent1.call(this)</code>完全可以被替换为<code> this.name = &#39;parent1&#39;;</code>这种继承方式唯一的作用，拿这个例子来讲，就是把父类<code>Parent</code>的name属性终于变成<code>子类Child实例</code>自己的属性了（对象本身就有的，而不是原型对象上的，可以通过<code>hasOwnProperty</code>方法来判断）。</p><img src="..\images\前端面试-js\构造函数继承.png" style="zoom:85%;" /><h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><p>组合式继承就是把前面两种方式，即<code>原型链继承</code>和<code>构造函数继承</code>，这两种不完美的方法结合了起来，并更正了<code>Child</code>原型对象的指向。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 第二次调用 Parent()</span></span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用 Parent()</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="comment">// 手动挂上构造器，指向自己的构造函数，更正指向</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Child</span>())</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-js\组合继承.png" style="zoom:80%;" /><p>可以看到<code> Child.prototype.constructor</code>指向是正确的，创建的<code>Child</code>实例也有自己的<code>name</code>和<code>play</code>属性，但是实例的原型对象上有多余的属性比如name和paly。</p><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>是对组合式继承的<strong>优化</strong>，不再使用父类(<code>Parent</code>)的<code>实例</code>作为子类(<code>Child</code>)的原型对象(<code>Prototype</code>)，而是使用**Object.create()**方法单独为子类创造一个原型对象。</p><p><code>Object.create()</code>能以传入的对象为<code>对象原型</code>，创造一个新的对象。</p><p>示例：<code>Object.create(Parent.prototype)</code></p><p>以Parent的原型对象为对象原型，创造一个新的对象，意思就是<strong>创造的对象</strong>的<code>_proto_</code>属性&#x3D;<code>Parent.prototype </code>，<strong>就好像创建了一个Parent实例</strong>，所以创建的对象显示的类型也是<code>Parent</code>，不过这个实例对象没有自己的属性（多余的属性比如name，play），再给这个对象添加自己的constructor属性后用来充当原型对象再合适不过了。</p><img src="..\images\前端面试-js\原型链.png" style="zoom:90%;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getFriends</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">//&#123;friends:&quot;child&quot;,name:&quot;parent&quot;,play:[1,2,3],__proto__:Parent&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// parent</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getFriends</span>()); <span class="comment">// child</span></span><br></pre></td></tr></table></figure><h3 id="extends-super"><a href="#extends-super" class="headerlink" title="extends+super"></a>extends+super</h3><p>使用<code>extends</code>关键字实现继承，基于<code>es6</code>新引入的<code>class</code>，本质上使用的也是<code>寄生组合式继承</code>，不过还要配合<code>super</code>关键字使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原型方法，会被挂载到构造函数的原型上</span></span><br><span class="line">  <span class="comment">// 即Person.prototype.getName = function() &#123;&#125;</span></span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gamer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="comment">//构造函数不是必须写的，如果不写构造函数就相当于书写了以下代码：</span></span><br><span class="line">  <span class="comment">//constructor(name) &#123;</span></span><br><span class="line">  <span class="comment">//  super(name)</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super(),表示调用父类的构造函数</span></span><br><span class="line">    <span class="comment">// 不调用super就会报错</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> asuna = <span class="keyword">new</span> <span class="title class_">Gamer</span>(<span class="string">&#x27;Asuna&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">asuna.<span class="title function_">getName</span>() <span class="comment">// 成功访问到父类的方法</span></span><br></pre></td></tr></table></figure><h2 id="Javascript本地存储的方式有哪些？区别及应用场景？"><a href="#Javascript本地存储的方式有哪些？区别及应用场景？" class="headerlink" title="Javascript本地存储的方式有哪些？区别及应用场景？"></a>Javascript本地存储的方式有哪些？区别及应用场景？</h2><p><code>javaScript</code>本地缓存的方法我们主要讲述以下四种：</p><ul><li>cookie</li><li>sessionStorage</li><li>localStorage</li><li>indexedDB</li></ul><p>其中<code>sessionStorage</code>和<code>localStorage</code>都是<code>H5</code>新增的。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h4><p><code>Cookie</code>是存储在客户端的<code>小型文本文件（txt）</code>，被用来解决 <code>HTTP</code><strong>无状态</strong>导致的问题，。</p><p>作为一段一般不超过 <code>4KB</code> 的小型文本数据（4KB 的大小限制主要针对单个 Cookie），它由一个名称（Name）、一个值（Value）和其它几个用于<code>控制</code> <code>cookie</code>有效期、安全性、使用范围的可选属性组成。</p><p>但是<code>cookie</code>在每次请求中都会被发送，如果不使用 <code>HTTPS</code>并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 <code>cookie</code>保持登录态的网站上，如果 <code>cookie</code>被窃取，他人很容易利用你的 <code>cookie</code>来假扮成你登录网站。</p><img src="..\images\前端面试-js\cookie.png" style="zoom:80%;" /><p>关于<code>cookie</code>常用的属性如下：</p><ul><li><p><strong>Expires</strong> </p><p>用于设置 Cookie 的过期时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Expires</span>=<span class="title class_">Wed</span>, <span class="number">21</span> <span class="title class_">Oct</span> <span class="number">2015</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">00</span> <span class="variable constant_">GMT</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Max-Age</strong> </p><p>用于设置在 Cookie 的有效时间（优先级比<code>Expires</code>高，书写方式也比Expires友好）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Max</span>-<span class="title class_">Age</span>=<span class="number">604800</span> <span class="comment">//单位是s</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Domain</strong></p><p>指定了 <code>Cookie</code> 在哪些域名下生效，包含了这些域名的请求，才会自动携带cookie。</p><p>添加cookie的时候，不指定Domain默认就是<code>当前域名</code>；指定了一个域名，则其子域名也总会被包含；</p><p>比如，在<code>https://www.bilibili.com/</code>页面下添加一个cookie但是未指定Domain，则Domain就是<code>www.bilibili.com</code></p><p>如果指定Domain为<code>bilibili.com</code>，则实际为<code>.bilibili.com</code>，表示在<code>bilibili.com</code>所有子域名下这个cookie也生效。</p></li><li><p><strong>Path</strong></p><p>指定了一个 <code>URL</code>路径，只有<strong>包含这个路径的请求</strong>才能携带这个cookie</p></li><li><p><strong>Secure</strong></p><p>标记为 <code>Secure</code>的 <code>Cookie</code>意味着这个cookie包含了重要的信息，不应该被泄漏，只能通过<code>HTTPS</code>请求安全地发送给服务器。</p></li><li><p><strong>HttpOnly</strong></p><p>标记为HttpOnly的请求只能通过<code>http/https</code>协议来操作。</p></li><li><p><strong>SameSite</strong></p><p><code>SameSite</code> 属性用于控制 Cookie 是否应该随<strong>跨站请求</strong>一起发送。它有三个可能的值:</p><ul><li><code>Strict</code>：Cookie 仅在<code>同站</code>请求中发送，即只有当用户从同一站点发起请求时才会包含 Cookie。</li><li><code>Lax</code>：大多数情况下不发送跨站请求中的 Cookie，但在导航到目标站点（如点击链接）时例外。</li><li><code>None</code>：允许跨站请求中发送 Cookie，但要求请求必须通过<code> HTTPS</code> 发送（即启用安全传输层）。</li></ul></li></ul><p>更多例子参考：<a href="https://www.sanye.blog/posts/c0add594.html">前端面试—网络 | 三叶的博客</a>中的<code>withCredentails</code>部分</p><h4 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a><strong>操作方式</strong></h4><ul><li><p><strong>通过js操作cookie</strong></p><ul><li><p>获取当前页面所有cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span></span><br></pre></td></tr></table></figure><p>返回一个字符串，包含当前页面的所有cookie的键值对，形如：<code>key=val;key2=val2;......;keys=vals</code></p><p>如果要查看当前页面的全部cookie的详细信息，可以选择<code>检查页面</code>，前往<code>应用程序-&gt;存储-&gt;cookie</code>中查看。</p></li><li><p>创建一个cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;key=val;Max-age=3600;Domain=www.sanye.blog&#x27;</span> <span class="comment">//可以继续添加其他限制属性</span></span><br></pre></td></tr></table></figure><p>我们知道，document.cookie，返回一个字符串，包含当前页面的所有cookie的键值对。上述创建cookie的代码的效果貌似是覆盖掉这个字符串，其实不是的，效果真的是添加一个cookie。</p></li><li><p>修改cookie</p><p>关于<code>cookie</code>的修改，首先要确定<code>domain</code>和<code>path</code>属性都是相同的才可以，这两个属性可以理解为用来限制cookie的作用域，其中有一个不同的时候都会创建出一个新的<code>cookie</code>，而不是修改原来的cookie</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;name=bb; domain=aa.net; path=/&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>删除cookie</p><p>最常用的方法就是给<code>cookie</code>设置一个过期的时间，这样<code>cookie</code>过期后会自动被浏览器删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;id=1;Max-age=0&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>通过http操作cookie</strong></p><p><strong>添加cookie</strong></p><p>http通过在响应头中添加<code>Set-Cookie</code>字段在客户端种cookie，如果有多个 Cookie 就在响应头中设置多个 <code>Set-Cookie</code> 字段。</p><p>通过http操作的cookie的方式与js操作cookie的方式在形式上是不同的，但本质上还是相同的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Set</span>-<span class="title class_">Cookie</span>: &lt;cookie-name&gt;=&lt;cookie-value&gt;; [<span class="title class_">Expires</span>=&lt;date&gt;]; [<span class="title class_">Max</span>-<span class="title class_">Age</span>=&lt;non-zero-digit&gt;]; [<span class="title class_">Domain</span>=&lt;domain-value&gt;]; [<span class="title class_">Path</span>=&lt;path-value&gt;]; [<span class="title class_">Secure</span>]; [<span class="title class_">HttpOnly</span>]; </span><br></pre></td></tr></table></figure><p><strong>更新或者删除cookie</strong></p><p>要更新现有的Cookie，只需再次发送带有<code>相同名称</code>的新 <code>Set-Cookie</code> 头。这将覆盖旧的同名Cookie。要删除一个Cookie，可以通过设置其 <code>Expires</code> 或 <code>Max-Age</code> 为过去的时间戳来实现</p></li></ul><h4 id="浏览器行为"><a href="#浏览器行为" class="headerlink" title="浏览器行为"></a><strong>浏览器行为</strong></h4><ul><li>浏览器会在每次请求时自动附加与目标URL相匹配的所有Cookies。</li><li>如果某个Cookie被标记为 <code>HttpOnly</code>，那么JavaScript代码不能读取或修改这个Cookie，增加了安全性。</li><li>当一个Cookie过期后，浏览器会自动将其从存储中移除，不再随请求一起发送。</li></ul><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p><code>HTML5</code>新方法，IE8及以上浏览器都兼容</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>持久化的本地存储，除非主动删除数据，否则数据永不过期</p></li><li><p>存储的信息在<code>同一域</code>中是共享的，这个同一域包括<code>子域名</code>，也就是说若两个域名即便只有子域名不同，也不会被认为是同一域名。</p><p>子域名指的是主域名（二级域名+顶级域名）之前的部分，比如<code>www.sanye.blog</code>中的<code>www</code>就是子域名，<code>sanye.blog</code>就是主域名，一般域名购买，购买的就是主域名。</p></li><li><p>当本页操作（新增、修改、删除）了<code>localStorage</code>中的数据的时候，本页面不会触发<code>storage</code>事件，但是别的页面会触发<code>storage</code>事件，这里的其他页面指的是<code>同源</code>的其他页面。</p></li><li><p>大小：5M（跟浏览器厂商有关系）,<code>localStorage</code> 的大小限制主要指的是 <strong>整个域名下所有存储数据的总和</strong>，而不是单个键值对的大小。</p></li><li><p><code>localStorage</code>本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</p></li><li><p>受同源策略的限制</p></li></ul><h4 id="storage事件补充"><a href="#storage事件补充" class="headerlink" title="storage事件补充"></a><strong>storage事件补充</strong></h4><p>假设你有两个标签页（Tab A 和 Tab B）打开了同一个网站 <code>example.com</code>，并且这两个标签页都在使用 <code>localStorage</code> 来存储一些数据。</p><ol><li><p><strong>Tab A</strong> 中执行以下 JavaScript 代码来设置一个新的 <code>localStorage</code> 项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&#x27;key&#x27;, &#x27;value&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Tab A</strong> 不会触发 <code>storage</code> 事件，因为它就是触发这次变更的<code>操作源</code>。</p></li><li><p><strong>Tab B</strong> 中监听 <code>storage</code> 事件，并打印出事件详情：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;storage&#x27;, function(event) &#123;</span><br><span class="line">  console.log(&#x27;Storage event received:&#x27;, event);</span><br><span class="line">  console.log(&#x27;Key:&#x27;, event.key);</span><br><span class="line">  console.log(&#x27;Old value:&#x27;, event.oldValue);</span><br><span class="line">  console.log(&#x27;New value:&#x27;, event.newValue);</span><br><span class="line">  console.log(&#x27;URL:&#x27;, event.url);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>当你在 <strong>Tab A</strong> 中设置了 <code>localStorage</code> 后，<strong>Tab B</strong> 会立即接收到 <code>storage</code> 事件，并输出类似如下的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Storage event received: StorageEvent &#123;…&#125;</span><br><span class="line">Key: key</span><br><span class="line">Old value: null</span><br><span class="line">New value: value</span><br><span class="line">URL: https://example.com/</span><br></pre></td></tr></table></figure></li><li><p>如果你在 <strong>Tab B</strong> 中也设置了相同的 <code>localStorage</code> 项，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&#x27;key&#x27;, &#x27;newValue&#x27;);</span><br></pre></td></tr></table></figure></li><li><p><strong>Tab B</strong> 自身不会触发 <code>storage</code> 事件，但 <strong>Tab A</strong> 会接收到 <code>storage</code> 事件，并显示相应的更新信息。</p></li></ol><h4 id="常见使用语法"><a href="#常见使用语法" class="headerlink" title="常见使用语法"></a><strong>常见使用语法</strong></h4><p>设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;cfangxu&#x27;</span>);</span><br></pre></td></tr></table></figure><p>获取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;username&#x27;</span>)</span><br></pre></td></tr></table></figure><p>获取键名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">key</span>(<span class="number">0</span>) <span class="comment">//获取第一个键名</span></span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;username&#x27;</span>)</span><br></pre></td></tr></table></figure><p>一次性清除所有存储</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure><p><code>localStorage</code> 也不是完美的，它有两个缺点：</p><ul><li>无法像<code>Cookie</code>一样设置过期时间</li><li>只能存入<code>字符串</code>，无法直接存对象，如果尝试存储一个对象，它会自动调用该对象的 <code>toString()</code> 方法，这通常会导致数据丢失或无法正确恢复原始对象；存入对象之前必须先<code>序列化</code>。</li></ul><h4 id="和cookie的区别与联系"><a href="#和cookie的区别与联系" class="headerlink" title="和cookie的区别与联系"></a>和cookie的区别与联系</h4><ul><li><strong>过期时间</strong>：<code>localStorage</code> 无法像<code>Cookie</code>一样设置<code>过期时间</code>，数据在本地的存储是<code>持久化</code>的，除非主动删除数据，否则数据<code>永不过期</code>。</li><li><strong>存取方式</strong>：<code>localStorage</code>中的数据必须<code>手动存取</code>，而<code>cookie</code>中的数据是<code>自动存取</code>的</li><li><strong>同源策略</strong>：<code>localStorage</code>严格遵循同源策略，同源页面才能共享同一份<code>localStorage</code>中的数据；虽然 Cookies 也默认遵循同源策略，但可以通过特定的设置来实现<code>跨子域的数据共享</code>。</li><li><strong>大小限制</strong>：二者都有存储大小的限制，每个<code>cookie</code>的存储大小限制是4kB，而每个页面的<code>localStorage</code>的存储大小限制一般是5MB，明显更大。</li><li><strong>存储类型</strong>：二者只能存储<code>字符串</code>。这意味着如果你想要存储对象或其他复杂的数据结构，需要进行<code>序列化</code>和<code>反序列化</code>操作。</li></ul><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p><code>sessionStorage</code>和 <code>localStorage</code>使用方法基本一致，唯一不同的是<code>生命周期</code>，<strong>一旦页面（会话）关闭，<code>sessionStorage</code> 中的数据将会被删除。</strong></p><h3 id="前端扩展存储方式"><a href="#前端扩展存储方式" class="headerlink" title="前端扩展存储方式"></a>前端扩展存储方式</h3><p>虽然 <code>Web Storage</code>对于存储较少量的数据很有用，但对于存储更大量的结构化数据来说，这种方法不太有用。<code>IndexedDB</code>提供了一个解决方案。</p><p><code>indexedDB</code>是一种低级API，用于客户端存储大量结构化数据(包括, 文件&#x2F; blobs)。该API使用<code>索引(index)</code>来实现对该数据的高性能搜索。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>储存量理论上没有上限</li><li>所有操作都是<code>异步</code>的，相比 <code>LocalStorage</code> 同步操作性能更高，尤其是数据量较大时</li><li>原生支持储存<code>JS</code>的对象</li><li>是个正经的数据库，意味着数据库能干的事它都能干</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>操作非常繁琐</li><li>本身有一定门槛</li></ul><p>关于<code>indexedDB</code>的使用基本使用步骤如下：</p><ul><li>打开数据库并且开始一个事务</li><li>创建一个 <code>object store</code></li><li>构建一个请求来执行一些数据库操作，像增加或提取数据等。</li><li>通过监听正确类型的 <code>DOM</code> 事件以等待操作完成。</li><li>在操作结果上进行一些操作（可以在 <code>request</code>对象中找到）</li></ul><p>关于使用<code>indexdb</code>的使用会比较繁琐，大家可以通过使用<code>Godb.js</code>库进行缓存，最大化的降低操作难度</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>标记用户与跟踪用户行为的情况，推荐使用<code>cookie</code></li><li>适合长期保存在本地的数据（令牌），推荐使用<code>localStorage</code></li><li>敏感账号一次性登录，推荐使用<code>sessionStorage</code></li><li>存储大量数据的情况、在线文档（富文本编辑器）保存编辑历史的情况，推荐使用<code>indexedDB</code></li></ul><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>是一种创建<strong>交互式网页</strong>应用的<strong>开发技术</strong>, 可以在<strong>不重新加载</strong>整个网页的情况下，<strong>与服务器交换数据</strong>，并且局部更新网页。</p><p><code>Ajax</code>的原理简单来说就是通过<code>XmlHttpRequest(xhr)</code>对象向服务器发送<strong>异步请求</strong>，收到服务器响应的数据后，用<code>Js</code>操作<code>DOM</code>来更新页面。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ul><li><p>创建 <code>Ajax</code>的核心对象 <code>XMLHttpRequest</code>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure></li><li><p>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法初始化一个 HTTP 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">open</span>(method, url, [<span class="keyword">async</span>][, user][, password])</span><br></pre></td></tr></table></figure><ul><li><code>method</code>：表示当前的请求方式，常见的有<code>GET</code>、<code>POST</code></li><li><code>url</code>：服务端地址</li><li><code>async</code>：布尔值，表示是否异步执行操作，默认为<code>true</code></li><li><code>user</code>: 可选的用户名用于认证用途；默认为<code>null</code></li><li><code>password</code>: 可选的密码用于认证用途，默认为<code>null</code></li></ul></li><li><p>构建请求所需的<code>数据内容</code>，并通过<code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="title function_">send</span>([body])<span class="comment">//如果请求体中不需要携带数据，什么都不要传入</span></span><br></pre></td></tr></table></figure></li><li><p>通过 <code>XMLHttpRequest</code> 对象提供的 <code>onreadystatechange</code> 事件（即<code>监听(on)准备状态(readystate)改变(change)</code>）监听服务器端的通信状态。</p><p>关于<code>XMLHttpRequest.readyState</code>属性有五个状态，用数字来区分，只要 <code>readyState</code>属性值一变化，就会触发一次 <code>readystatechange</code> 事件。</p><ul><li>0（unsent）：<code>open</code>方法还未调用，连接还未建立。</li><li>1（opened)：<code>open</code>方法调用了，但是还未发送请求（还未调用<code>send</code>方法）</li><li>2（headers_recieved）：请求发送了，<code>响应头</code>和<code>响应状态</code>已经接收到了，但是还未开始下载。</li><li>3（loading）：<code>响应体</code>下载中</li><li>4（done）：响应体下载完毕，请求完成。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line"><span class="comment">//request的三个常用属性</span></span><br><span class="line"><span class="comment">//request.readyState  查看请求的状态</span></span><br><span class="line"><span class="comment">//request.status 响应状态码</span></span><br><span class="line"><span class="comment">//request.responseText 响应文本</span></span><br><span class="line">request.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(request.<span class="property">readyState</span> === <span class="number">4</span>)&#123; <span class="comment">// 整个请求过程完毕</span></span><br><span class="line">        <span class="keyword">if</span>(request.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; request.<span class="property">status</span> &lt;= <span class="number">300</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">responseText</span>) <span class="comment">// 服务端返回的结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request.<span class="property">status</span> &gt;=<span class="number">400</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;错误信息：&quot;</span> + request.<span class="property">status</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于初始化一个 HTTP 请求。这个方法并不发送请求，而是为后续的 request.send() 调用做准备</span></span><br><span class="line">request.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;http://xxxx&#x27;</span>)</span><br><span class="line">request.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure></li><li><p><strong>接受并处理</strong>服务端向客户端响应的数据结果</p></li><li><p>将处理结果<strong>更新</strong>到 <code>HTML</code>页面中</p></li></ul><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><code>axios</code> 是一个基于<code>promise</code>的网络请求库，在浏览器端借助<code>XHR</code>，在<code>node.js</code>中借助<code>http</code>模块</p><p>有如下特点：</p><ul><li>拦截请求和响应</li><li>转换请求数据和响应数据</li><li>取消请求</li><li>自动转换<code>JSON</code> 数据</li><li>客户端支持防御<code>XSRF</code></li></ul><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>在浏览器中可以通过<code>script</code>标签直接引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在node模块化开发环境中，可以通过<code>npm包</code>的形式下载，需要使用的时候再导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --S //安装到开发环境</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>在线文档关于<code>axios</code>的介绍说实话没有让人看下去的动力，这里写点自己的东西。</p><ul><li><p><strong>使用axios.create创建axios实例</strong></p><p>创建出来的实例具有与axios一样的功能，这样就相当于为每个请求都配置了相同的<code>基地址</code>,<code>超时时间</code>，<code>响应头</code>，这不就起到了<code>封装</code>的作用吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//request.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://smart-shop.itheima.net/index.php?s=/api&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;platform&#x27;</span>: <span class="string">&#x27;H5&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>给axios实例添加响应拦截器，请求拦截器。</strong></p><p>响应拦截器返回（return）的数据，其实就是axios请求最终返回的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">  <span class="comment">// 只要有token，就在请求时携带，便于请求需要授权的接口</span></span><br><span class="line">  <span class="comment">// 每次请求都会获取token,也就是说token每次都是现用现取的，如果删除了就取不到了</span></span><br><span class="line">  <span class="keyword">const</span> token = store.<span class="property">getters</span>.<span class="property">token</span></span><br><span class="line">  <span class="keyword">if</span> (token) &#123;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;Access-Token&#x27;</span>] = token</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// 2xx 范围内的状态码(response.status)都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">  <span class="keyword">return</span> response.<span class="property">data</span> <span class="comment">//默认会被包装成resolved类型的promise对象</span></span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error) <span class="comment">//如果直接返回error，也会被包装成resolved类型的promise对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>取消请求</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios.CancelToken是一个构造函数，用来获得取消令牌源对象。</span></span><br><span class="line"><span class="comment">// source是一个取消令牌源对象。这个对象包含了两个重要的属性：</span></span><br><span class="line"><span class="comment">// token: 这是一个实际的取消令牌。你可以将这个令牌传递给 Axios 请求配置中的 cancelToken 属性，从而使得该请求可以被取消。</span></span><br><span class="line"><span class="comment">// cancel: 这是一个函数，调用它可以取消所有关联了source.token 的请求。</span></span><br><span class="line"><span class="comment">// 你可以选择性地提供一个消息参数，这个消息会作为取消原因包含在取消事件中。</span></span><br><span class="line"><span class="keyword">const</span> source = axios.<span class="property">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;xxxx&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">cancelToken</span>: source.<span class="property">token</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 取消请求 (请求原因是可选的)</span></span><br><span class="line"><span class="comment">// 调用source.cancel(&#x27;取消原因&#x27;) 时，它会将关联的 cancelToken 标记为已取消状态，并记录提供的取消原因（如 &#x27;取消原因&#x27;）</span></span><br><span class="line"><span class="comment">// 这个操作不会直接发送网络请求，而是改变了令牌的状态。</span></span><br><span class="line">source.<span class="title function_">cancel</span>(<span class="string">&#x27;主动取消请求&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>想要取消请求，需要先使用<code>axios.CancelToken</code>生成一个<code>取消令牌源对象source</code>，然后再请求中配置<code>cancelToken</code>属性的值为<code>source.token</code>，当想要取消请求的时候，就调用<code>source.cancel()</code>方法，传入取消请求的原因。</p><p>调用<code>source.cancel(&#39;取消原因&#39;) 时</code>，它会将关联的 <code>cancelToken</code> 标记为已取消状态，并记录提供的取消原因（如 ‘取消原因’）<br> 这个操作<strong>不会直接发送网络请求，而是改变了令牌的状态。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="comment">//获得取消请求源对象</span></span><br><span class="line"><span class="keyword">const</span> source = <span class="title class_">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(source.<span class="property">token</span>)<span class="comment">//输出token，结构如下</span></span><br></pre></td></tr></table></figure><img src="..\images\前端面试-vue\取消请求2.png" style="zoom:85%;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line"><span class="keyword">const</span> source = <span class="title class_">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line">source.<span class="title function_">cancel</span>(<span class="string">&#x27;主动取消&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(source.<span class="property">token</span>)</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-vue\取消请求.png" style="zoom:80%;" /><p>Axios 的<code>响应拦截器</code>会检查每个正在处理的请求是否关联了被标记为<strong>已取消</strong>的 <code>cancelToken</code>。如果匹配，则立即停止该请求的进一步处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给axios实例，添加响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// 2xx 范围内的状态码都会触发该函数</span></span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 清除loading效果</span></span><br><span class="line">  <span class="title class_">Toast</span>.<span class="title function_">clear</span>();</span><br><span class="line">  <span class="comment">// 判断是否是因为取消操作导致的错误</span></span><br><span class="line">  <span class="keyword">if</span> (axios.<span class="title function_">isCancel</span>(error)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request canceled:&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他错误处理</span></span><br><span class="line">    <span class="title class_">Toast</span>(<span class="string">&#x27;请求失败，请稍后重试&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简单的来说，我们想要某个请求被取消，那么这个请求必须携带<code>cancelToken</code>，当我们想要取消请求的时候，就调用<code>source.cancel()</code>方法并传入取消的原因，这个操作并不会发送新的请求，而是会修改<code>cancelToken</code>的状态，然后响应拦截器根据<code>cancelToken</code>的状态，判断不再需要处理这个请求，所以说，请求取消，完全不需要后端配合，请求发送后无论如何都会被响应，取消请求只不过是抛弃了响应结果。</p></li><li><p><strong>导出配置好的axios实例</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure></li><li><p><strong>使用axios发送请求</strong></p><p>我们通常把同一业务功能的<code>api</code>放到一个js文件中，比如和购物车<code>cart</code>相关的接口都放在<code>cart.js</code>文件中，在这些文件中引入导出的axios实例来发送请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import request from &#x27;index.js&#x27;</span><br></pre></td></tr></table></figure><p>发送请求有<strong>两种</strong>常用写法</p><ul><li><p><strong>request({})</strong></p><p>这种写法是直接传入一个<code>配置对象</code>，<code>请求方法(method)</code>等所有信息都包含在内,我们需要对大部分<strong>配置属性</strong>都熟悉</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>:</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:</span><br><span class="line">    <span class="attr">data</span>:</span><br><span class="line">    <span class="attr">headers</span>:</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>request.method()</strong></p><p>这种写法是把<code>请求方法</code>提取到外面，然后传入多个参数来实现的。</p><p>第一个参数指定请求的 <strong>URL</strong></p><p>第二个参数，如果是<code>get/delete</code>等请求就是除了<code>请求体</code>外的<code>配置对象</code>，即不包括<strong>data</strong>属性的配置对象。如果是<code>put/post</code>请求，则是<code>data</code>，即<code>请求体</code>数据对象，所以说第二个参数到底是<code>data</code>还是<code>不包括data属性的配置对象</code>，取决于请求的方法。</p><p>第三个参数，只有<code>put/post</code>请求可能需要配置第三个参数，即不包括<code>data</code>属性的配置对象。</p></li><li><p>案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import request from &#x27;@/utils/request&#x27;</span><br><span class="line">//修改购物车商品信息（这里url是模板字符串，因为使用了path参数）</span><br><span class="line">export const updateCartAPI = (&#123; skuId, selected, count &#125;) =&gt; &#123;</span><br><span class="line">  return request.put(`/member/cart/$&#123;skuId&#125;`, &#123; selected, count &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//delete也要传入data，属于接口不符合规范</span><br><span class="line">export const delCartAPI = (ids) =&gt; request(&#123; url: &#x27;/member/cart&#x27;, method: &#x27;delete&#x27;, data: &#123; ids &#125; &#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置对象和<code>接口文档</code>的对应关系</p><ul><li><p>path：需要在<strong>url</strong>中直接配置，嵌入在url的<code>资源路径</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/users/&#123;userId&#125;  ---&gt;  /users/123</span><br></pre></td></tr></table></figure></li><li><p>query：在配置对象的<code>params</code>属性中配置，会被放到url的<code>?</code>之后，并且多个参数之间用与号 <code>&amp;</code> 分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;name:&quot;tom&quot;,age:18&#125;  ---&gt;  /users?name=tom&amp;age=18</span><br></pre></td></tr></table></figure></li><li><p>body：即请求体，在<code>data</code>属性中配置</p></li><li><p>header：在配置对象的<code>headers</code>属性中配置</p></li></ul></li><li><p>配置对象和<code>请求报文</code>的对应关系</p><p>header对应请求报文中的<code>请求头</code>，data对应请求报文中的<code>请求体</code>，method请求方法，资源路径，查询参数等出现在<code>请求行</code>中。</p></li></ul><h3 id="响应结果结构分析"><a href="#响应结果结构分析" class="headerlink" title="响应结果结构分析"></a>响应结果结构分析</h3><img src="..\images\前端面试-js\axios.png" style="zoom:90%;" /><p>可以注意到status和data是同一级别的数据，在响应拦截器中常常通过<code>response.status</code>来判断执行哪个函数</p><p>响应错误对象的<code>response</code>属性则有与响应成功对象<code>一样</code>的结构</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//request.js</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Toast</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span></span><br><span class="line"><span class="comment">// 创建 axios 实例，将来对创建出来的实例，进行自定义配置</span></span><br><span class="line"><span class="comment">// 好处：不会污染原始的 axios 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://smart-shop.itheima.net/index.php?s=/api&#x27;</span>,<span class="comment">//设置基地址</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span>,<span class="comment">//设置请求超时时间</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;platform&#x27;</span>: <span class="string">&#x27;H5&#x27;</span>,<span class="comment">//固定的请求头，每次请求都会携带</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//给axios实例，添加请求拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">  <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">  <span class="comment">// 开启loading，禁止背景点击 (节流处理，防止多次无效触发)</span></span><br><span class="line">  <span class="title class_">Toast</span>.<span class="title function_">loading</span>(&#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;加载中...&#x27;</span>,</span><br><span class="line">    <span class="attr">forbidClick</span>: <span class="literal">true</span>, <span class="comment">// 禁止背景点击</span></span><br><span class="line">    <span class="attr">loadingType</span>: <span class="string">&#x27;spinner&#x27;</span>, <span class="comment">// 配置loading图标</span></span><br><span class="line">    <span class="attr">duration</span>: <span class="number">0</span> <span class="comment">// 不会自动消失</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只要有token，就在请求时携带，便于请求需要授权的接口</span></span><br><span class="line">  <span class="comment">// 每次请求都会获取token,也就是说token每次都是现用现取的，如果删除了就取不到了</span></span><br><span class="line">  <span class="keyword">const</span> token = store.<span class="property">getters</span>[<span class="string">&#x27;user/token&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> (token) &#123;</span><br><span class="line">    config.<span class="property">headers</span>[<span class="string">&#x27;Access-Token&#x27;</span>] = token</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给axios实例，添加响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 对响应数据做点什么，默认axios会多包装一层data，需要响应拦截器中处理一下，简化返回数据的结构</span></span><br><span class="line">  <span class="keyword">const</span> res = response.<span class="property">data</span></span><br><span class="line">  <span class="keyword">if</span> (res.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 给错误提示, Toast 默认是单例模式，后面的 Toast调用了，会将前一个 Toast 效果覆盖</span></span><br><span class="line">    <span class="comment">// 同时只能存在一个 Toast</span></span><br><span class="line">    <span class="title class_">Toast</span>(res.<span class="property">message</span>)</span><br><span class="line">    <span class="comment">// 抛出一个错误的promise</span></span><br><span class="line">    <span class="comment">// 即便响应成功了也要包装成错误么，但是我就不想用try-catch处理await的错误，转而使用消息提示，而不是页面爆红。</span></span><br><span class="line">    <span class="comment">// return Promise.reject(res.message)</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 正确情况，直接走业务核心逻辑，清除loading效果</span></span><br><span class="line">    <span class="title class_">Toast</span>.<span class="title function_">clear</span>()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">  <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出配置好的实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure><h3 id="实现一个简易版的axios"><a href="#实现一个简易版的axios" class="headerlink" title="实现一个简易版的axios"></a>实现一个简易版的axios</h3><p>构建一个<code>Axios</code>构造函数，核心代码为<code>request</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Axios</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//因为axios实例并没有什么常用的属性，所以这里没有任何初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心方法request，会自动挂载到Axios.prototype上，传入配置对象，立即返回一个promise对象（状态为pending）</span></span><br><span class="line">    <span class="title function_">request</span>(<span class="params">config</span>) &#123;</span><br><span class="line">        <span class="comment">//request方法会立即返回一个promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//对象解构赋值，获取到请求url，method（默认值是Get），data，并给这些属性赋予默认值</span></span><br><span class="line">            <span class="comment">//实际请求携带的配置参数可能不止这么点</span></span><br><span class="line">            <span class="keyword">const</span> &#123;url = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;get&#x27;</span>, data = &#123;&#125;&#125; = config;</span><br><span class="line">            <span class="comment">// 发送ajax请求</span></span><br><span class="line">            <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//用于初始化一个 HTTP 请求。这个方法并不发送请求</span></span><br><span class="line">            <span class="comment">//第三个参数是一个布尔值，表示是否异步执行请求，默认为true，表示异步。</span></span><br><span class="line">            xhr.<span class="title function_">open</span>(method, url[, <span class="literal">true</span>]);</span><br><span class="line">            xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="comment">//当请求被响应，根据响应状态码，改变promise对象的状态</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">                <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);<span class="comment">//这一操作，就把异步回调函数内的值传递到外部了，避免依赖这个数据的代码写在回调函数内</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送请求并携带数据</span></span><br><span class="line">            xhr.<span class="title function_">send</span>(data);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出request方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">CreateAxiosFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> axios = <span class="keyword">new</span> <span class="title class_">Axios</span>();</span><br><span class="line">    <span class="keyword">let</span> req = <span class="keyword">function</span>(<span class="params">config</span>)&#123;axios.<span class="title function_">request</span>(config)&#125;;</span><br><span class="line">    <span class="keyword">return</span> req;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 得到最后的全局变量axios(是一个函数)，说白了这个axios(不是axios实例)就是在冒充axios.request()</span></span><br><span class="line"><span class="keyword">let</span> axios = <span class="title class_">CreateAxiosFn</span>();</span><br></pre></td></tr></table></figure><p>上述代码就已经能够实现<code>axios(&#123;&#125;)</code>这种方式的请求</p><p>下面是来实现下<code>axios.method()</code>这种形式的请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methodsArr = [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>, <span class="string">&#x27;post&#x27;</span>];</span><br><span class="line"><span class="comment">//在Axios的prototype上挂载这些方法</span></span><br><span class="line"><span class="comment">//这种写法功能等同于直接在Axios类中一个个定义这些方法，不过更简洁。</span></span><br><span class="line">methodsArr.<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">Axios</span>.<span class="property"><span class="keyword">prototype</span></span>[method] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 处理只可能传入2个参数的方法</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>].<span class="title function_">includes</span>(method)) &#123; <span class="comment">// 2个参数(url[, config])</span></span><br><span class="line">            <span class="comment">//此处的this指向axios实例，所以能调用request方法，同时也说明这些方法本质也是在调用request方法</span></span><br><span class="line">            <span class="comment">//arguments 是一个类数组对象，它包含了传递给函数的所有参数</span></span><br><span class="line">            <span class="comment">//arguments 对象允许你在不知道具体有多少个参数的情况下访问所有传递给函数的参数,即便函数没有声明形参</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">                method,</span><br><span class="line">                <span class="attr">url</span>: <span class="variable language_">arguments</span>[<span class="number">0</span>],</span><br><span class="line">                ...(<span class="variable language_">arguments</span>[<span class="number">1</span>] || &#123;&#125;)<span class="comment">//如果第二个参数没传入，arguments[1]的值就是undefined，然后展开一个空对象</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3个参数(url[,data[,config]])</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">request</span>(&#123;</span><br><span class="line">                method,</span><br><span class="line">                <span class="attr">url</span>: <span class="variable language_">arguments</span>[<span class="number">0</span>],</span><br><span class="line">                <span class="attr">data</span>: <span class="variable language_">arguments</span>[<span class="number">1</span>] || &#123;&#125;,<span class="comment">//arguments[1]是一个数据对象，不需要展开</span></span><br><span class="line">                ...<span class="variable language_">arguments</span>[<span class="number">2</span>] || &#123;&#125;<span class="comment">//arguments[2]是剩余配置属性对象，需要展开</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>get，post这些方法与<code>request</code>方法一样，都挂载到<code>Axios.prototype</code>上，虽然这些方法本质是在调用<code>Axios.prototype.request</code>方法，但是它们还是属于<code>同级别</code>的关系。这些方法能通过<code>axios实例</code>调用，但是不能通过<code>axios</code>函数调用，但是我们得到<code>axios</code>应该是函数，我们因该要能通过<code>axios函数</code>调用这些方法。</p><h2 id="文件上传怎么做"><a href="#文件上传怎么做" class="headerlink" title="文件上传怎么做"></a>文件上传怎么做</h2><img src="..\images\前端面试-js\文件上传.png" style="zoom: 75%;" /><h3 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h3><p>借助input标签，点击选择文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">class</span>=<span class="string">&quot;postImage&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> postImage = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.postImage&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">   postImage.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>])<span class="comment">//是一个File对象</span></span></span><br><span class="line"><span class="language-javascript">   &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 选择文件后可以通过<code>e.target.files</code>获取到文件对象File数组</p><p>为什么是<code>files</code>呢，因为如果我们给input标签添加multiply属性，是允许选择多个文件的，也就是多文件上传，不过这要求用户有一定的电脑操作基础，要知道如何选择多个文件。所以开发过程中的方案其实是<code>多次单文件上传</code>，用一个数组存储每次循环的选择的文件对象。</p><h3 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h3><img src="..\images\前端面试-js\file.png" style="zoom:80%;" /><p><strong>常见属性</strong>：</p><ul><li>size属性：表示文件的<strong>字节数（B</strong>），可用来限制文件的大小</li><li>type属性：表示文件的类型</li></ul><p><strong>和Blob对象的关系</strong></p><p>属于Blob类的子类，二者可以随意转换；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Blob</span>([file]);<span class="keyword">new</span> <span class="title class_">File</span>([blob],filename)</span><br></pre></td></tr></table></figure><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>故名思义，可以转换文件对象，比如可以把<code>文件对象</code>异步转换成<code>base64</code>格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>()<span class="comment">//创建一个reader对象</span></span><br><span class="line">reader.<span class="title function_">readAsDataUrl</span>(file)<span class="comment">//调用readAsDataUrl方法，传入file对象</span></span><br><span class="line"><span class="comment">//把file对象转化成base64格式是*异步*的，监听reader的onload事件；需要在回调函数中拿到结果result</span></span><br><span class="line">reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(reader.<span class="property">result</span>)&#125;</span><br></pre></td></tr></table></figure><p>Blob对象也可以使用FileReader的语法</p><h3 id="URL-createObjectURL-file-blob"><a href="#URL-createObjectURL-file-blob" class="headerlink" title="URL.createObjectURL(file&#x2F;blob)"></a>URL.createObjectURL(file&#x2F;blob)</h3><p><code>URL.createObjectURL</code>会生成一个指向 Blob 或 File 对象的<code>临时 URL</code>。这个 URL 可以被用作 <code>&lt;img&gt;、&lt;video&gt;、&lt;audio&gt;、&lt;a&gt; </code>等 HTML 元素的 src 或 href 属性，用来展示。</p><p>允许在<code>不暴露文件的实际路径（网络图片）或内容（base64格式的图片）</code>的前提下，显示文件，增加了<code>安全性</code></p><p>对象 URL 是<code>临时的</code>，浏览器会自动在<code>页面卸载</code>时释放这些 URL。但是，为了确保最佳性能和避免内存泄漏，你应该在不再需要时，显式调用<code> URL.revokeObjectURL</code>。</p><p>举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;postImage&quot;</span>&gt;</span>更换图片<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">class</span>=<span class="string">&quot;postImage&quot;</span> <span class="attr">id</span>=<span class="string">&quot;postImage&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> postImage = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.postImage&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  postImage.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> url = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>])</span></span><br><span class="line"><span class="language-javascript">    img.<span class="property">src</span>= url</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="..\images\前端面试-js\临时url.png" style="zoom:85%;" /><h3 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fd = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line">fd.<span class="title function_">append</span>(<span class="string">&#x27;img&#x27;</span>, e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>])</span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">   <span class="attr">url</span>: <span class="string">&quot;http://localhost:8080/upload&quot;</span>,</span><br><span class="line">   <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">   <span class="attr">data</span>: fd<span class="comment">//直接当作请求体对象</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p><code>FormData</code> 对象允许你构造一组键&#x2F;值对，这组键&#x2F;值对可以被轻松地序列化为 <code>application/x-www-form-urlencoded</code> 或 <code>multipart/form-data</code> 格式，非常适合用来<strong>模拟 HTML 表单提交</strong>。</p></li><li><p>使用 <code>append()</code> 方法可以向 <code>FormData</code> 对象中添加字段或<strong>文件</strong>。</p></li><li><p>当 <code>FormData</code> 包含文件(File)时，<code>axios</code> 会自动设置请求头 <code>Content-Type</code> 为 <code>multipart/form-data</code>，这是文件上传的标准格式。</p><p>即便是一个和FormData对象内容<code>完全一致</code>的不同对象也做不到这点。</p></li></ul><h3 id="图像展示方法"><a href="#图像展示方法" class="headerlink" title="图像展示方法"></a>图像展示方法</h3><ul><li>拿到本地图片file对象，转换成<code>base64格式</code>的图片（由图片文件数据编码而来的一个字符串）</li><li>拿到本地图片file对象，生成一个<code>临时url</code>（只能用来展示）</li><li>网络图片链接，会自动发送一个请求获取图片</li></ul><h3 id="文件可上传格式"><a href="#文件可上传格式" class="headerlink" title="文件可上传格式"></a>文件可上传格式</h3><ul><li>file&#x2F;blob（二进制）</li><li>base64（即可展示又可上传，无敌了）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试---vue部分</title>
      <link href="/posts/f33bd2b9.html"/>
      <url>/posts/f33bd2b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h1><p>推荐一个学习vue的网站：<a href="https://www.vue3js.cn/">Vue3</a></p><h2 id="说说你对vue的理解"><a href="#说说你对vue的理解" class="headerlink" title="说说你对vue的理解"></a>说说你对vue的理解</h2><h3 id="前端发展背景"><a href="#前端发展背景" class="headerlink" title="前端发展背景"></a>前端发展背景</h3><p>最早的网页是没有数据库的，可以理解成就是一张可以在网络上浏览的报纸，就是<code>纯静态页面</code></p><p>直到<code>CGI</code>技术的出现通过 CGI Perl 运行一小段代码与数据库或文件系统进行<code>交互</code>(前后端交互)</p><p>后来JSP(Java Server Pages)技术取代了CGI技术，其实就是Java + HTML</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=utf-8&quot;</span> pageEncoding=<span class="string">&quot;utf-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;utf-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;JSP demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=<span class="string">&quot;http://localhost:8080/web05_session/1.jpg&quot;</span> width=<span class="string">&quot;200&quot;</span> height=<span class="string">&quot;100&quot;</span> alt=<span class="string">&quot;示例图片&quot;</span> /&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>JSP有一个很大的<code>缺点</code>，就是不太灵活。JSP使用<code> Java</code> 而不是<code> JavaScript</code>，并且 Java 代码只能在服务器端运行。我们每次的请求：获取的数据、内容的加载，服务器都会做对应的处理，并渲染dom然后返回渲染好的dom，简单的来说，JSP把页面的渲染工作完全交给后端服务器。</p><p>后来<code>ajax</code>火了，它允许用户在不刷新整个页面的前提下，和后端服务器交换数据，并由浏览器执行js代码，更新部分页面。</p><p>随后移动设备的普及，Jquery的出现，以及SPA（Single Page Application 单页面应用）的雏形，Backbone EmberJS AngularJS 这样一批前端框架随之出现，但当时SPA的路不好走，例如SEO问题，SPA 过多的页面、复杂场景下 View 的绑定等，都没有很好的处理经过这几年的飞速发展，节约了开发人员大量的精力、降低了开发者和开发过程的门槛，极大提升了开发效率和迭代速度。我们可以看到Web技术的变化之大与快，每一种新的技术出现都是一些特定场景的解决方案，那我们今天的主角Vue又是为了解决什么呢？</p><h3 id="Vue是什么"><a href="#Vue是什么" class="headerlink" title="Vue是什么"></a>Vue是什么</h3><p>是一个用于创建<code>用户界面</code>的开源<code>JavaScript框架</code>，也是一个创建<code>单页应用（SPA）</code>的前端框架。</p><h3 id="Vue核心特性"><a href="#Vue核心特性" class="headerlink" title="Vue核心特性"></a><strong>Vue核心特性</strong></h3><ul><li><p><strong>数据驱动视图更新</strong></p><p>数据驱动(MVVM)</p><p>MVVM表示的是 Model-View-ViewModel</p><ul><li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li><li>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面</li><li>ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁，在vue中这个桥梁是vue实例</li></ul></li><li><p><strong>组件化</strong></p><p>降低了代码的耦合度，可维护性，可扩展性高，便于调试</p></li><li><p><strong>指令系统</strong></p><p>指令 (Directives) 是带有<code> v- 前缀</code>的<code>特殊属性</code>，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p><p>常用的指令</p><ul><li>条件渲染指令 <code>v-if</code></li><li>列表渲染指令<code>v-for</code></li><li>属性绑定指令<code>v-bind</code></li><li>事件绑定指令<code>v-on</code></li><li>双向数据绑定指令<code>v-model</code></li></ul></li></ul><h2 id="说说你对vue双向绑定的理解"><a href="#说说你对vue双向绑定的理解" class="headerlink" title="说说你对vue双向绑定的理解"></a>说说你对vue双向绑定的理解</h2><p><code>双向绑定</code>不等同于<code>响应式</code>了，这两个东西是有区别的。</p><p><code>响应性</code>是一种可以使我们声明式地处理变化的编程范式。简单来讲就是当更改<code>响应式数据</code>时，视图会随即<code>自动更新</code>。而实现这个功能的原理就是劫持数据，收集依赖，当数据发生变化时，执行相应的依赖（副作用&#x2F;更新视图）。响应式的具体实现原理可以参考后面的文章《说说Vue实例挂载过程中发生了什么》，《手写一个简单的vue》，《说说你对Vue.observable的理解》。</p><p><code>双向绑定</code>是数据变化驱动视图更新，视图更新触发数据变化。其实就是<code>v-model</code>的功能，而我们知道<code>v-model</code>只是一个语法糖。因此如果要问双向绑定的原理，思路应该是<strong>如何实现这个语法糖</strong>。其原理是把<code>input</code>的value绑定data的一个值，当原生input的事件触发时，用事件的值来更新data的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用 v-model --&gt;</span><br><span class="line">&lt;input v-model=&quot;message&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 编译后的等效代码 --&gt;</span><br><span class="line">&lt;input :value=&quot;message&quot; @input=&quot;e =&gt; &#123;message = e.target.value&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue的学习路线"><a href="#Vue的学习路线" class="headerlink" title="Vue的学习路线"></a><strong>Vue的学习路线</strong></h2><h3 id="原生开发"><a href="#原生开发" class="headerlink" title="原生开发"></a><strong>原生开发</strong></h3><p>通过script标签引入vue.js,src属性通常是http链接，或者下载到本地的vue.js文件的路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果是http链接，当浏览器加载这个脚本会发送一个get请求获取并执行vue的js代码，类似jsonp请求。</p><p>引入vue.js后，<strong>Vue</strong>这个构造函数成为<strong>全局变量</strong>，挂载到<strong>window</strong>对象上</p><p>然后我们在页面的<strong>script</strong>标签中写些代码，创建一个vue实例，传入一个配置对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时我们还未引入<strong>组件</strong>的概念，但是我们已经能够学习vue的大部分知识点了。包括模板语法，数据绑定，数据代理如何实现，vue的常用指令，计算属性，数据监听，vue的生命周期等等。</p><h3 id="原生开发之组件化开发"><a href="#原生开发之组件化开发" class="headerlink" title="原生开发之组件化开发"></a><strong>原生开发之组件化开发</strong></h3><p>什么组件？组件化开发有什么好处？</p><p>在vue中，组件就是能实现<code>局部功能</code>的<code>html，css，js</code>代码的集合，组件化开发有利于<strong>代码复用</strong>，提高开发效率，同时把功能上密切相关的html，css，js代码放到一起，<strong>依赖关系明确</strong>，易于维护。</p><p>vue的组件可分为<strong>单文件组件</strong>和<strong>非单文件组件</strong>，非单文件组件就是通过<strong>Vue.extend({})<strong>，返回一个</strong>VueComponent</strong>构造函数，这个</p><p>构造函数被用来创建<strong>组件实例</strong>，依赖的<strong>配置对象</strong>就是<code>Vue.extend(&#123;&#125;)</code>传入的对象，这个配置对象的结构和<code>new Vue()</code>传入的配置对象的结构几乎一致。存在如下关系，即<code>Vuecomponent</code>是Vue的<code>子类</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">组件实例.<span class="property">_proto_</span> = <span class="title class_">VueComponent</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="title class_">VueComponent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_proto_</span> = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span></span><br></pre></td></tr></table></figure><img src="..\images\前端面试-vue\vue.png" style="zoom:80%;" /><h3 id="非单文件组件使用"><a href="#非单文件组件使用" class="headerlink" title="非单文件组件使用"></a><strong>非单文件组件使用</strong></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">:name</span>=<span class="string">&quot;str&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;str&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">School</span>&gt;</span><span class="tag">&lt;/<span class="name">School</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个school组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">School</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">str</span>: <span class="string">&quot;haha&quot;</span>,</span><br><span class="line">      <span class="attr">keyword</span>:<span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//组件注册</span></span><br><span class="line">    <span class="attr">components</span>:&#123;<span class="title class_">School</span>&#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a><strong>单文件组件</strong></h3><p>单文件组件就是我们熟知的<code>.vue</code>文件, 单文件组件解决了非单文件组件无法把<strong>css代码</strong>与html，js代码放到一起的问题。</p><p>显然，<code>.vue</code>文件是vue团队开发的文件，无法在浏览器上运行，所以我们需要借助打包工具webpack来处理这个文件，webpack又是基于nodejs的，nodejs是使用模块化开发的。这样vue的开发就过渡到了基于nodejs+webpack的<strong>模块化</strong>开发，为了简化模块化开发过程中webpack的配置，vue团队就开发了<code>vue-cli</code>，即vue的脚手架</p><p>单文件组件的大致结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>export default &#123;&#125;</code>由<code>export default Vue.extend(&#123;&#125;)</code>简化而来的，组件注册的时候会自动处理。</p><p>组件之间通过嵌套确定层级关系，所有其他组件都在根组件App.vue内，根组件直接嵌入index.html文件；组件化开发后不需要直接在html页面中写结构，内容被分解为一个一个vue组件。</p><h2 id="谈谈对el和template属性的理解"><a href="#谈谈对el和template属性的理解" class="headerlink" title="谈谈对el和template属性的理解"></a>谈谈对el和template属性的理解</h2><p>当我们在学习Vue的基础语法，vue的组件的适合一定涉及到了这两个容易混淆的属性。</p><ul><li><p><strong>创建Vue根实例必须要给出el属性</strong>，指明要为哪个容器服务，这个容器会成为<strong>模板</strong>；创建<code>组件实例</code><strong>不能</strong>传入el属性。</p></li><li><p>如果创建<strong>vue根实例</strong>同时配置了el和template属性，则template将<strong>替换el</strong>指定的容器成为模板(可以参考<code>vm.$mount</code>源码，template属性优先级更高)，不过要注意的是nodejs开发环境中，通过<code>import</code>导入的<code>vue</code>是精简版的，<strong>没有模板解析器的</strong>, 模板解析器被单独提取出来作为一个开发环境的包(生产环境打包就不会将模板解析器包含进去，从而减小最终文件的体积)，用来处理<code>.vue</code>文件中的<code>template</code>，所以在创建vue根实例的时候不能使用<code>template</code>，所以无法借助它实现在页面中自动插入Vue.app的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&#x27;&lt;App&gt;&lt;/App&gt;&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>:&#123;<span class="title class_">App</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码会报错，不能配置<code>template</code></p><p>应当修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">render</span>:<span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)<span class="comment">//传入的h是createElement函数，用来创建VNode</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>或者引入完整版的vue.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue/dist/vue.js&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>创建组件必须指定组件的结构，即template，组件的模板，不必指定组件为哪个容器服务（不要el）</p></li><li><p>el指定的容器中的<code>结构</code>可以被抽离为一个一个单独的模板<code>template</code>，一个个单独的组件，也就是说模板中可以不写实际结构，只写组件标签，这些组件标签会在模板解析的时候被解析。</p></li><li><p>其实组件中的<code>template</code>也能被拆分，从而形成一个一个组件，这就是组件的嵌套。</p></li></ul><h2 id="说说Vue实例挂载过程中发生了什么"><a href="#说说Vue实例挂载过程中发生了什么" class="headerlink" title="说说Vue实例挂载过程中发生了什么"></a>说说Vue实例挂载过程中发生了什么</h2><p>我们都听过知其然知其所以然这句话</p><p>那么不知道大家是否思考过<code>new Vue()</code>这个过程中究竟做了些什么？</p><p>过程中是如何完成<code>数据的绑定</code>，又是如何将<code>数据渲染到视图</code>的等等。</p><h3 id="流程图一览"><a href="#流程图一览" class="headerlink" title="流程图一览"></a>流程图一览</h3><img src="..\images\前端面试-vue\vue挂载3.png" style="zoom: 67%;" /><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>首先找到<code>vue</code>的构造函数</p><p><strong>vue构造函数源码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：src\core\instance\index.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Vue</span> (<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">    !(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Vue</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">//如果不是Vue实例调用这个构造函数就报错</span></span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//this指向创建的Vue实例</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>options</code>是用户传递入的配置对象，包含<code>data、methods</code>等常用属性。</p><p><code>vue</code>构建函数调用了<code>_init</code>方法，并传入了<code>options</code>，所以我们关注的核心就是<code>_init</code>方法：</p><p><strong>_init方法源码</strong></p><img src="..\images\前端面试-vue\vue挂载.png" style="zoom: 80%;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//位置：src\core\instance\init.js</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">    <span class="comment">//vm = this = vue实例</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    ....</span><br><span class="line"><span class="comment">// 初始化组件生命周期标志位</span></span><br><span class="line"><span class="title function_">initLifecycle</span>(vm)</span><br><span class="line"><span class="comment">// 初始化组件事件侦听</span></span><br><span class="line"><span class="title function_">initEvents</span>(vm)</span><br><span class="line"><span class="comment">// 初始化渲染方法</span></span><br><span class="line"><span class="title function_">initRender</span>(vm)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 调用生命周期钩子&#x27;beforeCreate&#x27;</span></span><br><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 初始化注入内容，在初始化data、props之前。</span></span><br><span class="line"><span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line"><span class="comment">// 初始化 props/data/method/watch/methods/computed</span></span><br><span class="line"><span class="title function_">initState</span>(vm)</span><br><span class="line"><span class="comment">//之所以最后初始化Provide，因为Provide引用的数据就是data或者computed等属性中的。</span></span><br><span class="line"><span class="title function_">initProvide</span>(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 调用生命周期钩子&#x27;created&#x27;</span></span><br><span class="line"><span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">....</span><br><span class="line"><span class="comment">// 挂载元素</span></span><br><span class="line"><span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">   vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析后得出如下结论：</p><ul><li>在调用<code>beforeCreate</code>之前，主要做一些数据初始化的工作，<code>数据初始化</code>并未完成，像<code>data</code>、<code>props</code>这些对象内部属性无法通过<code>this</code>访问到。所以说<code>beforeCreate</code>的执行时机<code>先于data()函数调用</code></li><li>执行<code>created</code>的时候，数据已经初始化完成，能够通过<code>this</code>访问<code>data</code>、<code>props</code>这些对象的属性，但这时候并未完成<code>dom</code>的挂载，因此无法访问到<code>dom</code>元素</li><li>通过调用<code>vm.$mount</code>方法实现了dom挂载</li></ul><p>我们主要进一步分析<code>initState</code>方法</p><p><strong>initState方法源码</strong></p><img src="..\images\前端面试-vue\vue挂载2.png" style="zoom: 67%;" /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码位置：src\core\instance\state.js</span></span><br><span class="line"><span class="comment">//vm是vue实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span> (<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="comment">// 初始化组件的watcher列表</span></span><br><span class="line">  vm.<span class="property">_watchers</span> = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span></span><br><span class="line">  <span class="comment">// 初始化props</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>)</span><br><span class="line">  <span class="comment">// 初始化methods，要做的其实很简单，单纯把methods中的全部方法挂载到this上就行</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化data  </span></span><br><span class="line">    <span class="title function_">initData</span>(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">observe</span>(vm.<span class="property">_data</span> = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化computed</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line">  <span class="comment">// 初始化watch</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) &#123;</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析后发现，<code>initState</code>方法<strong>依次，统一</strong>初始化了<code>props/methods/data/computed/watch</code>，说明在<code>created</code>的时候，这些东西都准备好了</p><p>我们继续分析<code>initState</code>中的<code>initData</code>方法</p><p><strong>initData方法源码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span> (<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  <span class="comment">// 判断data的类型是不是函数，如果是则调用函数，并把返回值赋予局部变量data，同时赋值给vm._data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    ? <span class="title function_">getData</span>(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  .....</span><br><span class="line">  <span class="comment">//获取data中所有可枚举属性</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 属性名不能与methods中的属性名重复</span></span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 属性名不能与props名称重复</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) &#123; <span class="comment">// 验证key值的合法性</span></span><br><span class="line">      <span class="comment">// 将vm._data中的key属性，代理到vm上,这样就可以通过this.key访问到vm._data.key的值（this=vm）</span></span><br><span class="line">      <span class="comment">// 所以说vm._data指向的对象是代理源对象</span></span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 监听data中数据的变化，data中的数据改变会触发视图更新</span></span><br><span class="line">  <span class="comment">// 由第一行代码可知data指的是一个局部变量，它和vm._data指向同一个数据对象，由于添加了数据代理</span></span><br><span class="line">  <span class="comment">// 修改this.key的值也会触发视图更新</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读源码后发现：</p><ul><li><code>props</code>和<code>method</code>在<code>data</code>之前就被初始化了，所以<code>data</code>中的属性值不能与<code>props</code>和<code>methods</code>中的属性值<code>重复</code>；之所以要防止重复，因为它们都会被代理到<code>this(vm)</code>上（是的，包括props中的数据），都是直接通过<code>this</code>来访问，重复了就会产生冲突。同时我们也可以发现，<code>props</code>中的数据的优先级是高于<code>data</code>中的数据的，<strong>因为初始化的时机更早</strong>。</li><li><code>data</code>定义的时候可选择<code>函数形式</code>或者<code>对象形式</code>（组件只能为函数形式），<code>data()</code>函数调用是为了产出数据，挂载到<code>vm._data</code>上，然后再给数据<code>添加代理</code>，<code>添加响应式</code>，所以<code>data</code>函数被调用的时候，内部是无法通过<code>this</code>来访问其他数据的。</li><li><code>initData</code>方法把<code>vm._data</code>中的属性代理到<code>vm</code>上并给<code>vm._data</code>上的数据添加了<code>响应式</code>（实现了数据的代理，给数据添了响应式）。</li></ul><p>vue的<strong>数据代理</strong>核心在于<code>proxy</code>方法，我们来看看它做了什么</p><p><strong>proxy方法</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">target, sourceKey, key</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(target, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[sourceKey][key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      target[sourceKey][key] = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span> <span class="comment">// 允许后续删除或重新定义该属性</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br></pre></td></tr></table></figure><p>再次之后，访问<code>target.key</code>返回的就是<code>target.sourceKey.key</code>，说到底还是从target上面取数据，只不过简化了访问的路径。</p><p>vue<strong>数据监听的核心</strong>在于<code>observe</code>方法，我们来分析一下这个方法</p><p><strong>observe方法源码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || obj == <span class="literal">null</span>) &#123;  </span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Observer</span>(obj);  <span class="comment">//observe方法的核心在于调用Observer类</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>Observer类的源码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">walk</span>(value);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="title function_">walk</span>(<span class="params">obj</span>) &#123;  </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;  </span><br><span class="line">      <span class="title function_">defineReactive</span>(obj, key, obj[key]);  </span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>我们很容易发现这个类的核心是<code>defineReactive</code>方法，那么这个方法内部到底做了些什么呢？</p><p>这里我自己实现了一个<code>简易版</code>的<code>defineReactive</code>方法来帮助理解它的原理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, value</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取数据&#x27;</span>)</span><br><span class="line">      <span class="comment">//这里不能写成obj[key]，否则会陷入无限递归，即在get中触发了get</span></span><br><span class="line">      <span class="comment">//返回的是闭包中的value值，也就是说再添加get之前，先把数据取出来</span></span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="comment">// 修改的是闭包中的value值，并没有直接修改obj中的数据。</span></span><br><span class="line">      <span class="comment">// 修改obj[key]也会陷入无限递归，因为再set中触发了set</span></span><br><span class="line">      value = val</span><br><span class="line">      <span class="comment">// 触发视图更新</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;修改数据&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>defineReactive</code>方法的核心在于使用<code>Object.defineProperty</code>给对象属性<code>添加监听</code>，<strong>且没有借助其他源对象</strong>。而是闭包中的数据。真正的<code>defineReactive</code>方法要做的比上述代码多的多，比如，如果<code>val</code>的值是对象，则递归添加响应式，还有触发get要收集依赖，数据改变要触发视图更新等。</p><p>修改后的Obj对象结构如图，可以看到原来的属性被<code>覆盖</code>了，变得不可枚举。</p><img src="..\images\前端面试-vue\defineReactive.png" style="zoom:90%;" /><p>分析之后我们发现，vue2中的<code>数据代理</code>和<code>数据监听</code>都是通过<code>Object.defineProperty</code>实现的。</p><p>由下面代码可知</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">walk</span>(value);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> new Observer(obj)返回的对象应该只有一个value属性，而整个value属性的值就是一个响应式对象。</p><p>vue的构造函数中使用的挂载方法是<code>vm.$mount</code>，我们尝试分析它的源码：</p><p><strong>vm.$mount方法源码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$mount</span> = <span class="keyword">function</span> (<span class="params"></span></span><br><span class="line"><span class="params">  el?: string | Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 获取或查询元素，传入的是vm.$options.el</span></span><br><span class="line">  el = el &amp;&amp; <span class="title function_">query</span>(el)</span><br><span class="line">  <span class="comment">// vue 不允许直接挂载到body或页面文档上</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="variable language_">document</span>.<span class="property">body</span> || el === <span class="variable language_">document</span>.<span class="property">documentElement</span>) &#123;</span><br><span class="line">    <span class="comment">//抛出异常</span></span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//提取出options，后续使用不需要通过this</span></span><br><span class="line">  <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span></span><br><span class="line">  <span class="comment">//如果没有render属性,也就是说没有render函数,解析 template/el 并转换为 render 函数</span></span><br><span class="line">  <span class="keyword">if</span> (!options.<span class="property">render</span>) &#123;</span><br><span class="line">    <span class="comment">//提取出template，后续使用不需要通过this</span></span><br><span class="line">    <span class="keyword">let</span> template = options.<span class="property">template</span></span><br><span class="line">    <span class="comment">// 存在template模板，解析vue模板文件</span></span><br><span class="line">    <span class="comment">// 第一个if主要是为了处理template属性的另类值，比如id选择器，dom对象，最终都是为了转换成模板字符串</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.<span class="title function_">charAt</span>(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">          template = <span class="title function_">idToTemplate</span>(template)</span><br><span class="line">          .....</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.<span class="property">nodeType</span>) &#123;<span class="comment">//这个条件语句用于检查 template 是否是一个 DOM 节点对象</span></span><br><span class="line">        <span class="comment">//返回的是一个字符串，代表了 template 元素内部的 HTML 内容</span></span><br><span class="line">        template = template.<span class="property">innerHTML</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//抛出异常</span></span><br><span class="line">        .....</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      <span class="comment">// 如果没有template属性，通过选择器获取元素内容（即获取tempalte）</span></span><br><span class="line">      template = <span class="title function_">getOuterHTML</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时template的值如果存在，一定是HTML字符串的形式，比如&#x27;&lt;p&gt;123&lt;/p&gt;&#x27;</span></span><br><span class="line">    <span class="comment">//然后再解析这个字符串</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = <span class="title function_">compileToFunctions</span>(template, &#123;</span><br><span class="line">        <span class="comment">//省略.....</span></span><br><span class="line">      &#125;, <span class="variable language_">this</span>)</span><br><span class="line">      options.<span class="property">render</span> = render</span><br><span class="line">      options.<span class="property">staticRenderFns</span> = staticRenderFns</span><br><span class="line">      .......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读上面代码，我们能得到以下结论：</p><ul><li>根元素不能是<code>body</code>或者<code>html</code>，也就是说<code>el</code>的指向不能是这两个元素。</li><li><code>$mount</code>方法的工作流程就是，如果没有<code>render</code>函数，则<strong>解析template（模板）</strong>，如果没有template(模板)，只有<code>el</code>（选择器），则通过选择器获取<code>template</code>，然后解析<code>template</code>模板，即HTML 字符串，得到<code>render</code>方法。</li></ul><p>对<code>template</code>的解析步骤大致分为以下几步：</p><ul><li>将<code>html</code>文档片段解析成<code>ast</code>描述符</li><li>将<code>ast</code>描述符解析成字符串</li><li>生成<code>render</code>函数</li></ul><p>生成<code>render</code>函数，挂载到<code>vm</code>上后，再调用<code>mountComponent</code>开始开始渲染</p><p><strong>mountComponent方法源码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  el: ?Element,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="comment">// 如果没有获取解析的render函数，则会抛出警告</span></span><br><span class="line">  <span class="comment">// render是解析模板文件生成的</span></span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行beforeMount钩子</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      ....</span><br><span class="line">      <span class="comment">//调用_render方法生成vnode</span></span><br><span class="line">      <span class="keyword">const</span> vnode = vm.<span class="title function_">_render</span>()</span><br><span class="line">      ....</span><br><span class="line">      <span class="comment">//调用_update方法将虚拟dom转化成真实dom并放入页面</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vnode, hydrating)</span><br><span class="line">      .....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 定义更新函数</span></span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render</span></span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 监听当前组件状态，当有数据变化时，更新组件</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    <span class="title function_">before</span> () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据更新引发的组件更新</span></span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法主要执行在<code>vue</code>初始化时声明的<code>_render</code>，<code>_update</code>方法，<code>_render</code>的作用主要是生成<code>vnode</code></p><p><code>_render</code>方法内部其实使用的是我们模板解析后得到的<code>render</code>函数，最终返回一个vnode。</p><p><strong>_render方法源码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">    <span class="comment">// render函数来自于组件的option</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_update</code>主要功能是调用<code>patch</code>，将<code>vnode</code>转换为真实<code>DOM</code>，并且更新到页面中。</p><h2 id="手写一个简单的Vue"><a href="#手写一个简单的Vue" class="headerlink" title="手写一个简单的Vue"></a>手写一个简单的Vue</h2><p>了解了Vue实例的挂载过程后，我们应该就能够模拟实现一个简单的Vue。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>你好啊&#123;&#123;str&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    &#123;&#123;num&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;num&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> app =  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">str</span>: <span class="string">&#x27;tom&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">       <span class="attr">num</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">add</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">num</span>++</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span><span class="comment">//假设是个对象，不是函数data()</span></span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>)</span><br><span class="line">         <span class="variable language_">this</span>.$compile(<span class="variable language_">this</span>.<span class="property">$el</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    $compile(node) &#123;</span><br><span class="line">      <span class="comment">//childNodes返回这个dom元素的所有子节点，包括文本结点</span></span><br><span class="line">      node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//nodeType 结点类型</span></span><br><span class="line">        <span class="comment">// 1 表示元素结点</span></span><br><span class="line">        <span class="comment">// 3 表示文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//递归进行模板解析</span></span><br><span class="line">          <span class="variable language_">this</span>.$compile(item)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是文本结点,进行模板替换</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$replace(item)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    $replace(item)&#123;</span><br><span class="line">      <span class="comment">//非贪婪匹配</span></span><br><span class="line">      <span class="comment">//通过textContent拿到文本结点的内容</span></span><br><span class="line">      item.<span class="property">textContent</span> = item.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">            <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key.<span class="title function_">trim</span>()]<span class="comment">//必须返回用来替换的字符串</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>vue2的生命周期函数很好实现，无非就是在特定时期调用特定的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;</span><br><span class="line">        <span class="keyword">if</span>(options.<span class="property">beforeCreate</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeCreate</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">options.<span class="property">beforeCreate</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(options.<span class="property">created</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">created</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">options.<span class="property">created</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(options.<span class="property">beforeMount</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeMount</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">options.<span class="property">beforeMount</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$el</span>= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>);</span><br><span class="line"><span class="variable language_">this</span>.$compile(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line"><span class="keyword">if</span>(options.<span class="property">mounted</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">mounted</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">options.<span class="property">mounted</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加事件"><a href="#添加事件" class="headerlink" title="添加事件"></a><strong>添加事件</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    $compile(node) &#123;</span><br><span class="line">      <span class="comment">//childNodes返回这个dom元素的所有子节点，包括文本结点</span></span><br><span class="line">      node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//nodeType 结点类型</span></span><br><span class="line">        <span class="comment">// 1 表示元素结点</span></span><br><span class="line">        <span class="comment">// 3 表示文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//@click</span></span><br><span class="line">          <span class="keyword">if</span> (item.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;@click&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">//最终还是使用了原生语法</span></span><br><span class="line">            item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="comment">// 如果此处使用的不是箭头函数，this的指向就是item了,我们要让this的指向变为vue实例。</span></span><br><span class="line">              <span class="comment">// item.getAttribute(&#x27;@click&#x27;).trim() 获取@click属性的值</span></span><br><span class="line">              <span class="comment">// 获取到这个属性的值，去除前后空格，假设是一个已有的方法名</span></span><br><span class="line">              <span class="comment">// 调用这个方法，同时修改函数的指向，使它指向vue实例，同时传入事件对象e</span></span><br><span class="line">              <span class="keyword">const</span> method = item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;@click&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">methods</span>[method].<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//递归</span></span><br><span class="line">          <span class="variable language_">this</span>.$compile(item)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$replace(item)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加代理"><a href="#添加代理" class="headerlink" title="添加代理"></a>添加代理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//把this.$data中的数据代理到this上</span></span><br><span class="line">    $proxy() &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">$data</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">          <span class="comment">//想要访问this.key，就返回this.$data[key]</span></span><br><span class="line">          <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">//想要修改this.key，就修改this.$data[key]</span></span><br><span class="line">          <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="comment">//数据未改变直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$data</span>[key]===newVal)&#123;</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$data</span>[key] = newVal</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加响应式"><a href="#添加响应式" class="headerlink" title="添加响应式"></a>添加响应式</h3><img src="..\images\前端面试-vue\响应式.png" style="zoom: 80%;" /><p>至此，我们修改数据，视图显然是不会更新的，即没有实现<code>数据驱动视图更新的效果</code>，简单来说，就是没有实现<strong>响应式</strong>。</p><p>想要实现响应式，<strong>我们需要监听数据，并收集依赖</strong></p><p>所谓<strong>收集依赖</strong>，就是要知道<code>data</code>中的某个属性，到底在哪些文本结点(或者计算属性)中使用过了，换句话说，就是这些文本结点依赖data中的那个数据；这个数据改变时，我们需要<strong>监听</strong>到这个数据的变化，然后通知依赖这个数据的文本结点(或者计算属性)更新内容。</p><p><strong>依赖收集</strong>主要是在<code>模板解析</code>过程中进行的，在监听到数据的<code>getter</code>被触发的时候，收集它的依赖。</p><p>我们定义一个<code>Watcher</code>类来记录<code>文本结点</code>，<code>文本结点内部未编译前的字符串</code>，和它<code>依赖的数据(vm.key)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">vm,key,node,str</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">key</span> = key</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">node</span> = node</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">str</span> = str</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">str</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">            <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>]</span><br><span class="line">         &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">options</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;<span class="comment">//其实如果data是函数的话，还要调用函数。</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Watcher</span> = &#123;&#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span>(options.<span class="property">beforeCreate</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeCreate</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">options.<span class="property">beforeCreate</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//把this.$data中的数据代理到this上</span></span><br><span class="line">        <span class="variable language_">this</span>.$proxy()</span><br><span class="line">        <span class="comment">//监听this.$data中的数据的变化</span></span><br><span class="line">        <span class="variable language_">this</span>.$observe()</span><br><span class="line"><span class="keyword">if</span>(options.<span class="property">created</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">created</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">options.<span class="property">created</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">        .......</span><br><span class="line"><span class="keyword">if</span>(options.<span class="property">beforeMount</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeMount</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">options.<span class="property">beforeMount</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$el</span>= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>);</span><br><span class="line">        <span class="comment">//编译模板</span></span><br><span class="line"><span class="variable language_">this</span>.$compile(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">        ......</span><br><span class="line"><span class="keyword">if</span>(options.<span class="property">mounted</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">mounted</span> == <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">options.<span class="property">mounted</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    $compile(node) &#123;</span><br><span class="line">      <span class="comment">//childNodes返回这个dom元素的所有子节点，包括文本结点和元素结点</span></span><br><span class="line">      node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//nodeType 结点类型</span></span><br><span class="line">        <span class="comment">// 1 表示元素结点</span></span><br><span class="line">        <span class="comment">// 3 表示文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//@click</span></span><br><span class="line">          <span class="keyword">if</span> (item.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;@click&#x27;</span>)) &#123;</span><br><span class="line">            <span class="comment">//本质基于原生js语法</span></span><br><span class="line">            item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> method = item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;@click&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">              <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">methods</span>[method].<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">//如果是文本结点</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.$replace(item)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    $replace(item)&#123;</span><br><span class="line">      item.<span class="property">textContent</span> = item.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">            <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">          key = key.<span class="title function_">trim</span>()</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$Watcher</span>[key])&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>,key,item,item.<span class="property">textContent</span>))</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key] = []</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>,key,item,item.<span class="property">textContent</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>[key]<span class="comment">//返回用来替换的字符串,就是data中的值</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用来给数据添加代理</span></span><br><span class="line">$proxy() &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">$data</span>) &#123;</span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">          <span class="comment">//想要访问this.key，就返回this.$data[key]</span></span><br><span class="line">          <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">//想要修改this.key，就修改this.$data[key]</span></span><br><span class="line">          <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="comment">//数据未改变直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$data</span>[key]===newVal)&#123;</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$data</span>[key] = newVal</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//用来给数据添加监听，即监听this.$data中数据的改变</span></span><br><span class="line">    $observe()&#123;</span><br><span class="line">        <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">$data</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//先取出值，防止无限递归</span></span><br><span class="line">            <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">            <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">$data</span>,key,&#123;</span><br><span class="line">                <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> value</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_">set</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">                    <span class="comment">//get,set中的this指向的是this.$data</span></span><br><span class="line">                    <span class="keyword">if</span>(value===newVal)&#123;</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果newVal是obj，还要递归添加响应式。</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">typeof</span> newVal == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">                        <span class="variable language_">this</span>.$observe(newVal)</span><br><span class="line">                    &#125;</span><br><span class="line">                    value = newVal</span><br><span class="line">                    <span class="comment">//通知依赖更新</span></span><br><span class="line">                    vm.<span class="property">$Watcher</span>[key].<span class="title function_">forEach</span>(<span class="function"><span class="params">w</span>=&gt;</span>&#123;</span><br><span class="line">                        w.<span class="title function_">update</span>()</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a><strong>双向绑定</strong></h3><p><code>双向绑定</code>并不等同于<code>响应式</code>了，这两个东西是有区别的。</p><p><code>响应性</code>简单来讲就是当更改响应式数据时，视图会随即自动更新，即<code>数据驱动视图更新</code>。而实现这个功能的原理就是<code>劫持(监听)数据</code>，<code>收集依赖</code>，当数据发生变化时，执行相应的依赖（副作用&#x2F;更新视图）。</p><p><code>双向绑定</code>是数据变化驱动视图更新，视图更新触发数据变化。其实就是<code>v-model</code>的功能，而我们知道<code>v-model</code>只是一个语法糖。因此如果要问<code>双向绑定</code>的原理，思路应该是<code>如何实现这个语法糖</code>。</p><p>只需完善<code>$compile</code>方法和<code>update</code>方法。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, key, node, str</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span> = node</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">str</span> = str</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//更新</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//如果不是文本结点，即没有模板字符串，更新的是元素结点的属性值</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">str</span> === <span class="literal">undefined</span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>]</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">textContent</span> = <span class="variable language_">this</span>.<span class="property">str</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">      <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">vm</span>[<span class="variable language_">this</span>.<span class="property">key</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$options</span> = options</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = options.<span class="property">data</span>;<span class="comment">//只考虑data是对象的情况</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$Watcher</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">beforeCreate</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeCreate</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      options.<span class="property">beforeCreate</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把this.$data中的数据代理到this上</span></span><br><span class="line">    <span class="variable language_">this</span>.$proxy()</span><br><span class="line">    <span class="comment">//监听this.$data中的数据改变</span></span><br><span class="line">    <span class="variable language_">this</span>.$observe()</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">created</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">created</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      options.<span class="property">created</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">beforeMount</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">beforeMount</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      options.<span class="property">beforeMount</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(options.<span class="property">el</span>);</span><br><span class="line">    <span class="comment">//模板解析</span></span><br><span class="line">    <span class="variable language_">this</span>.$compile(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">mounted</span> &amp;&amp; <span class="keyword">typeof</span> options.<span class="property">mounted</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      options.<span class="property">mounted</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  $compile(node) &#123;</span><br><span class="line">    <span class="comment">//childNodes返回这个dom元素的所有子节点，包括文本结点</span></span><br><span class="line">    node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//nodeType 结点类型</span></span><br><span class="line">      <span class="comment">// 1 表示元素结点</span></span><br><span class="line">      <span class="comment">// 3 表示文本结点</span></span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//@click</span></span><br><span class="line">        <span class="keyword">if</span> (item.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;@click&#x27;</span>)) &#123;</span><br><span class="line">          <span class="comment">//本质还是使用了原生语法</span></span><br><span class="line">          item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 如果此处使用的不是箭头函数，this的指向就是item了,我们要让this的指向变为vue实例。</span></span><br><span class="line">            <span class="comment">// item.getAttribute(&#x27;@click&#x27;).trim() 获取@click属性的值</span></span><br><span class="line">            <span class="comment">// 获取到这个属性的值，去除前后空格，假设是一个已有的方法名</span></span><br><span class="line">            <span class="comment">// 调用这个方法，同时修改函数的指向，使它指向vue实例，同时传入事件对象e</span></span><br><span class="line">            <span class="keyword">const</span> method = item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;@click&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">methods</span>[method].<span class="title function_">call</span>(<span class="variable language_">this</span>, e)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//v-model</span></span><br><span class="line">        <span class="keyword">if</span>(item.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>))&#123;</span><br><span class="line">          <span class="keyword">const</span> key = item.<span class="title function_">getAttribute</span>(<span class="string">&#x27;v-model&#x27;</span>).<span class="title function_">trim</span>()</span><br><span class="line">          item.<span class="property">value</span> = <span class="variable language_">this</span>[key] <span class="comment">//赋值</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">$Watcher</span>.<span class="title function_">hasOwnProperty</span>(key))&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, key, item))</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key] = []</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, key, item))</span><br><span class="line">          &#125;</span><br><span class="line">          item.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>[key] = item.<span class="property">value</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="variable language_">this</span>.$compile(item)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果是文本结点</span></span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$replace(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  $replace(item) &#123;</span><br><span class="line">    <span class="comment">//非贪婪匹配</span></span><br><span class="line">    <span class="comment">//通过textContent拿到文本结点的内容</span></span><br><span class="line">    <span class="comment">//如果文本节点中没有使用模板字符串，则匹配不到任何内容，回调函数中的代码也不会执行。</span></span><br><span class="line">    item.<span class="property">textContent</span> = item.<span class="property">textContent</span>.<span class="title function_">replace</span>(<span class="regexp">/\&#123;\&#123;(.*?)\&#125;\&#125;/g</span>, <span class="function">(<span class="params">match, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// match是匹配到的具体的字符串</span></span><br><span class="line">      <span class="comment">// key是匹配到的具体字符串删除具体字符的*剩余部分*,就是模板表达式中的变量</span></span><br><span class="line">      key = key.<span class="title function_">trim</span>()</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$Watcher</span>[key]) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, key, item, item.<span class="property">textContent</span>))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key] = []</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$Watcher</span>[key].<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, key, item, item.<span class="property">textContent</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>[key]<span class="comment">//返回用来替换的字符串,就是data中的值</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来给数据添加代理</span></span><br><span class="line">  $proxy() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">$data</span>) &#123;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">        <span class="comment">//想要访问this.key，就返回this.$data[key]</span></span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//想要修改this.key，就修改this.$data[key]</span></span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">          <span class="comment">//数据未改变直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$data</span>[key] === newVal) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">$data</span>[key] = newVal</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用来给数据添加监听，即监听this.$data中数据的改变</span></span><br><span class="line">  $observe() &#123;</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">$data</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//先取出值，防止无限递归</span></span><br><span class="line">      <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">$data</span>[key]</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>.<span class="property">$data</span>, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">          <span class="comment">//set函数内部的this指向this.$data</span></span><br><span class="line">          <span class="keyword">if</span> (value === newVal) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(<span class="keyword">typeof</span> newVal == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.$observe(newVal)</span><br><span class="line">          &#125;</span><br><span class="line">          value = newVal</span><br><span class="line">          vm.<span class="property">$Watcher</span>[key].<span class="title function_">forEach</span>(<span class="function"><span class="params">w</span> =&gt;</span> &#123;</span><br><span class="line">            w.<span class="title function_">update</span>()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> app =  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">str</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">    <span class="attr">num</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">num</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Vue-observable你有了解过吗？说说看"><a href="#Vue-observable你有了解过吗？说说看" class="headerlink" title="Vue.observable你有了解过吗？说说看"></a>Vue.observable你有了解过吗？说说看</h2><p><code>Vue.observable</code>，让一个对象变成响应式数据。<code>Vue</code> 内部会用它来处理 <code>data</code> 函数返回的对象</p><p>在 <code>Vue 2.x</code> 中，被传入的对象会直接被 <code>Vue.observable</code> 变更，它和被返回的对象是同一个对象，这一点，看看前面对<code>defineReactive</code>方法的介绍就很容易理解了。</p><p>在 <code>Vue 3.x</code> 中，则会返回一个可响应的代理对象，而对源对象直接进行变更仍然是不可响应的，因为在vue3中响应式的实现是基于<code>Proxy</code>这个构造函数，传入一个对象，会返回一个<code>新的</code>代理对象，对代理对象的修改会映射到源对象。</p><p><strong>使用场景</strong></p><p>创建一个<code>js</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入vue</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue</span></span><br><span class="line"><span class="string">// 创建state对象，使用observable让state对象可响应</span></span><br><span class="line"><span class="string">export let state = Vue.observable(&#123;</span></span><br><span class="line"><span class="string">  name: &#x27;</span>张三<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">  &#x27;</span>age<span class="string">&#x27;: 38</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure><p>在<code>.vue</code>文件中直接使用即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    姓名：&#123;&#123; name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    年龄：&#123;&#123; age &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName(&#x27;李四&#x27;)&quot;</span>&gt;</span>改变姓名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;setAge(18)&quot;</span>&gt;</span>改变年龄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; state, mutations &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  // 在计算属性中拿到值</span></span><br><span class="line"><span class="string">  computed: &#123;</span></span><br><span class="line"><span class="string">    name() &#123;</span></span><br><span class="line"><span class="string">      return state.name</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    age() &#123;</span></span><br><span class="line"><span class="string">      return state.age</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  // 调用mutations里面的方法，更新数据</span></span><br><span class="line"><span class="string">  methods: &#123;</span></span><br><span class="line"><span class="string">    changeName(name) &#123;</span></span><br><span class="line"><span class="string">       state.name = name</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  setAge(age) &#123;</span></span><br><span class="line"><span class="string">       state.age = age</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>详细解释</strong></p><p><code>依赖收集</code>是组件初始化过程中，模板解析时候的工作，组件模板解析的时候，如果使用到了某个<code>响应式对象</code>的某个属性，就会<code>new</code>一个<code>watcher</code>，存储到<code>Dep.target</code>中，然后取值的时候会触发<code>getter</code>，<code>getter</code>内部会判断<code>Dep.target</code>是否为空，不为空则收集依赖，把这个<code>watcher</code>取出来，<code>push</code>到这个属性（key）的<code>deps</code>（依赖数组）中。然后某个属性值修改的时候就会触发对应的<code>setter</code>，通知这些依赖的<code>watcher</code>更新内容，即调用依赖这个属性（key）的<code>watcher</code>的<code>update</code>方法。</p><p>所以说<code>Vue.observable</code>只能给数据添加响应式，但是想要实现数据修改，依赖这些数据的组件也重新渲染，就需要在模板解析过程中收集依赖。</p><h2 id="说说Vue的生命周期"><a href="#说说Vue的生命周期" class="headerlink" title="说说Vue的生命周期"></a><strong>说说Vue的生命周期</strong></h2><p>vue的生命周期指的是<strong>vue实例</strong>从创建到销毁的过程，可分为vue实例创建前后，dom挂载前后，数据更新前后，vue实例销毁前后四个阶段。这四个阶段分别对应了<code>8</code>个生命周期函数。</p><p>生命周期函数指的是在vue实例特定时间段执行的函数。</p><p>这里拿vue2的生命周期函数举例。</p><ul><li><p>beforeCreate：vue实例刚被创建，能拿到this，部分初始化工作完成，但是<strong>数据代理</strong>还未开始(未调用<code>initState</code>方法)，此时无法通过this获取<strong>data和methods等</strong></p></li><li><p>created:  <strong>数据代理结束</strong>，能通过this拿到data和methods，但是<strong>模板解析</strong>还未开始（未调用<code>vm.$mount</code>方法），页面展示的是<strong>未经vue编译的dom</strong>。</p></li><li><p>beforeMount：<strong>template模板解析结束</strong>，但是虚拟dom还未转化成真实dom挂载到页面中。</p></li><li><p>mounted：把<code>初始的</code>真实DOM放入页面，此时对dom的操作是有效的。</p></li><li><p>beforeUpdate：此时数据是新的，页面展示的内容是旧的, 因为vue视图是异步更新的。</p></li><li><p>updated:  此时<code>新旧虚拟dom比较</code>完毕，页面已更新。</p></li><li><p>beforeDestroy: 实例被销毁前调用，此时实例<code>属性与方法</code>仍然有效</p></li><li><p>destroyed: 完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器;并不能清除DOM，仅仅销毁实例.</p></li></ul><img src="..\images\前端面试-vue\生命周期.png" style="zoom:150%;" /><p><strong>数据请求在created和mouted的区别</strong></p><ul><li>这两个阶段<code>数据</code>和<code>方法</code>都已经初始化，都能通过<code>this</code>访问到，因为<code>created</code>的执行时期更早，所以能更早的发送请求，更快的返回数据。</li><li>一个组件中有子组件，它们的生命周期函数的执行顺序是先执行父组件的前三个声明周期函数，再执行子组件的前四个生命周期函数，然后在执行哦父组件的<code>mouted</code>函数。</li></ul><h2 id="说说你对slot的理解？slot使用场景有哪些？"><a href="#说说你对slot的理解？slot使用场景有哪些？" class="headerlink" title="说说你对slot的理解？slot使用场景有哪些？"></a>说说你对slot的理解？slot使用场景有哪些？</h2><p><code>slot</code>的作用就是用来<strong>自定义组件内部的结构</strong></p><p><code>slot</code>可以分来以下三种：</p><ul><li>默认插槽</li><li>具名插槽</li><li>作用域插槽</li></ul><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><p>子组件用<code>&lt;slot&gt;</code>标签来确定渲染的位置，标签里面可以放<code>DOM</code>结构，当父组件没有往插槽传入内容，标签内<code>DOM</code>结构就会显示在页面</p><p>父组件在使用的时候，直接在子组件的标签内写入内容即可</p><p>子组件<code>Child.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>默认插槽<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件给子组件传入的自定义结构，可以在子组件的<code>this.$slots</code>属性中拿到。</p><img src="..\images\前端面试-vue\slot.png" style="zoom: 67%;" /><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>默认插槽形如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们给<code>slot</code>标签添加<code>name</code>属性，默认插槽就变成了具名插槽</p><p>当我们需要在子组件内部的多个位置使用插槽的时候，为了把各个插槽区别开，就需要给每个插槽取名。</p><p>同时父组件传入自定义结构的时候，也要指明是传递给哪个插槽的。</p><p>子组件<code>Child.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span>插槽后备的内容<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span>具名插槽<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 具名插槽⽤插槽名做参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:content</span>&gt;</span>内容...<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>template</code>标签是用来分割，包裹自定义结构的。<code>v-slot</code>属性用来指定这部分结构用来替换哪个插槽。</p><p><code>v-slot:default</code>可以简化为<code>#default</code>，<code>v-slot:content</code>可以简化成<code>#content</code></p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>子组件在<code>slot</code>标签上绑定属性来将子组件的信息传给父组件使用，所有绑定的属性会被收集成一个对象，被父组件的<code>v-slot</code>属性接收。</p><p>子组件<code>Child.vue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">testProps</span>=<span class="string">&quot;子组件的值&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>没传footer插槽<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以通过解构获取<code>v-slot=&#123;user&#125;</code>，还可以重命名<code>v-slot=&quot;&#123;user: newName&#125;&quot;</code>和定义默认值<code>v-slot=&quot;&#123;user = &#39;默认值&#39;&#125;&quot;</code></p><p>所在<code>slot</code>中也存在’’双向数据传递’’，父组件给子组件传递<code>页面结构</code>，子组件给父组件传递子组件的数据。</p><h2 id="你有写过自定义指令吗？自定义指令的应用场景有哪些？"><a href="#你有写过自定义指令吗？自定义指令的应用场景有哪些？" class="headerlink" title="你有写过自定义指令吗？自定义指令的应用场景有哪些？"></a>你有写过自定义指令吗？自定义指令的应用场景有哪些？</h2><h3 id="什么是指令"><a href="#什么是指令" class="headerlink" title="什么是指令"></a>什么是指令</h3><p>在<code>vue</code>中提供了一套为<code>数据驱动视图</code>更为方便的操作，这些操作被称为<code>指令系统</code>。简单的来说，<code>指令系统</code>能够简化dom操作，帮助方便的实现<code>数据驱动视图更新</code>。</p><p>我们看到的<code>v-</code>开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能</p><p>除了核心功能默认<code>内置的指令</code> (<code>v-model</code> 和 <code>v-show</code>)，<code>Vue</code> 也允许注册<code>自定义指令</code></p><p><strong>指令使用的几种方式：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会实例化一个指令，但这个指令没有参数 </span></span><br><span class="line">v-xxx</span><br><span class="line"></span><br><span class="line"><span class="comment">//将值传到指令中</span></span><br><span class="line">v-xxx=<span class="string">&quot;value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串传入到指令中，如v-html=&quot;&#x27;&lt;p&gt;内容&lt;/p&gt;&#x27;&quot;</span></span><br><span class="line">v-xxx=<span class="string">&quot;&#x27;string&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传参数（arg），如v-bind:class=&quot;className&quot;</span></span><br><span class="line">v-<span class="attr">xxx</span>:arg=<span class="string">&quot;value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用修饰符（modifier）</span></span><br><span class="line">v-<span class="attr">xxx</span>:arg.<span class="property">modifier</span>=<span class="string">&quot;value&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p> 注意：指令中传入的都是<strong>表达式</strong>，无论是不是自定义指令，比如<code>v-bind:name = &#39;tom&#39;</code>，传入的是tom这个变量的值，而不是tom字符串，除非写成<code>&quot;&#39;tom&#39;&quot;</code>，传入的才是字符串。</p></blockquote><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>关于自定义指令，我们关心的就是三大方面，<strong>自定义指令的定义，自定义指令的注册，自定义指令的使用</strong>。</p><p><code>自定义指令</code>的使用方式和<code>内置指令</code>相同，我们不再研究，其中的难点就是<code>定义自定义指令</code>部分。</p><h4 id="注册自定义指令"><a href="#注册自定义指令" class="headerlink" title="注册自定义指令"></a>注册自定义指令</h4><p>注册一个自定义指令有<code>全局注册</code>与<code>局部注册</code>两种方式</p><p>全局注册主要是通过<code>Vue.directive</code>方法进行注册</p><p><code>Vue.directive</code>第一个参数是指令的名字（不需要写上<code>v-</code>前缀），第二个参数可以是对象数据，也可以是一个指令函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局注册一个自定义指令 `v-focus`</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="comment">// 聚焦元素</span></span><br><span class="line">    el.<span class="title function_">focus</span>()  <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>局部注册通过在组件配置对象中设置<code>directives</code>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">directives</span>: &#123;</span><br><span class="line">  <span class="attr">focus</span>: &#123;</span><br><span class="line">    <span class="comment">// 指令的定义</span></span><br><span class="line">    <span class="attr">inserted</span>: <span class="keyword">function</span> (<span class="params">el</span>) &#123;</span><br><span class="line">      el.<span class="title function_">focus</span>() <span class="comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus /&gt;</span><br></pre></td></tr></table></figure><p>在vue3中，局部注册的语法就不同了。如果混合使用<code>选项式api</code>，就可以像vue2一样借助<code>directives</code>属性解决，如果使用的是<code>setup语法糖</code>写法，就需要遵守如下语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用局部注册的自定义指令 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-highlight</span>=<span class="string">&quot;&#x27;yellow&#x27;&quot;</span>&gt;</span>This text will be highlighted in yellow<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-focus</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; onMounted, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; directive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 定义一个高亮指令</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> highlight = <span class="title function_">directive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    el.<span class="property">style</span>.<span class="property">backgroundColor</span> = binding.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 定义一个聚焦指令</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> focus = <span class="title function_">directive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params">el</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    el.<span class="title function_">focus</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入<code>directive</code>函数，传入自定义指令，完成组件的局部注册。</p><h4 id="定义自定义指令"><a href="#定义自定义指令" class="headerlink" title="定义自定义指令"></a>定义自定义指令</h4><p>自定义指令本质就是一个<strong>包含特定钩子函数的js对象</strong></p><p>在vue2中，这些常见的钩子函数包括：</p><ul><li><p><strong>bind()</strong></p><p><code>只调用一次</code>，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置，此时无法通过<code>el</code>拿到父级元素，也就是<code>el.parentNode</code>为空，但是也已经能拿到绑定的dom元素了。</p></li><li><p><strong>inserted()</strong></p><p>绑定指令的元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中，因为父元素可能还没插入文档中呢)，此时可以通过<code>el.parentNode</code>拿到父级元素</p></li><li><p><strong>mounted()</strong></p><p>指令绑定的元素被插入到<code>文档</code>中之后</p></li><li><p><strong>update()</strong></p><p>传入指令的值改变后触发</p></li><li><p><strong>unbind()</strong></p><p>只调用一次，指令与元素<code>解绑</code>时调用</p></li></ul><blockquote><p>注意：上述钩子函数在vue3中并不都有效，vue3中的自定义指令钩子函数和生命周期函数一致，具体见官方文档，<a href="https://cn.vuejs.org/guide/reusability/custom-directives#directive-hooks">https://cn.vuejs.org/guide/reusability/custom-directives#directive-hooks</a></p></blockquote><p>所有的钩子函数的参数都有以下：</p><ul><li><p><strong>el</strong>：指令所绑定的元素，可以用来直接操作 <code>DOM</code>，省去了手动捕获dom的步骤</p></li><li><p><strong>binding</strong>：</p><p>一个对象，包含以下property</p><ul><li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li><li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li><li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li><li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>，又比如<code>v-for=&quot;(value, key, index) in obj&quot;</code>传入的表达式为<code>&quot;(value, key, index) in obj&quot;</code></li><li><code>arg</code>：<strong>传给指令的参数</strong>，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>，又比如<code>v-bind:class = &quot;[&#39;box&#39;]&quot;</code>的参数为<code>class</code></li><li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code></li></ul></li><li><p><code>vnode</code>：<code>Vue</code> 编译生成的虚拟节点</p></li><li><p><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用</p></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>给某个元素添加节流</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.设置v-throttle自定义指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;throttle&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">bind</span>: <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> throttleTime = binding.<span class="property">value</span>; <span class="comment">// 节流时间</span></span><br><span class="line">    <span class="keyword">if</span> (!throttleTime) &#123; <span class="comment">// 用户若不设置节流时间，则默认2s</span></span><br><span class="line">      throttleTime = <span class="number">2000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="comment">//el是绑定指令的元素</span></span><br><span class="line">    el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!timer) &#123; <span class="comment">// 第一次执行</span></span><br><span class="line">      <span class="comment">//开启定时器，占用临界资源</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//一定事件后，释放资源</span></span><br><span class="line">          timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;, throttleTime);</span><br><span class="line">        <span class="comment">//同时绑定的另一个监听器也被调用，触发sayHello函数</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果在前throttleTime的时间内已经点击过了，则阻止目标元素绑定的监听器被调用，也就是说，sayHello不会被调用 </span></span><br><span class="line">        <span class="comment">//它不仅会阻止事件继续沿 DOM 树传播，还会阻止在同一阶段内其他监听器的执行，包括目标阶段的监听器。</span></span><br><span class="line">        event &amp;&amp; event.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="literal">true</span>);<span class="comment">//捕获触发，触发的顺序在冒泡触发之前</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2.为button标签设置v-throttle自定义指令</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sayHello&quot;</span> <span class="attr">v-throttle</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="Vue常用的修饰符有哪些有什么应用场景"><a href="#Vue常用的修饰符有哪些有什么应用场景" class="headerlink" title="Vue常用的修饰符有哪些有什么应用场景"></a>Vue常用的修饰符有哪些有什么应用场景</h2><h3 id="修饰符是什么"><a href="#修饰符是什么" class="headerlink" title="修饰符是什么"></a>修饰符是什么</h3><p>在<code>Vue</code>中，修饰符是用来修饰Vue中的指令的，它<strong>处理了许多<code>DOM</code>事件的细节</strong>，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理。</p><p><code>vue</code>中修饰符分为以下五种：</p><ul><li>表单修饰符</li><li>事件修饰符</li><li>鼠标按键修饰符</li><li>键值修饰符</li><li>v-bind修饰符</li></ul><h3 id="修饰符的具体作用"><a href="#修饰符的具体作用" class="headerlink" title="修饰符的具体作用"></a>修饰符的具体作用</h3><h4 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h4><p>在我们填写表单的时候用得最多的是<code>input</code>标签，指令用得最多的是<code>v-model</code></p><p>关于表单的修饰符有如下：</p><ul><li>lazy</li><li>trim</li><li>number</li></ul><p><strong>lazy</strong></p><p>在我们填完信息，光标离开标签的时候，才会将值赋予给<code>value</code>，也就是在<code>change</code>事件之后再进行信息同步</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">lazy</span>=<span class="string">&quot;value&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>trim</strong></p><p>自动过滤用户输入的首尾空格字符，而中间的空格不会过滤</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model.<span class="property">trim</span>=<span class="string">&quot;value&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>number</strong></p><p>自动将用户的输入值转为数值类型，但如果这个值无法被<code>parseFloat</code>解析，则会返回原来的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.<span class="property">number</span>=<span class="string">&quot;age&quot;</span> type=<span class="string">&quot;number&quot;</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p><strong>stop</strong></p><p>阻止了<code>事件冒泡</code>，相当于调用了<code>event.stopPropagation</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=<span class="string">&quot;shout(2)&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">//只输出1</span></span><br></pre></td></tr></table></figure><p><strong>prevent</strong></p><p>阻止了事件的<code>默认行为</code>，相当于调用了<code>event.preventDefault</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form @submit.<span class="property">prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><strong>self</strong></p><p>只当在 <code>event.target</code> 是当前元素自身时触发处理函数，既不是冒泡触发，也不是捕获触发，简单来说就是点击的就是这个元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click.<span class="property">self</span>=<span class="string">&quot;doThat&quot;</span>&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>@click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击</p></blockquote><p><strong>once</strong></p><p>绑定了事件以后只能触发一次，触发一次之后立即解除事件监听。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click.<span class="property">once</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;ok&lt;/button&gt;</span><br></pre></td></tr></table></figure><p><strong>capture</strong></p><p>使事件触发从包含这个元素的顶层开始往下触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click.<span class="property">capture</span>=<span class="string">&quot;shout(1)&quot;</span>&gt;</span><br><span class="line">    obj1</span><br><span class="line">&lt;div @click.<span class="property">capture</span>=<span class="string">&quot;shout(2)&quot;</span>&gt;</span><br><span class="line">    obj2</span><br><span class="line">&lt;div @click=<span class="string">&quot;shout(3)&quot;</span>&gt;</span><br><span class="line">    obj3</span><br><span class="line">&lt;div @click=<span class="string">&quot;shout(4)&quot;</span>&gt;</span><br><span class="line">    obj4</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">// 输出结构: 1 2 4 3 </span></span><br></pre></td></tr></table></figure><p><strong>passive</strong></p><p>在移动端，当我们在监听元素滚动事件的时候，会一直触发<code>onscroll</code>事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给<code>onscroll</code>事件整了一个<code>.lazy</code>修饰符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span><br><span class="line">&lt;!-- 而不会等待 <span class="string">`onScroll`</span> 完成  --&gt;</span><br><span class="line">&lt;!-- 这其中包含 <span class="string">`event.preventDefault()`</span> 的情况 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用,因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。</p><p><code>passive</code> 会告诉浏览器你不想阻止事件的默认行为</p></blockquote><p><strong>native</strong></p><p>让组件变成像<code>html</code>内置标签那样监听根元素的原生事件，否则组件上使用 <code>v-on</code> 只会监听自定义事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-<span class="attr">on</span>:click.<span class="property">native</span>=<span class="string">&quot;doSomething&quot;</span>&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><blockquote><p>使用.native修饰符来操作普通HTML标签是会令事件失效的</p></blockquote><h2 id="Vue中组件和插件有什么区别"><a href="#Vue中组件和插件有什么区别" class="headerlink" title="Vue中组件和插件有什么区别"></a>Vue中组件和插件有什么区别</h2><h3 id="组件是什么"><a href="#组件是什么" class="headerlink" title="组件是什么"></a>组件是什么</h3><p>在vue中，组件就是能实现<code>部分功能</code>的html，css，js代码的集合。</p><p><strong>优势</strong></p><ul><li><p>降低整个系统的<code>耦合度</code></p><p>在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</p></li><li><p>提高代码的<code>可维护性</code>，和<code>可复用性</code></p><p>由于每个组件的职责单一，并且组件在系统中是被复用的。</p></li></ul><h3 id="插件是什么"><a href="#插件是什么" class="headerlink" title="插件是什么"></a>插件是什么</h3><p>插件通常用来为 <code>Vue</code> 添加全局功能，比如通过全局混入来添加一些组件选项。如<code>vue-router</code></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>两者的区别主要表现在以下几个方面：</p><ul><li>编写形式</li><li>注册形式</li></ul><h4 id="编写形式"><a href="#编写形式" class="headerlink" title="编写形式"></a>编写形式</h4><p><strong>组件</strong></p><p>编写一个组件，可以有很多方式，我们最常见的就是<code>vue</code>单文件的这种格式，每一个<code>.vue</code>文件我们都可以看成是一个组件。</p><p><strong>插件</strong></p><p><code>vue</code>插件就是一个实现了 <code>install</code> 方法的对象。这个方法的第一个参数是 <code>Vue</code> 构造函数，第二个参数是一个可选的选项对象(options)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">MyPlugin</span>.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property">myGlobalMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">bind</span> (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">    <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params">methodOptions</span>) &#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册形式"><a href="#注册形式" class="headerlink" title="注册形式"></a>注册形式</h4><p><strong>组件注册</strong></p><p><code>vue</code>组件注册主要分为<code>全局注册</code>与<code>局部注册</code></p><p>局注册通过<code>Vue.component</code>方法，第一个参数为组件的名称，第二个参数为传入的配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;my-component-name&#x27;</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure><p>局部注册只需在用到的地方通过<code>components</code>属性注册一个组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> component1 = &#123;...&#125;<span class="comment">// 定义一个组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="attr">components</span>:&#123;</span><br><span class="line">component1<span class="comment">//局部注册</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在vue3中的组件注册</strong>：</p><p>全局注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>; <span class="comment">// 引入你的组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;);</span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;MyComponent&#x27;</span>, <span class="title class_">MyComponent</span>); <span class="comment">// 全局注册组件</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure><p>局部注册：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">MyComponent</span> <span class="comment">// 局部注册组件</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent.vue&#x27;</span>; <span class="comment">// 引入你的组件</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用局部注册的组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>&lt;script setup&gt;</code> 中导入的组件会<strong>自动注册</strong>并在模板中可用，无需显式地在 <code>components</code> 选项中列出它们。</p><p><strong>插件注册</strong></p><p>插件的注册通过<code>Vue.use()</code>的方式进行注册，第一个参数为<code>插件的名字</code>，第二个参数是可选择的<code>配置项</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(插件名字[,options])</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">use</span> = <span class="keyword">function</span>(<span class="params">plugin,options</span>)&#123;</span><br><span class="line">    <span class="comment">//this指向Vue构造函数</span></span><br><span class="line">    <span class="comment">//在use方法内部，会调用插件的install方法</span></span><br><span class="line">    plugin.<span class="title function_">install</span>(<span class="variable language_">this</span>,options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 注册插件的时候，需要在调用 <code>new Vue()</code> 启动应用<code>之前</code>完成，<code>Vue.use</code>会自动阻止多次注册相同插件，只会注册一次。</p></blockquote><h2 id="Vue组件通信的方式有哪些"><a href="#Vue组件通信的方式有哪些" class="headerlink" title="Vue组件通信的方式有哪些"></a>Vue组件通信的方式有哪些</h2><p><code>vue</code>中，每个组件之间的都有<code>独自的作用域</code>，组件间的数据是无法共享的\，但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的，要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统。</p><h3 id="组件间通信的分类"><a href="#组件间通信的分类" class="headerlink" title="组件间通信的分类"></a>组件间通信的分类</h3><ul><li>父子组件之间的通信</li><li>兄弟组件之间的通信</li><li>祖孙与后代组件之间的通信</li><li>非关系组件间之间的通信</li></ul><h3 id="组件间通信的方案"><a href="#组件间通信的方案" class="headerlink" title="组件间通信的方案"></a>组件间通信的方案</h3><h4 id="props传递数据"><a href="#props传递数据" class="headerlink" title="props传递数据"></a>props传递数据</h4><p>适用场景：父组件传递数据给子组件(父子组件之间的通信)</p><p>子组件设置<code>props</code>属性，定义接收父组件传递过来的参数，父组件在使用子组件标签中添加属性来传递值。</p><p>子组件接受的数据，会被挂载到子组件实例上，可以直接通过this访问。对于父组件传入，子组件未接受的数据，也能在<code>this.$atrr</code>，即<code>组件实例的属性</code>中拿到，因为未被接受的数据，就会被当作组件自身的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Children.vue</span></span><br><span class="line"><span class="attr">props</span>:&#123;  </span><br><span class="line"> <span class="comment">// 字符串形式  </span></span><br><span class="line"> <span class="attr">name</span>:<span class="title class_">String</span> <span class="comment">// 接收的类型参数  </span></span><br><span class="line"> <span class="comment">// 对象形式  </span></span><br><span class="line"> <span class="attr">age</span>:&#123;    </span><br><span class="line">     <span class="attr">type</span>:<span class="title class_">Number</span>, <span class="comment">// 接收的类型为数值  </span></span><br><span class="line">     <span class="attr">defaule</span>:<span class="number">18</span>,  <span class="comment">// 默认值为18  </span></span><br><span class="line">     <span class="attr">require</span>:<span class="literal">true</span> <span class="comment">// age属性必须传递  </span></span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Children name=&quot;jack&quot; age=18 /&gt;  </span><br></pre></td></tr></table></figure><p>要注意的是，props中的数据是父组件的，子组件不能直接修改</p><h4 id="emit-触发自定义事件"><a href="#emit-触发自定义事件" class="headerlink" title="$emit 触发自定义事件"></a>$emit 触发自定义事件</h4><p>适用场景：子组件传递数据给父组件(父子组件通信)</p><p>子组件通过<code>$emit</code>触发自定义事件，<code>$emit</code>第一个参数为自定义的事件名，第二个参数为传递给父组件的数值</p><p>父组件在子组件上绑定事件监听，通过传入的<code>回调函数</code>拿到子组件的传过来的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Children.vue</span><br><span class="line">this.$emit(&#x27;add&#x27;, good)  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Father.vue</span><br><span class="line">&lt;Children @add=&quot;cartAdd($event)&quot; /&gt;  </span><br></pre></td></tr></table></figure><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>在 Vue 2 中，<code>this.$refs</code> 是一个对象，它包含了所有通过 <code>ref</code> 属性注册的<code> DOM 元素</code>或<code>组件实例</code>。你可以使用 <code>this.$refs</code> 来直接访问这些元素或组件，从而进行操作，如获取DOM节点、调用子组件的方法，数据等。</p><p><strong>注意：</strong><code>this.$refs</code> <code>只能</code>在父组件中，用来引用通过 <code>ref</code> 属性标记的<code>子组件</code>或 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> ref=<span class="string">&quot;foo&quot;</span> /&gt;  </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">foo</span>  <span class="comment">// 获取子组件实例，通过子组件实例我们就能拿到对应的数据  </span></span><br></pre></td></tr></table></figure><p>同时，子组件也可通过<code>this.$parent</code>拿到父组件实例</p><h4 id="EventBus-事件总线"><a href="#EventBus-事件总线" class="headerlink" title="EventBus(事件总线)"></a><strong>EventBus(事件总线)</strong></h4><p>使用场景：兄弟组件传值</p><ul><li><p>通过共同祖辈<code>$parent</code>或者<code>$root</code>搭建通信</p><p>兄弟组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="title function_">on</span>(<span class="string">&#x27;add&#x27;</span>,<span class="variable language_">this</span>.<span class="property">add</span>)   </span><br></pre></td></tr></table></figure><p>另一个兄弟组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$parent.emit(&#x27;add&#x27;)   </span><br></pre></td></tr></table></figure></li></ul><p>本质就是要找到一个<strong>两个兄弟组件都能访问到的vue实例</strong>，这个vue实例的作用好像连接这两个组件的管道，通过这个Vue实例来通行。</p><h4 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h4><p>跨层级传递数据，传递方向是<code>单向</code>的，只能顶层向底层传递。</p><p>在<code>祖先组件</code>定义<code>provide</code>属性，<code>返回</code>传递的值，在后代组件通过<code>inject</code>接收祖先组件传递过来的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通类型是响应式的复杂类型则不是，这和vue2数据响应式的实现方式有关</span></span><br><span class="line"><span class="comment">// 这里丢失响应式的原因，和解构响应式对象失去响应式的原因是一样的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>, <span class="comment">// 普通类型（非响应式）</span></span><br><span class="line">      <span class="attr">userInfo</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125; <span class="comment">// 复杂类型（响应式）</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">provide</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//使用data或者computed中的数据</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="variable language_">this</span>.<span class="property">color</span>, <span class="comment">// 非响应式</span></span><br><span class="line">      <span class="attr">userInfo</span>: <span class="variable language_">this</span>.<span class="property">userInfo</span>, <span class="comment">// 响应式</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 注入的属性会自动添加到组件的依赖注入链中，因此它们也是响应式的。</span></span><br><span class="line">    <span class="comment">// 如果多个祖先组件都提供了同名的属性，那么最接近的祖先组件提供的属性会被优先使用（就近原则）。</span></span><br><span class="line"><span class="attr">inject</span>: [<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;userInfo&#x27;</span>],<span class="comment">//书写格式太像props了</span></span><br><span class="line"><span class="title function_">created</span> () &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span>, <span class="variable language_">this</span>.<span class="property">userInfo</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p>关于vuex的介绍，详见<a href="http://www.sanye.blog/posts/8b27fabc.html">vue | 三叶的博客</a></p><h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><h3 id="什么是SPA，和MPA有什么区别？"><a href="#什么是SPA，和MPA有什么区别？" class="headerlink" title="什么是SPA，和MPA有什么区别？"></a>什么是SPA，和MPA有什么区别？</h3><ul><li><p>SPA指的是<strong>只有一个页面的web应用程序</strong>，而MPA（多页面应用程序）指的是有多个页面的web应用程序</p></li><li><p>SPA通过js操作dom来局部更新页面内容；而MPA是通过页面切换来实现整页刷新，整页刷新就需要重新加载整个页面所需<code>资源</code>并重新渲染页面，速度慢；</p></li><li><p>SPA刷新速度更快，用户体验更好，同时把页面渲染工作交给客户端，减轻了服务端的压力。缺点是不利于搜索引擎优化(SEO)，首次加载速度较慢。</p></li></ul><p><a href="https://vue3js.cn/interview/vue/spa.html#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFspa">面试官：你对SPA单页面的理解，它的优缺点分别是什么？如何实现SPA应用呢 | web前端面试 - 面试官系列</a></p><h3 id="如何提高首屏加载速度？"><a href="#如何提高首屏加载速度？" class="headerlink" title="如何提高首屏加载速度？"></a>如何提高首屏加载速度？</h3><p>首屏加载时间，指的是浏览器从<strong>响应用户输入网址</strong>，到<strong>首屏内容</strong>渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容。</p><p><strong>首屏加载慢的原因</strong></p><ul><li>网络延时问题</li><li>资源文件体积是否过大</li><li>资源是否重复发送请求去加载了</li><li>加载脚本的时候，渲染内容堵塞了</li></ul><p><strong>提高首屏加载速度的方法</strong>：</p><ul><li><p>使用<strong>路由懒加载</strong></p><p>对于非首屏组件，使用路由懒加载，当需要访问这些组件的时候再加载对应的资源。</p><p>开发单页面应用程序时，只有一个<code>html</code>页面，打包后也只有一个<code>index.html</code>页面，其他所谓的<code>页面</code>，都是通过<code> JavaScript</code> 动态地修改<code>DOM</code>来实现的。开发过程中，一个页面对应一个或者多个<code>组件</code>，在打包后，每个组件都会转化成对应的<code>css</code>，<code>js</code>代码，其中的<code>js代码</code>不光包括业务逻辑，也负责修改dom，构建页面。</p><p>如果使用<code>路由懒加载</code>，我们可以观察到，打包后的js，css文件<code>数量</code>变多了，每个文件的体积也变小了，是因为使用<code>懒加载的组件</code>都被打包成<code>独立的</code>css，js文件了。这样，<code>index.html</code>引入的的<code>js</code>，<code>css</code>文件的体积也会变小，因为只包含<code>首屏组件</code>需要的<code>js，css</code>代码。</p></li><li><p><strong>缓存</strong>静态资源</p><p>对于已经请求过的资源，再次请求直接使用缓存。</p></li><li><p><strong>压缩</strong>图片等静态资源的大小</p></li><li><p>使用服务端渲染<strong>SSR</strong></p><p>将首页的html结构的拼接工作交给后端服务器</p><p>对于vue，推荐使用<code>nuxt.js</code></p></li><li><p>使用<strong>CDN加速</strong></p></li><li><p>内联首屏关键css</p></li></ul><h3 id="如何提高SPA的SEO"><a href="#如何提高SPA的SEO" class="headerlink" title="如何提高SPA的SEO"></a><strong>如何提高SPA的SEO</strong></h3><ul><li>使用服务端渲染SSR</li></ul><h2 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h2><h3 id="什么是SSR"><a href="#什么是SSR" class="headerlink" title="什么是SSR"></a>什么是SSR</h3><p>指由<code>服务端</code>完成页面的<code> HTML结构拼接</code>的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。</p><p>传统web开发，一般就是多页面应用程序，每个页面的html结构都在服务端拼接好。</p><p>单页面应用程序（SPA）通过<strong>浏览器执行js代码</strong>来实现页面的html结构的替换，拼接。</p><h3 id="解决了什么"><a href="#解决了什么" class="headerlink" title="解决了什么"></a>解决了什么</h3><ul><li><p><strong>有利于SPA的SEO</strong></p><p>使用服务端渲染，返回的页面就已经包含了一定的页面结构，能够被搜索引擎爬取。</p></li><li><p><strong>提高的首屏渲染速度</strong></p><p>使用服务端渲染，将<code>首屏结构</code>交给服务端来拼接，这样不必等待页面所有<code>js</code>加载完成，就可以看到首屏视图。</p></li></ul><h3 id="怎么实现"><a href="#怎么实现" class="headerlink" title="怎么实现"></a>怎么实现</h3><h2 id="给对象添加属性视图不刷新"><a href="#给对象添加属性视图不刷新" class="headerlink" title="给对象添加属性视图不刷新"></a>给对象添加属性视图不刷新</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>在vue2中，数据的响应式是在vue<strong>实例创建</strong>的时候，使用<strong>Object.defineProperty</strong>来实现的，后续添加属性并没有使用<code>这个方法</code>来添加响应式。</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>可以通过**Vue.set()或者this.$set()**来给新增属性添加响应式。</p><p>Vue.set( target, propertyName&#x2F;index, value )</p><ul><li><code> target:&#123;Object | Array&#125;</code></li><li><code>propertyName/index:&#123;string | number&#125; </code></li><li><code>value:&#123;any&#125; </code></li></ul><p>这个方法的本质就是<strong>使用Object.defineProperty（）给新添加的属性赋予响应式</strong></p><h2 id="v-if和v-for的优先级是什么"><a href="#v-if和v-for的优先级是什么" class="headerlink" title="v-if和v-for的优先级是什么"></a>v-if和v-for的优先级是什么</h2><p>我们查看下<code>vue</code>源码</p><p>源码位置：<code>\vue-dev\src\compiler\codegen\index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">genElement</span> (<span class="params">el: ASTElement, state: CodegenState</span>): string &#123;</span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">parent</span>) &#123;</span><br><span class="line">    el.<span class="property">pre</span> = el.<span class="property">pre</span> || el.<span class="property">parent</span>.<span class="property">pre</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (el.<span class="property">staticRoot</span> &amp;&amp; !el.<span class="property">staticProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genStatic</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">once</span> &amp;&amp; !el.<span class="property">onceProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genOnce</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">for</span> &amp;&amp; !el.<span class="property">forProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genFor</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">if</span> &amp;&amp; !el.<span class="property">ifProcessed</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genIf</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tag</span> === <span class="string">&#x27;template&#x27;</span> &amp;&amp; !el.<span class="property">slotTarget</span> &amp;&amp; !state.<span class="property">pre</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genChildren</span>(el, state) || <span class="string">&#x27;void 0&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.<span class="property">tag</span> === <span class="string">&#x27;slot&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">genSlot</span>(el, state)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// component or element</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以观察到，<code>v-for</code>的优先级是比<code>v-if</code>高的，这就意味着，当要渲染某个列表项的时候，会先渲染全部的列表项，再判断是否改保留某个列表项。</p><p>但在实际开发中，有时可能希望根据<code>某个条件</code>来决定是否渲染<code>整个列表</code>，而不是对列表中的每个项都应用条件，此时如果我们把<code>v-for</code>和<code>v-if</code>写到同一个元素上，即便最终我们并不要渲染整个列表，也会由于<code>v-for</code>的优先级更高，仍然会创建这些元素的 <code>VNode </code>，造成不必要的性能浪费。在这种情况下，可以考虑调整指令的位置或结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;shouldShowList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>即便不是根据某个条件来判断是否渲染<code>整个列表</code>，而是每个列表项都使用<code>不同的判断条件</code>，也不建议把<code>v-if</code>和<code>v-for</code>写到一起，而是先<code>筛选</code>出那些<code>需要渲染的列表项</code>，然后再使用<code>v-for</code>渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in filteredItems&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">filteredItems</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="comment">/* your condition */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="v-if和v-show如何理解"><a href="#v-if和v-show如何理解" class="headerlink" title="v-if和v-show如何理解"></a>v-if和v-show如何理解</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>二者都是用来控制页面中元素的显示与隐藏，当表达式值为<code>false</code>的时候，都不会占据页面的位置。</p><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><p><code>v-show</code>本质是通过<code>切换css样式</code>来实现元素的显示与隐藏，令<code>display:none</code>让元素隐藏，dom元素还存在。</p><p><code>v-if</code>本质则是通过<code>控制dom元素的删除与创建</code>来实现元素的显示与隐藏，因为<code>v-if</code>直接操作<code>dom</code>，所以<code>v-if</code>有更高的性能消耗。</p><p><code>v-if</code>才是真正的<code>条件渲染</code>，<code>v-show</code>的值为<code>false</code>的元素，也会被渲染。</p><h2 id="说说你对nextTick的理解"><a href="#说说你对nextTick的理解" class="headerlink" title="说说你对nextTick的理解"></a>说说你对nextTick的理解</h2><p>vue数据改变，并不会立即操作dom来更新视图；而是会开启一个<strong>异步更新队列</strong>，将这些<code>更新操作</code>放入其中；在一次<code>事件循环</code>后，进行一次<strong>批量更新</strong>；</p><p>如果我们重复修改某个数据，异步更新队列还会进行<strong>去重</strong>操作；对于同一个组件内的多个数据变化，它们会被<strong>合并</strong>成一次更新；</p><p>创建新的虚拟dom，与旧的虚拟dom比较，得出最小变更，再把这个最小变更应用到实际dom。</p><p>使用方法：<code>Vue.nextTick(()=&gt;&#123;&#125;)</code>或者<code>this.$nextTick(()=&gt;&#123;&#125;)</code></p><p>nextTick是<strong>异步api</strong>，会返回一个<strong>promise对象</strong>，传入的回调函数会在<code>dom更新后</code>执行，也可以使用async&#x2F;await来操作dom。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;原始值&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用回调函数</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;修改后的值&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;原始的值&#x27;</span></span><br><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;修改后的值&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用async/await</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">message</span> = <span class="string">&#x27;修改后的值&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;原始的值&#x27;</span></span><br><span class="line"><span class="keyword">await</span> <span class="variable language_">this</span>.$nextTick()<span class="comment">//此时没有传入回调函数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>.<span class="property">textContent</span>) <span class="comment">//&#x27;修改后的值&#x27;</span></span><br></pre></td></tr></table></figure><p><a href="https://vue3js.cn/interview/vue/nexttick.html">面试官：Vue中的$nextTick有什么作用？ | web前端面试 - 面试官系列</a></p><h2 id="说说你对vue中key的理解"><a href="#说说你对vue中key的理解" class="headerlink" title="说说你对vue中key的理解"></a>说说你对vue中key的理解</h2><p>key是给每一个虚拟dom（或者说vnode）的唯一id。在diff过程中，根据key值，可以更<strong>准确</strong>， 更快的找到待比较的虚拟dom，从而优化diff算法，提高dom的复用率。</p><p>如果不设置key，那key值默认就都是undefined，将会按顺序进行<strong>新旧虚拟dom</strong>的比较。</p><p>详细可参考禹神的vue视频：<a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?spm_id_from=333.788.videopod.episodes&vd_source=00483a04a5a69136669373a8ea522a9b&p=30">030_尚硅谷Vue技术_key作用与原理_哔哩哔哩_bilibili</a></p><h2 id="什么是虚拟dom？有什么作用？如何实现？"><a href="#什么是虚拟dom？有什么作用？如何实现？" class="headerlink" title="什么是虚拟dom？有什么作用？如何实现？"></a><strong>什么是虚拟dom？有什么作用？</strong>如何实现？</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>虚拟dom本质就是一个用来<strong>描述真实dom的js对象</strong>，是对真实dom的<strong>高度抽象</strong>。</p><h3 id="有什么作用"><a href="#有什么作用" class="headerlink" title="有什么作用"></a>有什么作用</h3><ul><li>操作<code>实际dom</code>是非常消耗性能的，频繁操作dom可能导致<strong>页面卡顿</strong>。使用diff算法进行，进行新旧虚拟dom之间的比较，能帮助我得出最小的变更，再把这个变更应用到实际dom中，<strong>从而减少dom的操作次数</strong>。</li><li><strong>抽象了原本的渲染过程</strong>，实现了<strong>跨平台的能力</strong>，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI。从 <code>React</code> 到 <code>Vue</code> ，虚拟 <code>DOM</code> 为这两个框架都带来了跨平台的能力（<code>React-Native</code> 和 <code>Weex</code>）</li></ul><h3 id="在vue中如何创建虚拟dom"><a href="#在vue中如何创建虚拟dom" class="headerlink" title="在vue中如何创建虚拟dom"></a><strong>在vue中如何创建虚拟dom</strong></h3><p><code>createElement</code> 创建 <code>VNode</code> 的过程，每个 <code>VNode</code> 有 <code>children</code>，<code>children</code> 每个元素也是一个<code>VNode</code>，这样就形成了一个虚拟树结构，用于描述真实的<code>DOM</code>树结构。</p><p>一个典型的 <code>vnode</code> 对象可能包含以下字段：</p><ul><li><code>tag</code>: 元素类型（例如 <code>&#39;div&#39;</code>、<code>&#39;span&#39;</code> 等）</li><li><code>data</code>: 包含元素的属性、样式、事件处理器等元数据</li><li><code>children</code>: 子节点数组，可以是其他 <code>vnode</code> 或文本字符串</li><li><code>text</code>: 如果是文本节点，则包含文本内容</li><li><code>el</code>: 引用对应的真实DOM节点（仅在某些实现中存在）</li></ul><h2 id="说说diff算法"><a href="#说说diff算法" class="headerlink" title="说说diff算法"></a>说说diff算法</h2><img src="..\images\前端面试-vue\dom操作优化.png" style="zoom:80%;" /><h2 id="说说你对keep-alive的理解"><a href="#说说你对keep-alive的理解" class="headerlink" title="说说你对keep-alive的理解"></a>说说你对keep-alive的理解</h2><p>keep-alive是<strong>vue中的内置组件</strong>，包裹动态组件（router-view）时，会缓存不活动的<strong>组件实例</strong>，而不是销毁它们，<strong>防止重复渲染DOM</strong>。</p><p>被缓存的组件会额外多出两个生命周期<code>activated</code>和<code>deactivated</code></p><p>keep-alive可以使用一些<code>属性</code>来更精细的控制组件缓存。</p><ul><li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件<strong>会</strong>被缓存</li><li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都<strong>不会</strong>被缓存</li><li><code>max</code> - 数字。最多可以缓存多少组件实例，超出这个数字之后，则<strong>删除第一个</strong>被缓存的组件，由此可以推测存在一个缓存队列，先入先出。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;a,b&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正则表达式 (使用 `v-bind`,动态绑定，表示传入的是表达式) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;/a|b/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数组 (使用 `v-bind，动态绑定，表示传入的是表达式`) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>vue3中的keep-alive的语法不同于vue2</p><p>基础用法，默认缓存所有页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component &#125;&quot;</span>&gt;</span>Component可以理解为用来替代router-view的组件</span><br><span class="line">  //keep-alive包裹的不再是router-view而是具体的组件</span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>精确控制具体哪些组件缓存，因为再vue3中使用组件已经不再需要注册，也不需要给组件命名，所以我们控制组件（页面）缓存的依据变成了<strong>页面的路由对象</strong>，而不是组件的名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span>  <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在路由对象中添加meta属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&quot;/keepAliveTest&quot;</span>,</span><br><span class="line">   <span class="attr">name</span>: <span class="string">&quot;keepAliveTest&quot;</span>,</span><br><span class="line">   <span class="attr">meta</span>: &#123;</span><br><span class="line">       <span class="attr">keepAlive</span>: <span class="literal">true</span> <span class="comment">//设置页面是否需要使用缓存</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/views/keepAliveTest/index.vue&quot;</span>)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component, route &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!route.meta.keepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是就到此位置的话，切换页面的时候会报错：<code>vue3 TypeError: parentComponent.ctx.deactivate is not a function 报错</code></p><p>网上提供的<a href="https://blog.csdn.net/zhouning7879/article/details/130639409">解决方案</a>就是给每个component提供一个key。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; Component, route &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;route.name&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;route.meta.isKeepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;Component&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;route.name&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!route.meta.isKeepAlive&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>详细可参考：<a href="https://juejin.cn/post/6978772143748153381">vue3中使用keep-alive目的：掘金</a></p><p><strong>组件名称匹配，组件名称指的到底是什么呢？</strong></p><p>匹配首先检查<strong>组件自身的</strong> <code>name</code> 选项，如果 <code>name</code> 选项不可用，则匹配它的<strong>局部注册名称</strong> (父组件 <code>components</code> 选项的<strong>键值</strong>)，匿名组件不能被匹配。</p><p><strong>组件被缓存了，如何获取数据呢？</strong></p><p>借助<code>beforeRouteEnter</code>这个<code>组件内的导航守卫</code>，或者<code>activated</code>生命周期函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)&#123;</span><br><span class="line">    <span class="title function_">next</span>(<span class="function"><span class="params">vm</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(vm)</span><br><span class="line">        <span class="comment">// 每次进入路由执行</span></span><br><span class="line">        vm.<span class="title function_">getData</span>()  <span class="comment">// 获取数据</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">activated</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">getData</span>() <span class="comment">// 获取数据</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h2><p>mixin本质就是一个<strong>js对象</strong>，包含了vue组件<strong>任意功能选项</strong>，如<code>data</code>、<code>components</code>、<code>methods</code>、<code>created</code>、<code>computed</code>等等</p><p>，被用来<strong>分发</strong> <code>Vue</code> 组件中的<strong>可复用功能</strong>。</p><p>可分<strong>为全局混入和局部混入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">  <span class="attr">created</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;全局混入&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)<span class="comment">//全局混入</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">mixins</span>:[&#123;<span class="attr">created</span>:<span class="function">()=&gt;</span>&#123;&#125;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果混入组件的时候出现了<strong>功能选项冲突</strong>，一般以组件功能选项为准。</p><p><a href="https://vue3js.cn/interview/vue/mixin.html#%E4%B8%80%E3%80%81mixin%E6%98%AF%E4%BB%80%E4%B9%88">面试官：说说你对vue的mixin的理解，有什么应用场景？ | web前端面试 - 面试官系列</a></p><p>在<strong>vue3</strong>的组合式api中，混入（mixin）显然就没有用武之地了，转而被<code>composable</code>替代，下面就是一个例子，介绍了在vue3中是如何复用代码的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//useCountDown.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">&#x27;dayjs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//导出一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">countDown</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Time</span> = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> formatTime = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> dayjs.<span class="title function_">unix</span>(<span class="title class_">Time</span>.<span class="property">value</span>).<span class="title function_">format</span>(<span class="string">&#x27;mm分ss秒&#x27;</span>))</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">start</span> = (<span class="params">time</span>) =&gt; &#123;</span><br><span class="line">    <span class="title class_">Time</span>.<span class="property">value</span> = time</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Time</span>.<span class="property">value</span>--</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Time</span>.<span class="property">value</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(n)</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(<span class="string">&#x27;订单超时&#x27;</span>)</span><br><span class="line">        router.<span class="title function_">push</span>(<span class="string">&#x27;/cartList&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; formatTime, start &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好理解啊，就像大多数编程语言一样，把能实现部分功能的代码<strong>封装成一个函数</strong>，需要的时候再导入这个函数，调用这个函数，和把这些代码直接写在组件中相比，区别只于私有化了变量，需要通过return导出。</p><h2 id="跨域是什么？Vue项目中你是如何解决跨域的呢？"><a href="#跨域是什么？Vue项目中你是如何解决跨域的呢？" class="headerlink" title="跨域是什么？Vue项目中你是如何解决跨域的呢？"></a>跨域是什么？Vue项目中你是如何解决跨域的呢？</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p><strong>跨域</strong>本质是<code>浏览器</code>基于<strong>同源策略</strong>的一种<code>安全手段</code>，它是<strong>浏览器</strong>最核心也最基本的安全功能，服务器间通信不会有跨域的问题。</p><p>所谓同源（即指在同一个域）具有以下三个相同点</p><ul><li>协议相同（protocol）</li><li>主机相同（host）</li><li>端口相同（port）</li></ul><p>反之非同源请求，也就是协议、端口、主机其中一项不相同的时候，这时候就会产生跨域(非同源产生跨域)</p><p>举个例子，我们直接打开 HTML 文件使用的是<code>file:///</code>协议加载，如果文档内部请求了其他<code>网络资源</code>，因为HTTP 请求使用的是 <code>http://</code> 或 <code>https:// </code>协议，协议不同，就发生了跨域。</p><p>和<strong>跨站</strong>有什么区别呢？跨站不涉及协议和端口号，<strong>一般情况下，跨站指的就是主域名不同</strong>，比如<code>www.bilibili.com</code>和<code>game.bilibili.com</code>属于同站。</p><h3 id="如何解决-1"><a href="#如何解决-1" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li>JSONP</li><li>CORS</li><li>Proxy</li></ul><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a><strong>JSONP</strong></h4><p>利用了<code>script</code>标签可以<strong>跨域加载脚本</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">function</span> <span class="title function_">onClick</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">      script.<span class="property">src</span> = <span class="string">&quot;http://127.0.0.1:8081/api/callback?callback=hello&quot;</span></span><br><span class="line">      <span class="comment">//给script标签对象添加监听事件</span></span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">      <span class="comment">//比addEventListener写法简单</span></span><br><span class="line">      <span class="comment">//原始事件监听模型</span></span><br><span class="line">      script.<span class="property">onload</span> = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">        script.<span class="title function_">remove</span>()<span class="comment">//调用remove方法删除这个标签</span></span><br><span class="line">      &#125;<span class="comment">//脚本加载后立马删除，监听*onload*事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;onClick()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实还有其他标签可以跨域加载资源，貌似大部分标签都可以跨域加载资源…</p><p><strong>媒体资源</strong></p><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td>img标签</td><td>可以跨域加载图像资源，但是如果给img标签加上crossorigin属性，那么就会以跨域的方式请求图片资源</td></tr><tr><td>audio和video标签</td><td>可以跨域加载视频，音频</td></tr></tbody></table><p><strong>前端基础三大文件</strong></p><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td>link标签</td><td>可以跨域加载CSS文件</td></tr><tr><td>iframe标签</td><td>可以跨域加载HTML页面。</td></tr><tr><td>script标签</td><td>可以跨域加载脚本</td></tr></tbody></table><p>jsonp请求有个明显的缺点：只能发送<code>get</code>请求</p><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><strong>Proxy</strong></h4><p>代理（Proxy）也称<code>网络代理</code>，是一种特殊的<code>网络服务</code>，允许一个（一般为客户端）通过<code>代理</code>与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。</p><p>代理的方式也可以有多种：</p><ul><li><p><strong>在脚手架中配置</strong></p><p>在开发过程中，我们可以在<code>脚手架</code>中配置代理。我们可以通过<code>webpack（或者vite）</code>为我们开起一个<code>本地服务器</code>(devServer，域名一般是<code>localhost:8080</code>)，作为请求的<code>代理对象</code>，所以说，这个本地服务器不仅能<code>部署</code>我们<code>开发打包</code>的资源，还能起到<code>代理</code>作用。</p><p>通过该服务器<code>转发</code>请求至目标服务器，得到结果再转发给前端，因为服务器之间通信不存在跨域问题，所以能解决跨域问题。</p><p>打包之后的项目文件，因为脱离了代理服务器，所以说这种方式只能在<code>开发环境</code>使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vue.config.js 即vue-cli脚手架（基于webpack）开发的vue项目</span></span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">   <span class="attr">proxy</span>: &#123;</span><br><span class="line">     <span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//匹配所有以/api开头的请求路径</span></span><br><span class="line">       <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>, <span class="comment">// 后端服务器地址</span></span><br><span class="line">       <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 改变请求源，让浏览器认为请求是来自本地</span></span><br><span class="line">       <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;, <span class="comment">// 重写路径，移除前缀</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vite.config.js 即vue-create脚手架（基于vite）开发的vue项目</span></span><br><span class="line"><span class="attr">server</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//匹配所有以/api开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span>, <span class="comment">// 后端服务器地址</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 改变请求源，让浏览器认为请求是来自本地</span></span><br><span class="line">        <span class="attr">rewrite</span>: <span class="function">(<span class="params">path</span>) =&gt;</span> path.<span class="title function_">replace</span>(<span class="regexp">/^\/api/</span>, <span class="string">&#x27;&#x27;</span>), <span class="comment">// 重写路径，移除前缀</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="..\images\前端面试-vue\跨域.png" style="zoom:85%;" /><p>可以看到，我们要使用代理，在编写接口时，就不能书写完整的路径，比如就不能直接把请求url写成<code>https://www.sanye.blog/books</code>，这样必然跨域，我们应该把请求写为<code>/books</code>，部署到本地服务器后加载网页，发起这个请求前，会先自动与<code>域名</code>拼接，实际的请求就变为<code>http://localhost:8080/books</code>，这样就没跨域，不过确实，这么操作的话，就是在请求本地服务器中的<code>books</code>资源，而不是目标服务器中的，如果我们本地服务器中有这个资源（vue-cli中是public目录下有books文件，无后缀），那么本地服务器就会把这个资源返回给浏览器，<strong>无论我们是否开启了代理</strong>，所以我们实际还要添加<code>/api</code>类似的多余的前缀，确保我们访问的<code>不是</code>本地服务器中的资源，然后本地服务器会帮我们按照配置的规则进行<code>路径重写</code>，得到正确的请求URL，再向目标服务器请求资源。</p></li><li><p><strong>在服务端开启代理</strong></p><p>其实也不是打包后就不能通过代理来解决跨域问题，如果我们把<code>打包后的前端资源</code>部署到<code>本地的服务器</code>，比如使用基于<code>node.js</code>的<code>express</code>框架搭建的<code>本地服务器</code>，我们也可以通过配置代理来解决跨域问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>( <span class="string">&#x27;express &#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">//其实webpack-dev-server开启代理功能的核心也是这个中间件</span></span><br><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>( <span class="string">&#x27;http-proxy-middleware &#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>( . /public)）<span class="comment">//引入静态资源</span></span><br><span class="line">app.<span class="title function_">use</span>( <span class="string">&#x27;/api&#x27;</span> ,<span class="title function_">createProxyMiddleware</span>(&#123;</span><br><span class="line"><span class="attr">target</span>: <span class="string">&#x27; https:// www.toutiao.com&#x27;</span>,</span><br><span class="line"><span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line"><span class="attr">pathRewrite</span>:&#123;</span><br><span class="line"><span class="string">&#x27;^/api &#x27;</span> : <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>总之想要配置代理，就离不开一台允许你配置代理的<code>服务器</code>，把打包后的前端资源托管到<code>其他平台</code>，我们也无法来配置代理，也就无法解决跨域问题。</p></li></ul><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h4><p>CORS （Cross-Origin Resource Sharing），即跨域资源共享，意思就是虽然你在跨域请求我的资源，但是我还是<code>选择性的</code>共享资源给你，浏览器根据<code>响应头</code>中的<code>特定字段</code>来决定是否拦截<code>跨域请求</code>返回的数据。</p><p>因为需要在<code>响应头</code>上做文章，所以这个工作主要是前后端协调后由后端负责，至于前后端如何协调，参考<code>简单请求</code>和<code>复杂请求</code>部分。</p><h2 id="如何理解简单请求和复杂请求"><a href="#如何理解简单请求和复杂请求" class="headerlink" title="如何理解简单请求和复杂请求"></a>如何理解简单请求和复杂请求</h2><table><thead><tr><th></th><th>简单请求</th><th>复杂请求</th></tr></thead><tbody><tr><td>请求方法(携带在请求行中)</td><td>get，post，head</td><td>除get，post，head外的请求方法</td></tr><tr><td>请求头</td><td>满足cors安全规范（一般不修改请求头就是安全的）<code>Content-Type</code> 的值仅限于以下三种之一：  <code>application/x-www-form-urlencoded</code> <code>multipart/form-data</code> <code>text/plain</code></td><td>设置了自定义的 HTTP 头，或者 <code>Content-Type</code> 不是上述三种之一时</td></tr></tbody></table><p>在非跨域情况下，区分二者并没有什么意义，但是在跨域情况下，发送复杂请求前，会先发送一次<code>预检请求</code>，请求方法为<code>options</code>，</p><p>在请求头中携带<code>Origin</code>,<code>Access-Control-Request-Method</code>,<code>Access-Control-Request-Headers</code>字段，询问服务器是否接受来自xxx源，请求方法为xxx，请求头为xxx的<code>跨域复杂请求</code>，如果接受则再发送这样的<code>复杂请求</code>。</p><img src="..\images\前端面试-vue\options.jpg" style="zoom:80%;" /><p>服务端处理代码（以express框架为例）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">options</span>( <span class="string">&#x27;/students &#x27;</span>,<span class="function">(<span class="params"> req,res</span>)=&gt;</span>&#123;</span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> , <span class="string">&#x27;http://127.0.0.1:5500&#x27;</span>)</span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods &#x27;</span> , <span class="string">&#x27;GET&#x27;</span>)</span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers &#x27;</span> ,<span class="string">&#x27;school&#x27;</span>）</span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Max-Age &#x27;</span> , <span class="number">7200</span>)<span class="comment">//告诉浏览器在7200s内不要再发送预检请求询问</span></span><br><span class="line">res.<span class="title function_">send</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样处理起来明显比较繁琐，实际上我们借助<code>CORS中间件</code>就能统一处理<code>简单请求和复杂请求（包括预检请求）</code>的跨域问题。</p><h2 id="vue项目如何部署？有遇到布署服务器后刷新404问题吗"><a href="#vue项目如何部署？有遇到布署服务器后刷新404问题吗" class="headerlink" title="vue项目如何部署？有遇到布署服务器后刷新404问题吗"></a>vue项目如何部署？有遇到布署服务器后刷新404问题吗</h2><h3 id="如何部署"><a href="#如何部署" class="headerlink" title="如何部署"></a>如何部署</h3><p>前后端分离开发模式下，前后端是<code>独立布署</code>的，前端只需要将最后的构建物上传至目标服务器的<code>web</code>容器指定的<code>静态目录</code>下即可，我们知道<code>vue</code>项目在构建后，是生成一系列的静态文件。</p><h3 id="404问题"><a href="#404问题" class="headerlink" title="404问题"></a>404问题</h3><p>HTTP 404 错误意味着链接指向的资源不存在，问题在于为什么不存在？且为什么只有<code>history</code>模式下会出现这个问题，而hash模式下不会有?</p><p>history模式，刷新页面，<code>前端路由部分</code>会被当作<code>请求URL</code>的一部分发送给服务器，然而服务器<code>并没有相关配置</code>，所以<code>响应404</code>。</p><p>而hash模式，前端路由在URL的<code>#</code>后面，不会被当作请求URL的一部分。</p><p>要解决使用history路由的项目，必须和<code>后端</code>沟通，当请求的页面不存在时，返回<code>index.html</code>，把页面控制权全交给<code>前端路由</code>，</p><p>但是这样有个问题，就是后端服务器不会再响应<code>404</code>错误了，当找不到请求的资源总是会返回index.html，即便请求的资源在前后端中都不存在（即把页面控制权交给前端路由，也没有对应的页面），所以为了避免这种情况，应该在 Vue应用里面<code>覆盖所有的路由情况</code>，最后给出一个 <code>404 页面</code>(虽然说是404页面，但是响应状态码是200，因为返回了<code>index.html</code>)</p><h2 id="hash路由和history路由的实现原理，二者有什么区别？"><a href="#hash路由和history路由的实现原理，二者有什么区别？" class="headerlink" title="hash路由和history路由的实现原理，二者有什么区别？"></a>hash路由和history路由的实现原理，二者有什么区别？</h2><img src="..\images\前端面试-vue\前端路由.png" style="zoom:67%;" /><p><code>哈希路由</code>（Hash-based Routing）和<code> History 路由</code>（History API-based Routing）是前端路由的两种常见实现方式，它们用于在单页面应用程序 (SPA) 中模拟多页面体验，而无需重新加载整个页面。</p><h3 id="hash路由"><a href="#hash路由" class="headerlink" title="hash路由"></a>hash路由</h3><h4 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a><strong>是什么</strong></h4><p><code>前端路由</code>被放到<code>url</code>的<code>hash</code>部分，即url中<code>#</code>后面的部分。<code>哈希值</code>改变也不会触发页面<code>重新加载</code>，浏览器也不会将<code>哈希值</code>发送到服务器，因此无论<code>哈希值</code>如何变化，服务器只会返回同一个初始 HTML 文件。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul><li>不需要服务器配置支持，因为哈希值不会被发送给服务器。</li><li><code>兼容性好</code>，几乎所有浏览器都支持哈希变化事件。</li><li>URL 中包含显眼的 <code>#</code> 符号，可能影响美观。</li><li>前端路由部分十分明确，方便部署，可以部署在服务器的<code>任何位置</code>。</li></ul><h4 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a><strong>如何做</strong></h4><img src="..\images\前端面试-js\hash.png" style="zoom:67%;" /><p>可以直接设置 <code>window.location.hash</code> 属性来<code>改变</code> URL 中的哈希部分，改变 <code>window.location.hash</code> 不会触发<code>页面刷新</code>，但它会添加一个<code>新的历史记录条目</code>。</p><p>前端 JavaScript 监听 <code>hashchange</code> 事件来<code>检测</code>哈希的变化，并根据新的哈希值更新页面内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;hashchange&#x27;, function () &#123;</span><br><span class="line">    const hash = window.location.hash.slice(1); // 获取去掉 # 后的部分</span><br><span class="line">    console.log(`Hash changed to: $&#123;hash&#125;`);</span><br><span class="line">    // 根据 hash 更新页面内容</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="history路由"><a href="#history路由" class="headerlink" title="history路由"></a>history路由</h3><h4 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a><strong>是什么</strong></h4><p>使用标准的路径形式，例如 <code>http://example.com/page1</code>，<code>前端路由</code>被放到<code>url</code>中的<code>资源路径</code>部分</p><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><ul><li><p>没有显眼的<code>#</code>号，更为美观</p></li><li><p>需要后端支持，否则会出现<code>404</code>问题，因为前端路由会被发送到后端，而后端并未做对应配置。</p></li><li><p>对较老版本的浏览器兼容性较差（IE10+ 支持 History API）</p></li><li><p>history路由的项目一般部署在<code>服务器根目录</code>，域名后面的路径就是<code>前端路径</code>，否则需要在<code>前端路由库</code>(比如VueRouter)中做额外配置，确保浏览器能从url中提取出文件路径。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: <span class="string">&#x27;/app/&#x27;</span>, <span class="comment">// 设置基础路径</span></span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 你的路由配置</span></span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例如，如果用户的 URL 是 <code>http://example.com/app/user/profile</code>，那么前端路由库会将 <code>/user/profile</code> 视为<code>实际的路由路径</code>，而 <code>/app/</code> 则被视为基础路径。</p></li></ul><h4 id="如何做-1"><a href="#如何做-1" class="headerlink" title="如何做"></a><strong>如何做</strong></h4><img src="..\images\前端面试-js\history.png" style="zoom:67%;" /><p>使用 <code>HTML5</code> 的 History API (<code>history.pushState()</code> 和 <code>history.replaceState()</code>) 来<code>修改</code> URL，而不会触发页面刷新。</p><p><strong>history.pushState(stateObj, title, url)</strong></p><ul><li><p><strong>功能</strong>：</p><ul><li><p>向浏览器的<code>历史栈</code>中添加一个新的记录，历史栈长度+1，</p></li><li><p>并更新<code>当前 URL</code>，但不重新加载页面。</p></li></ul></li><li><p><strong>参数</strong></p><ul><li><code>stateObj</code>: 一个对象，用于存储与该状态相关联的数据，可以通过 <code>popstate</code> 事件访问。也可以通过<code>history.state</code>属性访问。</li><li><code>title</code>：通常被忽略或设为空字符串（大多数浏览器不支持）。</li><li><code>url</code>：新的 URL，可以是相对路径或绝对路径，<strong>但不能改变域名，否则会报错</strong>。</li></ul><img src="..\images\前端面试-js\a.png" style="zoom:90%;" /></li></ul><p><strong>history.replaceState(stateObj, title, url)</strong></p><ul><li><strong>功能</strong>：<ul><li>替换当前的历史记录条目，而不是添加新的条目。</li><li>它同样更新<code>当前 URL</code> 但不刷新页面。</li></ul></li><li><strong>参数</strong>：与 <code>pushState</code> 相同。</li></ul><p>监听 <code>popstate</code> 事件来响应浏览器的前进&#x2F;后退按钮操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// History 路由监听</span><br><span class="line">window.addEventListener(&#x27;popstate&#x27;, function (event) &#123;</span><br><span class="line">    console.log(&#x27;URL changed to:&#x27;, event.state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢-？"><a href="#说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢-？" class="headerlink" title="说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢 ？"></a>说下你的vue项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢 ？</h2><p>在划分项目结构的时候，需要遵循一些基本的原则：</p><ul><li>文件夹和文件夹内部文件的语义一致性</li><li>单一入口&#x2F;出口</li><li>就近原则，紧耦合的文件应该放到一起，且应以相对路径引用</li><li>公共的文件应该以绝对路径的方式从根目录引用</li><li><code>/src</code> 外的文件不应该被引入</li></ul><p><strong>文件夹和文件夹内部文件的语义一致性</strong></p><p>我们的目录结构都会有一个文件夹是按照<code>路由模块</code>来划分的，如<code>pages</code>文件夹，这个文件夹里面应该包含我们项目所有的路由模块，并且<code>仅</code>应该包含路由模块，而不应该有别的其他的非路由模块的文件夹</p><p>这样做的好处在于一眼就从 <code>pages</code>文件夹看出这个项目的路由有哪些</p><p><strong>单一入口&#x2F;出口</strong></p><p>举个例子，在<code>pages</code>文件夹里面存在一个<code>seller</code>文件夹，这时候<code>seller</code> 文件夹应该作为一个独立的模块由外部引入，并且 <code>seller/index.js</code> 应该作为外部引入 seller 模块的唯一入口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误用法</span><br><span class="line">import sellerReducer from &#x27;src/pages/seller/reducer&#x27;//可以是reducer，就可以是其他，这样出口就不唯一。</span><br><span class="line"></span><br><span class="line">// 正确用法</span><br><span class="line">import &#123; reducer as sellerReducer &#125; from &#x27;src/pages/seller&#x27;//默认引入seller目录下的index.js文件</span><br></pre></td></tr></table></figure><p><strong>就近原则，紧耦合的文件应该放到一起，且应以相对路径引用</strong></p><p>使用<code>相对路径</code>可以保证模块内部的独立性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 正确用法</span><br><span class="line">import styles from &#x27;./index.module.scss&#x27;</span><br><span class="line">// 错误用法</span><br><span class="line">import styles from &#x27;src/pages/seller/index.module.scss&#x27;</span><br></pre></td></tr></table></figure><p>举个例子</p><p>假设我们现在的 seller 目录是在 <code>src/pages/seller</code>，如果我们后续发生了路由变更，需要加一个层级，变成 <code>src/pages/user/seller</code>。</p><p>如果我们采用第一种相对路径的方式，那就可以直接将整个文件夹拖过去就好，<code>seller</code> 文件夹内部不需要做任何变更。</p><p>但是如果我们采用第二种绝对路径的方式，移动文件夹的同时，还需要对每个 <code>import</code> 的路径做修改</p><p>总之就是要体会到相对路径的好处，移动文件也不需要修改路径，只要相对位置没变就好。</p><p><strong>&#x2F;src 外的文件不应该被引入</strong></p><p><code>vue-cli</code>脚手架已经帮我们做了相关的约束了，正常我们的前端项目都会有个<code>src</code>文件夹，里面放着所有的项目需要的资源，<code>js</code>,<code> css</code>, <code>png</code>, <code>svg</code> 等等。<code>src</code> 外会放一些项目配置，依赖，环境等文件</p><p>这样的好处是方便划分项目代码文件和配置文件</p><h2 id="Vue如何做权限管理"><a href="#Vue如何做权限管理" class="headerlink" title="Vue如何做权限管理"></a>Vue如何做权限管理</h2><p>权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源</p><p>而前端权限归根结底是<code>请求的发起权</code>，请求的发起可能有下面两种形式触发</p><ul><li>页面加载触发</li><li>页面上的按钮点击触发</li></ul><h3 id="如何做-2"><a href="#如何做-2" class="headerlink" title="如何做"></a>如何做</h3><p>前端权限控制可以分为四个方面：</p><ul><li>接口权限</li><li>按钮权限</li><li>菜单权限</li><li>路由权限</li></ul><p><strong>接口权限</strong></p><p>接口权限目前一般采用<code>jwt</code>的形式来验证，没有通过的话一般返回<code>401</code>（用户不存在），跳转到登录页面重新进行登录</p><p>登录完拿到<code>token</code>，将<code>token</code>存起来，通过<code>axios</code>请求拦截器进行拦截，每次请求的时候头部携带<code>token</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">    config.headers[&#x27;token&#x27;] = cookie.get(&#x27;token&#x27;)</span><br><span class="line">    return config</span><br><span class="line">&#125;)</span><br><span class="line">axios.interceptors.response.use(res=&gt;&#123;&#125;,&#123;response&#125;=&gt;&#123;</span><br><span class="line">    if (response.data.code === 40099 || response.data.code === 40098) &#123; //token过期或者错误</span><br><span class="line">        router.push(&#x27;/login&#x27;)//路由跳转</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vue3有了解过吗？能说说跟vue2的区别吗？"><a href="#vue3有了解过吗？能说说跟vue2的区别吗？" class="headerlink" title="vue3有了解过吗？能说说跟vue2的区别吗？"></a>vue3有了解过吗？能说说跟vue2的区别吗？</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>关于<code>vue3</code>的重构背景，尤大是这样说的：</p><p>「Vue 新版本的理念成型于 2018 年末，当时 Vue 2 的代码库已经有两岁半了。比起通用软件的生命周期来这好像也没那么久，但在这段时期，前端世界已经今昔非比了</p><p>在我们更新（和重写）Vue 的主要版本时，主要考虑两点因素：首先是新的 JavaScript 语言特性在主流浏览器中的受支持水平；其次是当前代码库中随时间推移而逐渐暴露出来的一些设计和架构问题」</p><p>简要就是：</p><ul><li>利用新的语言特性(es6)</li><li>解决架构问题</li></ul><h3 id="新增特性"><a href="#新增特性" class="headerlink" title="新增特性"></a>新增特性</h3><p>Vue 3 中需要关注的一些新功能包括：</p><ul><li><p><strong>fragment</strong></p><p>在 Vue 2 中，组件必须有一个根元素。而在 Vue 3 中，组件可以有多个根节点，它们会自动被<code>fragment</code>标签包裹，它不参与渲染。</p></li><li><p><strong>Teleport</strong></p><p><code>Teleport </code>组件的<code>内部结构</code>将会被“传送”到指定的目标容器中</p><p>组件标签的<code>to </code>属性，指定目标容器的<code>选择器</code>或 <code>DOM </code>节点</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showToast&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>打开 toast<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- to 属性就是目标位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;#teleport-target&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;visible&quot;</span> <span class="attr">class</span>=<span class="string">&quot;toast-wrap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;toast-msg&quot;</span>&gt;</span>我是一个 Toast 文案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>composition Api</strong></p><p>即组合式api，把逻辑紧密联系的代码放到一起，提高了代码的可维护性。</p></li></ul><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="vue3做了哪些优化？"><a href="#vue3做了哪些优化？" class="headerlink" title="vue3做了哪些优化？"></a>vue3做了哪些优化？</h2><p>这是一个很大的话题，这里只做<code>简要介绍</code>，后续对每个部分都有<code>详细解释</code>。</p><ul><li><p>更小</p><p>Vue3移除了一些不常用的 API，引入<code>tree-shaking</code>，可以将无用模块“剪辑”，仅打包需要的，使<strong>打包的整体体积变小了</strong>。</p></li><li><p>更快</p><p>主要体现在编译方面：</p><ul><li>diff算法优化</li><li>静态提升</li><li>事件监听缓存</li><li>SSR优化</li></ul></li><li><p>更友好</p><p><code>vue3</code>在兼顾<code>vue2</code>的<code>options API</code>的同时还推出了<code>composition API</code>，大大增加了代码的逻辑组织和代码复用能力。</p></li></ul><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a><strong>优化方案</strong></h3><p><code>vue3</code>从很多层面都做了优化，可以分成三个方面：</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>源码可以从两个层面展开：</p><ul><li><p>源码管理</p><p><code>vue3</code>整个源码是通过 <code>monorepo</code>的方式维护的，根据功能将不同的模块拆分到<code>packages</code>目录下面不同的子目录中</p><p>这样使得<code>模块拆分</code>更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。</p></li><li><p>TypeScript</p><p><code>Vue3</code>是基于<code>typeScript</code>编写的，提供了更好的类型检查，能支持复杂的类型推断</p></li></ul><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul><li><p>体积优化</p></li><li><p>编译优化</p></li><li><p>数据劫持优化</p><p>在<code>vue2</code>中，数据劫持是通过<code>Object.defineProperty</code>，这个 API 有一些缺陷，<strong>并不能检测对象属性的添加和删除</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>尽管<code>Vue</code>为了解决这个问题提供了 <code>set</code>和<code>delete</code>实例方法，但是对于用户来说，还是增加了一定的心智负担。</p><p>相比之下，<code>vue3</code>是通过<code>proxy</code>监听整个对象，那么对于删除还是监听当然也能监听到</p><p>同时<code>Proxy</code> 并不能监听到内部深层次的对象变化，而 <code>Vue3</code> 的处理方式是在<code>getter</code> 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归。</p></li></ul><h4 id="语法API"><a href="#语法API" class="headerlink" title="语法API"></a>语法API</h4><p>这里当然说的就是<code>composition API</code>，其两大显著的优化：</p><ul><li>优化逻辑组织</li><li>优化逻辑复用</li></ul><p>在<code>vue2</code>中，我们是通过<code>mixin</code>实现功能复用，如果多个<code>mixin</code>混合，会存在两个非常明显的问题：<code>命名冲突</code>和<code>数据来源不清晰</code></p><p>而在组合式api中，我们可以将一些可复用的代码抽离出来作为<code>一个函数</code>并导出，在需要使用的地方导入后直接调用即可。这个种模块化的方式既解决了<code>命名冲突</code>的问题，也解决了<code>数据来源不清晰</code>的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mouse/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; toRefs, reactive, onUnmounted, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;&#123;</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入</span></span><br><span class="line"><span class="keyword">import</span> useMousePosition <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMousePosition</span>()<span class="comment">//直接调用</span></span><br><span class="line">        <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#Vue3-0里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？"></a>Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</h2><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改对象的现有属性，并返回此对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个对象，将这个对象转变成响应式对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="comment">//如果存在嵌套对象的情况，则递归添加响应式。</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="keyword">typeof</span> val == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_">observe</span>(val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                <span class="comment">//当给key赋值为对象的时候，还需要在set方法中给这个对象也添加响应式。</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">typeof</span> newVal == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">                    <span class="title function_">observe</span>(newVal)</span><br><span class="line">                &#125;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="comment">//调用update方法，做一些更新视图的工作，依赖这个属性的视图，计算属性，watch都会更新或执行一些逻辑</span></span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrData = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="title function_">observe</span>(arrData)</span><br><span class="line">arrData.<span class="title function_">push</span>() <span class="comment">//无响应</span></span><br><span class="line">arrData.<span class="title function_">pop</span>()  <span class="comment">//无响应</span></span><br><span class="line">arrDate[<span class="number">0</span>] = <span class="number">99</span> <span class="comment">//ok，有响应</span></span><br></pre></td></tr></table></figure><p><strong>缺点小结</strong></p><ul><li><code>Object.defineProperty</code>无法监听到数组方法对数组元素的修改</li><li>需要遍历对象每个属性<code>逐个添加监听</code>，而且无法监听到<code>对象属性</code>的<code>添加</code>与<code>删除</code>，如果属性值是嵌套对象，还深层监听，造成性能问题。</li></ul><h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a>Proxy</h3><p><code>Proxy</code>的监听是<code>整个对象</code>，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了</p><p>定义一个响应式方法<code>reactive</code>，这个<code>reactive</code>方法就是vue3中的<code>reactive</code>方法的<strong>简化版</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下简单数据的操作，发现都能劫持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1.获取</span></span><br><span class="line">state.<span class="property">foo</span> <span class="comment">// 输出获取foo:foo</span></span><br><span class="line"><span class="comment">// 2.设置已存在属性</span></span><br><span class="line">state.<span class="property">foo</span> = <span class="string">&#x27;fooooooo&#x27;</span> <span class="comment">//设置foo:fooooooo</span></span><br><span class="line"><span class="comment">// 3.设置不存在属性</span></span><br><span class="line">state.<span class="property">dong</span> = <span class="string">&#x27;dong&#x27;</span> <span class="comment">// 输出设置dong:dong</span></span><br><span class="line"><span class="comment">// 4.删除属性</span></span><br><span class="line"><span class="keyword">delete</span> state.<span class="property">dong</span> <span class="comment">// 输出删除dong:true</span></span><br></pre></td></tr></table></figure><p>再测试嵌套对象情况，这时候发现就不那么 OK 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">bar</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 获取bar:[object Object] 其实就是获取到了bar:&#123;a:1&#125;啦 这个操作进行了两次属性访问，但是只触发了一次getter</span></span><br><span class="line"><span class="comment">//这就意味着</span></span><br><span class="line">state.<span class="property">bar</span>.<span class="property">a</span> = <span class="number">10</span> </span><br></pre></td></tr></table></figure><p>如果要解决，需要在<code>get</code>之上再进行一层代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="comment">//如果返回的对象是一个object，则给这个对象添加响应式</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> res===<span class="string">&#x27;object&#x27;</span> ? <span class="title function_">reactive</span>(res) : res</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改后输出的结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取<span class="attr">bar</span>:[object <span class="title class_">Object</span>]</span><br><span class="line">设置<span class="attr">a</span>:<span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Object.defineProperty</code>这个方法存在许多缺点，比如必须<code>遍历对象</code>的所有属性<code>逐个添加监听</code>，而且无法监听对象属性的增加与删除，如果属性的值是<code>引用类型</code>还需要<code>深度监听</code>，造成<code>性能问题</code>。</p><p>对于数组，<code>Object.defineProperty</code>方法无法监听到数组方法对数组元素的修改，需要重写数组方法。</p><p>而Proxy能监听整个对象的变化，也能监听到数组方法对数组元素的修改。</p><h2 id="说说Vue-3-0中Treeshaking特性？"><a href="#说说Vue-3-0中Treeshaking特性？" class="headerlink" title="说说Vue 3.0中Treeshaking特性？"></a>说说Vue 3.0中Treeshaking特性？</h2><h3 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h3><p><code>Tree shaking</code> 是一种通过<strong>清除多余js代码</strong>方式来<code>优化项目打包体积</code>的技术。</p><h3 id="如何做-3"><a href="#如何做-3" class="headerlink" title="如何做"></a>如何做</h3><p><code>Tree shaking</code>是基于<code>ES6</code>模块语法（<code>import</code>与<code>exports</code>），主要是借助<code>ES6</code>模块的<code>静态编译</code>思想，在<code>编译时</code>就能确定模块的依赖关系，以及输入和输出的变量。</p><p><code>Tree shaking</code>无非就是做了两件事：</p><ul><li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li><li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ul><p>那么为什么使用 CommonJs、AMD 等模块化方案无法支持 Tree Shaking 呢？</p><p>因为在 CommonJs、AMD、CMD 等旧版本的 js 模块化方案中，导入导出行为是<strong>高度动态</strong>，难以预测的，只能在<code>代码运行的时候</code>确定模块的依赖关系，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>)&#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line">  <span class="built_in">exports</span>.<span class="property">foo</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 ESM 方案则从规范层面规避这一行为，它要求所有的导入导出语句只能出现在<code>模块顶层</code>，可以理解为全局作用域；且导入导出的模块名必须为字符串常量，这意味着下述代码在 ESM 方案下是非法的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>)&#123;</span><br><span class="line">  <span class="keyword">import</span> bar <span class="keyword">from</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，ESM 下模块之间的依赖关系是<code>高度确定</code>的，与运行状态无关，编译工具只需要对 ESM 模块做<code>静态语法分析</code>，就可以从代码字面量中推断出哪些模块值未曾被其它模块使用，这是实现 Tree Shaking 技术的必要条件。</p><p>更多内容参考：<a href="https://www.sanye.blog/posts/762e27cc.html">前端面试—webpack | 三叶的博客</a></p><h2 id="Composition-Api-与-Options-Api-有什么不同？"><a href="#Composition-Api-与-Options-Api-有什么不同？" class="headerlink" title="Composition Api 与  Options Api 有什么不同？"></a>Composition Api 与  Options Api 有什么不同？</h2><h3 id="代码组织方式"><a href="#代码组织方式" class="headerlink" title="代码组织方式"></a>代码组织方式</h3><p>选项式api按照<code>代码的类型</code>来组织代码；而组合式api按照<code>代码的逻辑</code>来组织代码，逻辑紧密关联的代码会被放到一起。</p><h3 id="代码复用方式"><a href="#代码复用方式" class="headerlink" title="代码复用方式"></a>代码复用方式</h3><p>在选项式api这，我们使用<code>mixin</code>来实现代码复用，使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候</p><p>就存在两个非常明显的问题：</p><ul><li>命名冲突</li><li>数据来源不清晰</li></ul><p>而在组合式api中，我们可以将一些可复用的代码抽离出来作为<code>一个函数</code>并导出，在需要在使用的地方导入后直接调用即可。这个种<code>模块化</code>的方式，既解决了<code>命名冲突</code>的问题，也解决了<code>数据来源不清晰</code>的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试---网络</title>
      <link href="/posts/c0add594.html"/>
      <url>/posts/c0add594.html</url>
      
        <content type="html"><![CDATA[<p>全文主要参考如下gituhub项目，在此基础上补充了一些自己的东西：</p><p><a href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a></p><p>项目网站：<a href="https://vue3js.cn/interview/">web前端面试 - 面试官系列</a></p><p>一个非常全面，细致的前端面试题库,十分的推荐，深刻体会到github的强大之处了。</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>以下内容参考视频：<a href="https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.1387.0.0">【干货】浏览器是如何运作的？_哔哩哔哩_bilibili</a></p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li><p>用户界面</p></li><li><p>浏览器引擎<br>用于在<code>用户界面</code>和<code>渲染引擎</code>之间传递数据，类似一个桥梁，组成包括<code>持久层</code></p></li><li><p>渲染引擎：组成包括</p><ul><li><strong>HTML 解析器</strong>：负责读取 HTML 文档并构建 DOM 树。</li><li><strong>CSS 解析器</strong>：解析 CSS 代码，并应用到 DOM 元素上。</li><li><strong>布局引擎</strong>：计算每个可见元素的位置和尺寸，即<code>重排</code>（reflow）过程。</li><li><strong>绘制引擎</strong>：将<code>渲染树</code>转换为屏幕上的像素，即<code>重绘</code>（repaint）过程。</li><li><strong>合成器</strong>：如果有多个图层（例如，带有 <code>transform</code> 或 <code>opacity</code> 的元素），则会将这些图层合成为最终的画面。</li></ul><p>常见示例：</p><ul><li>Trident：ie浏览器内核</li><li>Gecko(壁虎)：火狐浏览器内核</li><li>Webkit：苹果浏览器Safari的开源内核</li><li>Blink：基于WebKit内核优化而来，谷歌，edge，opera浏览器的内核；webkit内核开源对浏览器的发展贡献还是挺大的。</li></ul></li><li><p>js引擎：执行嵌入在网页中的 JavaScript 代码，如 V8（用于 Blink）、SpiderMonkey（用于 Gecko）等。</p></li></ul><p>通常我们谈论<code>浏览器内核</code>，特指的就是浏览器的<code>渲染引擎</code>，但其实还可以认为，浏览器内核还包括js引擎等组件。</p><p>虽然<code>渲染引擎</code>和<code>JavaScript引擎</code>在功能上是分离的，但是js代码的执行会阻塞渲染，其中的原因之一就是执行js代码会暂停html文件的解析。</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>浏览器本身是多进程的，包括网络进程，浏览器进程（控制标签页外的用户界面；协调其他进程），缓存进程，GPU进程（负责渲染整个页面），渲染器进程（渲染标签页），插件进程。</p><h3 id="在地址栏输入并enter会发生什么"><a href="#在地址栏输入并enter会发生什么" class="headerlink" title="在地址栏输入并enter会发生什么"></a>在地址栏输入并enter会发生什么</h3><p>UI线程捕捉用户输入，如果发现是个网址，则把这个地址交给<code>网络线程</code>来请求DNS解析，然后进行安全检查(TLS&#x2F;SSL握手)，安全检查通过后把数据交给UI线程，然后ui线程创建一个渲染进程，解析HTML标签。</p><p><strong>css和图片等资源（的加载和解析）不会阻塞html解析，而script标签会</strong>；当HTML解析器遇到一个<code>&lt;script&gt;</code>标签（无论是内联脚本还是外部脚本），它会暂停HTML文档的解析，转而去<code>加载</code>和<code>执行</code>这个脚本，这是因为JavaScript有能力动态地修改DOM结构。</p><p>但是我们如果我们把<code>script</code>标签都放在<code>&lt;/body&gt;</code>之后，就不会有阻塞html解析的问题，但是在<code>HTML2.0</code>时，如果将<code>script</code>标签放到<code>&lt;/body&gt;</code>标签之后，则是不符合标准的，但是也是不报错的，此时当浏览器解析的时候，会将放在<code>&lt;/body&gt;</code>后面的<code>script</code>标签放到<code>&lt;/body&gt;</code>的前面🥲，所以我们自己摆放<code>script</code>标签还是自觉的放到<code>&lt;head&gt;</code>标签中或者<code>&lt;/body&gt;</code>标签之前。</p><p>多数情况下，我们将<code>script</code>标签放在底部（还是在<code>&lt;/body&gt;</code>标签之前），让其最后加载。如果<code>script</code>标签中存在一些操作全局样式的代码，此时应该让其放在前面，让其优先解析</p><p>然而对于添加了async，defer属性的script标签，它们<code>加载</code>脚本是异步的，不会阻塞html文档的解析；对于添加async属性的script标签，由于是加载完后立马执行js代码，所以可能阻塞html文件的渲染。</p><p><strong>dom树和渲染树</strong></p><p>dom树上的结点包含<code>不可视结点</code>，而渲染树上不包含；渲染树上包含<code>伪元素结点</code>，但是dom树上不包括，因为伪元素不是html结构的一部分。简单来说，区别在于<code>不可视结点</code>和<code>伪元素</code>。</p><h2 id="http是什么与https有什么区别"><a href="#http是什么与https有什么区别" class="headerlink" title="http是什么与https有什么区别"></a>http是什么与https有什么区别</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>http，即超文本<strong>传输</strong>协议，常被用于在<strong>浏览器</strong>和<strong>网站服务器</strong>之间的通信，以<strong>明文</strong>方式发送内容，不提供任何方式的数据加密。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>无状态</p><p>HTTP协议无法根据<strong>之前的状态</strong>来处理本次请求。</p></li><li><p>灵活</p><p>HTTP允许传输<strong>任意类型的数据对象</strong>。正在传输的类型由<code>Content-Type</code>加以标记。</p></li></ul><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><ul><li><p><strong>4xx</strong>（客户端错误）</p><ul><li>404：服务器中不存在请求的资源。</li><li>403：请求的<strong>权限不足</strong>。</li><li>401：身份认证失败，该<code>用户不存在</code>。</li><li>400（bad request）：请求存在<strong>语法错误</strong>，通常是因为请求的方式<strong>不符合接口文档规范</strong>。</li></ul></li><li><p><strong>5xx</strong>（服务端错误）</p><ul><li>500：服务器错误，但是未给出具体原因</li><li>502：上游服务器返回了错误的响应</li><li>504：上游服务器<code>响应超时</code>。</li></ul></li><li><p><strong>3xx</strong>（重定向）</p><ul><li>304：<strong>服务器提示浏览器读取缓存</strong>（重定向到缓存）</li><li>302：临时重定向，第一次请求返回一个<strong>临时</strong>请求url，第二次请求访问这个临时url，产生两次请求</li><li>301：永久重定向，第一次请求返回一个<strong>永久</strong>请求url，第二次请求访问这个永久url，产生两次请求</li></ul></li><li><p><strong>2xx</strong>（请求成功）</p><ul><li><p>200（成功）：请求已成功，并返回<code>响应头</code>或<code>响应体</code></p></li><li><p>201：创建用户成功（由0到1的过程）</p></li><li><p>204：服务器成功处理了请求，但是<strong>没有返回任何内容</strong>；通常用于响应<code>DELETE</code>请求，表示资源已被成功删除，但没有返回具体内容。</p></li></ul></li></ul><h4 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h4><ul><li><p><strong>HTTP1.0</strong></p><p>默认使用<code>短连接</code>（请求头中的Connection字段的值默认是close）每次请求都需要与服务器建立一个<code>TCP</code>连接，服务器完成请求处理并<code>响应数据</code>后立即断开<code>TCP</code>连接。</p><p>比如，解析<code>html</code>文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接</p><p>最终导致，一个<code>html</code>文件的访问，包含了多次的请求和响应，每次请求都需要创建连接、关系连接</p><p>频繁的建立，断开连接，明显造成了<strong>性能上的缺陷</strong>，如果需要建立长连接，需要设置一个非标准的<code>Connection</code>字段 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure><p>也就是说其实<code>http1.0</code>也能实现长连接，但是需要手动修改请求头。</p></li><li><p><strong>HTTP1.1</strong></p><p>与HTTP1.0的区别在于：</p><ul><li><p><strong>默认支持长连接</strong></p><p>即在一个<code>TCP连接</code>上可以传送多个<code>HTTP</code>请求和响应，减少了建立和关闭连接的消耗和延迟。这样，在加载<code>html</code>文件的时候，文件中多个请求和响应就可以在一个连接中传输，<strong>减少了加载时间</strong>。</p></li><li><p><strong>下次请求不需要等待上次请求响应</strong></p><p>但是<strong>服务器端</strong>必须按照接收到客户端请求的先后顺序<strong>依次回送响应结果</strong>，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p></li><li><p>添加新的<strong>请求方法</strong>比如<code>put</code>、<code>delete</code>、<code>options</code>（预检请求），添加了<strong>新的请求头</strong>比如<code>If-None-Match</code>,<code>If-Modified-Since</code></p></li></ul></li></ul><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p><code>https</code>是基于<code>http</code>的，在http的基础上使用了<code>TLS/SSL</code>加密,详见文章<a href="https://www.sanye.blog/posts/72ebd24d.html">hexo博客搭建的一些思考 | 三葉的博客</a></p><h2 id="GET请求和POST请求的区别"><a href="#GET请求和POST请求的区别" class="headerlink" title="GET请求和POST请求的区别"></a>GET请求和POST请求的区别</h2><ul><li><p><strong>用途不同</strong></p><p>get请求被用来<strong>获取数据</strong>，post请求被用来<strong>提交数据</strong>。</p></li><li><p><strong>编码方式</strong></p><p>GET请求只能进行<code>url编码</code>，而POST支持多种编码方式。</p></li><li><p><strong>携带信息</strong></p><p>GET请求一般把<code>携带的参数</code>放在<code>URL</code>上，不安全，而且url上<code>携带的参数</code>有<code>长度限制</code>，而POST请求一般把<code>携带的参数</code>放在<code>请求体</code>上，没有长度限制，也<strong>相对</strong>更为安全。</p><p>然而，从传输的角度来说，他们都是不安全的，因为<code>HTTP</code> 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。只有使用<code>HTTPS</code>才能加密安全。</p></li></ul><h2 id="http常用请求头"><a href="#http常用请求头" class="headerlink" title="http常用请求头"></a>http常用请求头</h2><ul><li><p>Accept：客户端能够接受的响应数据类型</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br></pre></td></tr></table></figure></li><li><p>Authorization：用于超文本传输协议的<strong>认证的认证信息</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</span><br></pre></td></tr></table></figure></li><li><p>Cache-Control： 用来指定在这次的请求&#x2F;响应链中的所有缓存机制 都必须 遵守的指令</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache //无论浏览器中的缓存是否过期，都询问是否应该使用缓存</span><br></pre></td></tr></table></figure></li><li><p>Content-Length：表示请求体的长度</p></li><li><p>Content-Type：<strong>请求体</strong>的数据类型</p></li><li><p>If-Modified-Since：在<strong>协商缓存</strong>中被用来询问服务器是否应该使用缓存。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT //值为上次返回的Last-Modified,询问自该时间点后资源是否发生改变</span><br></pre></td></tr></table></figure></li><li><p>If-None-Match：在<strong>协商缓存</strong>中被用来询问服务器是否应该使用缓存。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: &quot;737060cd8c284d8af7ad3082f209582d&quot;</span><br><span class="line">//值为上次返回的Etag，就是文件内容的哈希值，文件内容改变，这个值就会改变。</span><br></pre></td></tr></table></figure></li><li><p>Cookie：携带cookie，cookie具体的介绍前往<strong>js面试</strong>一文中。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buvid3=57161BE6-C8C6-DA39-581F-E6FCB97E737107226infoc;</span><br><span class="line">b_nut=1708906907; </span><br><span class="line">i-wanna-go-back=-1;//就是这样的键值对格式，一个键值对就是一个cookie，其实每个cookie包含的信息远不止如此</span><br></pre></td></tr></table></figure></li></ul><h2 id="浏览器的缓存策略"><a href="#浏览器的缓存策略" class="headerlink" title="浏览器的缓存策略"></a>浏览器的缓存策略</h2><p>浏览器的缓存方式主要分为两大类，<strong>强缓存和协商缓存</strong>：</p><ul><li><p>强缓存</p><p>当浏览器请求某个资源的时候，如果浏览器缓存中存在该资源，且没有过期，那么将直接使用缓存，而<strong>不会发送请求</strong>（缓存是否过期是根据缓存的<code>Expires/Cache-Control</code>字段来判断的）。</p><p>特点是<strong>客户端</strong>查看缓存资源的特定字段来判断是否使用缓存。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置缓存的过期时间，即10s后</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Expires&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() + <span class="number">1000</span> * <span class="number">10</span>).<span class="title function_">toGMTString</span>())</span><br><span class="line"><span class="comment">//设置缓存有效时间为10s</span></span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Cache-Control&#x27;</span>,<span class="string">&#x27;max-age=10&#x27;</span>) </span><br></pre></td></tr></table></figure></li><li><p>协商缓存</p><p>是指在<strong>缓存中的资源过期</strong>后，浏览器通过在<strong>请求头</strong>中设置<code>If-Modified-Since</code>或者<code>If-None-Match</code>字段，<strong>询问服务器</strong>是否应该使用缓存；如果服务器发现资源未改变，则响应<code>304</code><strong>提示浏览器使用缓存</strong>，否则响应<code>200</code>并<strong>返回新的资源</strong>，以及<code>最近一次</code>修改该资源的时间即<code>Last-Modified</code>，或者<code>最新的ETag</code>值。</p><p><code>If-Modified-Since</code>的值为上次返回的<code>Last-Modified</code>，<code>If-None-Match</code>的值为上次返回的<code>ETag</code>值；<code>Last-Modified</code> 表示本地文件最后修改日期；<code>Etag</code>，就是由<strong>文件内容得出的哈希值</strong>，文件内容改变，这个值就会改变。</p><p>协商缓存好比食物的保质期过了，于是询问还能不能吃。</p></li></ul><img src="..\images\前端面试\缓存.png" style="zoom:100%;" /><h2 id="如何理解OSI七层模型"><a href="#如何理解OSI七层模型" class="headerlink" title="如何理解OSI七层模型"></a>如何理解OSI七层模型</h2><ul><li><p>应用层</p><p>该层协议定义了<strong>应用进程</strong>之间的交互规则，包括<code>DNS</code>协议，<code>HTTP</code>协议，电子邮件系统采用的 <code>SMTP</code>协议等。</p><p>在应用层交互的数据单元我们称之为<strong>报文</strong></p></li><li><p>表示层</p><p>该层提供的服务主要包括<code>数据压缩</code>，<code>数据加密</code>以及<code>数据描述</code>，使应用程序不必担心在各台计算机中表示和存储的内部格式<code>差异</code></p></li><li><p>会话层</p><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话</p><p>该层提供了数据交换的定界和同步功能，包括了<code>建立检查点</code>和<code>恢复方案</code>的方法</p></li><li><p>传输层</p><p>传输层的主要任务是为两台主机<code>进程之间</code>的通信提供服务。其中，主要的传输层协议是<code>TCP</code>和<code>UDP</code></p></li><li><p>网络层</p><p>负责<strong>主机</strong>到<strong>主机</strong>的通信，<code>ip</code>地址就工作在这一层，常见的设备比如<code>路由器</code>。在发送数据时，网络层把传输层产生的报文或用户数据报<strong>封装</strong>成分组或者包，向下传输到数据链路层。</p><p>在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多<strong>路由协议</strong></p></li><li><p>数据链路层</p></li><li><p>物理层</p></li></ul><p>比较重要的就是应用层，传输层，网络层，数据链路层，物理层，对这些模型的解释主要还是偏概念，较难以理解,了解就好。</p><img src="..\images\前端面试\osi.png" style="zoom: 33%;" /><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a><strong>数据链路层</strong></h3><h4 id="常见的设备"><a href="#常见的设备" class="headerlink" title="常见的设备"></a>常见的设备</h4><ul><li><p>交换机</p><p>用来进行帧的转发</p><p>一般来说，一个交换机确定一个<code>子网</code>；基于<code>全双工</code>的特点，每个接口构成一个<code>冲突域</code>，整个交换机构成一个<code>广播域</code>；</p><p>交换机学习后可以知道每台主机在哪个端口，可以对数据帧进行精确转发，所以交换机一般不广播，但是不是不能广播。</p><p>交换机的转发基于帧中的<code>MAC地址</code>如果没有<code>MAC地址</code>，交换机将无法有效地进行帧的转发,可以理解为交换机只知道端口和MAC地址的对应关系。</p></li><li><p>网桥</p><p>可以理解为2个端口的交换机。左右2个端口连接集线器，每个集线器连接多台主机，每个端口记录了<strong>该端口侧</strong>的所有主机的MAC地址。</p></li></ul><h4 id="常见协议"><a href="#常见协议" class="headerlink" title="常见协议"></a>常见协议</h4><ul><li><p><strong>arp协议</strong></p><p>是一种用于将网络层的<code>IP地址</code>解析为数据链路层的<code>MAC地址</code>的协议（ip-&gt;mac），ARP一般用于局域网（LAN）中，记录私有ip地址和mac地址的映射关系。因为<code>ip地址</code>无法在数据链路层工作。</p><p><strong>工作流程</strong></p><p>当一台主机要与某个ip地址对应的主机通信的时候，首先检查自己的<code>arp缓存表</code>，查看是否有该ip地址对应的mac地址。</p><p>如果没有则<code>广播arp</code>请求到<strong>本地网络</strong>上的所有主机，这个请求包括了<em>源mac，源ip和目标ip</em>；如果收到该请求的主机发现自己的ip和请求的目标ip匹配，就把自己的mac地址发送给目标主机（单播）</p><p>目标主机得知该<code>ip地址</code>的<code>mac地址</code>后，就把这个地址封装到帧中并传输。</p></li></ul><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><strong>物理层</strong></h3><p>物理层的作用是实现计算机节点之间<strong>比特流</strong>的<code>透明传送</code>,该层主要是和硬件有关，与软件关系不大。</p><h4 id="常见设备"><a href="#常见设备" class="headerlink" title="常见设备"></a>常见设备</h4><p>常见的设备有<code>集线器</code>,<code>中继器</code></p><ul><li><p><strong>集线器</strong></p><p>连接多台主机，由于半双工的特点，所有接口组成一个<code>冲突域</code>，共享传输介质，带宽；拓扑结构是<code>星型</code>。</p></li><li><p><strong>中继器</strong></p><p>用来放大信号。</p></li></ul><h4 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h4><ul><li>有线<ul><li>双绞线：传输数字信号或者模拟信号</li><li>同轴电缆：传输数字信号或者模拟信号</li><li>光纤：传输<code>光信号</code>，衰减小、带宽高和<strong>抗干扰能力强</strong>，因为光信号<strong>不受电磁干扰</strong>，因此不会受到外界电磁场的影响。这意味着它可以避免来自电力线、无线电波和其他电子设备产生的电磁干扰。</li></ul></li><li>无线<ul><li>无线电波</li><li>微波</li></ul></li></ul><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><img src="..\images\前端面试\交换机.png" style="zoom:90%;" /><p>如图所示<code>PC0-PC5</code>，这6台主机通过交换机<code>Switch0</code>相连，这6台主机构成一个<code>广播域</code>，也可以说是一个<code>内部网络</code>，一个<code>局域网(LAN)</code></p><p>这6台电脑之间的通信不需要经过<code>路由器</code>，也就是说“不需要联网”。</p><p>而<code>Switch0</code>又和一个路由器<code>Router0</code>相连，这就把这个<code>内部网络</code>和<code>互联网</code>连接了起来，允许这些主机访问其他主机或者服务器，比如B站服务器。</p><p>这台路由器常常被叫做<code>默认网关</code>。路由器会给连接到它的每台主机(也包括<strong>自身</strong>)<strong>动态分配</strong>（DHCP，动态主机配置协议）一个<strong>私有ip地址</strong>，如图所示。</p><p>当PC0中的<code>浏览器</code>要发送一个请求时，这个请求在<code>应用层</code>被称作<code>报文</code>，然后被交给<code>传输层</code>，<code>传输层</code>把<code>报文</code>与<code>源端口</code>和<code>目标端口</code>封装成<code>段</code>，交给<code>网络层</code>，<code>网络层</code>把<code>段</code>与<code>源ip地址</code>和<code>目标ip地址</code>封装成<code>包</code></p><img src="..\images\前端面试\案例分析.png" style="zoom:50%;" /><p>我们还需要知道这个<code>目标ip</code>地址对应的<code>mac</code>地址，才能封装成<code>帧</code>，才能在<code>数据链路层</code>的交换机上进行转发 ，我们先查看本地主机<code>arp缓存表</code>，查找这个<code>ip地址</code>对应的<code>mac地址</code>，如果缓存表中没有对应的记录，我们就需要进行<strong>arp广播</strong>，如果<code>目标ip地址</code>在本地网络，<code>目标ip地址</code>对应的<code>主机</code>在收到<code>arp广播</code>后会返回自己的MAC地址（单播），然后<code>PC0</code>把数据包封装成<code>帧</code>，通过交换机转发给这台主机即可。</p><p>如果<code>目标ip地址</code>不在本地网络，广播arp请求则<code>无响应</code>，此时<strong>更换arp广播的目标ip地址为默认网关ip地址，再发送一次arp广播</strong>，找到<code>默认网关ip</code>对应的<code>mac地址</code>（默认网关ip地址也是网关自己分配的<code>私有ip地址</code>，主机号一般是最小的），再把请求转发到<code>默认网关</code>。</p><p><strong>arp广播帧格式</strong>：</p><img src="..\images\前端面试\案例分析2.png" style="zoom: 50%;" /><p>默认网关即<code>路由器</code>收到arp广播后，发现是在询问自己的MAC地址（目标ip&#x3D;默认网关ip），并记住<code>客户端MAC地址</code>与<code>客户端ip地址</code>的对应关系，并返回自己的MAC地址（单播），然后主机<code>PC0</code>就能将数据封装成<code>帧</code>，转发给<code>默认网关</code>。</p><img src="..\images\前端面试\案例分析3.png" style="zoom: 50%;" /><p>默认网关，即路由器在接收到转发的<code>帧</code>，确认是发送给自己的帧后，解封<code>帧</code>成<code>包</code>，替换<code>包</code>中的<strong>源ip地址(私有ip地址</strong>)为路由器对应的<strong>公有ip地址，路由器还会给这个私有ip地址分配一个对外端口号，我们把用这个端口号替换源端口号，并记录对应关系（NAT）</strong>；</p><p>有了对外端口号，就能实现<code>公有IP地址</code>到<code>私有ip地址</code>的<code>1对多</code>映射，有人肯能会问，为什么还要替换端口号呢？直接有<code>原来的端口号</code>来标识<code>不同的私有ip</code>不行吗？确实不行，因为不同的私有ip（不同的主机），可以使用相同的端口号。</p><img src="..\images\前端面试\NAT.png" style="zoom: 80%;" /><p>路由器再根据包里的<code>目标ip地址</code>进行<code>路由转发</code>，<code>服务器网关</code>如果知道这个<code>目标ip地址</code>对应的是那台服务器（知道目标ip地址对应的服务器mac地址），则把<code>数据包</code>封装成<code>帧</code>，经<code>交换机</code>转发给对应的服务器，如果不知道则进行<code>arp广播</code>。</p><p>对应的服务器收到<code>帧</code>后进行逐层<strong>解封</strong>，根据<code>目标MAC地址</code>确认这个帧是发给自己的，根据<code>目标ip地址</code>确认这个包是发给自己的，根据<code>目标端口</code>确定要与哪个应用程序交互，再把<code>报文</code>交给这个应用程序处理。</p><img src="..\images\前端面试\数据链路层.png" style="zoom:50%;" /><p>详细参考：<a href="https://www.bilibili.com/video/BV1EU4y1v7ju/?spm_id_from=333.337.search-card.all.click&vd_source=00483a04a5a69136669373a8ea522a9b">互联网数据传输原理 ｜OSI七层网络参考模型_哔哩哔哩_bilibili</a></p><h2 id="如何理解TCP-IP协议"><a href="#如何理解TCP-IP协议" class="headerlink" title="如何理解TCP&#x2F;IP协议"></a>如何理解TCP&#x2F;IP协议</h2><img src="..\images\前端面试\TCP与IP.png" style="zoom: 80%;" /><p>TCP&#x2F;IP协议不仅仅指的是<code>TCP</code>和<code>IP</code>两个协议，而是指一个由<code>FTP</code>、<code>SMTP</code>、<code>TCP</code>、<code>UDP</code>、<code>IP</code>等协议构成的<strong>协议簇</strong>，</p><p>只是因为在<code>TCP/IP</code>协议中<code>TCP</code>协议和<code>IP</code>协议<strong>最具代表性</strong>，所以通称为TCP&#x2F;IP协议簇。</p><h2 id="如何理解UDP-和-TCP"><a href="#如何理解UDP-和-TCP" class="headerlink" title="如何理解UDP 和 TCP?"></a>如何理解UDP 和 TCP?</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP(Transmission Control Protocol)，传输控制协议，是一种可靠、<strong>面向字节流的通信协议</strong>，将<code>应用层报文</code>看成一串无结构的字节流，分解为多个<code>TCP报文段</code>后交给网络层传输。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP(User Datagram Protocol)，用户数据报协议，是一个简单的<strong>面向数据报的通信协议</strong>。即对应用层交下来的报文，不合并，不拆分，只是在其上面加上<strong>首部</strong>后就交给了下面的网络层。</p><h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><ul><li><p><strong>添加端口号</strong></p><p>都是工作在<code>传输层</code>的协议，都能给<code>报文</code>添加端口号（源端口，目标端口），把报文封装成<code>段</code>。</p></li><li><p><strong>首部开销</strong></p><p><code>TCP报文段</code>首部内容更多，首部更大，<code>UDP报文段</code>首部开销小。</p></li><li><p><strong>报文分段</strong></p><p>如果<code>报文</code>很大，TCP会将报文<strong>分段</strong>，并给这些<code>报文段</code>编号。而UDP则始终把<code>应用层</code>的报文当做一个<code>整体</code>，不进行分片，直接封装。</p></li><li><p><strong>连接建立</strong></p><p>TCP是<code>面向连接</code>的，即发送数据之前需要建立连接，<strong>保证数据可靠性</strong>，而<code>UDP</code>是无连接的，直接发送数据，<strong>不保证数据可靠性</strong>。</p></li><li><p><strong>流量与拥塞控制</strong></p><p>TCP具有<code>流量控制</code>和<code>拥塞控制</code>，而UDP没有。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>TCP 应用场景适用于对<code>效率要求低</code>，<code>对准确性要求高</code>或者要求有连接的场景，而UDP 适用场景为对<code>效率要求高</code>，对<code>准确性要求低</code>的场景，各有优缺。</p><h2 id="TCP连接如何建立，如何断开"><a href="#TCP连接如何建立，如何断开" class="headerlink" title="TCP连接如何建立，如何断开"></a>TCP连接如何建立，如何断开</h2><p>建立tcp连接的建立与断开这一过程可以简记为:<strong>三次握手，四次挥手</strong></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送<strong>3个包</strong></p><p>主要作用就是为了<strong>确认双方的接收能力和发送能力是否正常</strong>、指定自己的初始化序列号为后面的可靠性传送做准备</p><p>过程如下：</p><ul><li>第一次握手：客户端给服务端发一个<code> SYN(同步)报文</code>，并指明客户端的<code>初始化序列号 ISN(init sequence number)</code>，此时客户端处于<code> SYN_SENT</code> 状态</li><li>第二次握手：服务器收到客户端的 <code>SYN </code>报文之后，会以自己的 <code>SYN 报文</code>作为应答，为了<strong>确认</strong>客户端的 SYN，将客户端的<code> ISN+1</code>作为<code>ACK</code>的值，此时服务器处于<code>SYN_RCVD</code>的状态</li><li>第三次握手：客户端收到 <code>SYN 报文</code>之后，会发送一个 <code>ACK 报文</code>，值为服务器的<code>ISN+1</code>。此时客户端处于 <code>ESTABLISHED </code>状态。服务器收到 ACK 报文之后，也处于<code>ESTABLISHED</code>状态，此时，双方已建立起了连接。</li></ul><img src="..\images\前端面试\三次握手.png" style="zoom:85%;" /><h3 id="为什么不是二次握手"><a href="#为什么不是二次握手" class="headerlink" title="为什么不是二次握手"></a>为什么不是二次握手</h3><ul><li><p>如果2次握手就建立连接，假如因为网络问题，客户端发送了不止一次<code>SYN</code>包，那么就会建立多个连接，占用不必要的资源。</p></li><li><p>假如客户端发送一个<code>SYN</code>请求，但是由于<code>网络超时</code>，客户端<code>放弃了建立连接</code>，不再等待<code>服务端响应</code>，如果此时使用两次握手建立连接，服务器接受到<code>超时的同步请求</code>后就错误的打开了一个连接，而这个连接是客户端不需要的。</p></li><li><p>如果只进行2次握手，服务端无法确保客户端的<strong>接收能力</strong>正常，<strong>因为服务端的请求得不到响应</strong>。</p></li></ul><p>三次握手就好比一个生活中的情景对话：</p><p>C：我要建立同步连接</p><p>S：你真的要建立同步连接吗？</p><p>C：是的我要建立同步连接</p><p>这样增加一次握手就是增加了一次<code>确认</code>的过程，确保本次连接确实是被需要的。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><img src="..\images\前端面试\四次挥手.png" style="zoom:90%;" /><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="什么是IP"><a href="#什么是IP" class="headerlink" title="什么是IP"></a>什么是IP</h3><p>IP(Internet Protocol)，也叫互联网协议。它定义了如何将数据分割成数据包、地址编码、路由选择以及如何重新组装这些数据包以恢复原始信息。IP 提供的是<strong>无连接</strong>的服务，这意味着每个数据包独立处理，不需要事先建立专用的通信通道。这也意味着 IP 不保证数据包按顺序到达或不会丢失。</p><h3 id="什么是IP地址"><a href="#什么是IP地址" class="headerlink" title="什么是IP地址"></a>什么是IP地址</h3><p>IP地址是IP (Internet Protocol，互联网协议)为每个<code>连接到网络</code>的设备分配的一个<strong>逻辑地址</strong>，用来<strong>唯一标识每一台设备</strong>，这使得设备之间能够互相识别并进行通信。IP地址的格式可分为<code>ipv4</code>(32位)，<code>ipv6</code>(128位 )。</p><h3 id="IPv4格式IP地址分类"><a href="#IPv4格式IP地址分类" class="headerlink" title="IPv4格式IP地址分类"></a>IPv4格式IP地址分类</h3><p>ipv4格式的IP地址被分为<code>私有IP地址</code>和<code>公有IP地址</code>，私有ip地址的出现，主要是为了解决ipv4格式的IP地址<strong>数量不足</strong>的问题。</p><p>私有ip地址只能在<code>局域网</code>中通信，而公有ip地址才能在<code>互联网</code>通信，一个<code>公有ip地址</code>常常对应多个<code>私有ip地址</code>。</p><p>路由器内部的<code>DHCP</code>会自动为设备分配<code>私有ip地址</code>，而<code>公有ip地址</code>由运营商分配。</p><p>ipv4格式的地址另一种常见的分类方式是分为<code>A,B,C</code>四大类</p><ul><li><p>A类</p><p>对应的子网掩码为<code>255.0.0.0</code>，即前8位用来表示<code>网络号</code>，后24位用来表示<code>主机号</code>，前一位比特必须是<code>0</code>（限定前几位比特是为了能快速识别是哪类IP地址），表示 IP 地址范围为 <code>0.0.0.0</code> 到 <code>127.255.255.255</code></p></li><li><p>B类</p><p>对应的子网掩码为<code>255.255.0.0</code>，即前16位用来表示<code>网络号</code>，后16位用来表示<code>主机号</code>，前两位比特必须是<code>10</code>，表示 IP 地址范围为 <code>128.0.0.0</code> 到 <code>191.255.255.255</code></p></li><li><p>C类</p><p>对应的子网掩码为<code>255.255.255.0</code>，即前24位用来表示<code>网络号</code>，后8位用来表示<code>主机号</code>，前三位比特必须是<code>110</code>，最为常见，表示 IP 地址范围为 <code>192.0.0.0</code> 到 <code>223.255.255.255</code></p></li><li><p>特殊地址</p><ul><li><p>127.0.0.0</p><p>对任何ip地址的访问都会访问这个ip地址</p></li><li><p>广播地址</p><p>主机号全为<code>1</code>的地址。</p></li><li><p>网络地址</p><p>主机号全为<code>0</code>的地址,不能用来标识某一台主机。</p></li></ul></li></ul><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><p>DNS（Domain Names System），域名系统，是互联网一项服务，是把<code>域名</code>转换成对应的<code>IP地址</code>的服务器。</p><h3 id="什么是域名"><a href="#什么是域名" class="headerlink" title="什么是域名"></a>什么是域名</h3><p>域名可以理解为给ip地址起的别名，方便记忆。域名由一般三部分构成，由<code>.</code>连接，从右到左分别是顶级域名，权威域名，本地域名。</p><h3 id="域名查询方式"><a href="#域名查询方式" class="headerlink" title="域名查询方式"></a>域名查询方式</h3><ul><li><p><strong>递归查询</strong></p><p>如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案，可以理解为<strong>帮人帮到底</strong>，但是这样对B服务器（域名服务器）的压力就很大，域名服务器不返回下级域名服务器ip地址，而是负责的帮忙询问，只返回普通服务器ip地址。</p><img src="..\images\前端面试\dns.png" style="zoom:90%;" /></li><li><p><strong>迭代查询</strong></p><p>如果接收者 B 没有请求者 A 所需要的<strong>准确内容</strong>，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求。</p><img src="..\images\前端面试\dns2.png" style="zoom:90%;" /></li></ul><h3 id="域名缓存"><a href="#域名缓存" class="headerlink" title="域名缓存"></a>域名缓存</h3><p>计算机中<code>DNS</code>的记录分成了两种缓存方式：</p><ul><li><strong>浏览器</strong>缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。</li><li><strong>操作系统</strong>缓存：操作系统的缓存其实是用户<strong>自己配置</strong>的 <code>hosts</code> 文件</li></ul><h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><ul><li>当我们访问一个网站，就需要通过DNS解析获取它的ip地址，首先搜索<strong>浏览器的 DNS 缓存</strong>，缓存中维护一张<code>域名</code>与<code> IP 地址</code>的对应表</li><li>若缓存没有命中，则继续搜索<strong>操作系统的 DNS 缓存</strong></li><li>若操作系统缓存仍然没有命中，操作系统将向<strong>本地域名服务器</strong>（默认域名服务器）发送一次DNS查询请求，询问这个域名的ip地址，本地域名服务器采用<code>递归查询</code><strong>自己的 DNS 缓存</strong>（因为域名是多级结构嘛），查找成功则返回结果。</li><li>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向<strong>上级域名服务器</strong>进行<strong>迭代查询</strong><ul><li>首先本地域名服务器向<strong>根域名服务器</strong>发起请求，询问<code>根域名服务器</code>，返回<strong>顶级域名服务器</strong>的<code>ip地址</code>到本地服务器</li><li>本地域名服务器拿到这个<strong>顶级域名服务器</strong>的ip地址后，就向其发起请求，返回<strong>权威域名服务器</strong>的<code>ip地址</code></li><li>本地域名服务器根据<strong>权威域名服务器</strong>的ip地址向其发起请求，最终得到该域名对应的 <code>IP 地址</code>。</li></ul></li><li><code>本地域名服务器</code>将得到的 IP 地址返回给<code>操作系统</code>，同时自身将 IP 地址<code>缓存</code></li><li><code>操作系统</code>将 IP 地址返回给<code>浏览器</code>，同时自身将 IP 地址<code>缓存</code></li><li>至此，<code>浏览器</code>就得到了域名对应的 IP 地址，并将 IP 地址<code>缓存</code></li></ul><img src="..\images\前端面试\dns解析过程.png" style="zoom:100%;" /><p>域名解析参考：<a href="https://www.bilibili.com/video/BV1bo4y1o7Yk?spm_id_from=333.788.videopod.sections&vd_source=00483a04a5a69136669373a8ea522a9b">【实操演示】域名DNS解析设置 | 第一次设置域名解析？看这个就明白了 | 什么是域名解析 | 如何设置_哔哩哔哩_bilibili</a></p><h2 id="如何理解CDN"><a href="#如何理解CDN" class="headerlink" title="如何理解CDN"></a>如何理解CDN</h2><p>CDN也叫做<strong>内容分发网络</strong>，通过在多地设置CDN服务器，并存储<code>源服务器</code>的<strong>文件副本</strong>，并把请求路由到<code>最近或者最合适</code>的服务器，从而起到<strong>减少网络时延</strong>的作用，特点是<strong>就近取材，内容缓存</strong></p><p>除了减少网络时延，提高网页的加载速度，CDN技术还能解决源服务器宕机导致的服务瘫痪。</p><p>CDN在<strong>域名解析</strong>过程中起作用，配置了cdn加速的域名，解析后返回的不再是固定的<code>源服务器ip</code>，而是距离请求设备<code>最近的</code>或者<code>最合适的cdn服务器</code>的ip。<code>cdn服务器</code>的选择工作由<strong>CDN专用DNS服务器</strong>实现。</p><p>接入CDN加速后的域名解析流程，拿<code>www.sanye.blog</code>这个域名举例：</p><ul><li>先查询本地浏览器DNS缓存，是否有<code>www.sanye.blog</code>这个域名对应的ip地址，如果没有，再查询<code>操作系统DNS缓存</code></li><li>如果<code>操作系统DNS缓存</code>命中，则把对应的ip地址返回给<code>浏览器</code>，否则操作系统向<code>本地dns服务器</code>发送一次dns查询请求。</li><li>本地dns服务器<code>递归查询</code>本地记录，如果查找到对应的ip地址则返回给操作系统，否则询问<code>上级服务器</code>。</li><li>本地dns服务器进行一系列<code>迭代查询</code>，最终询问<code>sanye.blog</code>权威域名服务器，并获得一条<code>CNAME</code>记录。</li><li>这条<code>CNAME</code>记录表明<code>www.sanye.blog</code>指向一个<code>cdn加速域名</code>。</li><li>本地DNS服务器自动继续解析这个<code>加速域名</code>，这个解析过程涉及到了<code>cdn专用域名服务器</code>，最终得到一台最合适的cdn服务器的ip地址，返回给操作系统。</li></ul><p>cdn专用域名服务器的工作流程:</p><ul><li>查看用户的 <code>IP 地址</code>，查表得知<code>地理位置</code>，找相对最近的边缘节点</li><li>看用户所在的<code>运营商网络</code>，找相同网络的边缘节点</li><li>检查边缘节点的负载情况，找负载较轻的节点</li><li>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等</li></ul><p>结合上面的因素，得到<code>最合适的cdn服务器（边缘结点）</code>，然后把这个节点的ip地址返回给<code>本地dns服务器</code>，本地dns服务器将这个ip地址返回给操作系统，操作系统则把这个ip返回给浏览器，最终用户就能够就近访问<code>CDN</code>的缓存代理。</p><img src="..\images\前端面试\cdn.png" style="zoom:80%;" /><p>其中有两个衡量<code>CDN</code>服务质量的指标：</p><ul><li>命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比</li><li>回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比。必须指定cdn服务区的<code>回源地址</code>，也就是源服务器地址，不然cdn服务器都不知道去哪儿拷贝资源。</li></ul><p>命中率+回源率 &#x3D; 1，命中率越高，表明加速效果越好。</p><p>CDN原理具体参考：<a href="https://www.bilibili.com/video/BV12T4y1P7Fh?spm_id_from=333.788.videopod.sections&vd_source=00483a04a5a69136669373a8ea522a9b">【白话科普】用动画告诉你 CDN是如何工作的 | CDN是什么 | 如何让你的网站网站快速打开 | CDN原理 | 服务器自由_哔哩哔哩_bilibili</a></p><h2 id="地址栏输入-URL-敲下回车后发生了什么"><a href="#地址栏输入-URL-敲下回车后发生了什么" class="headerlink" title="地址栏输入 URL 敲下回车后发生了什么"></a>地址栏输入 URL 敲下回车后发生了什么</h2><p>所有步骤如下：</p><ul><li>URL解析</li><li>DNS 查询</li><li>建立TCP 连接</li><li>发送HTTP 请求</li><li>响应请求</li><li>页面渲染</li></ul><h3 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a><strong>URL解析</strong></h3><p>判断输入的url<code>是否合法</code>，不合法则根据<strong>关键字</strong>进行搜索，合法<strong>则对这个URL进行结构分析</strong>。</p><p>一个合法的URL包括<code>协议</code>，<code>域名/ip</code>，<code>端口号</code>（默认为80或者443），<code>资源路径</code>，<code>查询参数</code>等</p><h3 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a><strong>DNS查询</strong></h3><p>通过DNS查询获得域名部分对应的<code>ip地址</code>。</p><p>在之前文章中讲过<code>DNS</code>的查询，这里就不再讲述了。</p><h3 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a><strong>建立TCP连接</strong></h3><p>然后再根据得到的ip地址，通过三次握手，与目标服务器建立TCP连接。</p><p>在之前文章中讲过TCP连接的建立，这里就不再讲述了</p><h3 id="发送http请求"><a href="#发送http请求" class="headerlink" title="发送http请求"></a><strong>发送http请求</strong></h3><p>连接建立后，浏览器发送http请求报文</p><p><code>http请求报文</code>结构从上至下依次是：</p><ul><li><p>请求行</p><p>包括<code>请求方法</code>，<code>资源路径</code>，<code>协议以及协议版本号</code></p></li><li><p>请求头</p><p>http请求<code>常见请求头</code>再前面有介绍。</p></li><li><p>请求体</p><p>用来存放<code>请求携带的数据</code></p></li></ul><img src="..\images\前端面试\请求报文.png" style="zoom:80%;" /><h3 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a><strong>响应请求</strong></h3><p>当服务器接收到浏览器的请求之后，就会对请求进行处理，执行一些逻辑操作，并返回一个http响应报文，其中携带一个html文件。</p><p><code>http响应报文</code>结构从上至下依次是：</p><ul><li>响应行</li><li>响应头</li><li>响应体</li></ul><p>结构其实和<code>请求报文</code>结构很类似，就不举例说明了。</p><p>在服务器响应之后，由于现在<code>http</code>默认开始长连接<code>keep-alive</code>，一般只有当页面关闭之后，<code>tcp</code>链接则会经过四次挥手完成断开。</p><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a><strong>页面渲染</strong></h3><p>当浏览器接收响应报文后，会对这个报文进行解析：</p><ul><li>查看<code>响应头</code>的信息，<strong>根据不同的指示做对应处理</strong>，比如重定向，存储cookie，解压gzip，缓存资源等等</li><li>特别是查看响应头的 <code>Content-Type</code>的值，根据不同的资源类型采用不同的解析方式。</li><li>查看响应体，发现返回的是一个html文件，便开始进行页面渲染。</li></ul><p>关于页面的渲染过程如下：</p><ul><li>解析HTML，构建 DOM 树</li><li>解析 CSS ，生成 CSS 规则树</li><li>合并 DOM 树和 CSS 规则，生成 render 树</li><li><strong>布局 render 树</strong>（ Layout &#x2F; reflow ），负责各元素尺寸、位置的计算</li><li><strong>绘制 render 树</strong>（ paint ），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</li></ul><img src="..\images\前端面试\页面渲染.png" style="zoom:100%;" /><h2 id="说说你对websocket的理解"><a href="#说说你对websocket的理解" class="headerlink" title="说说你对websocket的理解"></a>说说你对websocket的理解</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a><strong>是什么</strong></h3><p>WebSocket，是一种网络传输协议，位于<code>OSI</code>模型的应用层。可在单个<code>TCP</code>连接上进行<code>全双工</code>通信，能更好的节省服务器资源和带宽并达到<code>实时通迅</code>。</p><p><strong>协议名</strong></p><p>引入<code>ws</code>和<code>wss</code>分别代表明文和密文的<code>websocket</code>协议，且默认端口使用80或443，几乎与<code>http</code>一致</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws://www.chrono.com</span><br><span class="line">ws://www.chrono.com:8080/srv</span><br><span class="line">wss://www.chrono.com:445/im?user_id=xxx</span><br></pre></td></tr></table></figure><p><strong>握手</strong></p><p>类似HTTP请求建立<code>TCP</code>连接需要握手，<code>WebSocket</code>也要有一个握手过程，然后才能正式收发数据。</p><h3 id="与HTTP的区别"><a href="#与HTTP的区别" class="headerlink" title="与HTTP的区别"></a><strong>与HTTP的区别</strong></h3><ul><li><p><strong>更强的实时性（全双工）</strong></p><p>相对于HTTP请求需要等待客户端发起请求服务端才能响应（半双工），延迟明显更少。</p></li><li><p><strong>保持连接状态（有状态）</strong></p><p>创建通信后，可省略状态信息，不同于HTTP每次请求需要<code>携带身份验证</code>，也可以说，websocket是<code>有状态</code>的。</p></li><li><p><strong>较少的控制开销</strong></p><p>数据包头部协议较小，不同于http每次请求需要携带完整的头部。</p></li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i ws</span><br></pre></td></tr></table></figure><p><strong>创建一个websocket服务</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> ws.<span class="title class_">Server</span>(&#123;<span class="attr">port</span>:<span class="number">8080</span>&#125;,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开启服务成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>监听客户端连接</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>,<span class="function">(<span class="params">s</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户连接了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>监听用户发送消息</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>,<span class="function">(<span class="params">socket</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户连接成功&#x27;</span>)</span><br><span class="line">  <span class="comment">//注意这里使用的不是wss</span></span><br><span class="line">  <span class="comment">//socket可以理解为某个用户对象</span></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="title function_">toString</span>())</span><br><span class="line">    socket.<span class="title function_">send</span>(<span class="string">&#x27;这是服务端发送的数据&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>实现广播</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>,<span class="function">(<span class="params">s</span>)=&gt;</span>&#123;</span><br><span class="line">  wss.<span class="property">clients</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">client</span>=&gt;</span>&#123;</span><br><span class="line">    client.<span class="title function_">send</span>(e.<span class="title function_">toString</span>())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>监听用户断开连接</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Client disconnected&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>检测websocket状态</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer  = <span class="literal">null</span></span><br><span class="line">timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//检测每个用户的连接状态</span></span><br><span class="line">  wss.<span class="property">clients</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">client</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(client.<span class="property">readyState</span> === ws.<span class="property">OPEN</span>)&#123;</span><br><span class="line">      client.<span class="title function_">send</span>(<span class="string">&#x27;连接正常&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p><strong>完整代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>)</span><br><span class="line"><span class="comment">//创建一个websocket服务</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> ws.<span class="title class_">Server</span>(&#123;<span class="attr">port</span>:<span class="number">8080</span>&#125;,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开启服务成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//连接的用户数</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span></span><br><span class="line"><span class="comment">//监听客户端连接</span></span><br><span class="line">wss.<span class="title function_">on</span>(<span class="string">&#x27;connection&#x27;</span>,<span class="function">(<span class="params">socket</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//socket可以理解为与服务端建立连接的客户端对象,客户端建立连接的时候，拿到客户端对象</span></span><br><span class="line">  <span class="comment">//用户数加1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在线用户数：&#x27;</span>,++num)</span><br><span class="line">  <span class="comment">//给连接到服务器的客户端添加消息监听</span></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//wss.clients可以理解为所有与服务端连接的socket数组,任意用户收到消息，广播给全部用户</span></span><br><span class="line">    wss.<span class="property">clients</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">client</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//client的类型和socket差不多吧</span></span><br><span class="line">      client.<span class="title function_">send</span>(<span class="string">&quot;这是来自服务端的消息：&quot;</span>+e.<span class="title function_">toString</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//给连接到服务器的客户端添加连接关闭的监听</span></span><br><span class="line">  socket.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Client disconnected&#x27;</span>,<span class="string">&#x27;在线用户数：&#x27;</span>,--num);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> timer  = <span class="literal">null</span></span><br><span class="line">timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//检测每个用户的连接状态</span></span><br><span class="line">  wss.<span class="property">clients</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">client</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(client.<span class="property">readyState</span> === ws.<span class="property">OPEN</span>)&#123;</span><br><span class="line">      client.<span class="title function_">send</span>(<span class="string">&#x27;连接正常&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>使用内置的<code>WebSocket</code>即可</p><p><strong>创建ws对象并建立连接</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080&quot;</span>)<span class="comment">//传入url，与指定的服务器建立连接</span></span><br></pre></td></tr></table></figure><p><strong>监听连接建立</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;open&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;客户端连接成功&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>监听服务端传来的消息</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>向服务器发送消息</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">emit</span>(<span class="params"></span>)&#123;</span><br><span class="line">  ws.<span class="title function_">send</span>(<span class="string">&#x27;我是tom&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主动断开连接</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="title function_">close</span>()</span><br></pre></td></tr></table></figure><p>之后<code>wss.clients</code>数组的长度会-1</p><p><strong>完整代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;emit()&quot;</span>&gt;</span>send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;ws.close()&quot;</span>&gt;</span>close<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:8080&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">  ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;open&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;客户端连接服务器成功&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//监听服务端传来的消息</span></span></span><br><span class="line"><span class="language-javascript">  ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//e的数据类型是一个对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//向服务器发送消息</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">emit</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    ws.<span class="title function_">send</span>(input.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>客户端创建ws对象使用的是js内置<code>WebSocket</code>对象，服务端使用的是npm下载的<code>node</code>包</li><li>客户端监听使用<code>addEventListener</code>，服务端监听使用<code>on</code></li><li>双端发送消息使用的都是<code>send</code>，接受消息的<code>事件名</code>都是<code>message</code>，不过传入回调函数的数据格式不同。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ul><li>弹幕</li><li>媒体聊天</li><li>协同编辑</li><li>基于位置的应用</li><li>体育实况更新</li><li>股票基金报价实时更新</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>这部分是博主看到的比较有意思的面试题，或者自己想出的问题，不过面试问的问题都是基于项目出发的，懂的都懂。</p><h3 id="说说二维码登录流程"><a href="#说说二维码登录流程" class="headerlink" title="说说二维码登录流程"></a>说说二维码登录流程</h3><ul><li><p>用户在网页上选择二维码登录选项。</p></li><li><p>网页携带<code>设备信息（如浏览器类型、操作系统等）</code>向服务器<code>请求生成</code>登录的二维码，服务端生成一个<code>二维码id</code>，并将这个id与请求中携带的<code>设备信息</code>绑定，存储在服务器数据库中，返回给网页。</p></li><li><p>网页获取<code>二维码id</code>后展示二维码并轮询二维码状态(设置定时器，每个一段时间发送一个ajax请求询问二维码状态)。</p></li><li><p>用户用移动设备扫描二维码，获取到<code>二维码id</code>，移动设备将<code>账号信息</code>连同<code>二维码id</code>发送给服务器</p></li><li><p>服务端收到信息后会将<code>账号信息</code>与<code>二维码id</code>绑定，并返回一个临时token；此时移动端会提示<code>是否登录</code>，pc端二维码状态变为<code>已扫描</code></p></li><li><p>移动端确认登录，会将<code>临时token</code>发送到服务器，服务器收到token后会根据<code>二维码id</code>绑定的<code>设备信息</code>和<code>用户信息</code>生成一个用于pc端登录的<code>token</code>，并在pc端轮询二维码状态的时候<code>返回给pc端</code>。</p></li></ul><img src="..\images\前端面试\扫码登录.png" style="zoom:80%;" /><img src="..\images\前端面试\扫码登录2.png" style="zoom: 80%;" /><h3 id="说说用户登录流程"><a href="#说说用户登录流程" class="headerlink" title="说说用户登录流程"></a>说说用户登录流程</h3><ul><li>用户输入账号密码，前端先校验账号密码的<code>格式</code>是否正确，然后把账号密码连同<code>设备信息（如浏览器类型、操作系统、设备标识符等）</code>发送给后端<code>对应接口</code></li><li>后端校验账号密码是否正确，如果校验通过（正确），把<code>设备信息</code>和<code>账号</code>绑定，并返回一个根据<code>用户id</code>和<code>设备信息</code>加密后生成的token字符串</li><li>前端接收到返回的token后把它存储在<code>localStorage</code></li><li>后续前端的每次请求都会<code>携带token</code>和<code>设备信息</code></li><li>后端会校验请求中的<code>token</code>是否有效，是否与携带的<code>设备信息</code>匹配，不匹配或者token无效则请求失败；服务器应该<code>返回相应的错误信息</code>，并要求用户重新登录。</li></ul><h3 id="说说withCredentials"><a href="#说说withCredentials" class="headerlink" title="说说withCredentials"></a>说说withCredentials</h3><p><code>withCredentials</code> 是<code>XMLHttpRequest</code>中的一个属性，用于控制是否在<code>跨域请求</code>中发送凭据（如 cookies、HTTP 认证信息等）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://api.example.com/data&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>; <span class="comment">// 启用凭据</span></span><br></pre></td></tr></table></figure><p>同时服务器响应头中也应该包含正确的 CORS 头，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: https://example.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p><strong>简单的来说，就是需要前后端协调配合，才能实现跨域携带cookie。</strong></p><p>默认情况下，cookies 只会在同源请求中自动发送。这意味着如果请求是从同一协议、主机名和端口发出的，则会包含相关 cookies。</p><p>举个例子：</p><p>如果当前页面是 <code>www.bilibili.com</code>，并且你发送一个请求，请求的域名是 <code>www.bilibili.com</code>，因为这个请求没有跨域，那么无论是设置为 <code>Domain=www.bilibili.com</code> 的 Cookie 还是设置为 <code>Domain=.bilibili.com</code> 的 Cookie 都会被自动携带。</p><p>但当你在 <code>https://www.bilibili.com</code> 页面下，发送请求 <code>https://game.bilibili.com</code> 时，这是一个<strong>跨域请求</strong>，<code>Domain=www.bilibili.com</code> 的 Cookie不会被自动携带，因为它们仅限于 <code>www.bilibili.com</code>。<code>Domain=.bilibili.com</code> 的 Cookie<strong>可能</strong>会被携带，但是需要满足以下条件：</p><ul><li>客户端明确设置了 <code>withCredentials: true</code>。</li><li>服务器正确配置了 CORS 头，允许凭据传输。</li><li>Cookie 的 <code>SameSite</code> 属性设置为 <code>None</code> 并且启用了 <code>Secure</code> 属性。</li></ul><p>如果<code>withCredentials</code>的值为false（就是没有配置或者配置为false），那即便<code>Domain=.bilibili.com</code>的cookie能在<code>game.bilibili.com</code>下生效，也不会被携带。</p><h3 id="如何实现控制文件点击下载或者预览"><a href="#如何实现控制文件点击下载或者预览" class="headerlink" title="如何实现控制文件点击下载或者预览"></a>如何实现控制文件点击下载或者预览</h3><p><strong>前端</strong></p><p>不添加download属性，默认点击链接预览图片。</p><p>通过a标签的<code>download</code>属性<code>强制下载</code>，但是必须要求网页以http&#x2F;https协议（网络协议）加载，不能是直接打开的网页。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./violet.png&quot;</span> <span class="attr">download</span>=<span class="string">&quot;薇尔莉特&quot;</span>&gt;</span>点击下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>给download赋值可以指定下载时，使用的文件名。如果省略此属性，则浏览器会尝试<code>自动解析URL</code>中的文件名(寻找默认文件名)</p><p><strong>后端</strong></p><p>可以在响应头中通过设置<code>Content-disposition</code>来决定是下载还是预览，因为点击<code>a链接</code>会送一个获取图片（文件）的请求。</p><ul><li><p><code>inline</code></p><p>指示浏览器尝试直接显示内容（如在浏览器窗口或新标签页中打开），这是默认行为。</p></li><li><p><code>attachment</code>：指示浏览器<strong>将内容作为附件下载</strong>，同时还可以通过<code>filename</code>指定下载名称</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Content</span>-<span class="title class_">Disposition</span>: inline;</span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Disposition</span>: attachment; filename=<span class="string">&quot;example.pdf&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="如何让图片复制后的链接失效"><a href="#如何让图片复制后的链接失效" class="headerlink" title="如何让图片复制后的链接失效"></a>如何让图片复制后的链接失效</h3><ul><li>在链接中添加<code>token</code>，让这个链接变成临时链接</li><li>使用<code>URL.createObjectURL</code>创建的临时url来展示图片</li></ul><h3 id="host-referer-origin-这三个请求字段有什么区别"><a href="#host-referer-origin-这三个请求字段有什么区别" class="headerlink" title="host referer origin 这三个请求字段有什么区别"></a>host referer origin 这三个请求字段有什么区别</h3><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><ul><li><p><strong>作用</strong>：<code>Host</code> 头部是HTTP&#x2F;1.1协议中必须包含的一个请求头，用于<strong>指定请求的目标主机名和端口号</strong>。</p></li><li><p><strong>格式</strong>：<code>Host: example.com[:port]</code></p></li><li><p>用途</p><ul><li>它帮助服务器识别客户端想要访问的具体主机，这对于虚拟主机（即在同一IP地址上托管多个域名）非常重要，典型的例子就是<code>github.io</code>，github pages都被托管到4个固定的ip但是却对应多个域名。</li></ul></li><li><p>如果URL使用了默认端口（HTTP为80，HTTPS为443），则可以省略端口号。</p></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure><h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><ul><li><p><strong>作用</strong>：<code>Referer</code> 头部包含了<strong>发起当前请求的页面的URL</strong>。它主要用于追踪用户是从哪个页面跳转过来的，有助于分析流量来源以及实现防盗链等功能。</p></li><li><p><strong>注意拼写错误</strong>：虽然正确的英文单词应该是“Referrer”，但在HTTP协议中该头部被误写作“Referer”。</p></li><li><p><strong>格式</strong>：<code>Referer: http://example.com/path</code></p></li><li><p>用途：</p><ul><li>网站可以通过这个信息来了解用户是从哪里链接过来的。</li></ul></li><li><p>常用于统计分析、反盗链措施等场景。</p></li></ul><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: https://www.example.com/previous-page</span><br></pre></td></tr></table></figure><h4 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h4><ul><li><p><strong>作用</strong>：<code>Origin</code> 头部用于<strong>标识发起请求的源站点</strong>（scheme, host, port）。它主要应用于<code>跨域资源共享(CORS)</code>请求中，用来告知服务器请求的来源，以便决定是否允许该请求。</p></li><li><p><strong>格式</strong>：<code>Origin: scheme://host[:port]</code></p></li><li><p>用途：</p><ul><li>在<code>跨域请求时</code>，浏览器会自动添加此头部以帮助服务器判断是否接受来自不同源的请求。</li></ul></li><li><p>与<code>Referer</code>不同的是，<code>Origin</code>仅包含协议、主机名和端口号，而<strong>不包括具体的资源路径</strong>。</p></li></ul><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: https://www.example.com</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>**<code>Host</code>**：指定请求的目标主机和端口，是HTTP请求的基本组成部分(域名+端口号)</li><li>**<code>Referer</code>**：提供发起请求的前一个页面的<code>完整URL</code>，主要用于跟踪用户行为或实施安全策略(协议+域名+端口号+资源路径)。</li><li>**<code>Origin</code>**：标识请求发起者的源（协议+主机+端口），主要用于跨域请求的安全控制（协议+域名+端口号）</li></ul><p>比如我在<code>https://www.example.com/post/index.html</code>发送一个请求<code>https://www.sanye.blog</code>，这个请求的host就是<code>www.sanye.blog</code>，而这个请求的<code>referer</code>就是<code>https://www.example.com/post/index.html</code>，这个请求的origin就是<code>https://www.example.com</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http/https </tag>
            
            <tag> osi </tag>
            
            <tag> dns </tag>
            
            <tag> tcp/udp </tag>
            
            <tag> cdn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack基础</title>
      <link href="/posts/8b27fb24.html"/>
      <url>/posts/8b27fb24.html</url>
      
        <content type="html"><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>基于<strong>node.js</strong>来开发的<strong>静态资源打包工具</strong>，最<strong>基本的功能</strong>是<strong>递归解析依赖的文件并打包，顺便把模块化代码转化成可以直接在浏览器上运行的代码</strong>。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli -D //下载webpack和调用webpack的命令</span><br></pre></td></tr></table></figure><p>不下载到全局的原因：</p><ul><li><p>不同项目可能需要使用不同版本的webpack</p></li><li><p>下载到全局无法被项目中的package.json文件记录，分享项目给其他人使用的时候需要额外下载webpack</p></li></ul><h3 id="webpack打包命令"><a href="#webpack打包命令" class="headerlink" title="webpack打包命令"></a>webpack打包命令</h3><ul><li><p>如果全局安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack</span><br></pre></td></tr></table></figure></li><li><p>如果安装到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack <span class="comment">#npx会自动在node_modules/.bins目录下查找可执行文件</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack --watch <span class="comment">#实时监测文件的变化，变化后保存文件自动打包</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h3><p>webpack配置文件，在此自定义webpack配置，就不用每次都在命令行中指定配置参数。</p><p>这个文件的执行环境是node.js，必须使用<strong>cjs语法</strong>，使用module.exports导出<strong>配置对象</strong>。</p><p><strong>常见属性</strong></p><h4 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h4><ul><li><p>指定一个入口文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entry</span>:<span class="string">&#x27;./src/main.js&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>指定多个入口文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entry</span>:&#123;</span><br><span class="line">   <span class="attr">app</span>:<span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">   <span class="attr">app2</span>:<span class="string">&#x27;./src/main2.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="comment">//entry: [&#x27;./src/index.js&#x27;, &#x27;./src/another-entry.js&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>更详细的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entry</span>:&#123;</span><br><span class="line">    <span class="attr">app</span>:&#123;</span><br><span class="line">      <span class="attr">import</span>:<span class="string">&#x27;./src/main.js&#x27;</span>,<span class="comment">//指定入口文件</span></span><br><span class="line">      <span class="attr">dependOn</span>:<span class="string">&#x27;lodash&#x27;</span>,<span class="comment">//指定依赖的模块</span></span><br><span class="line">      <span class="attr">filename</span>:<span class="string">&#x27;page/[name].bundle.js&#x27;</span>,<span class="comment">//指定打包后的js文件名称</span></span><br><span class="line">    &#125; <span class="comment">//app是模块名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p>属性值为一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    filename：打包后输出的js文件名</span><br><span class="line">    path：打包后所有文件的存放位置，必须是绝对路径，所以使用path.<span class="title function_">resolve</span>()来拼接路径，如果最终拼接的不是绝对路径，还会和当前工作目录拼接，确保结果是一个绝对路径。</span><br><span class="line">    clean：布尔值，为<span class="literal">true</span>表示每次打包清除之前的打包文件</span><br><span class="line">    publicPath：指定所有文件的公共路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><p>定义打包模式（必填）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mode</span>:developmemt||production</span><br></pre></td></tr></table></figure><p><strong>开发模式和打包模式的区别</strong></p><p>开发环境：</p><ul><li>不需要使用文件缓存，所以不需要给文件名额外添加[contenthash]</li><li>保留devServer</li><li>删除压缩css，js文件配置</li></ul><p>生产环境：</p><ul><li>需要使用缓存，保留文件额外名[contenthash]</li><li>删除devServer</li><li>保留压缩css，js文件配置</li><li>使用tree-shaking</li></ul><h4 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h4><h4 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h4><p><code>webpack-dev-server</code>配置的地方</p><p><strong>webpack-dev-server</strong>是一个由webpack团队维护的，webpack高度支持的<strong>独立的工具</strong>，用于在开发过程中提供一个<strong>开发服务器</strong>， 使用不需要导入，但是需要额外下载。</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-dev-server -D</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">devServer</span>:&#123;</span><br><span class="line">    <span class="attr">static</span>:<span class="string">&#x27;./dist&#x27;</span>,<span class="comment">//提供开发环境中的一个静态资源目录，静态资源是指在开发中我们不希望被打包的一些资源</span></span><br><span class="line">    <span class="attr">port</span>:<span class="number">8080</span>,<span class="comment">//配置服务器端口号</span></span><br><span class="line">        <span class="attr">compress</span>: <span class="literal">true</span>, <span class="comment">//保证传输的是压缩文件从而提高我们的传输效率</span></span><br><span class="line">        <span class="comment">//headers:配置响应头</span></span><br><span class="line">    <span class="attr">proxy</span>:[</span><br><span class="line">       &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/api&#x27;</span>,<span class="comment">//使用的是前缀匹配</span></span><br><span class="line">        <span class="attr">changeOrigin</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">target</span>:<span class="string">&#x27;http://localhost:8081&#x27;</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]<span class="comment">//配置代理，解决跨域问题，因为搭建的本地服务器部署的网页也可能发请求获取其他源下的资源。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack-dev-server</span><br></pre></td></tr></table></figure><p>运行这个命令不仅会启动Webpack的打包过程（打包到内存，不输出实际文件），还会启动一个开发服务器，部署的是打包到内存中的文件。至于是生产打包还是开发打包，就看<strong>当前的webpack配置文件</strong>了，但是一般开发环境才会用。</p><p>这个服务器会监听源文件(src目录下的js文件)的变化，源文件修改并保存会自动重新编译（因为只编译发生变化的部分）和刷新浏览器。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="资源模块"><a href="#资源模块" class="headerlink" title="资源模块"></a>资源模块</h3><p>用来加载<strong>图片</strong>或者字体</p><h4 id="asset-resource"><a href="#asset-resource" class="headerlink" title="asset&#x2F;resource"></a>asset&#x2F;resource</h4><p>导出<strong>资源打包后的路径</strong>，打包后导出源文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[&#123;</span><br><span class="line">      <span class="attr">test</span>:<span class="regexp">/\.jpg$/</span>,</span><br><span class="line">      <span class="attr">type</span>:<span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">      <span class="attr">generator</span>:&#123;</span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&#x27;images/[contenthash][ext]&#x27;</span>#打包后的图片名称</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="asset-inline"><a href="#asset-inline" class="headerlink" title="asset&#x2F;inline"></a>asset&#x2F;inline</h4><p>导出源的<code>data:url</code>，打包后的结果不会包括源文件</p><h4 id="asset-source"><a href="#asset-source" class="headerlink" title="asset&#x2F;source"></a>asset&#x2F;source</h4><p>导出资源的源码，如果是文本文件就是内容，不会导出源文件</p><h4 id="asset"><a href="#asset" class="headerlink" title="asset"></a>asset</h4><p>webpack将按照默认条件，自动地在resource和 inline 之间进行<strong>选择</strong>，小于8kb的文件，将会视为inline模块类型，否则会被视为resource模块类型。也可以修改这个配置文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[&#123;</span><br><span class="line">      <span class="attr">test</span>:<span class="regexp">/\.jpg$/</span>,</span><br><span class="line">      <span class="attr">type</span>:<span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">      <span class="attr">generator</span>:&#123;</span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&#x27;images/[contenthash][ext]&#x27;</span>#打包后的图片名称</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="attr">parser</span>: &#123;</span><br><span class="line">        <span class="attr">dataUrlCondition</span>:&#123;</span><br><span class="line">        <span class="attr">maxSize</span>: <span class="number">4</span> * <span class="number">1024</span> *<span class="number">1024</span></span><br><span class="line">    &#125;<span class="comment">//4Mb</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p>扩展webpack的功能，帮助webpack解析其他类型（非js类型）的文件，并把这些文件转换成有效的模块，实现代码转换；只要有对应的loader，万物皆是模块。</p><blockquote><p>loader在webpack.config.js文件中使用的时候通常不需要导入，直接使用即可, Webpack 会根据配置中的名称自动查找并使用相应的加载器</p></blockquote><h4 id="解析css文件"><a href="#解析css文件" class="headerlink" title="解析css文件"></a><strong>解析css文件</strong></h4><p>我们需要下载<strong>css-loader</strong>,以及<strong>style-loader</strong>或者<strong>mini-css-extract-plugin</strong></p><p>style-loader: 把解析后的css样式放到打包后的html文件的style标签中</p><p>mini-css-extract-plugin：把css提取为<strong>单独的文件</strong>，多个css文件会合并为一个单独的css文件，在html-webpack-plugin插件的作用下还会自动在html文件中引入(在head标签中)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[</span><br><span class="line">         &#123;</span><br><span class="line">        <span class="attr">test</span>:<span class="regexp">/\.css$/</span>,<span class="comment">//匹配css文件</span></span><br><span class="line">        <span class="attr">use</span>:[<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">          <span class="comment">//或者</span></span><br><span class="line">          <span class="comment">// use:[&#x27;style-loader&#x27;,&#x27;css-loader&#x27;]</span></span><br><span class="line">       &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loader是支持<strong>链式调用</strong>的，顺序从右往左，就拿上面的例子来说，先对css文件使用css-loader，再使用style-loader。</p><blockquote><p> 注意:单纯打包css文件不会修改原来的css代码，也不会压缩代码，只是把原来的css代码放到一个文件中。压缩，修改css代码需要借助其他插件。</p></blockquote><h4 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a><strong>babel-loader</strong></h4><p>webpack本身只能对js代码打包,压缩，不能进行ES6到ES5的转换，需要借助babel-loader将新的语法转换成低版本的语法，实现语法降级，比如对esm语法的转化。</p><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-loader @babel/core @babel/preset-env --save-dev</span><br></pre></td></tr></table></figure><p><code>babel-loader</code> 是一个 Webpack 加载器，用于在 Webpack 构建过程中使用 Babel 转译 JavaScript 代码。</p><p><code>@babel/core</code> 是 Babel 的核心库，负责执行实际的代码转译工作</p><p><code>@babel/preset-env</code> 是一个智能预设，可以根据目标环境自动选择需要的 Babel 插件，以生成兼容的代码。</p><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">   <span class="attr">rules</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="attr">use</span>: &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h3><p>我们可能在不同的文件引入相同的模块，这样就可能出现重复打包的问题。</p><p>将公共的代码抽离出去，减小啊打包后文件的大小，从而提高首屏的加载效率。</p><p><strong>分离方法</strong></p><h4 id="模块抽离"><a href="#模块抽离" class="headerlink" title="模块抽离"></a>模块抽离</h4><p>在得知哪个模块被重复引用的前提下，抽离出该模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">entry</span>:&#123;</span><br><span class="line">    <span class="attr">index</span>:&#123;</span><br><span class="line">      <span class="attr">import</span>:<span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">      <span class="attr">dependOn</span>:<span class="string">&#x27;shared&#x27;</span><span class="comment">//表示依赖哪个模块</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">another</span>:&#123;</span><br><span class="line">      <span class="attr">import</span>:<span class="string">&#x27;./src/another.js&#x27;</span>,</span><br><span class="line">      <span class="attr">dependOn</span>:<span class="string">&#x27;shared&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">shared</span>:<span class="string">&#x27;lodash&#x27;</span></span><br><span class="line">&#125; <span class="comment">//index，another，shared是模块名</span></span><br></pre></td></tr></table></figure><h4 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import(&#x27;./math.js&#x27;)//返回一个promise对象</span><br></pre></td></tr></table></figure><p>如果引入的模块是<strong>命名导出，</strong>传入回调函数的参数格式形如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="title function_">f</span>(x,y),</span><br><span class="line">    <span class="attr">sub</span>: <span class="title function_">f</span>(x,y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用then时可以使用<strong>解构赋值来模仿按需导入</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x,y</span>)=&gt;&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x+y)</span><br><span class="line">&#125;<span class="comment">//lazy.js代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./lazy.js&#x27;</span>).<span class="title function_">then</span>( <span class="function">(<span class="params">&#123;add&#125;</span>)=&gt;</span>&#123;<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">1</span>)&#125; )</span><br></pre></td></tr></table></figure><p>如果是<strong>默认导出</strong>，传入回调函数的参数格式形如,就不能直接解构了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">default</span>:&#123;</span><br><span class="line">        <span class="attr">add</span>: <span class="title function_">f</span>(x,y),</span><br><span class="line">        <span class="attr">sub</span>: <span class="title function_">f</span>(x,y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态导入的文件打包的时候会被<strong>自动抽离为</strong>一个<strong>单独的文件</strong>,即便没有被多次使用。</p><p>编译的时候动态导入的文件会被<strong>打包好</strong>，使用的时候再导入</p><p><strong>魔法注释</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName:&#x27;math&#x27; */</span><span class="string">&#x27;./lazy.js&#x27;</span>) <span class="comment">//指定动态导入的文件打包后的模块名（也许不是最后文件名）</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch:true */</span><span class="string">&#x27;./lazy.js&#x27;</span>) <span class="comment">//首页内容都加载完毕，等待网络空闲的时候再加载这个文件</span></span><br></pre></td></tr></table></figure><h4 id="split-chunks-plugin"><a href="#split-chunks-plugin" class="headerlink" title="split-chunks-plugin"></a><strong>split-chunks-plugin</strong></h4><p>使用插件split-chunks-plugin</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p> 生成一个<strong>自动引用</strong>打包后的文件的html文件，包括mini-css-extract-plugin生成的css文件，会自动注入打包后的html文件中。</p><p> 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>在webpack.config.js中配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27; html-webpack-plugin&#x27;</span>) <span class="comment">//引入</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">          <span class="attr">template</span>:<span class="string">&#x27;html模板路径&#x27;</span>,</span><br><span class="line">          <span class="attr">filename</span>:<span class="string">&#x27;输出的html文件名&#x27;</span>,</span><br><span class="line">          <span class="attr">title</span>:<span class="string">&#x27;打包后html文件的title&#x27;</span>,</span><br><span class="line">          <span class="attr">inject</span>:<span class="string">&#x27;指定打包后的js文件的的注入位置&#x27;</span>,</span><br><span class="line">          <span class="attr">chunks</span>:[]<span class="comment">//指定引入哪些打包后的js文件（入口文件），默认全引入</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ] </span><br><span class="line">&#125;<span class="comment">//注册</span></span><br></pre></td></tr></table></figure><p><strong>构建多页面应用</strong>：在plugins里new多次HtmlWebpackPlugin</p><p><strong>自定义</strong>打包后的html的标题：</p><ul><li>在配置对象中添加titile属性并赋值</li><li>在<strong>html模板</strong>中的title标签内容替换为<code>&lt;%= htmlWebpackPlugin.options.title %&gt;</code></li></ul><h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p>把导入的css文件的所有css代码，提取到一个单独的css文件里，代替<code>style-loader</code></p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">          <span class="attr">filename</span>:<span class="string">&#x27;styles/main.css&#x27;</span> <span class="comment">//打包后css文件的名称</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">    <span class="attr">modules</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[ &#123;<span class="attr">test</span>:<span class="regexp">/\.css$/</span>,<span class="attr">use</span>:[<span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,<span class="string">&#x27;css-loader&#x27;</span>]&#125; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//注册</span></span><br></pre></td></tr></table></figure><h3 id="css-minimizer-webpack-plugin"><a href="#css-minimizer-webpack-plugin" class="headerlink" title="css-minimizer-webpack-plugin"></a>css-minimizer-webpack-plugin</h3><p><strong>压缩</strong>打包后的css文件</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i css-minimizer-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CssMinimizeWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">      <span class="attr">minimizer</span>:[<span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>()]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//注册</span></span><br></pre></td></tr></table></figure><h3 id="split-chunks-plugin-1"><a href="#split-chunks-plugin-1" class="headerlink" title="split-chunks-plugin"></a>split-chunks-plugin</h3><p><strong>自动抽离</strong>重复引用的模块,无需下载，webpack内置, 但自动抽离代码在大型项目中使用，构建过程<strong>较费时</strong></p><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span></span><br><span class="line">    <span class="attr">optimization</span>: &#123;</span><br><span class="line">    splitChunks：&#123;<span class="attr">chunks</span>:<span class="string">&#x27;all&#x27;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">//注册</span></span><br></pre></td></tr></table></figure><h3 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a>webpack-bundle-analyzer</h3><p>可以帮助开发者<strong>可视化和分析</strong> Webpack 打包后的<strong>文件大小和内容</strong>,它生成一个交互式的报告，显示每个模块的大小及其在最终打包文件中的占比，从而帮助识别和优化代码。</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-bundle-analyzer -D</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">BundleAnalyzerPlugin</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">   <span class="attr">plugins</span>:[<span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>()]</span><br><span class="line">&#125;<span class="comment">//注册</span></span><br></pre></td></tr></table></figure><h3 id="terse-webpack-plugin"><a href="#terse-webpack-plugin" class="headerlink" title="terse-webpack-plugin"></a>terse-webpack-plugin</h3><p>用来压缩js代码，但是Webpack 5 内置了对 Terser 的支持，在<strong>生产模式</strong>下会自动使用 Terser 进行js代码压缩，这一功能已经是webpack核心功能的一部分。但是如果需要自定义 Terser 的选项，仍然需要安装 <code>terser-webpack-plugin</code> 并进行相应的配置。这时，<code>terser-webpack-plugin</code> 是作为一个第三方插件来使用的。</p><h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h2><p>在<a href="https://www.sanye.blog/posts/762e27cc.html">前端面试—webpack | 三叶的博客</a>中已介绍，不赘述。</p><h2 id="搭建vue脚手架"><a href="#搭建vue脚手架" class="headerlink" title="搭建vue脚手架"></a>搭建vue脚手架</h2><h3 id="npm包下载"><a href="#npm包下载" class="headerlink" title="npm包下载"></a>npm包下载</h3><p><strong>webpack开发必备：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack webpack-cli html-webpack-plugin webpack-dev-server -D</span><br></pre></td></tr></table></figure><p><strong>vue相关：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-template-compiler vue-loader -D</span><br></pre></td></tr></table></figure><p><code>vue-template-compiler</code>用来解析vue模板</p><p><code>vue-loader</code>用来解析.vue文件</p><p>配置vue-loader:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">VueLoaderPlugin</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader&#x27;</span>) <span class="comment">//vue-loader还包含一个plugin</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">plugins</span>:[</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>() <span class="comment">//作用是让其他文件的（js，scss文件）的解析规则复用到解析vue文件</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[ &#123;<span class="attr">test</span>:<span class="regexp">/\.vue$/</span>,<span class="attr">use</span>:<span class="string">&#x27;vue-loader&#x27;</span>&#125; ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>css相关：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i css-loader mini-css-extract-plugin -D</span><br></pre></td></tr></table></figure><p><strong>sass相关：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i sass sass-loader -D</span><br></pre></td></tr></table></figure><p><strong>babel相关：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-loader @babel/core @babel/preset-env -D</span><br></pre></td></tr></table></figure><p><strong>生产环境相关</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue axios vue-router</span><br></pre></td></tr></table></figure><blockquote><p>注意vue下载的是vue2</p></blockquote><h3 id="模拟vue-cli打包"><a href="#模拟vue-cli打包" class="headerlink" title="模拟vue-cli打包"></a>模拟vue-cli打包</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;serve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server --mode development&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --mode production&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="完整配置文件"><a href="#完整配置文件" class="headerlink" title="完整配置文件"></a>完整配置文件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">VueLoaderPlugin</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">entry</span>:<span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>:&#123;</span><br><span class="line">    <span class="attr">filename</span>:<span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">clean</span>:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>:<span class="string">&#x27;./src/index.html&#x27;</span>,</span><br><span class="line">      <span class="attr">filename</span>:<span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">      <span class="attr">inject</span>:<span class="string">&#x27;body&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>:<span class="string">&#x27;styles/main.css&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">VueLoaderPlugin</span>()<span class="comment">//作用是让其他文件的（js，scss文件）的解析规则复用到解析vue文件</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">module</span>:&#123;</span><br><span class="line">    <span class="attr">rules</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>:<span class="regexp">/\.s[ca]ss$/</span>,</span><br><span class="line">        <span class="attr">use</span>:[ <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,<span class="string">&#x27;css-loader&#x27;</span>,<span class="string">&#x27;sass-loader&#x27;</span>] <span class="comment">//先使用sass-loader再使用css-loader</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>:<span class="regexp">/\.vue$/</span>,</span><br><span class="line">        <span class="attr">use</span>:<span class="string">&#x27;vue-loader&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>:<span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="attr">exclude</span>:<span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="attr">use</span>:&#123;</span><br><span class="line">          <span class="attr">loader</span>:<span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>:&#123;</span><br><span class="line">            <span class="attr">presets</span>:[<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mode</span>:<span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">devServer</span>:&#123;</span><br><span class="line">    <span class="attr">static</span>:<span class="string">&#x27;./dist&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="webpack打包流程"><a href="#webpack打包流程" class="headerlink" title="webpack打包流程"></a>webpack打包流程</h2><ul><li><p>合并webapck配置文件和命令行中的参数，创建compiler对象</p></li><li><p>加载所有配置的插件，执行compiler对象的run方法，<strong>开始编译</strong></p></li><li><p>从入口文件开始，使用配置的loader<strong>递归解析</strong>依赖的文件，把他们转化成可用的模块，并构建模块依赖图</p></li><li><p>把入口文件和它依赖的模块<strong>打包</strong>成一个单独的文件。</p></li></ul><h2 id="loader和plugin的区别"><a href="#loader和plugin的区别" class="headerlink" title="loader和plugin的区别"></a>loader和plugin的区别</h2><p>loader主要用来编译，转换文件，<strong>扩展了模块化的范围</strong>，只作用在打包文件之前。</p><p>webpack在运行过程中会产生许多广播事件，plugin通过监听webpack的广播事件，调用webpack提供的api来改变webpack的打包结果；插件可以<strong>扩展 Webpack 的功能</strong>，比如生成html文件，压缩css代码，可以作用在<strong>打包任何时期</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建的一些思考</title>
      <link href="/posts/72ebd24d.html"/>
      <url>/posts/72ebd24d.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要给域名申请SSL证书"><a href="#为什么要给域名申请SSL证书" class="headerlink" title="为什么要给域名申请SSL证书"></a>为什么要给域名申请SSL证书</h2><p>只有给域名申请了SSL证书，<strong>才能以https协议访问域名</strong>，才能确保客户端和服务端的会话是加密的，是安全的。</p><h3 id="https"><a href="#https" class="headerlink" title="https"></a><strong>https</strong></h3><p>http是不安全的，在客户端与服务端使用http通信的时候，请求响应报文都是明文的，消息被截获后通信内容就泄漏了。</p><p>https在http的基础上，使用<strong>TLS&#x2F;SSL</strong>加密，从而确保通信是安全的。</p><p>使用<code>https</code>协议访问某个域名&#x2F;网站，除了基本的<code>DNS解析</code>，TCP三次握手建立连接，还要经过<strong>SSL握手</strong>，然后才能开始<strong>加密通信</strong>。</p><h3 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS&#x2F;SSL"></a><strong>TLS&#x2F;SSL</strong></h3><p>TLS&#x2F;SSL加密过程中<strong>既使用了对称加密，也使用了非对称加密</strong>。使用非对称加密是为了得到一个<strong>会话密钥</strong>，这个会话密钥并没有进行传输，而是双方通过计算得出来的，握手成功后，再使用这个会话密钥进行对称加密。</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a><strong>对称加密</strong></h4><p>使用<strong>同一把密钥</strong>进行加密和解密。发送方和接收方必须<strong>共享</strong>相同的密钥。优点是解密速度快，适合大量数据的加密，缺点是密钥必须共享，这个过程密钥可能被窃取。</p><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a><strong>非对称加密</strong></h4><p>使用一对密钥：公钥（公开）和私钥（保密）。公钥用于加密，私钥用于解密。优点是只传输公钥，私钥不进行传输，泄漏风险很小，很安全，缺点是<strong>解密速度慢</strong>。</p><h4 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a><strong>SSL证书</strong></h4><p>SSL证书其实就是保存在<strong>源服务器</strong>的数据文件，想要证书生效必须向<code>CA</code>申请，表明域名是属于谁的(可以理解为域名必须实名认证，有人需要为这个域名负责)，还包含了<strong>公钥和私钥</strong>。</p><h4 id="TLS-SSL握手过程"><a href="#TLS-SSL握手过程" class="headerlink" title="TLS&#x2F;SSL握手过程"></a><strong>TLS&#x2F;SSL握手过程</strong></h4><p>在握手的过程中，服务端会把自己的<strong>SSL证书</strong>和<strong>公钥</strong>发送给客户端验证，浏览器会通过查询浏览器的<strong>证书信任列表</strong>来判断这个证书是否有效，证书无效则浏览器显示这个连接<strong>不安全</strong>，有效则继续进行后续操作，经过<code>非对称加密</code>得到一个<strong>会话密钥</strong>，握手结束。</p><p>在握手过程中第一随机数，第二随机数，和公钥都是明文传输的，就意味着有暴露的风险，但是<code>第三随机数</code>的传输是经过公钥加密的，只能用<code>私钥</code>解密,也就是只有服务端知道第三随机数是什么，这就是一次<strong>非对称加密</strong>，然后再用那3个随机数计算得到<strong>会话密钥</strong>，会话密钥没有进行传输所以是安全的，握手结束后，后续的通信都用这个会话密钥加密。</p><img src="..\images\hexo所思\ssl.png" style="zoom:80%;" /><p>详细解释可参考：<a href="https://www.bilibili.com/video/BV1KY411x7Jp/?vd_source=00483a04a5a69136669373a8ea522a9b">HTTPS是什么？加密原理和证书。SSL&#x2F;TLS握手过程_哔哩哔哩_bilibili</a></p><h3 id="为什么接入cdn加速后还要申请SSL证书"><a href="#为什么接入cdn加速后还要申请SSL证书" class="headerlink" title="为什么接入cdn加速后还要申请SSL证书"></a>为什么接入cdn加速后还要申请SSL证书</h3><p>在我们不接入cdn加速服务之前，我们无论是访问<code>用户名.github.io</code>还是<code>自定义域名</code>，最终都是从GitHub pages服务器拿到数据，SSL握手的对象也是<strong>githubpages服务器</strong>, github为我们<strong>免费生成</strong>的SSL证书是存储在githubpages服务器的;但是我们接入cdn服务后，我们就不是从源服务器（githubpages服务器）取数据了，而是cdn服务器，<strong>握手的对象就是cdn服务器</strong>，所以我们还需要手动为我们的自定义域名（或者默认域名）申请一次SSL证书，存储在CDN服务器中，后续我们才能使用https协议访问cdn服务器。</p><h2 id="gulp和webpack的区别"><a href="#gulp和webpack的区别" class="headerlink" title="gulp和webpack的区别"></a>gulp和webpack的区别</h2><img src="..\images\hexo所思\gulp.png" style="zoom:67%;" /><p>Gulp是基于<strong>nodejs流</strong>的前端构建工具，可以实现文件的<strong>转换，压缩</strong>，合并，监听，自动部署等功能。gulp拥有强大的<code>插件库</code>，基本上满足开发需求，而且开发人员也可以根据自己的需求开发自定义插件。难得是，gulp只有五个api，<strong>容易上手</strong>。配置文件是<strong>gulpfile.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">&quot;gulp-sass&quot;</span>)</span><br><span class="line"></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&quot;sassStyle&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    gulp.<span class="title function_">src</span>(<span class="string">&quot;style/*.scss&quot;</span>)<span class="comment">//入口文件</span></span><br><span class="line">        .<span class="title function_">pipe</span>(<span class="title function_">sass</span>())</span><br><span class="line">        .<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&quot;style&quot;</span>))<span class="comment">//目标文件</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面就是一个基本的<code>gulpfile</code>配置文件，实现了<code>scss</code>文件到<code>css</code>文件的转换；在终端输入<code>gulp sassStyle</code>（sassStyle是任务名）就能够进行文件处理了。<br>对于<code>gulp</code>而言，会有一个<code>task</code>，这个<code>task</code>只会做一件事，比如将sass格式的文档转换成css文件；对于一个<code>task</code>而言，会有一个入口文件，即<code>gulp.src</code>，最会有一个目标文件，即<code>gulp.dest</code>；一入一出，可以将gulp理解为 <code>一元函数</code>，输入一个<code>x</code>，根据<code>funcion</code>产出一个<code>y</code>。</p><p>webpack的主要作用是<strong>解析模块之间的依赖关系</strong>，并把他们有条理的<strong>打包</strong>起来，顺便把模块化的代码转化成浏览器可以识别的代码。webpack从<strong>入口文件</strong>开始，<strong>递归</strong>找出所有<strong>依赖的模块</strong>，并使用配置的<strong>loader解析模块</strong>，使之变为可用的模块，而在webpack会在各个特定的时期<strong>广播</strong>对应事件，<strong>插件</strong>会<strong>监听</strong>这些事件，在某个事件中进行特定的操作。通俗一点来说，webpack本身来递归找到各个文件之间的依赖关系，在这个过程中，使用loaders对文件进行解析，最后，在各个不同的事件阶段，插件可以对文件进行一个统一的处理。</p><p>虽然Webpack与gulp都是前端工程化的管理工具，但是二者的侧重点不同——gulp更加关注的是自动化的构建工具，你把代码写好了，gulp会帮你编译、压缩、解析。而Webpack关注的是在<strong>模块化背景</strong>下的<strong>打包</strong>工作；它侧重的还是如何将依赖的文件合理的组织起来，并且实现按需加载。</p><p>详细参考文章：<a href="https://segmentfault.com/a/1190000017933455">Javascript五十问——从源头细说Webpack与Gulp - Javascript 五十问 - SegmentFault 思否</a></p><h2 id="把博客部署到vercel上为什么加载的更快"><a href="#把博客部署到vercel上为什么加载的更快" class="headerlink" title="把博客部署到vercel上为什么加载的更快"></a>把博客部署到vercel上为什么加载的更快</h2><p><strong>免费提供的CDN服务</strong></p><p>Vercel 利用其全球分布的 <strong>CDN 边缘节点</strong>来缓存和分发静态内容。这意味着用户可以从离他们最近的服务器获取内容，减少了数据传输的延迟。虽然github也提供免费的CDN服务，但是 CDN 覆盖范围不如 Vercel 广泛。</p><p><strong>自动文件压缩</strong></p><p> Vercel 会自动对你的代码进行压缩和优化，减少文件大小，加快加载时间。例如，它会对 JavaScript 和 CSS 文件进行压缩，移除不必要的空格和注释。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http/https </tag>
            
            <tag> gulp </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从0开始搭建hexo+butterfly博客</title>
      <link href="/posts/42807cbc.html"/>
      <url>/posts/42807cbc.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是hexo"><a href="#什么是hexo" class="headerlink" title="什么是hexo?"></a>什么是hexo?</h2><p>Hexo 是一个快速、简洁且高效的<strong>博客框架</strong>。 Hexo 使用 <code>Markdown</code>（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页（html）。</p><p>其他博客框架：vuepress , gatsby；前者适合vue开发者，后者适合react开发者。</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><blockquote><p>需要提前准备的工具：vscode, git, node.js；去对应的官网下载即可。</p></blockquote><p>在任意位置新建一个文件夹，右键选择用vscode打开；或者直接打开vscode新建一个文件夹，取一个合适的名字，比如blog；右键文件夹，在当前文件下打开终端，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli //全局安装hexo</span><br><span class="line">hexo init blog //初始化一个博客blog</span><br><span class="line">cd blog //进入到博客文件</span><br><span class="line">npm install //安装所需依赖</span><br><span class="line">hexo server //在本地部署博客</span><br></pre></td></tr></table></figure><p>好了，再访问<code>http://localhost:4000</code>就能看到运行在本地的博客了</p><h2 id="hexo常用指令"><a href="#hexo常用指令" class="headerlink" title="hexo常用指令"></a>hexo常用指令</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">clean</span> <span class="string">//清除打包后的文件，即删除public文件夹</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">generate</span> <span class="string">//可以简写为hexo</span> <span class="string">g，作用是生成静态文件</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">server</span> <span class="string">//可以简写为hexo</span> <span class="string">s,部署自己的博客到本地，会打包文件但是不会输出实际文件</span></span><br><span class="line"><span class="string">hexo</span> <span class="string">deploy</span> <span class="string">//部署自己的博客到服务器</span></span><br></pre></td></tr></table></figure><h2 id="项目结构分析"><a href="#项目结构分析" class="headerlink" title="项目结构分析"></a>项目结构分析</h2><ul><li>node_modules:存放安装到本项目的npm包</li><li>scaffold：存放md文档模板<ul><li>page.md:页面的模板</li><li>post.md:博客的模板</li></ul></li><li>source：存放博客和页面的文件夹<ul><li>_post: 存放博客的文件夹</li><li>categories：存放分类页面的文件夹，通常只有一个文件</li><li>tags：存放标签页面的文件夹，通常只要一个文件</li></ul></li><li>theme：存放下载的主题的文件夹</li><li>_config.yml: 博客的配置文件</li><li>_config.主题名.yml:主题的配置文件，自定义主题配置的地方</li></ul><h2 id="更换主题：butterfly"><a href="#更换主题：butterfly" class="headerlink" title="更换主题：butterfly"></a>更换主题：butterfly</h2><p>hexo自带的主题也许不是那么好看，没关系，hexo提供了丰富的主题给我们选择，我们可以去官网上查找，或者去GitHub上查找（推荐），下面我们以GitHub为例。</p><p>在国内直接访问github很不稳定，需要借助加速器，这里推荐<a href="https://steampp.net/">steam++</a></p><p>没有账号的用自己的邮箱注册一个即可，登录后在home主界面搜索hexo themes,查找自己喜欢的主题,这里我们选择butterfly主题。</p><ul><li>下载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><ul><li><p>在你的博客文件夹的themes文件夹中,就能看到butterfly文件夹，删除.git文件夹。</p></li><li><p>在博客根目录下新建_config.butterfly.yml文件，复制themes&#x2F;butterfly文件夹下的_config.yml文件内容，粘贴到该文件。</p></li><li><p><strong>后续自定义博客都在_config.butterfly.yml文件下进行。</strong></p></li></ul><h2 id="新建博客文章"><a href="#新建博客文章" class="headerlink" title="新建博客文章"></a>新建博客文章</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 文章名</span><br></pre></td></tr></table></figure><p>执行这条命令之后你就能在source&#x2F;_post文件夹下看到一个新的md文件，它就是你编写博客的地方。</p><p><strong>md文件结构分析</strong></p><ul><li>Front-matter: 是 markdown 文件最上方以 — 分隔的区域,<strong>不是写博客的区域，而是配置博客的区域</strong><ul><li>Page-Front-Matter: 用于 <strong>页面</strong> 配置</li><li>Post Front-matter：用于 <strong>文章页</strong> 配置</li></ul></li></ul><p>具体是配置什么的直接看文档<a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 文檔(二) 主題頁面 | Butterfly</a></p><ul><li>用md语法写博客的区域</li></ul><p><strong>修改博客下方的文章链接</strong></p><p>在根目录下的<strong>_config.yml</strong>文件中修改,确保url是你博客部署的网址，替换掉默认的示例。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://www.sanye.blog</span></span><br></pre></td></tr></table></figure><p><strong>修改博客分享方式</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">share:</span></span><br><span class="line">  <span class="comment"># Choose: sharejs / addtoany</span></span><br><span class="line">  <span class="comment"># Leave it empty if you don&#x27;t need share</span></span><br><span class="line">  <span class="attr">use:</span> <span class="string">sharejs</span> <span class="comment">#选择提供分享功能的服务商，不需要分享功能则置空</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Share.js</span></span><br><span class="line">  <span class="comment"># https://github.com/overtrue/share.js</span></span><br><span class="line">  <span class="attr">sharejs:</span></span><br><span class="line">    <span class="attr">sites:</span> <span class="string">wechat,weibo,qq</span> <span class="comment">#选择分享到哪些平台</span></span><br></pre></td></tr></table></figure><h2 id="新建分类"><a href="#新建分类" class="headerlink" title="新建分类"></a>新建分类</h2><p>为了方便我们博客文章的查找，我们很自然的会想到给博客分类，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories //本质是在创建一个页面page</span><br></pre></td></tr></table></figure><p>你会找到 source&#x2F;categories&#x2F;index.md 这个文件</p><p>修改这个文件的Front-Matter部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">分类</span>  </span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-01-05 00:00:00</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&#x27;categories&#x27;</span></span><br></pre></td></tr></table></figure><p>然后我们在每篇博客的Front-matter部分就可以通过categories属性给文章分类。示例：categories: ‘book’</p><p><strong>注意</strong>：如果我们未创建分类页面，点击<strong>分类标签</strong>是会报错的，提示找不到该页面。</p><h2 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h2><p>我们还可以给每篇文章添加多个标签，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags //本质也是在创建一个页面page</span><br></pre></td></tr></table></figure><p>你会找到 source&#x2F;tags&#x2F;index.md 这个文件</p><p>修改这个文件的Front-Matter部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&#x27;tags&#x27;</span></span><br></pre></td></tr></table></figure><p>然后我们在每篇博客的Front-matter部分就可以通过tags属性给文章添加标签，一篇文章可以添加多个标签，示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tags:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;html&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;css&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果我们未创建tags页面，点击<strong>tags标签</strong>是会报错的，提示找不到该页面。</p><h2 id="自定义主页"><a href="#自定义主页" class="headerlink" title="自定义主页"></a>自定义主页</h2><p>博客的主页就是博客的首页，如下：</p><img src = '../images/搭建hexo/home.png' style="width:600px;"><p>自定义主页的<strong>详细内容见官方文档</strong><a href="https://butterfly.js.org/posts/4aa8abbe/">Butterfly 文檔(三) 主題配置 | Butterfly</a>，下面我<strong>只介绍</strong>我遇到困难的部分。</p><h3 id="自定义菜单"><a href="#自定义菜单" class="headerlink" title="自定义菜单"></a>自定义菜单</h3><p>在_config.butterfly.yml文件中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"> <span class="attr">Home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line"> <span class="attr">Tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line"> <span class="attr">Categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br></pre></td></tr></table></figure><p>当然这些都是我认为最基础的菜单设置，<code>||</code>前面的表示的是<strong>页面的路径</strong>,后面表示的是<strong>图标</strong>。</p><p>在自定义这部分的时候我遇到了一个问题，就是无论如何配置，菜单上都会有music和video选项，原因是在themes&#x2F;butterfly的_config.yml文件中，music和video选项是默认选中的。<code>Hexo 会自动合併主题中的 _config.yml 和 _config.butterfly.yml 里的配置，如果存在同名配置，会使用 _config.butterfly.yml 的配置，其优先度较高</code>。参考文档<a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 文檔(一) 快速開始 | Butterfly</a></p><h3 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h3><p>如果能根据本地博客内容实现文章搜索，那实在是太方便了；hexo提供了多种搜索方式，其中本地搜索最容易实现。</p><p>前往博客根目录，打开cmd命令窗口执行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>然后在_config.butterfly.yml文件中配置即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"> <span class="comment"># Choose: algolia_search / local_search / docsearch</span></span><br><span class="line"> <span class="comment"># leave it empty if you don&#x27;t need search</span></span><br><span class="line"> <span class="attr">use:</span> <span class="string">local_search</span></span><br></pre></td></tr></table></figure><p>更多搜索方式参考文章：<a href="https://www.jianshu.com/p/500e2e1e66c5">Hexo + Butterfly 键入搜索功能 - 简书</a>以及butterfly官方文档</p><h3 id="自定义首页图片"><a href="#自定义首页图片" class="headerlink" title="自定义首页图片"></a>自定义首页图片</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁用顶部图片</span></span><br><span class="line"><span class="attr">disable_top_img:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># The banner image of index page</span></span><br><span class="line"><span class="attr">index_img:</span> <span class="comment">#指定顶部图片</span></span><br><span class="line"><span class="comment"># The height of top_img, eg: 300px/300em/300rem</span></span><br><span class="line"><span class="attr">index_top_img_height:</span> <span class="string">16rem</span> <span class="comment">#指定顶部图片的高度</span></span><br></pre></td></tr></table></figure><p>这三个配置项默认并不在一起，但是我为了方便配置把它们放到了一起。</p><h3 id="引入图片"><a href="#引入图片" class="headerlink" title="引入图片"></a>引入图片</h3><ul><li><p>通过网络图片的形式引入</p><p>优点：减小打包体积</p><p>缺点：博客部署在github使用<code>网络图片</code>可能存在跨域问题</p></li><li><p>通过本地图片引入</p><p>优点： 不存在跨域问题，直接使用本地图片即可。</p><p>引入方式：在根目录下的source文件夹中新建一个<code>images</code>文件夹，然后本地图片都放里面(假设放入了一张图片xxx.jpg)，然后博客文章就能通过<code>../images/xxx.jpg</code>的相对路径来访问了。</p><p>而且为了让我们的博客图片无论在本地直接打开博客md文件的时候能正常显示，还是在部署到本地或者远程服务器的时候能正常显示，我们需要用<strong>img标签</strong>来展示我的图片，而不是使用<code>![]()</code>这种md语法。</p></li></ul><h3 id="B站banner"><a href="#B站banner" class="headerlink" title="B站banner"></a>B站banner</h3><p>用过B站的小伙伴应该都注意到了B站首页banner图片的特色，我们也可以用它来装饰自己的博客！</p><img src = '../images/搭建hexo/banner.png' style="width:600px;"><p>参考文章：<a href="https://akilar.top/posts/780a2cea/">Bilibili Dynamic Banner | Akilarの糖果屋</a></p><p>大家跟着这篇文章做就行，我跟着做完后发现有个问题，主页还是无法显示B站轮播图，自己研究了一下发现是<code>bilibili-banner.pug</code>文件的问题，第一行<code>if (!is_home())</code>就指定了<code>bilibili banner</code>的结构不能被添加到主页面，于是我把这个判断改为<code>if (is_home())</code>，即只在首页添加，如果删掉这个判断，就是在文章和首页都添加。</p><p>还有一个问题就是，正常情况下，我们把鼠标放到<code>bilibili banner</code>上左右移动，图片会跟着移动并且内容会随之改变，但是因为<code>header</code>中其他元素占据了太多空间且布局在<code>banner</code>顶部，会阻碍我们鼠标与<code>banner</code>交互，我们可以选择<code>删除这些结构</code>，或者修改这些元素的<code>css样式</code>。</p><p>我们额外添加一条样式：<code>pointer-events: none;</code>可以让指定元素忽略所有鼠标事件，从而使事件<strong>穿透</strong>到下层元素，这个属性还是可被继承的。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件路径：\themes\butterfly\source\css\_layout\head.styl</span></span><br><span class="line"><span class="selector-id">#site-info</span></span><br><span class="line">      <span class="attribute">pointer-events</span>: none;</span><br><span class="line">      <span class="attribute">position</span>: absolute</span><br><span class="line">      <span class="attribute">top</span>: <span class="variable">$index_site_info_top</span></span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span></span><br><span class="line">      <span class="attribute">width</span>: <span class="number">100%</span></span><br></pre></td></tr></table></figure><p>还能优化的一点就是因为B站banner放到移动端展示效果不好，所以原文章作者使用了<code>媒体查询</code>，当视口宽度小于<code>1000px</code>的时候，banner的样式就会变为<code>display:none</code>，此时如果我们未设置<code>index_img</code>那首页就是纯蓝色背景不好看，我们检查页面文档能发现，banner是一个宽高都是<code>100%的div元素</code>，而<code>index_img</code>是背景图片，二者是<code>不冲突</code>的，如果banner存在，则会覆盖，压住<code>index_img</code>，如果banner隐藏，<code>index_img</code>就能显示出来，所以建议最好再指定一下<code>index_img</code>，这样移动端也能看到自定义的<code>index_img</code>。</p><h3 id="自定义社交图标"><a href="#自定义社交图标" class="headerlink" title="自定义社交图标"></a>自定义社交图标</h3><img src = '../images/搭建hexo/social.png' style="width:300px;"><p>如上图就是社交图标，可以在_config.butterfly.yml文件的social属性中配置，点击即可跳转到相关网页。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fa-brands fa-bilibili:</span> <span class="string">https://space.bilibili.com/660655866?spm_id_from=333.1007.0.0</span> <span class="string">||</span> <span class="string">Bilibli</span> <span class="string">||</span> <span class="string">&#x27;#74C0FC&#x27;</span></span><br><span class="line">  <span class="attr">fab fa-github:</span> <span class="string">https://github.com/syhy</span> <span class="string">||</span> <span class="string">Github</span> <span class="string">||</span> <span class="string">&#x27;#24292e&#x27;</span></span><br><span class="line">  <span class="attr">fas fa-envelope:</span> <span class="string">mailto:3519450570@qq.com</span> <span class="string">||</span> <span class="string">Email</span> <span class="string">||</span> <span class="string">&#x27;#4a7dbe&#x27;</span></span><br></pre></td></tr></table></figure><p>书写格式 图标名：url || 描述性文字 || color</p><p>图标名可在这个网站上查找：<a href="https://fontawesome.com/">fontawesome</a></p><h3 id="统计网站访客数目"><a href="#统计网站访客数目" class="headerlink" title="统计网站访客数目"></a>统计网站访客数目</h3><p>我们的博客是纯静态网页，没有涉及到与后端的数据交互，但是我们如果想要实现统计网站访客数目的功能，就必须借助后端，那该怎么实现呢？幸运的是，有人愿意<strong>免费</strong>给我们提供服务器来存储我们网站的访客数据。</p><p><a href="https://busuanzi.ibruce.info/">不蒜子 - 极简网页计数器</a> 是一个轻量级的网站访问统计工具，它通过简单的 <strong>JavaScript 代码嵌入到网页</strong>中来实现访问次数的统计。</p><p><strong>大致原理</strong></p><p>当用户访问包含 Busuanzi 脚本的页面时，该脚本会在用户的浏览器上执行，然后发送一个<strong>jsonp请求</strong>，请求头中的Referer字段会携带当前网站的url，busuanzi服务器会从Referer字段中提取出<strong>网站的域名</strong>等信息，并将该域名对应的网站访问次数<strong>加1</strong>，再<strong>返回</strong>一串js代码，这串代码中包含了网站被访问次数等信息，然后浏览器会执行这串代码，把返回的信息<strong>渲染到页面上</strong>。具体原理参考<strong>源码</strong>。</p><p>如官网所示，我们只需在网页中引入一个js文件就行，对于butterfly主题的hexo博客，用上这个工具更是简单，我们只需要在主题配置文件中启用这个插件就行：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保开启webinfo，不然也不会显示访客数据</span></span><br><span class="line"><span class="attr">card_webinfo:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>博客网站访客量<strong>虚高</strong>的原因。</p><ul><li><p>我们的博客部署在本地<strong>localhost:4000</strong>,大家都用这个域名测试博客，访客量当然特别高了，部署到自己的网站后就没问题了。</p></li><li><p>我们的博客网站所在域名之前可能已经使用过busuanzi提供的服务了，但是无论我们是按照官网的指示直接引入js文件，还是在butterfly的主题配置文件中开启相关配置，请求获取的都是官方的js文件，也就是<strong>源码</strong>，我们可以通过直接在浏览器导航栏输入官方js文件的网址（在官网已给出），从而下载，修改源码来解决这个问题。我们把下载好的源码放在<code>themes/butterfly/source/js目录</code>下，并在源码中做如下修改：</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们先分析这三个字段什么意思</span></span><br><span class="line"><span class="comment">// &quot;site_uv&quot;: 独立访客数</span></span><br><span class="line"><span class="comment">// &quot;page_pv&quot;: 当前页面的访问量</span></span><br><span class="line"><span class="comment">// &quot;site_pv&quot;: 站点总访问量</span></span><br><span class="line"><span class="attr">bszs</span>: [<span class="string">&quot;site_pv&quot;</span>, <span class="string">&quot;page_pv&quot;</span>, <span class="string">&quot;site_uv&quot;</span>],</span><br><span class="line">    <span class="attr">texts</span>: <span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">bszs</span>.<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">b</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> c = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;busuanzi_value_&quot;</span> + b);</span><br><span class="line">            <span class="keyword">if</span> (c) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (b) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;site_pv&quot;</span>:</span><br><span class="line">                        c.<span class="property">innerHTML</span> = a[b]-虚高的值;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;page_pv&quot;</span>:</span><br><span class="line">                        <span class="comment">//文章链接通常是唯一的，出现二手的概率很小，所以直接使用返回过来的值</span></span><br><span class="line">                        c.<span class="property">innerHTML</span> = a[b]</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;site_uv&quot;</span>:</span><br><span class="line">                        c.<span class="property">innerHTML</span> = a[b] - 虚高的值;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>然后在主题配置文件中修改busuanzi的默认cdn链接，指定为本地文件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CDN:</span></span><br><span class="line">  <span class="attr">option:</span></span><br><span class="line">    <span class="attr">busuanzi:</span> <span class="string">/js/busuanzi.js</span></span><br></pre></td></tr></table></figure><p>当然，如果我们的博客因为<strong>部署的域名改变</strong>了，需要加上先前的访问次数，也可以使用这种方式来实现。</p><h3 id="live2D"><a href="#live2D" class="headerlink" title="live2D"></a>live2D</h3><p>谁不想给自己的博客界面添加一个可爱的看板娘呢？来看看如何实现吧。</p><img src="../images/搭建hexo/live2D.png" style="height:100px"><p>在github上有个star非常多的，基于hexo的live2D项目：<a href="https://github.com/EYHN/hexo-helper-live2d">EYHN&#x2F;hexo-helper-live2d: Add the Sseexxyyy live2d to your hexo!</a></p><p>部署起来也非常方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>安装完成之后再配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">log:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment">#注释掉mode，使用的就是默认模型</span></span><br><span class="line">  <span class="comment">#mode:</span></span><br><span class="line">  <span class="comment">#use:</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">200</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br></pre></td></tr></table></figure><p><strong>详细配置</strong>请前往原项目查看</p><p>其他可用模型：<a href="https://github.com/xiazeyu/live2d-widget-models">xiazeyu&#x2F;live2d-widget-models: Model library for live2d-widget.js</a>（交互功能不如默认模型）</p><p>其他live2D项目：<a href="https://github.com/stevenjoezhang/live2d-widget">stevenjoezhang&#x2F;live2d-widget: 把萌萌哒的看板娘抱回家 (ノ≧∇≦)ノ | Live2D widget for web platform</a></p><h2 id="永久链接"><a href="#永久链接" class="headerlink" title="永久链接"></a>永久链接</h2><p>“Hexo 文章链接默认的生成规则是：<code>:year/:month/:day/:title</code>，是按照年、月、日、标题来生成的。</p><p>这样的话，生成的链接非常长长长长长，而且如果我们的 Markdown 使用中文标题，那就更惨了，URL 一转码，将是一场灾难。</p><p>更难受的是如果我们修改了文章的日期或者标题，那么将导致<strong>链接改变</strong>，别人或者你分享出去的文章就会 <strong>404</strong>，这非常的蛋疼啊，所以就有了这种插件，不论你如何修改文章的日期、名称，只要不改变 <strong>footer-matter 中的 id 值</strong>，那么文章链接永远不会变。”</p><p>该话引用自<a href="https://imbhj.com/posts/b6a99401/">Hexo 博客生成永久链接 | Ordis’Blog</a></p><p>大家跟着这个博客去敲代码就好了。</p><h2 id="自定义页脚"><a href="#自定义页脚" class="headerlink" title="自定义页脚"></a>自定义页脚</h2><p>butterfly主题配置文件的<code>footer.custom_text</code>属性是支持传入html解构的，而其他footer属性不支持，我们可以选择关掉其他footer属性，把要定义的解构全写<code>footer.custom_text</code>里，可以放入一些彩色图标，添加更多结构，提供更大的自由度。</p><h2 id="加载动画"><a href="#加载动画" class="headerlink" title="加载动画"></a>加载动画</h2><p>如果我们的博客部署在GitHub，或者我们的博客打开需要加载较多的网络资源，就会导致我们的博客打开很慢，这个时候通过加入加载动画就能优化读者的阅读体验。</p><p>参考文章：<a href="https://blog.meta-code.top/2022/06/18/2022-73/">多种加载动画</a></p><p>我在做自己的博客的时候并没有完全跟着博客敲代码，而是先大致了解一下代码的逻辑，然后只选择了其中的一种加载动画—钢铁之心，</p><p>如果有像我一样不喜欢加载完成后展开的过渡效果的，可以对<code>source/css/_layout/loading.styl</code>文件做如下修改</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="selector-class">.loaded</span></span><br><span class="line">     <span class="attribute">display</span> <span class="attribute">none</span></span><br><span class="line">     <span class="selector-class">.loading-left-bg</span></span><br><span class="line">       <span class="attribute">transition</span> <span class="attribute">all</span> <span class="number">1.0s</span></span><br><span class="line">       <span class="attribute">transform</span> <span class="attribute">translate</span>(-<span class="number">100%</span>, <span class="number">0</span>)</span><br><span class="line">     <span class="selector-class">.loading-right-bg</span></span><br><span class="line">       <span class="attribute">transition</span> <span class="attribute">all</span> <span class="number">1.0s</span></span><br><span class="line">       <span class="attribute">transform</span> <span class="attribute">translate</span>(<span class="number">100%</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>意思就是，页面加载完毕之后，直接隐藏<code>loading-box</code>。</p><p>如果要手动实现加载动画的话，除了一些css代码，核心就是<code>window</code>的<code>load</code>事件；</p><p>加载动画能够显示出来，也需要加载并解析它需要的css文件，为了让加载动画尽快显示出来，我们可以选择把这些css代码内联到html文件内，这样渲染加载动画无需等待其他首屏关键css文件，但是我们的博客有许多html页面，手动内联也太麻烦了…</p><p>如果加载动画需要的css代码是通过link标签引入的，还要等待其他首屏关键css加载解析完毕才能开始渲染加载动画，可以自己使用3G测试。</p><h2 id="修改鼠标样式"><a href="#修改鼠标样式" class="headerlink" title="修改鼠标样式"></a>修改鼠标样式</h2><p>修改起来也是很简单的，直接跟着文章敲代码就行。</p><p><a href="https://cnhuazhu.top/butterfly/2021/07/05/Hexo%E9%AD%94%E6%94%B9/Hexo%E9%BC%A0%E6%A0%87%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/">Hexo鼠标样式修改 | 花猪のBlog</a></p><p>大家也可以自行去查找更多的鼠标样式<br>上述鼠标样式使用的css文件是<strong>网络文件,<strong>现在链接好像已经失效了，我们可以选择把</strong>鼠标样式图片（.cur文件）</strong>下载到本地的themes\butterfly\source\img目录下然后通过绝对路径引入。如果你觉得某个博主的鼠标样式好看，也可以右键检查页面，查看网络日志，获取博主鼠标样式图片的链接然后直接下载到本地。</p><p>参考：</p><p><a href="https://jiangnanpsalter.github.io/2024/04/05/hexo+butterfly%E4%B8%BB%E9%A2%98%E5%88%A9%E7%94%A8css%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99%E9%BC%A0%E6%A0%87%E6%8C%87%E9%92%88%E6%A0%B7%E5%BC%8F/">hexo+butterfly主题利用css部署网站鼠标指针样式 | JiangnanPsalter</a></p><p><a href="https://pearlchocolatezy.com/2023/02/15/SetBlogCursorCSS/">Hexo|Butterfly修改鼠标指针样式 | 珍珠巧克力</a></p><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><p>提高我们的博客在浏览器中的搜索排名，从而提高我们的博客的<strong>曝光量</strong>，让更多人看到。</p><ul><li><p>下载插件<a href="https://github.com/hexojs/hexo-filter-nofollow">hexojs&#x2F;hexo-filter-nofollow： 自动为所有外部链接添加 nofollow 属性。</a></p><p>通过给博客中引入的外部链接（比如a标签）添加<code>rel=&quot;noopener external nofollow noreferrer&quot;</code>属性来优化SEO</p><p><strong>noopener</strong>: 防止新打开的页面通过<code>window.opener</code>属性访问原始页面的<code>window</code>对象。</p><p><strong>external</strong>: 表示链接指向的是外部网站。</p><p><strong>nofollow</strong>: 告诉搜索引擎不要将这个链接视为对目标页面的信任投票；防止页面的链接权重传递给外部网站，有助于保留更多的链接权重；如果你的博客中包含指向低质量或垃圾网站的链接，使用<code>nofollow</code>可以减少这些链接对你的网站造成负面影响的风险。</p></li><li><p>下载插件<a href="https://github.com/coneycode/hexo-generator-baidu-sitemap">Baidu Sitemap generator plugin for Hexo</a></p><p>下载并配置好后执行hexo g，会自动生成博客的站点地图。需要在百度搜索资源平台注册账号，添加并<strong>验证</strong>自己的网站，然后<strong>提交网站的sitemap.xml（站点地图）</strong>, 从而提高自己的网站在百度中的SEO</p><blockquote><p>如果购买的是国外域名，验证可能因超时而失败</p></blockquote></li><li><p>下载插件<a href="https://github.com/hexojs/hexo-generator-sitemap">hexojs&#x2F;hexo-generator-sitemap: Sitemap generator for Hexo.</a></p><p>下载并配置好后执行hexo g，会自动生成博客的站点地图。然后可以选择去google或者bing的资源平台验证自己的网站并提交站点地图，比较推荐提交到<a href="https://www.bing.com/webmasters/home">Home - Bing Webmaster Tools</a>，不需要科学上网。</p><p>参考文章：<a href="https://blog.codejerry.cn/posts/hexoseo/">Hexo文章加密 &amp; 搜索引擎优化SEO &amp; 评论系统Twikoo | Yan Zhang’s blog</a></p></li></ul><h2 id="部署博客到github"><a href="#部署博客到github" class="headerlink" title="部署博客到github"></a>部署博客到github</h2><h3 id="部署方法"><a href="#部署方法" class="headerlink" title="部署方法"></a>部署方法</h3><p>方法1：可以通过<code>https://[username].github.io</code>的格式来访问部署的资源</p><ul><li><p>仓库名必须为<code>[username].github.io</code>，这样貌似必须通过<code>https://[username].github.io/[username].github.io</code>的方式来访问，其实只需要通过<code>https://[username].github.io</code>的方式来访问就行。</p><img src="..\images\搭建hexo\部署.png" style="zoom:80%;" /></li><li><p>打包产物放到<code>master</code>分支</p></li><li><p>优点是路径短，更适合用来做博客</p></li></ul><p>方法2：可以通过<code>https://[username].github.io/[repo]</code>的格式来访问部署的资源</p><ul><li>可以自定义仓库名</li><li>更适合用来展示demo</li><li>打包产物放到<code>gh-pages</code>分支</li></ul><p>我们使用第一种方式，还要先下载<code>hexo-deployer-git</code>，这个插件的作用可以自行查找。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure><p>再在<code>_config.yml</code>文件中进行相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/shiyuhuiya/shiyuhuiya.github.io.git</span> <span class="comment">#写自己的仓库路径</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">hexo</span> <span class="string">deploy</span></span><br></pre></td></tr></table></figure><p>如果部署失败，可以尝试开启steam++加速github再次部署。</p><p>参考资料：<a href="https://www.bilibili.com/video/BV1dt4y1Q7UE/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&vd_source=00483a04a5a69136669373a8ea522a9b">【干货】Luke教你20分钟快速搭建个人博客系列(hexo篇) | 自动化部署在线编辑统统搞定 | 前端必会！_哔哩哔哩_bilibili</a></p><p>但是部署到github pages有一个明显的缺点，就是加载速度很慢。为什么加载速度很慢呢？<strong>因为github pages服务器在国外，离我们较远；距离越远，意味着要经过越多的网络结点，每个节点都会引入额外的延迟，遇到网络拥塞的概率也越大。</strong></p><h3 id="自定义github域名"><a href="#自定义github域名" class="headerlink" title="自定义github域名"></a>自定义github域名</h3><p>为了能让我们的域名<code>更有个性</code>（不会提高网站的加载速度），我们可以选择自定义域名，这需要我们购买域名；域名购买国内国外的都可以，只要域名解析后对应的服务器不是中国境内的，就<strong>不需要备案</strong>。可参考<a href="https://www.zhihu.com/question/624841875/answer/3239063269">国内域名一定要备案吗？ - 知乎</a></p><p>国外域名购买流程比较简单，比较推荐的是<strong>namesilo</strong></p><p><a href="https://zhuanlan.zhihu.com/p/33921436?s_r=0">Namesilo 域名购买及使用教程（附 Namesilo 优惠码） - 知乎</a></p><p>购买域名后，我们就能自定义我们的域名的dns解析方式；打开域名管理，在我们的域名下添加一条<code>CNAME</code>类型的dns记录，让对<code>自定义域名</code>的解析转变成对<code>用户名.github.io</code>域名的解析</p><p>具体<code>域名解析</code>方式已经在<code>《前端面试---网络》</code>一文中介绍，下面只给出几幅图。</p><p><strong>未自定义域名</strong>前的请求流程</p><img src="..\images\搭建hexo\未自定义域名.png" style="zoom:85%;" /><p><strong>自定义域名后</strong>的请求简化流程，比如我在<code>namesilo</code>网站上购买了<code>sanye.blog</code>这个域名，并在我的域名的dns解析记录下添加一条<code>CNAME</code>记录，让对域名<code>www.sanye.blog</code>域名的解析指向<code>用户名.github.io</code>域名的解析</p><img src = "../images/搭建hexo/自定义域名.png" /><p>拿到ip后访问对应的<code>githubpages</code>服务器，请求中携带的<code>host</code>是<code>www.sanye.blog</code>，因为我们在github上配置了，所以github知道对应的<code>默认域名</code>，然后就从<code>默认域名</code>中提取出<code>用户名</code>，根据<code>用户名</code>返回对应的资源。</p><p>添加自定义域名后，对原域名的访问也会<code>重定向</code>到自定义域名。在你的 GitHub Pages 仓库中，GitHub 会生成或更新一个名为 <code>CNAME</code> 的文件，其中包含你的自定义域名（例如 <code>www.sanye.blog</code>）。这个文件告诉 GitHub 你的站点应该通过哪个自定义域名访问。</p><p>建议在github pages中开启<strong>enfore https</strong>这样<code>直接访问自定义域名</code>也不会以http协议加载，而是强制用https协议访问，不会出现“网站不安全”的警告。</p><p>具体步骤参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/393050270">Github 部署个人网页 | 自定义域名 - 知乎</a><a href="https://zhuanlan.zhihu.com/p/393050270">Github 部署个人网页 | 自定义域名 - 知乎</a></p><blockquote><p>上述这篇文章“购买国内域名就要备份的说法是不准确的”</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/405672922">搞懂自定义域名 - 知乎</a></p><p><strong>然而我并不建议给github pages自定义域名</strong>🤣，因为即便自定义了域名，也不会提高我们博客的访问速度，因为我们的博客还是部署在github服务器上的，访问速度还是很慢，为什么要浪费宝贵的域名呢，因为我们是给<code>[用户名].github.io</code>这个仓库自定义域名，这就意味着对<code>[用户名].github.io</code>这个域名的解析都会<code>重定向</code>到我们<code>自定义的域名</code>，这就导致，其他仓库，原本的访问url格式是，<code>https://[username].github.io/[repo]</code>，<strong>即便不自定义域名</strong>，也会被重定向到<code>https://自定义域名/[repo]</code>，所以</p><p>最好还是把博客copy到vercel然后给vercel服务器上的项目自定义域名，参考下文。</p><h3 id="如何提高博客的加载速度"><a href="#如何提高博客的加载速度" class="headerlink" title="如何提高博客的加载速度"></a>如何提高博客的加载速度</h3><ul><li><p><strong>我们可以选择把我们的博客部署到其他平台。</strong></p><p>参考<a href="https://akilar.top/posts/812734f8/">使用第三方托管平台部署博客 | Akilarの糖果屋</a>；这篇文章介绍了其他的博客部署平台，<br>gitee：国内网站，但是目前pages功能停用了，除此之外还有其他问题;</p><p>Netlify：国外网站，免费，但是注册麻烦，需要hotmail或者gmail等国外常用邮箱，一顿操作下来发现还是白忙活🥲; </p><p>webify：腾讯的产品，要money，没有尝试过;</p><p><strong>vercel</strong>：注册简单且<strong>免费</strong>，直接使用<code>github</code>账号登录即可，在国内的访问速度也<strong>比github pages要快</strong>，并且何以导入git仓库，部署起来非常方便，后续在对应仓库中推送新的提交也会<strong>自动部署</strong>，省心省力。</p><p>部署步骤可参考文章：<a href="https://blog.csdn.net/qq_44960878/article/details/131548656">如何使用 Vercel 部署自己的 Hexo 博客_vercel部署博客-CSDN博客</a></p><p>在Vercel上部署好静态站点之后，会获得哦一个自动分配的域名，以<strong>vercel.app</strong>结尾，就像<code>githubpages</code>也会给默认域名一样，不幸的是，这个域名被dns污染了（被墙了），有人不想我们这么简单就能使用这个网站，我们无法通过这个<code>自动分配</code>的域名访问到我们的项目；但是我们还是有解决办法的，比较推荐的就是<strong>自定义域名</strong>，按照提示操作即可，又不幸的是，自定义域名使用到的<code>cname-vercel-dns.com</code>也存在被dns污染的问题，对此网上常见的解决办法是把<code>cname-vercel-dns.com</code>替换成<strong>固定的ip值</strong>，或者替换成<code>cname-china.vercel-dns.com</code>，还有一种方法是借助<code>cloudfare</code>，把对<code>cname-vercel-dns.com</code>的解析工作交给<code>cloudfare</code>，这个工作默认是你<strong>购买的域名的服务商</strong>提供的。</p><blockquote><p> 个人猜测：如果购买的是国内的域名，使用的就是国内的dns解析服务，就存在被墙的风险，所以推荐购买国外域名，使用<strong>国外的dns解析服务</strong>，也许就不会有这个问题，至少博主使用国外的域名暂时没遇到什么问题</p></blockquote><p>可参考文章：<a href="https://blog.csdn.net/qq_34761385/article/details/133634798">Vercel部署个人静态之DNS污染劫持问题_vercel dns-CSDN博客</a></p></li><li><p><strong>打包静态资源</strong></p><p><strong>打包html,js,css</strong></p><p>执行hexo g指令后，我们可以看到<strong>public文件夹</strong>中生成了一系列的静态文件，比如html,css,js,这些文件的内容格式是非常容易阅读的，显然，他们是未经过压缩的，我们可以借助打包工具<strong>gulp</strong>,实现对这些静态资源的打包，然后再部署到网站上去，能在一定程度上提高我们博客的加载速度。<br>参考文章：<a href="https://akilar.top/posts/49b73b87/">使用gulp压缩博客静态资源 | Akilarの糖果屋</a></p><p><strong>打包图片</strong></p><p>其实官方文档<a href="https://butterfly.js.org/posts/4073eda/">Butterfly 文檔(六) 進階教程 | Butterfly</a>也提供了相关的打包方法，本质就是对本地的图片压缩后再使用，减小图片体积。</p><ul><li><p><a href="https://tinypng.com/">TinyPNG – Compress WebP, PNG and JPEG images intelligently</a></p></li><li><p><a href="https://saerasoft.com/caesium/">Caesium - Image Compressor</a></p></li></ul></li><li><p><strong>cdn加速</strong></p><p>cdn加速在《前端面试—网络》一文中以及介绍过了，不赘述。</p><p>这里谈谈如何如何给国外域名使用CDN加速</p><p>可参考文章：<a href="https://zhuanlan.zhihu.com/p/393779644">Github 部署 | CDN 加速网页，速度嗖嗖的快！ - 知乎</a></p><p>这篇文章其实还是<strong>有问题的</strong>，虽然<strong>腾讯云</strong>能给国外域名提供cdn加速，但是<code>加速区域</code>只能选择国外，加速国内就要求<strong>域名备份</strong>(当然国内域名开通CDN加速也要备份)，也就是说，我们在源服务器（github pages服务器）上的部署的博客文件只能被<code>国外的cdn服务器</code>缓存，对在国内访问网站的加载速度的提高<strong>并不明显</strong>，而且开通cdn加速后还要自己给自定义域名申请<strong>ssl证书</strong>(因为存储我们博客的cdn服务器需要ssl证书，才能以https协议访问)，这个过程还要验证域名，而且不知道为什么一直通过不了验证，干脆放弃……</p><p>使用腾讯云给我们的域名<strong>接入cdn加速</strong>后，会得到一个<code>CNAME</code>，然后我们在我们的域名的<code>dns记录</code>上添加对应的<code>CNAME</code>记录即可。</p><p>还有就是在上面的文章中，给我们的国外域名加速，给<code>cdn服务器</code>配置的<code>源站地址</code>是<code>github pages</code>服务器的四个<strong>ip地址</strong>，查阅资料后发现，其实源站地址指定为<strong>用户名.github.io</strong>这个域名也是<strong>可行且容易理解的</strong>，所有形如<strong>用户名.github.io</strong>的域名都只会被解析到这<code>4个ip地址</code>中的<strong>一个</strong>，<strong>也就是说这4个ip可以对应多个域名</strong>，<strong>一个域名也能对应不止一个ip地址</strong>，这些 IP 地址通常指向<strong>相同的资源</strong>。具体来说，这些 IP 地址背后的服务器存储的资源是相同的，但它们可能分布在不同的地理位置或数据中心，以实现<strong>负载均衡和提高可用性</strong>。</p><p>在阅读butterfly文档的过程中发现竟然提供了<strong>cdn加速</strong>的方案？了解之后发现是一些国内的网站，主动给一些国外的常用的前端资源提供了cdn加速，并免费提供访问的cdn链接，然而我们的博客生成静态资源显然是<strong>享受不到</strong>的这种免费的cdn加速的。但是如果你使用到了某些外部链接，可以考虑把他们替换为经过cdn加速的链接 ，从而提高博客加载速度。</p><p>总之给部署在github上的博客接入<code>CDN加速</code>是一件<strong>很麻烦的事情</strong>，其实用<strong>vercel</strong>部署自己的博客访问速度其实也很nice了，因为<code>vercel</code>提供了免费的cdn服务。</p></li></ul><h2 id="优化开发体验"><a href="#优化开发体验" class="headerlink" title="优化开发体验"></a>优化开发体验</h2><p>即便我们把自己的博客部署在本地服务器<code>localhost:4000</code>来测试，也需要加载外部资源，比如butterfly主题的样式表等其他资源，这就导致我们开发过程中，博客首页的渲染速度也非常的慢。对此，我们可以通过下载butterfly提供的插件&#96;&#96;hexo-butterfly-extjs&#96;来解决，将这些需要的外部资源都下载到本地，从而极大程度减少加载外部资源的时间，从而提高渲染的速度。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CDN:</span></span><br><span class="line">  <span class="comment"># The CDN provider for internal and third-party scripts</span></span><br><span class="line">  <span class="comment"># Options for both: local/jsdelivr/unpkg/cdnjs/custom</span></span><br><span class="line">  <span class="comment"># <span class="doctag">Note:</span> Dev version can only use &#x27;local&#x27; for internal scripts</span></span><br><span class="line">  <span class="comment"># <span class="doctag">Note:</span> When setting third-party scripts to &#x27;local&#x27;, you need to install hexo-butterfly-extjs</span></span><br><span class="line">  <span class="attr">internal_provider:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">third_party_provider:</span> <span class="string">local</span></span><br></pre></td></tr></table></figure><p>但是我把这个包下载到<code>开发依赖</code>中（dependencies），编译后这个包也会被打包进去(<code>PluginSrc</code>文件夹)，最后部署出现了错误，提示我提交了隐私信息🥲；最终我是删掉了<code>.deploy_git</code>文件夹(不过我的commit的记录也没了)，卸载这个包才顺利部署。</p><p>其实只要把这个包下载到<code>开发依赖</code>（devDependencies），编译的时候，设置<code>third_party_provider</code>的值不为<code>local</code>，这个包就不会被编译进最终文件。</p><h2 id="感想与结语"><a href="#感想与结语" class="headerlink" title="感想与结语"></a>感想与结语</h2><p>hexo+butterfly框架能帮助我们迅速开发一个美观实用的博客，这些框架，主题，以及相关插件的诞生基于开发者雄厚的html，css，js等前端知识积累；做为刚入们的前端开发者，我也知道给光看文档能学到的实在是有限，在网上找资料学到的也是偏向实践，想要深入了解原理，自己做出这些效果，还得多学多练，打好自己前端基础。</p><p>如果你还想进一步美化自己的博客，给自己的博客添加更多的功能，你可以选择不断的阅读butterfly官方文档，也可以去网上查找更多的资料，以下是我推荐的一些资料，希望能帮助到你。</p><ul><li><a href="https://hexo.io/zh-cn/">Hexo官方文档</a></li><li>一个非常全面的butterfly魔改教程：<a href="https://butterfly.zhheo.com/page.html">页面 | Butterfly主题美化教程</a></li><li><a href="https://www.itbaima.cn/document/o0ab271mkdsas87">md语法学习</a></li><li>butterfly主题官方文档：<a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></li><li><a href="https://www.namesilo.com/">NameSilo官网</a></li><li><a href="https://zhutix.com/tag/cursors/?shuxing=jian">鼠标指针 - 光标 - 电脑鼠标指针下载 - 致美化 - 漫锋网</a></li><li>demo<ul><li><a href="https://zfe.space/">小冰博客 - 做个有梦想的人！</a></li><li><a href="https://blog.captainz.cc/">Hyper Tech - 专注于质量的博客。</a></li><li><a href="https://www.cnblogs.com/an-shiguang">時光心向阳 - 博客园</a></li></ul></li></ul><p>​</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
